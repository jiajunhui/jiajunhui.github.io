<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="Android Touch事件的分发是 Android 工程师必备技能之一。手指触摸屏幕时，即产生了触摸信息。这个触摸信息由屏幕这个硬件产生，被系统底层驱动获取，交给Android的输入系统服务：InputManagerService，也就是IMS">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Touch事件分发机制">
<meta property="og:url" content="http://example.com/2017/01/11/android_touch_dispatch/index.html">
<meta property="og:site_name" content="奔跑的蜗牛">
<meta property="og:description" content="Android Touch事件的分发是 Android 工程师必备技能之一。手指触摸屏幕时，即产生了触摸信息。这个触摸信息由屏幕这个硬件产生，被系统底层驱动获取，交给Android的输入系统服务：InputManagerService，也就是IMS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/android_touch_dispatch01.png">
<meta property="og:image" content="http://example.com/images/android_touch_dispatch02.png">
<meta property="og:image" content="http://example.com/images/android_touch_dispatch03.png">
<meta property="og:image" content="http://example.com/images/android_touch_dispatch04.png">
<meta property="article:published_time" content="2017-01-11T13:11:00.000Z">
<meta property="article:modified_time" content="2023-02-11T02:25:13.943Z">
<meta property="article:author" content="小贾">
<meta property="article:tag" content="系统机制">
<meta property="article:tag" content="Touch事件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/android_touch_dispatch01.png">


<link rel="canonical" href="http://example.com/2017/01/11/android_touch_dispatch/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;2017&#x2F;01&#x2F;11&#x2F;android_touch_dispatch&#x2F;&quot;,&quot;path&quot;:&quot;2017&#x2F;01&#x2F;11&#x2F;android_touch_dispatch&#x2F;&quot;,&quot;title&quot;:&quot;Android Touch事件分发机制&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Android Touch事件分发机制 | 奔跑的蜗牛</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">奔跑的蜗牛</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A6%82%E4%BD%95%E5%88%B0%E8%BE%BEActivity"><span class="nav-number">1.</span> <span class="nav-text">事件如何到达Activity</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ViewRootImpl%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E5%8F%91%E4%BA%8B%E4%BB%B6%E7%9A%84"><span class="nav-number">2.</span> <span class="nav-text">ViewRootImpl是如何分发事件的</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ViewGroup%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91"><span class="nav-number">2.1.</span> <span class="nav-text">ViewGroup的事件分发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91"><span class="nav-number">2.2.</span> <span class="nav-text">View的事件分发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E4%BA%8B%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">拦截事件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B1%87%E6%80%BB"><span class="nav-number">4.</span> <span class="nav-text">事件分发汇总</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">滑动冲突处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.</span> <span class="nav-text">滑动冲突场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.2.</span> <span class="nav-text">滑动冲突原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%80%9D%E6%83%B3"><span class="nav-number">5.3.</span> <span class="nav-text">滑动冲突解决思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5%E6%80%9D%E8%B7%AF"><span class="nav-number">5.4.</span> <span class="nav-text">实践思路</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小贾"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">小贾</p>
  <div class="site-description" itemprop="description">Just do IT</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jiajunhui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiajunhui" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:junhui_jia@163.com" title="E-Mail → mailto:junhui_jia@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/jiajunhui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/01/11/android_touch_dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="小贾">
      <meta itemprop="description" content="Just do IT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔跑的蜗牛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android Touch事件分发机制
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-01-11 21:11:00" itemprop="dateCreated datePublished" datetime="2017-01-11T21:11:00+08:00">2017-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Android Touch事件的分发是 Android 工程师必备技能之一。手指触摸屏幕时，即产生了触摸信息。这个触摸信息由屏幕这个硬件产生，被系统底层驱动获取，交给Android的输入系统服务：InputManagerService，也就是IMS</p>
<span id="more"></span>

<p>IMS会对这个触摸信息进行处理，经过WMS找到要分发的window，随后发送给对应的viewRootImpl。因此发送触摸信息的并非WMS，WMS提供的是window的相关信息。</p>
<p>当viewRootImpl接收到触摸信息时，也正是应用程序进程事件分发的开始。</p>
<p><img src="/images/android_touch_dispatch01.png" alt="image"></p>
<h1 id="事件如何到达Activity"><a href="#事件如何到达Activity" class="headerlink" title="事件如何到达Activity"></a>事件如何到达Activity</h1><p>事件分发：<br>DecorView -&gt; Activity -&gt; PhoneWindow -&gt; DecorView<br>当屏幕被触摸input系统事件从Native层分发Framework层的InputEventReceiver.dispachInputEvent()调用了</p>
<ul>
<li><p><strong>ViewRootImpl</strong>.WindowInputEventReceiver.dispachInputEvent()-&gt;</p>
</li>
<li><p><strong>ViewRootImpl</strong>中的<strong>DecorView</strong>.dispatchTouchEvent-&gt;Window.Callback.dispatchTouchEvent(ev) or super.dispatchTouchEvent(ev)</p>
</li>
<li><p><strong>Activity</strong>.dispatchTouchEvent-&gt;getWindow().superDispatchTouchEvent(ev) “<strong>PhoneWindow</strong>”</p>
</li>
<li><p><strong>window</strong>.superDispatchTouchEvent()-&gt;mDecor.superDispatchTouchEvent(event)</p>
</li>
<li><p><strong>DecorView</strong>.superDispatchTouchEvent()-&gt;super.dispatchTouchEvent(event)</p>
</li>
<li><p><strong>ViewGroup</strong>.dispatchTouchEvent()</p>
</li>
</ul>
<p>android的view管理是以window为单位的，每一个window对应一个view树。Window机制不只管理着view的显示，也负责view的事件分发。关于window的本质，能够阅读笔者的另外一篇文章window机制。研究事件分发的来源，须要从window机制入手。布局</p>
<p>因此，首先要了解一个概念：view树，即viewRootImpl。<br>每一棵view树都有一个根，叫作ViewRootImpl ，他负责管理这整一棵view树的绘制、事件分发等。因此能够说，事件分发是从viewRootImpl开始的。</p>
<p>应用界面通常会有多个view树，activity布局就是一个view树、其余应用的悬浮窗也是一个view树、dialog界面也是一个view树、使用windowManager添加的view也是一个view树等等。最简单的view树能够只有一个view。</p>
<p>android中view的绘制和事件分发，都是以view树为单位。每一棵view树，则为一个window 。系统服务WindowManagerService，管理界面的显示就是以window为单位，也能够说是以view树为单位。而view树是由viewRootImpl来负责管理的，因此能够说，wms（WindowManagerService的简写）管理的是viewRootImpl。<br><img src="/images/android_touch_dispatch02.png" alt="image"></p>
<p>对上图作个简单解释。</p>
<p>wms是运行在系统服务进程的，负责管理全部应用的window。应用程序与wms的通讯必须经过Binder进行跨进程通讯。<br>每一个viewRootImpl在wms中都有一个windowState对应，wms能够经过windowState找到对应的viewRootImpl进行管理<br>了解window机制的一个重要缘由是：事件分发并非由Activity驱动的，而是由系统服务驱动viewRootImpl来进行分</p>
<h1 id="ViewRootImpl是如何分发事件的"><a href="#ViewRootImpl是如何分发事件的" class="headerlink" title="ViewRootImpl是如何分发事件的"></a>ViewRootImpl是如何分发事件的</h1><p>1、viewRootImpl会直接调用管理的view的 dispatchTouchEvent 方法，根据具体的view的类型，调用具体的方法。<br>2、view树的根view多是一个view，也多是一个viewGroup，view会直接处理事件，而viewGroup则会进行分发。<br>3、DecorView重写了 dispatchTouchEvent 方法，会先判断是否存在callBack，优先调用callBack的方法，也就是把事件传递给了Activity。<br>4、其余的viewGroup子类会根据自身的逻辑进行事件分发。</p>
<p>所以，触摸事件必定是从Activity开始的吗？不是,Activity只是其中的一种状况，只有Activity本身负责的那一棵view树，才必定会到达activity，而其余的window，则不会通过Activity。触摸事件是从viewRootImpl开始，而不是Activity。</p>
<p>Touch事件分发中只有两个主角:ViewGroup和View。Activity的Touch事件事实上是调用它内部的ViewGroup的Touch事件，可以直接当成ViewGroup处理。</p>
<p>View在ViewGroup内，ViewGroup也可以在其他ViewGroup内，这时候把内部的ViewGroup当成View来分析。</p>
<p>ViewGroup的相关事件有三个：onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent。View的相关事件只有两个：dispatchTouchEvent、onTouchEvent。</p>
<p>先分析ViewGroup的处理流程：首先得有个结构模型概念：ViewGroup和View组成了一棵树形结构，最顶层为Activity的ViewGroup，下面有若干的ViewGroup节点，每个节点之下又有若干的ViewGroup节点或者View节点，依次类推。如图：</p>
<p><img src="/images/android_touch_dispatch03.png" alt="image"></p>
<p>Activity 的dispatchTouchEvent（）事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * Called to process touch screen events.  You can override this to</span></span><br><span class="line"><span class="comment">     * intercept all touch screen events before they are dispatched to the</span></span><br><span class="line"><span class="comment">     * window.  Be sure to call this implementation for touch screen events</span></span><br><span class="line"><span class="comment">     * that should be handled normally.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ev The touch screen event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean Return true if this event was consumed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DecorView会调用super.DispatchTouchEvent方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为DecorView是一个FrameLayout，它最终还是调用了我们熟悉的ViewGroup的dispatchTouchEvent()</p>
<p>所谓的事件分发，本质上就是一个递归函数的调用，这个递归函数就是dispatchTouchEvent，至于onIntercepterTouchEvent，onTouchEvent，OnTouchListener，onClickListener…balabala都是在这个递归函数里面的操作而已，最核心，最骨干的还是dispatchTouchEvent。</p>
<p>当一个Touch事件(触摸事件为例)到达根节点，即Acitivty的ViewGroup时，它会依次下发，下发的过程是调用子View(ViewGroup)的dispatchTouchEvent方法实现的。简单来说，就是ViewGroup遍历它包含着的子View，调用每个View的dispatchTouchEvent方法，而当子View为ViewGroup时，又会通过调用ViwGroup的dispatchTouchEvent方法继续调用其内部的View的dispatchTouchEvent方法。上述例子中的消息下发顺序是这样的：①-②-⑤-⑥-⑦-③-④。dispatchTouchEvent方法只负责事件的分发，它拥有boolean类型的返回值，当返回为true时，顺序下发会中断。在上述例子中如果⑤的dispatchTouchEvent返回结果为true，那么⑥-⑦-③-④将都接收不到本次Touch事件。</p>
<h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//如果事件以无障碍焦点的View为目标，并且此View就是那个无障碍焦点View则开始</span></span><br><span class="line">       <span class="comment">//正常事件分发。</span></span><br><span class="line">       <span class="comment">// If the event targets the accessibility focused view and this is it, start</span></span><br><span class="line">       <span class="comment">// normal event dispatch. Maybe a descendant is what will handle the click.</span></span><br><span class="line">       <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">           ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 第一步:对于ACTION_DOWN进行处理(Handle an initial down)</span></span><br><span class="line"><span class="comment">            * 因为ACTION_DOWN是一系列事件的开端,当是ACTION_DOWN时进行一些初始化操作.</span></span><br><span class="line"><span class="comment">            * 从源码的注释也可以看出来:清除以往的Touch状态(state)开始新的手势(gesture)</span></span><br><span class="line"><span class="comment">            * cancelAndClearTouchTargets(ev)中有一个非常重要的操作:</span></span><br><span class="line"><span class="comment">            * 将mFirstTouchTarget设置为null!!!!</span></span><br><span class="line"><span class="comment">            * 随后在resetTouchState()中重置Touch状态标识</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">           <span class="comment">// Handle an initial down.</span></span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">               <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">               <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">               <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">               cancelAndClearTouchTargets(ev);</span><br><span class="line">               resetTouchState();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 第二步:检查是否要拦截(Check for interception)</span></span><br><span class="line"><span class="comment">		 * 在哪些情况下会调用该代码呢？有如下几种情况</span></span><br><span class="line"><span class="comment">		 * 1 处理ACTION_DOWN事件</span></span><br><span class="line"><span class="comment">		 * 2 当ACTION_DOWN事件被子View消费后处理ACTION_MOVE和ACTION_UP时</span></span><br><span class="line"><span class="comment">		 *  会调用该代码。因为此时mFirstTouchTarget!=null。所以此时ViewGroup</span></span><br><span class="line"><span class="comment">		 *  是有机会拦截ACTION_MOVE和ACTION_UP的,但是我们也可以调用方法:</span></span><br><span class="line"><span class="comment">		 *  requestDisallowInterceptTouchEvent来禁止ViewGroup的事件拦截.</span></span><br><span class="line"><span class="comment">		 *  如果子View没有消费Touch事件,那么那么当后续的ACTION_MOVE和ACTION_UP</span></span><br><span class="line"><span class="comment">		 *  到来时是不会调用到本处代码的.</span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 * 在dispatchTouchEvent(MotionEventev)这一大段代码中</span></span><br><span class="line"><span class="comment">		 * 使用变量intercepted来标记ViewGroup是否拦截Touch事件的传递.</span></span><br><span class="line"><span class="comment">		 * 该变量在后续代码中起着很重要的作用.</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 从此处if(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)及其内部代码可知:</span></span><br><span class="line"><span class="comment">		 * 当ViewGroup决定拦截事件后,那么后续的点击事件将会默认交给它处理,不再调用</span></span><br><span class="line"><span class="comment">		 * onInterceptTouchEvent()判断是否需要拦截.</span></span><br><span class="line"><span class="comment">		 * 这个是为什么?</span></span><br><span class="line"><span class="comment">		 * 因为在处理ACTION_DOWN时如果Touch事件被子View消费,那么mFirstTouchTarget不为空;</span></span><br><span class="line"><span class="comment">		 * 反之,如果Touch事件没有被子View消费,那么mFirstTouchTarget为空,即此时Touch由当前</span></span><br><span class="line"><span class="comment">		 * 的ViewGroup拦截。此时当ACTION_MOVE和ACTION_UP来到时,不再满足:</span></span><br><span class="line"><span class="comment">		 * if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)</span></span><br><span class="line"><span class="comment">		 * 当然也就无法调用其内部的onInterceptTouchEvent()。</span></span><br><span class="line"><span class="comment">		 * 通俗地说:一旦ViewGroup拦截了ACTION_DOWN事件由自身的onTouchEvent()处理,那么</span></span><br><span class="line"><span class="comment">		 * 对于后续的ACTION_MOVE和ACTION_UP而言ViewGroup不再调用onInterceptTouchEvent()</span></span><br><span class="line"><span class="comment">		 * 判断是否拦截.</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 这里有个东西需要注意:FLAG_DISALLOW_INTERCEPT</span></span><br><span class="line"><span class="comment">		 * 在子View中调用requestDisallowInterceptTouchEvent()后造成disallowIntercept为true</span></span><br><span class="line"><span class="comment">		 * 即禁止拦截.于是不满足if(!disallowIntercept)所以也就调用不到该if内的onInterceptTouchEvent()</span></span><br><span class="line"><span class="comment">		 * 自然就没有办法拦截了.</span></span><br><span class="line"><span class="comment">		 * 但是requestDisallowInterceptTouchEvent()对于ACTION_DOWN是无效的.</span></span><br><span class="line"><span class="comment">		 * 因为对于ACTION_DOWN会调用 cancelAndClearTouchTargets(ev)和resetTouchState();</span></span><br><span class="line"><span class="comment">		 * 对FLAG_DISALLOW_INTERCEPT等状态值复原重置(参考上面的代码)</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 举两种情况说明:</span></span><br><span class="line"><span class="comment">		 * 1 当处理ACTION_DOWN时当然会满足</span></span><br><span class="line"><span class="comment">		 *  if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)</span></span><br><span class="line"><span class="comment">		 *  对于ACTION_DOWN子View有两种处理结果</span></span><br><span class="line"><span class="comment">		 *  1.1 消耗了Touch事件,那么mFirstTouchTarget不为null.</span></span><br><span class="line"><span class="comment">		 *      所以处理后续的ACTION_MOVE和ACTION_UP时依然满足该if判断</span></span><br><span class="line"><span class="comment">		 *  1.2 没有消耗Touch事件.mFirstTouchTarget=null.不满足该if.</span></span><br><span class="line"><span class="comment">		 *      所以后续的ACTION_MOVE和ACTION_UP由ViewGroup处理,此时再讨论什么拦截也就没有意义了.</span></span><br><span class="line"><span class="comment">		 *      同样的道理当子View消费了ACTION_DOWN后当处理ACTION_MOVE的时候ViewGroup拦截了该事件</span></span><br><span class="line"><span class="comment">		 *      那么当ACTION_UP随之到来时由于mFirstTouchTarget=null所以不会再调用该段代码,自然也就</span></span><br><span class="line"><span class="comment">		 *      不会调用onInterceptTouchEvent()判断是否拦截了.这点在上面的注释也有提及</span></span><br><span class="line"><span class="comment">		 * 2 当出现1.1的情况时满足该if判断.</span></span><br><span class="line"><span class="comment">		 *  如果在子View中调用了requestDisallowInterceptTouchEvent()那么就禁止拦截</span></span><br><span class="line"><span class="comment">		 *  即disallowIntercept=true.所以不满足if (!disallowIntercept)当然也就调用不到</span></span><br><span class="line"><span class="comment">		 *  onInterceptTouchEvent(ev)了,而是执行else&#123; intercepted = false;&#125;</span></span><br><span class="line"><span class="comment">		 *  也就是说ViewGroup无法拦截Touch了.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check for interception.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">           <span class="comment">// 事件为ACTION_DOWN或者mFirstTouchTarget不为null(即已经找到能够接收touch事件的目标组件)时if成立</span></span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   </span><br><span class="line">           	<span class="comment">//判断disallowIntercept(禁止拦截)标志位,可以理解为一个是否允许ViewGroup拦截的开关</span></span><br><span class="line">			<span class="comment">//因为在其他地方可能调用了requestDisallowInterceptTouchEvent()设置mGroupFlags 改变该值.</span></span><br><span class="line">			<span class="comment">//对于此方法的作用其实看requestDisallowInterceptTouchEvent()这个方法名就可明白了</span></span><br><span class="line">               <span class="comment">//disallowIntercept 默认值为FALSE</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//当禁止拦截为false时(即disallowIntercept为false)调用onInterceptTouchEvent(ev)方法</span></span><br><span class="line">               <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">               </span><br><span class="line">               	<span class="comment">//既然disallowIntercept为false那么就调用onInterceptTouchEvent()方法将结果赋值给intercepted</span></span><br><span class="line">               	<span class="comment">//常说事件传递中的流程是:dispatchTouchEvent-&gt;onInterceptTouchEvent-&gt;onTouchEvent</span></span><br><span class="line">               	<span class="comment">//其实在这就是一个体现,在dispatchTouchEvent()中调用了onInterceptTouchEvent()</span></span><br><span class="line">                   intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                   ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               </span><br><span class="line">               	<span class="comment">//禁止拦截的FLAG为ture说明没有必要去执行是否需要拦截了能够顺利通过,所以设置拦截变量为false</span></span><br><span class="line">               	<span class="comment">//即当禁止拦截为true时(即disallowIntercept为true)设置intercepted = false</span></span><br><span class="line">                   <span class="comment">//父view无法拦截事件</span></span><br><span class="line">                   intercepted = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">           	<span class="comment">//当事件不是ACTION_DOWN并且mFirstTouchTarget为null(即没有Touch的目标组件)时</span></span><br><span class="line">           	<span class="comment">//设置 intercepted = true表示ViewGroup执行Touch事件拦截的操作。</span></span><br><span class="line">               <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">               <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">               intercepted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If intercepted, start normal event dispatch. Also if there is already</span></span><br><span class="line">           <span class="comment">// a view that is handling the gesture, do normal event dispatch.</span></span><br><span class="line">           <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 第三步:检查cancel(Check for cancelation)</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">// Check for cancelation.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                   || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 第四步:事件分发(Update list of touch targets for pointer down, if needed)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span></span><br><span class="line">                   &amp;&amp; !isMouseEvent;</span><br><span class="line">           TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//不是ACTION_CANCEL并且ViewGroup的拦截标志位intercepted为false(不拦截)</span></span><br><span class="line">           <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">               <span class="comment">// If the event is targeting accessibility focus we give it to the</span></span><br><span class="line">               <span class="comment">// view that has accessibility focus and if it does not handle it</span></span><br><span class="line">               <span class="comment">// we clear the flag and dispatch the event to all children as usual.</span></span><br><span class="line">               <span class="comment">// We are looking up the accessibility focused host to avoid keeping</span></span><br><span class="line">               <span class="comment">// state since these events are very rare.</span></span><br><span class="line">               View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                       ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">//处理ACTION_DOWN事件.这个环节比较繁琐</span></span><br><span class="line">               <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                       || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                       || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                           : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                   <span class="comment">// have become out of sync.</span></span><br><span class="line">                   removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                   <span class="comment">// 依据Touch坐标寻找子View来接收Touch事件</span></span><br><span class="line">                   <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">float</span> x =</span><br><span class="line">                               isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">float</span> y =</span><br><span class="line">                               isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);</span><br><span class="line">                       <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                       <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                       <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                               &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                       <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                        <span class="comment">// 遍历子View判断哪个子View接受Touch事件</span></span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                           <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                   childrenCount, i, customOrder);</span><br><span class="line">                           <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                   preorderedList, children, childIndex);</span><br><span class="line">                           <span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">                                   || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                               <span class="keyword">continue</span>;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           newTouchTarget = getTouchTarget(child);</span><br><span class="line">                           <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           </span><br><span class="line">                           	<span class="comment">// 找到接收Touch事件的子View!!!!!!!即为newTouchTarget.</span></span><br><span class="line">                           	<span class="comment">// 既然已经找到了,所以执行break跳出for循环</span></span><br><span class="line">                               <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                               <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                               newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           resetCancelNextUpFlag(child);</span><br><span class="line">                           </span><br><span class="line">                           <span class="comment">/**</span></span><br><span class="line"><span class="comment">                            * 如果上面的if不满足,当然也不会执行break语句.</span></span><br><span class="line"><span class="comment">                            * 于是代码会执行到这里来.</span></span><br><span class="line"><span class="comment">                            * </span></span><br><span class="line"><span class="comment">                            * </span></span><br><span class="line"><span class="comment">                            * 调用方法dispatchTransformedTouchEvent()将Touch事件传递给子View做</span></span><br><span class="line"><span class="comment">                            * 递归处理(也就是遍历该子View的View树)</span></span><br><span class="line"><span class="comment">                            * 该方法很重要,看一下源码中关于该方法的描述:</span></span><br><span class="line"><span class="comment">                            * Transforms a motion event into the coordinate space of a particular child view,</span></span><br><span class="line"><span class="comment">                            * filters out irrelevant pointer ids, and overrides its action if necessary.</span></span><br><span class="line"><span class="comment">                            * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</span></span><br><span class="line"><span class="comment">                            * 将Touch事件传递给特定的子View.</span></span><br><span class="line"><span class="comment">                            * 该方法十分重要!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            * 在该方法中为一个递归调用,会递归调用dispatchTouchEvent()方法!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            * 在dispatchTouchEvent()中:</span></span><br><span class="line"><span class="comment">                            * 如果子View为ViewGroup并且Touch没有被拦截那么递归调用dispatchTouchEvent()</span></span><br><span class="line"><span class="comment">                            * 如果子View为View那么就会调用其onTouchEvent(),这个不再赘述.</span></span><br><span class="line"><span class="comment">                            * </span></span><br><span class="line"><span class="comment">                            * </span></span><br><span class="line"><span class="comment">                            * 该方法返回true则表示子View消费掉该事件,同时进入该if判断.</span></span><br><span class="line"><span class="comment">                            * 满足if语句后重要的操作有:</span></span><br><span class="line"><span class="comment">                            * 1 给newTouchTarget赋值</span></span><br><span class="line"><span class="comment">                            * 2 给alreadyDispatchedToNewTouchTarget赋值为true.</span></span><br><span class="line"><span class="comment">                            *   看这个比较长的英语名字也可知其含义:已经将Touch派发给新的TouchTarget</span></span><br><span class="line"><span class="comment">                            * 3 执行break.</span></span><br><span class="line"><span class="comment">                            *   因为该for循环遍历子View判断哪个子View接受Touch事件,既然已经找到了</span></span><br><span class="line"><span class="comment">                            *   那么就跳出该for循环.</span></span><br><span class="line"><span class="comment">                            * 4 注意:</span></span><br><span class="line"><span class="comment">                            *   如果dispatchTransformedTouchEvent()返回false即子View的onTouchEvent返回false</span></span><br><span class="line"><span class="comment">                            *   (即Touch事件未被消费)那么就不满足该if条件.所以也就无法执行addTouchTarget().</span></span><br><span class="line"><span class="comment">                            *   在此简单说一下addTouchTarget()中涉及到的ViewGroup的一个内部类TouchTarget——它是一个事件链.</span></span><br><span class="line"><span class="comment">                            *   该处的mFirstTouchTarget就是一个TouchTarget.它保存了可以消耗Touch事件的View.</span></span><br><span class="line"><span class="comment">                            *   在该处,如果dispatchTransformedTouchEvent()返回true即子View的onTouchEvent返回true则说明</span></span><br><span class="line"><span class="comment">                            *   该View消耗了Touch事件,那么将该View加入到事件链中!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            *   尤其注意:</span></span><br><span class="line"><span class="comment">                            *   这个操作是在处理ACTION_DOWN的代码块里进行的.即是在:</span></span><br><span class="line"><span class="comment">                            *    if (actionMasked == MotionEvent.ACTION_DOWN|| </span></span><br><span class="line"><span class="comment">                            *    (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || </span></span><br><span class="line"><span class="comment">                            *    actionMasked == MotionEvent.ACTION_HOVER_MOVE)</span></span><br><span class="line"><span class="comment">                            *    这个大的if判断中处理的.</span></span><br><span class="line"><span class="comment">                            *    当处理ACTION_MOVE事件和ACTION_UP事件的时候是不会进入这个if判断的!!!!!</span></span><br><span class="line"><span class="comment">                            *    而是直接从去判断mFirstTouchTarget!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            *    所以如果一个View不处理ACTION_DOWN那么该,那么该View是不会保存在mFirstTouchTarget</span></span><br><span class="line"><span class="comment">                            *    中的,也就无法继续处理ACTION_MOVE事件和ACTION_UP事件!!!!!!!!!!即若该View不消耗</span></span><br><span class="line"><span class="comment">                            *    ACTION_DOWN事件那么系统是不会讲ACTION_MOVE和ACTION_UP事件传给给该View的</span></span><br><span class="line"><span class="comment">                            * 5 注意:</span></span><br><span class="line"><span class="comment">                            *   如果dispatchTransformedTouchEvent()返回true即子View</span></span><br><span class="line"><span class="comment">                            *   的onTouchEvent返回true(即Touch事件被消费)那么就满足该if条件.</span></span><br><span class="line"><span class="comment">                            *   从而mFirstTouchTarget不为null!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            * 6 小结:</span></span><br><span class="line"><span class="comment">                            *   对于此处ACTION_DOWN的处理具体体现在dispatchTransformedTouchEvent()</span></span><br><span class="line"><span class="comment">                            *   该方法返回boolean,如下:</span></span><br><span class="line"><span class="comment">                            *   true----&gt;事件被消费-----&gt;mFirstTouchTarget!=null</span></span><br><span class="line"><span class="comment">                            *   false---&gt;事件未被消费---&gt;mFirstTouchTarget==null</span></span><br><span class="line"><span class="comment">                            *   因为在dispatchTransformedTouchEvent()会调用递归调用dispatchTouchEvent()和onTouchEvent()</span></span><br><span class="line"><span class="comment">                            *   所以dispatchTransformedTouchEvent()的返回值实际上是由onTouchEvent()决定的.</span></span><br><span class="line"><span class="comment">                            *   </span></span><br><span class="line"><span class="comment">                            *   简单地说onTouchEvent()是否消费了Touch事件(true or false)的返回值决定了</span></span><br><span class="line"><span class="comment">                            *   dispatchTransformedTouchEvent()的返回值!!!!从而决定了mFirstTouchTarget是否为null!!!!!!</span></span><br><span class="line"><span class="comment">                            *   从而进一步决定了ViewGroup是否处理Touch事件.这一点在下面的代码中很有体现.</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line"></span><br><span class="line">                           <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                               <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                               mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                               <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                       <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                           mLastTouchDownIndex = j;</span><br><span class="line">                                           <span class="keyword">break</span>;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                   mLastTouchDownIndex = childIndex;</span><br><span class="line">                               &#125;</span><br><span class="line">                               mLastTouchDownX = ev.getX();</span><br><span class="line">                               mLastTouchDownY = ev.getY();</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//调用addTouchTarget()将child添加到mFirstTouchTarget链表的表头</span></span><br><span class="line">                               <span class="comment">//注意在addTouchTarget()方法内部会对mFirstTouchTarget操作,使其不为null</span></span><br><span class="line"></span><br><span class="line">                               newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                               alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// The accessibility focus didn&#x27;t handle the event, so clear</span></span><br><span class="line">                           <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                           ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                   &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 该if条件表示:</span></span><br><span class="line"><span class="comment">                    * 经过前面的for循环没有找到子View接收Touch事件并且之前的mFirstTouchTarget不为空</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                       <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                       newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                       </span><br><span class="line">                       <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//newTouchTarget指向了最初的TouchTarget</span></span><br><span class="line">                           newTouchTarget = newTouchTarget.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 经过上面对于ACTION_DOWN的处理后mFirstTouchTarget有两种情况:</span></span><br><span class="line"><span class="comment">            * (当然如果不是ACTION_DOWN就不会经过上面较繁琐的流程而是从此处开始执行,比如ACTION_MOVE和ACTION_UP)</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * 情况1 mFirstTouchTarget为null</span></span><br><span class="line"><span class="comment">            *       即没有找到能够消费touch事件的子组件或者是touch事件被拦截了</span></span><br><span class="line"><span class="comment">            * 情况2 mFirstTouchTarget不为null</span></span><br><span class="line"><span class="comment">            *       即找到了能够消费touch事件的子组件则后续的touch事件都可以传递到子View</span></span><br><span class="line"><span class="comment">            * 这两种情况的详细分析见下.</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * 这两种情况下都会去调用方法:</span></span><br><span class="line"><span class="comment">            * dispatchTransformedTouchEvent(MotionEvent event,boolean cancel,View child,int desiredPointerIdBits)</span></span><br><span class="line"><span class="comment">            * 我们重点关注该方法的第三个参数View child.</span></span><br><span class="line"><span class="comment">            * 详情请参加下面dispatchTransformedTouchEvent()源码分析</span></span><br><span class="line"><span class="comment">            * 在该源码中解释了：</span></span><br><span class="line"><span class="comment">            * 为什么子view对于Touch事件处理返回true那么其上层的ViewGroup就无法处理Touch事件了!!!!!!!!!</span></span><br><span class="line"><span class="comment">            * 为什么子view对于Touch事件处理返回false那么其上层的ViewGroup才可以处理Touch事件!!!!!!!!!!</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">           <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                       TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">           	<span class="comment">/**</span></span><br><span class="line"><span class="comment">           	 * 情况2：mFirstTouchTarget不为null</span></span><br><span class="line"><span class="comment">           	 * 即找到了可以消费Touch事件的子View且后续Touch事件可以传递到该子View</span></span><br><span class="line"><span class="comment">           	 * 在源码中的注释为:</span></span><br><span class="line"><span class="comment">           	 * Dispatch to touch targets, excluding the new touch target if we already dispatched to it.  </span></span><br><span class="line"><span class="comment">           	 * Cancel touch targets if necessary.</span></span><br><span class="line"><span class="comment">           	 */</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">               <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">               TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">               TouchTarget target = mFirstTouchTarget;</span><br><span class="line">               <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                   <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                       </span><br><span class="line">                   	<span class="comment">//如果前面利用ACTION_DOWN事件寻找符合接收条件的子组件的同时消费掉了ACTION_DOWN事件</span></span><br><span class="line">                   	<span class="comment">//那么这里为handled赋值为true</span></span><br><span class="line">                       handled = <span class="keyword">true</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   </span><br><span class="line">                       <span class="comment">//对于非ACTION_DOWN事件继续传递给目标子组件进行处理</span></span><br><span class="line">                       <span class="comment">//依然是递归调用dispatchTransformedTouchEvent()</span></span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                               || intercepted;</span><br><span class="line">                       <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                               target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                           handled = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               mFirstTouchTarget = next;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               predecessor.next = next;</span><br><span class="line">                           &#125;</span><br><span class="line">                           target.recycle();</span><br><span class="line">                           target = next;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   predecessor = target;</span><br><span class="line">                   target = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 处理ACTION_UP和ACTION_CANCEL</span></span><br><span class="line"><span class="comment">            * Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line"><span class="comment">            * 在此主要的操作是还原状态</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">           <span class="keyword">if</span> (canceled</span><br><span class="line">                   || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                   || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">               resetTouchState();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">               removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handled;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Pass the touch screen motion event down to the target view, or this</span></span><br><span class="line"><span class="comment">  * view if it is the target.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> event The motion event to be dispatched.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> True if the event was handled by the view, false otherwise.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//判断当前事件是否能获得焦点，如果不能获得焦点或者不存在一个View，那我们就直接返回False跳出循环</span></span><br><span class="line">     <span class="comment">// If the event should be handled by accessibility focus first.</span></span><br><span class="line">     <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">         <span class="comment">// We don&#x27;t have focus or no virtual descendant has it, do not handle the event.</span></span><br><span class="line">         <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// We have focus and got the event, then use normal event dispatch.</span></span><br><span class="line">         event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">//这段是系统调试方面，可以直接忽略</span></span><br><span class="line">     <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">         mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">     <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">         <span class="comment">// Defensive cleanup for new gesture</span></span><br><span class="line">         stopNestedScroll();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">             result = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">         ListenerInfo li = mListenerInfo;</span><br><span class="line">         <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                 &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                 &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">             result = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//由自己内部的onTouchEvent处理。</span></span><br><span class="line">         <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">             result = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">         mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class="line">     <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest</span></span><br><span class="line">     <span class="comment">// of the gesture.</span></span><br><span class="line">     <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">             actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">             (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">         stopNestedScroll();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>负责对事件进行分发的方法主要有三个，分别是：</p>
<p>dispatchTouchEvent(）<br>onTouchEvent（）<br>onInterceptTouchEvent（）</p>
<p><img src="/images/android_touch_dispatch04.png" alt="image"></p>
<p>Down事件的分发决定了那个view要捕获事件，如果捕获了，后续的事件就直接分发给它，也就是说move up等事件的分发交给谁，取决于它们的起始事件Down由谁捕获。</p>
<p>在以上可看出，ViewGroup的dispatchTouchEvent是真正在执行“分发”工作，而View的dispatchTouchEvent方法，并不执行分发工作，或者说它分发的对象就是自己，决定是否把touch事件交给自己处理，而处理的方法，便是onTouchEvent事件，事实上子View的dispatchTouchEvent方法真正执行的代码是自己内部的onTouchEvent方法。</p>
<p>一般情况下，我们不该在普通View内重写dispatchTouchEvent方法，因为它并不执行分发逻辑。当Touch事件到达View时，我们该做的就是是否在onTouchEvent事件中处理它。</p>
<p>那么，ViewGroup的onTouchEvent事件是什么时候处理的呢？当ViewGroup所有的子View都返回false时，onTouchEvent事件便会执行。由于ViewGroup是继承于View的，它其实也是通过调用View的dispatchTouchEvent方法来执行onTouchEvent事件。</p>
<p>在目前的情况看来，似乎只要我们把所有的onTouchEvent都返回false，就能保证所有的子控件都响应本次Touch事件了。但必须要说明的是，这里的Touch事件，只限于Acition_Down事件，即触摸按下事件,而Aciton_UP和Action_MOVE却不会执行。事实上，一次完整的Touch事件，应该是由一个Down、一个Up和若干个Move组成的。Down方式通过dispatchTouchEvent分发，分发的目的是为了找到真正需要处理完整Touch请求的View。当某个View或者ViewGroup的onTouchEvent事件返回true时，便表示它是真正要处理这次请求的View，之后的Aciton_UP和Action_MOVE将由它处理。当所有子View的onTouchEvent都返回false时，这次的Touch请求就由根ViewGroup，即Activity自己处理了。</p>
<p>Down事件的分发决定了那个view要捕获事件，如果捕获了，后续的事件就直接分发给它，也就是说move up等事件的分发交给谁，取决于它们的起始事件Down由谁捕获。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本源码来自 api 28,不同版本略有不同。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步：处理拦截</span></span><br><span class="line">   <span class="keyword">boolean</span> intercepted;  </span><br><span class="line">     <span class="comment">// 注意这个条件，后者代表着有子view消费事件。后面会讲</span></span><br><span class="line">   <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 子view调用了parent.requestDisallowInterceptTouchEvent干预父布局的拦截，不让它爸拦截它</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">             intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">             ev.setAction(action); </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             intercepted = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//既不是DOWN事件，mFirstTouchTarget还是null，这种情况挺常见：如果ViewGroup的所有的子View都不消费				//事件，那么当ACTION_MOVE等非DOWN事件到来时，都被拦截了。</span></span><br><span class="line">         intercepted = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，分发ACTION_DOWN</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>; <span class="comment">//注意这个变量,会用到</span></span><br><span class="line">   <span class="comment">// 不拦截才会分发它，如果拦截了，就不分发ACTION_DOWN了</span></span><br><span class="line">    <span class="keyword">if</span> (!intercepted) &#123;</span><br><span class="line">        <span class="comment">//处理DOWN事件，捕获第一个被触摸的mFirstTouchTarget，mFirstTouchTarget很重要，</span></span><br><span class="line">        保存了消费了ACTION_DOWN事件的子<span class="function">view</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(ev.getAction == MotionEvent.ACTION_DOWN)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//遍历所有子view(看源码知子View是按照Z轴排好序的)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//子view如果：1.不包含事件坐标 2. 在动画  则跳过</span></span><br><span class="line">                <span class="keyword">if</span> (!isTransformedTouchPointInView() || !canViewReceivePointerEvents()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将事件传递给子view的坐标空间，并且判断该子view是否消费这个触摸事件（分发Down事件）</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent()) &#123;</span><br><span class="line">                    <span class="comment">//将该view加入头节点，并且赋值给mFirstTouchTarget</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步：分发非DOWN事件</span></span><br><span class="line">        <span class="comment">//如果没有子view捕获ACTION_DOWN，则交给本ViewGroup处理这个事件。我们看到，这里并没有判断是否拦截，</span></span><br><span class="line">        <span class="comment">//为什么呢？因为如果拦截的话，上面的代码不会执行，就会导致mFirstTouchTarget== null，于是就走下面第一         				//个条件里的逻辑了</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.dispatchTouchEvent(ev); <span class="comment">//调用View的dispatchTouchEvent，也就是自己处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历touchTargets链表，依次分发事件</span></span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget) &#123;</span><br><span class="line">                  handled = <span class="keyword">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  	<span class="keyword">if</span> (dispatchTransformedTouchEvent()) &#123;</span><br><span class="line">                      handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  target = target.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理ACTION_UP和CANCEL，手指抬起来以后相关变量重置</span></span><br><span class="line">        <span class="keyword">if</span> (ev.getAction == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拦截事件"><a href="#拦截事件" class="headerlink" title="拦截事件"></a>拦截事件</h1><p>ViewGroup还有个onInterceptTouchEvent，看名字便知道这是个拦截事件。这个拦截事件需要分两种情况来说明：</p>
<p>1.假如我们在某个ViewGroup的onInterceptTouchEvent中，将Action为Down的Touch事件返回true，那便表示将该ViewGroup的所有下发操作拦截掉，这种情况下，mTarget会一直为null，因为mTarget是在Down事件中赋值的。由于mTarge为null，该ViewGroup的onTouchEvent事件被执行。这种情况下可以把这个ViewGroup直接当成View来对待。</p>
<p>2.假如我们在某个ViewGroup的onInterceptTouchEvent中，将Acion为Down的Touch事件都返回false，其他的都返回True，这种情况下，Down事件能正常分发，若子View都返回false，那mTarget还是为空，无影响。若某个子View返回了true，mTarget被赋值了，在ACTION_MOVE和ACTION_UP分发到该ViewGroup时，便会给mTarget分发一个ACTION_CANCEL的MotionEvent，同时清空mTarget的值，使得接下去的ACTION_MOVE(如果上一个操作不是UP)将由ViewGroup的onTouchEvent处理。</p>
<h1 id="事件分发汇总"><a href="#事件分发汇总" class="headerlink" title="事件分发汇总"></a>事件分发汇总</h1><p>1、IMS从系统底层接收到事件以后，会从WMS中获取window信息，并将事件信息发送给对应的viewRootImpl<br>2、viewRootImpl接收到事件信息，封装成motionEvent对象后，发送给管理的view<br>3、view会根据自身的类型，对事件进行分发仍是本身处理<br>4、顶层viewGroup通常是DecorView，DecorView会根据自身callBack的状况，选择调用callBack或者调用父类ViewGroup的方法<br>5、后面的Touch事件分发中有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。</p>
<p>6、ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。</p>
<p>7、当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。</p>
<p>8、当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。</p>
<p>9、当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。</p>
<p>10、onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。</p>
<p>11、触摸事件由ACTION_DOWN、ACTION_MOVE、ACTION_UP组成，其中一次完整的触摸事件中，DOWN只有一个，MOVE有若干个，可以为0个。UP可以为1个或0个。</p>
<h1 id="滑动冲突处理"><a href="#滑动冲突处理" class="headerlink" title="滑动冲突处理"></a>滑动冲突处理</h1><h2 id="滑动冲突场景"><a href="#滑动冲突场景" class="headerlink" title="滑动冲突场景"></a>滑动冲突场景</h2><p>Android中有许多控件支持用户进行拖拽，滑动等操作，比如SeekBar，ViewPager，ScrollView，RecyclerView等等。随着业务的展现的需求变化，UI越来越复杂，不可避免的就会出现嵌套的多个可滑动View的情况，比如ViewPager中套ViewPager，ScrollView中套ViewPager，ViewPager中套RecyclerView，还有一些开发者自行开发的，可接受滑动手势的控件与标准控件的嵌套。</p>
<p>当ViewTree中从根到某一叶子节点的路径上，存在多个可接受滑动手势的控件时，就有可能发生滑动冲突。</p>
<h2 id="滑动冲突原因"><a href="#滑动冲突原因" class="headerlink" title="滑动冲突原因"></a>滑动冲突原因</h2><p>一般而言，产生滑动冲突的时候，一定有一个可以滑动的父控件作为容器，包裹着一个可以滑动的子控件。</p>
<p>Android的touch事件分发的方向是从父控件到子控件，而事件消费方向则是从子控件到父控件，对于一个可滑动的ViewGroup，假如他有一个子View是一个按钮，那么当用户手触摸该按钮时，该按钮默认会消费掉这一个touch事件序列中的所有的touch事件，直到用户抬手。</p>
<p>理论上父控件没有机会处理滑动事件，因为父控件的onTouchEvent并不会收到touch事件。</p>
<p>此时通常的做法是重写ViewGroup#onInterceptTouchEvent，在其中判断用户的手指在该控件上滑动的距离，如果距离超过一个阈值，则认为用户是在滑动而不是点击，此时ViewGroup#onInterceptTouchEvent返回true，所有事件均直接传给该ViewGroup的onTouchEvent，由拦截事件的控件自身进行处理。</p>
<p>当然重写ViewGroup#dispatchTouchEvent也可以做到，只不过一般不重写它，重写它的要么是经验丰富的人，要么就是略懂的新人。</p>
<p>一般而言，Android官方控件，包括support包中的控件，对滑动冲突都有一定的避免能力，天然就能互相嵌套，且滑动效果符合开发者预期，这是多种手段互相配合的结果。</p>
<h2 id="滑动冲突解决思想"><a href="#滑动冲突解决思想" class="headerlink" title="滑动冲突解决思想"></a>滑动冲突解决思想</h2><p>由于事件一定是通过父控件派发，因此父控件可以监听触摸事件，识别滑动手势，在需要处理滑动时让ViewGroup#onInterceptTouchEvent返回true。但这并不足够，因为父控件并不知道自己内部的子控件到底是什么业务逻辑，可滑动的子控件也不知道自己的父控件到底知不知道什么时候能拦截，什么时候不能拦截，因此父控件提供了ViewGroup#requestDisallowInterceptTouchEvent方法给子控件调用，让子控件能及时通知父控件，什么时候可以拦截，什么时候不能拦截。</p>
<p>一般的，如果有嵌套的可滑动控件，一定是子控件优先滑动，父控件在适当时机拦截事件，自行处理滑动事件。对于父控件如何识别滑动手势，并识别是否可以拦截，也有两种常见的方案。</p>
<p><strong>滑动阈值</strong><br>事件流经父控件时，父控件不对事件做拦截操作，但时刻计算用户的滑动方向和距离，一旦用户的滑动方向与自己可滑动的方向夹角小于一定程度，并且滑动距离超过一个阈值，同时子控件没有禁止父控件拦截的情况下，父控件在ViewGroup#onInterceptTouchEvent中返回true，以拦截事件，之后交由ViewGroup#onTouchEvent处理滑动的具体事务。如果子控件禁止父控件拦截事件，则父控件不拦截事件，也不需要识别滑动手势。</p>
<p>与此同时，如果子控件识别到自己可滑动，将会通过requestDisallowInterceptTouchEvent来禁止父控件对自己可能的拦截行为，并在合适的时机重新允许父控件拦截事件。</p>
<p>从原理上讲，滑动阈值本身并不是为了处理滑动冲突，因为一个正常的可滑动容器，必须要能做到识别滑动手势并拦截，如果不拦截，一旦内部有任何控件吃一切事件，它就滑不动了，不要觉得吃一切事件的控件是极端情况，一个clickable的View，默认就会吃全部事件，也就是说，如果父控件不拦截滑动事件，那么当用户手指落在按钮上开始滑动时，父控件永远收不到事件。</p>
<p>只不过很多人在写一些自定义的可滑动容器时，第一反应就是做阈值判断拦截事件，因此也算时处理滑动冲突的方案。</p>
<p>是不是只要有滑动阈值判断就高枕无忧了呢？</p>
<p>并不是。</p>
<p>一个有滑动阈值的父控件，我们可以说它对子控件自行处理滑动事件是宽容的，而子控件，一般而言没那么宽容，比如SeekBar只要收到DOWN事件，就会请求父控件不拦截事件，相当于当可滑动的子控件完全不给父控件机会拦截自己，当然也就不会有冲突。这种场景下，当用户滑动子控件时，父控件是无论如何不会滑动的。</p>
<p>但假如子控件也是一个有滑动阈值的控件，也就是说两个宽容的控件凑一块了，会怎么样呢？</p>
<p>原生Android事件分发体系里面，涉及到滑动事件的处理，要么是父控件拦截掉事件并处理滑动手势；要么是子控件自行处理滑动，禁止父控件拦截，无论如何，只有一方会处理滑动事件。</p>
<p>而我们知道事件是从父控件派发到子控件的，父控件拦截发生在子控件收到事件之前，假如父控件的阈值是10，子控件的阈值是20，那么一旦达到阈值</p>
<p>最先判断需要处理滑动事件的一定是父控件，因为父控件拦截在前，且阈值小于子控件，子控件根本没机会检测到滑动手势。</p>
<p>有人说将父控件的阈值调整到大于子控件就可以了，这样就能让子控件率先达到阈值，自行处理滑动了。</p>
<p>这种想法还是忽略了一个问题，用户滑动的距离并不是一个从0开始平滑增长的值，而是一系列离散的数，用户的两个touch时间之间的距离，是可能突然变得很大的，比如一上来距离就达到了40，假如父控件的阈值是30，子控件的阈值是10，由于父控件的拦截判断在先，还是父控件先拦截的事件，而不是我们想要的子控件来处理滑动。</p>
<p>所以遇到两个有滑动阈值的控件嵌套，且他们滑动的方向一致时，滑动冲突无法避免。</p>
<p><strong>主动检测</strong><br>既然滑动阈值这种纯靠父子控件自我感觉的方案在某些情况下行不通，那么就需要有主动检测的手段。</p>
<p>即父控件检测到滑动事件后，首先对子控件在该方向和距离上的可滑动性进行检测，如果子控件不可滑动，则事件由父控件拦截；如果子控件可以滑动，则正常放行，由子控件自行处理滑动事件并禁止父控件拦截。恰好有这么两个方法：</p>
<p>View.canScrollHorizontally和View.canScrollVertically。support包中还有兼容版本的实现。</p>
<p>最典型的例子就是ViewPager，我们知道多个ViewPager嵌套是不会有滑动冲突的，并且还能在子ViewPager无法滑动时，改为滑动父ViewPager，它的原理就是使用View.canScrollHorizontally对子控件的可滑动性进行检测。</p>
<p>大部分原生控件都正确实现了这两个方法。</p>
<p><strong>嵌套滑动机制</strong><br>嵌套滑动机制本身是为了解决可滑动父子View的联动问题，正如前面所说，一个滑动事件要么是父控件处理，要么是子控件处理，很难做到子控件处理一部分之后再交给父控件处理，或者父控件处理一部分之后再交给子控件处理。</p>
<p>嵌套滑动机制可以解决可滑动View的联动问题，天然就是解决滑动冲突的方案，只是嵌套滑动机制，对于早期版本的支持有限，我并没有深入了解过，这里就不讨论了。</p>
<h2 id="实践思路"><a href="#实践思路" class="headerlink" title="实践思路"></a>实践思路</h2><p>如果是写可滑动的父控件（即逻辑上的View容器，内部可能嵌套其他可滑动View）</p>
<p>一般使用滑动阈值的方法就可以正确实现，如果想实现实现更精确的控制，可以使用View.canScrollXXX来检测子控件的可滑动性。</p>
<p>如果是写可滑动的子控件（即逻辑上的子控件，内部不再嵌套其他可滑动View），务必不要通过阈值来判断是否需要禁止父控件拦截事件，而是在收到ACTION_DOWN的时候立即请求禁止拦截，在合适的时机再取消禁止。如果能准确知道自己的父控件会使用View.canScrollXXX来检测自己，也可以直接通过正确实现该方法来与父控件配合。</p>
<p>如果在实践中，遇到两个嵌套的可滑动View，均使用了滑动阈值来判断是否处理滑动，且这俩View的源码我们均不能修改，那么可以考虑给子控件设置一个OnTouchListener，遇到ACTION_DOWN直接请求禁止拦截，在合适的时候再取消禁止，虽然体验上会有些奇怪，至少能保证不出很明显的滑动冲突问题。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6/" rel="tag"># 系统机制</a>
              <a href="/tags/Touch%E4%BA%8B%E4%BB%B6/" rel="tag"># Touch事件</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016/07/17/java_jvm_faq/" rel="prev" title="Java JVM相关的灵魂拷问">
                  <i class="fa fa-chevron-left"></i> Java JVM相关的灵魂拷问
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2017/03/11/android_custom_view/" rel="next" title="Android自定义View">
                  Android自定义View <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小贾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  





</body>
</html>
