<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="为了系统的安全与稳定，Linux系统是存在进程隔离的：两个不同的进程，如应用App进程和ActivityManagerService服务所在的system_server系统进程，是无法直接通过内存地址访问到对方内部的函数或者变量的。所以两个进程如果需要相互访问就涉及到一个跨进程通信的概念即IPC(Inter-process communication，进程间通讯)。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android进程间通信Binder机制原理">
<meta property="og:url" content="http://example.com/2019/06/01/android_binder/index.html">
<meta property="og:site_name" content="小贾的博客">
<meta property="og:description" content="为了系统的安全与稳定，Linux系统是存在进程隔离的：两个不同的进程，如应用App进程和ActivityManagerService服务所在的system_server系统进程，是无法直接通过内存地址访问到对方内部的函数或者变量的。所以两个进程如果需要相互访问就涉及到一个跨进程通信的概念即IPC(Inter-process communication，进程间通讯)。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/android_binder_framework_struct.png">
<meta property="og:image" content="http://example.com/images/android_binder_driver_c_s_flow.png">
<meta property="og:image" content="http://example.com/images/android_binder_mmap_c_s_flow.png">
<meta property="og:image" content="http://example.com/images/android_binder_c_s_flow.png">
<meta property="og:image" content="http://example.com/images/android_binder_libbinder_struct.png">
<meta property="og:image" content="http://example.com/images/android_binder_bp_bb_transact.png">
<meta property="og:image" content="http://example.com/images/android_binder_ipc_thread_state.png">
<meta property="og:image" content="http://example.com/images/android_binder_sufrafce_flinger.png">
<meta property="og:image" content="http://example.com/images/android_binder_frame_work_java_struct.png">
<meta property="og:image" content="http://example.com/images/android_binder_java_binder_example.png">
<meta property="og:image" content="http://example.com/images/android_binder_aidl_my_aidl.png">
<meta property="og:image" content="http://example.com/images/android_binder_end_summary.png">
<meta property="article:published_time" content="2019-06-01T14:51:00.000Z">
<meta property="article:modified_time" content="2023-01-04T07:34:20.964Z">
<meta property="article:author" content="贾俊辉">
<meta property="article:tag" content="系统机制">
<meta property="article:tag" content="IPC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/android_binder_framework_struct.png">


<link rel="canonical" href="http://example.com/2019/06/01/android_binder/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;2019&#x2F;06&#x2F;01&#x2F;android_binder&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;06&#x2F;01&#x2F;android_binder&#x2F;&quot;,&quot;title&quot;:&quot;Android进程间通信Binder机制原理&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Android进程间通信Binder机制原理 | 小贾的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">小贾的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Binder%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">Binder整体架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binder%E9%A9%B1%E5%8A%A8%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text">Binder驱动与协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.</span> <span class="nav-text">Binder驱动设备初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%BC%80Binder%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94binder-open"><span class="nav-number">2.2.</span> <span class="nav-text">打开Binder驱动——binder open</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E2%80%94%E2%80%94binder-mmap"><span class="nav-number">2.3.</span> <span class="nav-text">内存映射——binder_mmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E9%A9%B1%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94binder-ioctl"><span class="nav-number">2.4.</span> <span class="nav-text">Binder驱动控制协议——binder_ioctl</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binder-Framework-C-%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">Binder Framework C++层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">主要类结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84Binder%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88ProcessState%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">进程的Binder初始化（ProcessState）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8EBinder%E9%A9%B1%E5%8A%A8%E7%9A%84%E9%80%9A%E4%BF%A1-IPCThreadState"><span class="nav-number">3.3.</span> <span class="nav-text">与Binder驱动的通信(IPCThreadState)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-Binder%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E4%B8%BE%E4%BE%8B"><span class="nav-number">3.4.</span> <span class="nav-text">C++ Binder服务实现举例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.4.1.</span> <span class="nav-text">服务端实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.4.2.</span> <span class="nav-text">注册服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.4.3.</span> <span class="nav-text">客户端实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.4.4.</span> <span class="nav-text">获取服务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ServiceManager%E2%80%94%E2%80%94Binder%E6%9C%8D%E5%8A%A1%E2%80%9C%E5%A4%A7%E7%AE%A1%E5%AE%B6%E2%80%9D"><span class="nav-number">4.</span> <span class="nav-text">ServiceManager——Binder服务“大管家”</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ServiceManager%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">4.1.</span> <span class="nav-text">ServiceManager进程的启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServiceManager%E8%BF%9B%E7%A8%8BBinder%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.2.</span> <span class="nav-text">ServiceManager进程Binder服务接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libbinder%E4%B8%AD%E5%AF%B9%E8%AE%BF%E9%97%AEServiceManager%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">4.3.</span> <span class="nav-text">libbinder中对访问ServiceManager接口的封装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binder-Framework-Java%E5%B1%82"><span class="nav-number">5.</span> <span class="nav-text">Binder Framework Java层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">主要结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JNI%E8%A1%94%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">JNI衔接调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-Binder%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E4%B8%BE%E4%BE%8B"><span class="nav-number">5.3.</span> <span class="nav-text">Java Binder服务实现举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AIDL%E6%9C%BA%E5%88%B6"><span class="nav-number">5.4.</span> <span class="nav-text">AIDL机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">6.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="贾俊辉"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">贾俊辉</p>
  <div class="site-description" itemprop="description">Just do IT</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jiajunhui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiajunhui" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:junhui_jia@163.com" title="E-Mail → mailto:junhui_jia@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/jiajunhui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/06/01/android_binder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="贾俊辉">
      <meta itemprop="description" content="Just do IT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小贾的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android进程间通信Binder机制原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-01 22:51:00" itemprop="dateCreated datePublished" datetime="2019-06-01T22:51:00+08:00">2019-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>为了系统的安全与稳定，Linux系统是存在进程隔离的：两个不同的进程，如应用App进程和ActivityManagerService服务所在的system_server系统进程，是无法直接通过内存地址访问到对方内部的函数或者变量的。所以两个进程如果需要相互访问就涉及到一个跨进程通信的概念即IPC(Inter-process communication，进程间通讯)。</p>
<span id="more"></span>

<p>本质上是借助于不同进程的内核空间都是共享的原理，两个不同的进程都去访问内核空间，从而达到“间接”访问对方的目的。Binder就是Android系统中大量使用的IPC机制，无论是应用程序对系统服务的请求（例如应用调用系统核心服务AMS的startActivity接口去实现应用启动），还是应用程序自身提供对外服务，都需要使用到Binder。因此，Binder机制在Android系统中的地位非常重要，可以说，<strong>理解Binder是理解Android系统的前提</strong>。</p>
<p>其实在Unix/Linux系统中，存在很多传统的IPC机制。如管道、消息队列、共享内存、Socket、信号量等。但是Android系统虽然是基于Linux系统但是却很少会使用这些这些传统的IPC机制，而是大部分场景下都是使用Binder。主要原因是，<strong>相对于传统的IPC机制，Binder有如下三点优势：</strong></p>
<ol>
<li><strong>性能上的优势</strong>：管道，消息队列，Socket的通讯都需要两次数据拷贝，而<strong>Binder由于使用了内存映射所以只需要一次拷贝</strong>。要知道，对于系统底层的IPC形式，少一次数据拷贝，对整体性能的影响是非常之大的。</li>
<li><strong>稳定性上的优势</strong>：Binder本身是C/S架构的，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制复杂，难以使用。从稳定性的角度讲，Binder机制是优于内存共享的。</li>
<li><strong>安全性上的优势</strong>：传统IPC形式，无法得到对方的身份标识（UID/PID)，而在使用Binder IPC时，这些身份标示是跟随调用过程而自动传递的。Server端很容易就可以知道Client端的身份，非常便于做安全检查，这一点对移动操作系统非常重要。</li>
</ol>
<h1 id="Binder整体架构"><a href="#Binder整体架构" class="headerlink" title="Binder整体架构"></a>Binder整体架构</h1><p>借用一张经典的架构图来描述binder的整体架构全貌，如下所示： </p>
<p><img src="/images/android_binder_framework_struct.png" alt="img"></p>
<p>从图中可以看出。这个Binder机制从架构上大致可以分为三层：</p>
<ol>
<li><strong>驱动层</strong>，我们知道Android系统是基于Linux内核的，Binder驱动层则位于Linux内核中。Binder 驱动会将自己注册为一个misc device，并向上层提供一个dev/binder节点（此Binder节点并不会对应真实的硬件设备）。Binder驱动运行在内核态，提供了最底层的数据传递，对象标识，线程管理，调用过程控制等功能，<strong>是Binder实现跨进程通信的核心</strong>。</li>
<li><strong>Framework C++层</strong>，以驱动层为基础，Binder机制C++的封装实现。</li>
<li><strong>Framework Java层</strong>，Binder机制的Java层的封装实现，采用JNI调用复用C++层的实现。</li>
</ol>
<p><strong>Binder通信架构是典型的C/S架构</strong>，由Client、Server、ServiceManager、Binder Driver四大组件组成。Client、Server、ServiceManager、Binder Driver这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder Driver）之间的关系。<strong>其相互配合完成一次Binder通信的大概过程如下</strong>：</p>
<ol>
<li>首先在系统开机启动时，一个进程通过Binder驱动将自己注册成ServiceManager，其地址固定为0；</li>
<li><strong>Server通过驱动向ServiceManager中注册Binder（Server中的Binder实体），表明可以对外提供服务</strong>。驱动为这个Binder创建位于内核中的实体节点以及ServiceManager对实体的引用，将名字以及新建的引用打包传给ServiceManager，ServiceManger将其填入查找表；</li>
<li>Client通过名字，在Binder驱动的帮助下从ServiceManager中获取到对Binder实体的引用，通过这个引用就能实现和Server进程的通信。</li>
</ol>
<p>整个过程如下图所示： </p>
<p><img src="/images/android_binder_driver_c_s_flow.png" alt="img"></p>
<h1 id="Binder驱动与协议"><a href="#Binder驱动与协议" class="headerlink" title="Binder驱动与协议"></a>Binder驱动与协议</h1><p>这部分源码位置在Linux内核中：</p>
<blockquote>
<p>/kernel/drivers/android/binder.c</p>
</blockquote>
<blockquote>
<p>/kernel/include/uapi/linux/android/binder.h</p>
</blockquote>
<h2 id="Binder驱动设备初始化"><a href="#Binder驱动设备初始化" class="headerlink" title="Binder驱动设备初始化"></a>Binder驱动设备初始化</h2><p><strong>Binder驱动设备在初始化时主要完成如下几件事情</strong>：</p>
<ol>
<li>通过misc_register()将自己注册为misc device类型的驱动设备；</li>
<li>填写file_operations函数指针结构体以标识用户空间在使用Binder驱动时所支持的文件操作；</li>
<li>指定Binder设备的名称是“binder”，这样用户空间便可以通过对/dev/binder文件进行操作来使用Binder。如下代码所示：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*kernel/drivers/android/binder.c*/</span></span><br><span class="line"><span class="keyword">static</span> int __init init_binder_device(<span class="keyword">const</span> <span class="built_in">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span></span> *binder_device;</span><br><span class="line">    binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!binder_device)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    binder_device-&gt;miscdev.fops = &amp;binder_fops;<span class="comment">// 1.Binder驱动支持的文件操作</span></span><br><span class="line">    binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;<span class="comment">//动态分配次设备号</span></span><br><span class="line">    binder_device-&gt;miscdev.name = name;<span class="comment">//2.驱动名称设置，一般就是“binder”</span></span><br><span class="line">    binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">    binder_device-&gt;context.name = name;</span><br><span class="line">    mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock);</span><br><span class="line">    ret = misc_register(&amp;binder_device-&gt;miscdev);<span class="comment">// 3.注册Binder驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(binder_device);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span></span> binder_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,<span class="comment">// binder_ioctl</span></span><br><span class="line">    .compat_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,<span class="comment">// binder_mmap</span></span><br><span class="line">    .open = binder_open,<span class="comment">// binder_open</span></span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由此可见，Binder驱动为上层应用提供了6个接口——其中使用最多的就是binder_ioctl、binder_mmap和binder_open。这是因为：<strong>需要使用Binder的进程，几乎总是先通过binder_open打开Binder设备，然后通过binder_mmap进行内存映射，最后再通过binder_ioctl来进行实际的操作</strong>。Client对于Server端的请求，以及Server对于Client请求结果的返回，都是通过ioctl完成的。</p>
<h2 id="打开Binder驱动——binder-open"><a href="#打开Binder驱动——binder-open" class="headerlink" title="打开Binder驱动——binder open"></a>打开Binder驱动——binder open</h2><p>上层用户空间的进程在访问Binder驱动时，<strong>首先需要通过open(“dev/binder”)打开Binder驱动设备</strong>，这个操作最终对应的实现是在binder_open()中。如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*kernel/drivers/android/binder.c*/</span></span><br><span class="line"><span class="keyword">static</span> int binder_open(<span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span> *nodp, <span class="class"><span class="keyword">struct</span> <span class="title">file</span></span> *filp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span></span> *binder_dev;</span><br><span class="line">    binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">&quot;%s: %d:%d\n&quot;</span>, __func__,</span><br><span class="line">             current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line">    proc = kzalloc(sizeof(*proc), GFP_KERNEL);<span class="comment">//1.创建进程对应的binder_proc对象</span></span><br><span class="line">    <span class="keyword">if</span> (proc == NULL)</span><br><span class="line">           <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    spin_lock_init(&amp;proc-&gt;inner_lock);</span><br><span class="line">    spin_lock_init(&amp;proc-&gt;outer_lock);</span><br><span class="line">    get_task_struct(current-&gt;group_leader);</span><br><span class="line">    proc-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br><span class="line">    <span class="comment">/* binderfs stashes devices in i_private */</span></span><br><span class="line">    <span class="keyword">if</span> (is_binderfs_device(nodp))</span><br><span class="line">        binder_dev = nodp-&gt;i_private;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        binder_dev = container_of(filp-&gt;private_data,</span><br><span class="line">                      <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span></span>, miscdev);</span><br><span class="line">    proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line">    binder_alloc_init(&amp;proc-&gt;alloc);</span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">        <span class="comment">// 2.初始化binder_proc</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads);</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line">    mutex_lock(&amp;binder_procs_lock);<span class="comment">// 获取锁</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);<span class="comment">// 3.添加到全局列表binder_procs中</span></span><br><span class="line">    mutex_unlock(&amp;binder_procs_lock);</span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line">        <span class="built_in">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line">        snprintf(strbuf, sizeof(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * proc debug entries are shared between contexts, so</span></span><br><span class="line"><span class="comment">         * this will fail if the process tries to open the driver</span></span><br><span class="line"><span class="comment">         * again with a different context. The priting code will</span></span><br><span class="line"><span class="comment">         * anyway print all contexts that a given PID has, so this</span></span><br><span class="line"><span class="comment">         * is not a problem.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, <span class="number">0444</span>,</span><br><span class="line">            binder_debugfs_dir_entry_proc,</span><br><span class="line">            (void *)(unsigned long)proc-&gt;pid,</span><br><span class="line">            &amp;proc_fops);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Binder驱动中，通过binder_procs集合记录了所有使用Binder的进程。每个初次打开Binder设备的进程都会创建一个binder_proc结构体对象，用来描述使用Binder的进程，然后被添加到这个列表中的。</p>
<h2 id="内存映射——binder-mmap"><a href="#内存映射——binder-mmap" class="headerlink" title="内存映射——binder_mmap"></a>内存映射——binder_mmap</h2><p>在打开Binder设备之后，上层进程就要通过mmap进行内存映射。mmap的作用有如下两个：</p>
<ul>
<li>申请一块内存空间，用来接收Binder通信过程中的数据</li>
<li>对这块内存进行地址映射，以便将来访问</li>
</ul>
<p>mmap在内核对应的就是binder_mmap()函数：在这个函数中，会申请一块物理内存，然后将用户空间和内核空间虚拟地址同时对应到这块物理内存上。在这之后，当有Client要发送数据给Server的时候，<strong>只需一次copy_from_user动作，将Client发送过来的数据拷贝到Server端的内核空间指定的内存地址即可（从而实现前文说的Binder通信机制只需要一次内存拷贝的效果）</strong>，由于这个内存地址在服务端已经同时映射到用户空间，因此无需再做一次复制，Server即可直接访问，整个过程如下图所示： </p>
<p><img src="/images/android_binder_mmap_c_s_flow.png" alt="img"></p>
<p>mmap_and_transaction.png</p>
<p>这幅图的说明如下：</p>
<ol>
<li>Server在启动之后，调用对/dev/binder设备调用mmap；</li>
<li>内核中的binder_mmap函数进行对应的处理：<strong>申请一块物理内存，然后在用户空间和内核空间同时进行映射</strong>；</li>
<li>Client通过BINDER_WRITE_READ命令发送请求，这个请求将先到驱动中，同时需要将数据从Client进程的用户空间拷贝到内核空间；</li>
<li>驱动通过BR_TRANSACTION通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问。</li>
</ol>
<h2 id="Binder驱动控制协议——binder-ioctl"><a href="#Binder驱动控制协议——binder-ioctl" class="headerlink" title="Binder驱动控制协议——binder_ioctl"></a>Binder驱动控制协议——binder_ioctl</h2><p>binder_ioctl()实现了上层应用进程与Binder驱动之间的交互命令，可以说承载了Binder驱动的大部分业务，也是我们学习的重中之重。下面表格中列出binder_ioctl支持的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BINDER_WRITE_READ</td>
<td>读写操作，可以用此命令向Binder读取或写入数据</td>
</tr>
<tr>
<td>BINDER_SET_MAX_THREADS</td>
<td>设置支持的最大线程数。因为客户端可以并发向服务器端发送请求，如果Binder驱动发现当前线程数已经超过设定值，就会告知Binder Server停止启动新的线程</td>
</tr>
<tr>
<td>BINDER_SET_CONTEXT_MGR</td>
<td>Service Manager专用，将自己设置为“Binder大管家”。系统中只能有一个SM存在</td>
</tr>
<tr>
<td>BINDER_THREAD_EXIT</td>
<td>通知Binder线程退出。每个线程退出时都应该告知Binder驱动、才能释放相关资源；否则会造成内存泄漏</td>
</tr>
<tr>
<td>BINDER_VERSION</td>
<td>获取Binder版本号</td>
</tr>
</tbody></table>
<p>其中BINDER_WRITE_READ这个命令是重点，又分为若干子命令，如下表所示：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BC_TRANSACTION</strong></td>
<td>Binder事务，即：Client对于Server的请求</td>
</tr>
<tr>
<td><strong>BC_REPLY</strong></td>
<td>事务的应答，即：Server对于Client的回复</td>
</tr>
<tr>
<td>BC_ENTER_LOOPER</td>
<td>通知驱动主线程ready</td>
</tr>
<tr>
<td>BC_REGISTER_LOOPER</td>
<td>通知驱动子线程ready</td>
</tr>
<tr>
<td>BR_REPLY</td>
<td>通知进程收到Binder请求的回复（Client）</td>
</tr>
<tr>
<td>BR_TRANSACTION_COMPLETE</td>
<td>驱动对于接受请求的确认回复</td>
</tr>
<tr>
<td>BR_TRANSACTION</td>
<td>通知进程收到一次Binder请求（Server端）</td>
</tr>
<tr>
<td>BR_DEAD_BINDER</td>
<td>发送死亡通知</td>
</tr>
<tr>
<td><strong>BR_SPAWN_LOOPER</strong></td>
<td>通知Binder进程创建一个新的线程</td>
</tr>
</tbody></table>
<p>其中BC_TRANSACTION和BC_REPLAY是最关键的两个命令，Binder机制中Client与Server交互基本靠它们完成。</p>
<p>单独看上面的协议可能很难理解，这里我们以一次Binder请求过程来详细看一下Binder协议是如何通信的，就比较好理解了。 </p>
<p><img src="/images/android_binder_c_s_flow.png" alt="img"></p>
<p>binder_request_sequence.png</p>
<p>这幅图的说明如下：</p>
<ul>
<li>Binder是C/S架构的，通信过程牵涉到：Client，Server以及Binder驱动三个角色</li>
<li>Client对于Server的请求以及Server对于Client回复都需要通过Binder驱动来中转数据</li>
<li>BC_XXX命令是进程发送给驱动的命令</li>
<li>BR_XXX命令是驱动发送给进程的命令</li>
<li>整个通信过程由Binder驱动控制</li>
</ul>
<h1 id="Binder-Framework-C-层"><a href="#Binder-Framework-C-层" class="headerlink" title="Binder Framework C++层"></a>Binder Framework C++层</h1><p>Binder Framework的C++部分：<strong>主要功能是实现向下与Binder驱动的对接交互，并封装复杂的内部实现，对外提供使用接口</strong>。头文件定义位于：/frameworks/native/include/binder/，实现位于这个路径：/frameworks/native/libs/binder/ 。<strong>Binder库最终会编译成一个动态链接库libbinder.so，供其他进程链接使用</strong>。为了便于说明，下文中我们将Binder Framework 的C++部分称为libbinder。</p>
<h2 id="主要类结构"><a href="#主要类结构" class="headerlink" title="主要类结构"></a>主要类结构</h2><p>先用一张类图描述libbinder中的主要类结构之间的关系：</p>
<p><img src="/images/android_binder_libbinder_struct.png" alt="img"></p>
<p>对照上面这张libbinder的设计类图，我们来理一下各个核心类的功能与职责：</p>
<ul>
<li><strong>基类</strong></li>
</ul>
<ol>
<li><strong>IBinder</strong>：Binder对象的基类，这个类描述了所有在Binder上传递的对象，它既是Binder服务端对象BBinder的父类，也是Binder客户端对象BpBinder的父类；<strong>主要定义的方法有</strong>：a.transact ———进行一次Binder操作；b.queryLocalInterface——尝试获取本地Binder对象；c.<strong>getInterfaceDescriptor ——</strong>获取Binder的服务接口唯一的描述****；d.isBinderAlive——查询Binder服务是否还活着等；</li>
<li><strong>IInterface</strong>：<strong>Binder服务接口的基类</strong>，Binder服务通常需要同时提供客户端接口和服务端接口。每个Binder服务都是为了某个功能而实现的，因此其本身会定义一套接口集来描述自己提供的所有功能。而Binder服务既有自身实现服务的类，也要有给客户端进程调用的类。为了便于开发，这两中类里面的服务接口应当是一致的。因此为了实现方便，本地实现类和远程接口类需要有一个公共的描述服务接口的基类（即上图中的IXXXService）来继承。而这个基类通常是IInterface的子类。</li>
</ol>
<ul>
<li><strong>客户端类</strong></li>
</ul>
<ol>
<li><strong>BpBinder</strong> ：BpBinder的实例代表了客户端Binder，这个类的对象将被客户端调用。这个类最重要就是<strong>提供了transact方法</strong>，这个方法会将客户端调用的参数封装好通过IPCThreadState逻辑封装后发送给Binder驱动。</li>
<li><strong>BpInterface</strong>：客户端接口的基类，远程接口是供客户端调用的接口集。<strong>BpInterface是个模板类</strong>，它们在继承自INTERFACE的基础上还继承了BpRefBase，通过这个类的remote方法可以获取到指向服务实现方的句柄。</li>
</ol>
<ul>
<li><strong>服务端类</strong></li>
</ul>
<ol>
<li><strong>BBinder</strong>：BBinder的实例代表了服务端Binder，它描述了服务的提供方，所有Binder服务的实现者都要继承这个类（的子类），在继承类中，最重要的就是实现<strong>onTransact方法</strong>，因为这个方法是所有请求的入口。因此，这个方法是和BpBinder中的transact方法对应的，这个方法同样也有一个uint32_t code参数（统一在IBinder中定义），在这个方法的实现中，由服务提供者通过code对请求的接口进行区分，然后调用具体实现服务的方法。</li>
<li><strong>BnInterface</strong>：服务端接口的基类，是需要服务端服务中真正实现的接口集。<strong>BnInterface是个模板类</strong>，它们在继承自INTERFACE(Binder服务接口的基类，继承自IInterface)的基础上还继承了BBinder，<strong>由此可以通过复写onTransact方法来提供实现</strong>。</li>
</ol>
<ul>
<li><strong>与驱动通信的类</strong></li>
</ul>
<ol>
<li><strong>ProcessState</strong> : <strong>代表使用Binder的进程</strong>。在讲解Binder驱动的时候我们就提到：任何使用Binder机制的进程都必须要对/dev/binder设备进行open以及mmap之后才能使用，这部分逻辑是所有使用Binder机制进程共同的。对于这种共同逻辑的封装便是Framework层的职责之一。libbinder中，ProcessState类封装了这个逻辑，从而<strong>负责进程Binder的初始化</strong>。</li>
<li><strong>IPCThreadState</strong> ：<strong>代表了进程中使用Binder的线程</strong>，这个类中封装了<strong>与Binder驱动通信的具体实现逻辑</strong>。</li>
</ol>
<p><strong>在客户端接口的实现类中，每个接口在组装好参数之后，都会调用remote()-&gt;transact来发送请求，而这里其实就是调用的BpBinder的transact方法，这样请求便通过Binder到达了服务实现方的onTransact中。这个过程如下图所示</strong>：</p>
<p><img src="/images/android_binder_bp_bb_transact.png" alt="img"></p>
<h2 id="进程的Binder初始化（ProcessState）"><a href="#进程的Binder初始化（ProcessState）" class="headerlink" title="进程的Binder初始化（ProcessState）"></a>进程的Binder初始化（ProcessState）</h2><p>之前讲解Binder驱动的时候讲过，需要使用Binder的进程，需要先通过binder_open打开Binder设备，然后通过binder_mmap进行内存映射。由于这部分逻辑是所有使用Binder的进程共有的，所以libbinder中使用ProcessState类统一封装了这个逻辑，具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/binder/ProcessState.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) <span class="comment">// 1M - 8k</span></span></span><br><span class="line"></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))<span class="comment">// 1.调用open_driver打开binder驱动设备</span></span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mExecutingThreadsCount</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , <span class="built_in">mStarvationStartTimeMs</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mCallRestriction</span>(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO(b/139016109): enforce in build system</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID_APEX__)</span></span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;Cannot use libbinder in APEX (only system.img libbinder) since it is not stable.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.mmap执行内存映射动作</span></span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这是ProcessState构造函数，Binder的初始化工作都是在这个函数中完成的</strong>。在这个函数中，初始化mDriverFD的时候调用了open_driver方法打开binder设备，然后又在函数体中，通过mmap进行内存映射。<strong>这里需要注意的是mmap函数的参数中有个BINDER_VM_SIZE，这个就是指定在内核上开辟的内存空间的大小，也是一次Binder通信传递的最大数据量，目前默认定义大小是1016个字节（1M-8K）</strong>。这个其实也就解释了我们平常开发过程中遇到的一个问题，就是通过Intent传递过大的对象时会报TransactionTooLargeException异常的原因。open_driver动作具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/binder/ProcessState.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MAX_BINDER_THREADS 15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);<span class="comment">// 1.通过open系统调用打开了dev/binder设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2.通过ioctl获取Binder实现的版本号，并检查是否匹配</span></span><br><span class="line">        <span class="keyword">status_t</span> result = <span class="built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to obtain version failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;</span>,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        <span class="comment">// 3.通过ioctl设置进程支持的最大Binder线程数</span></span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>open_driver函数中除了实现通过open系统调用打开了dev/binder设备外。<strong>还会通过ioctl调用的BINDER_SET_MAX_THREADS命令设置进程支持的最大Binder线程数，目前定义的一般进程默认最大Binder线程数是15</strong>。这个也解释了我们在开发过程中遇到一类性能问题：就是进程的Binder线程耗尽，此时进程中已经开启了15个Binder线程用于处理binder请求且都处于工作或阻塞状态，此时如果有新的binder请求时就无法继续处理了，从而导致阻塞卡主；</p>
<h2 id="与Binder驱动的通信-IPCThreadState"><a href="#与Binder驱动的通信-IPCThreadState" class="headerlink" title="与Binder驱动的通信(IPCThreadState)"></a>与Binder驱动的通信(IPCThreadState)</h2><p>IPCThreadState是一个单例类，进程中的每个Binder线程存在一个实例，负责了与驱动通信的细节处理。这个类中的关键几个方法说明如下：</p>
<p><img src="/images/android_binder_ipc_thread_state.png" alt="img"></p>
<p>IPCThreadState.PNG</p>
<p>以其中最主要的是transact方法为例，该方法会完成一次Binder数据传输动作，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/binder/IPCThreadState.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.通过writeTransactionData完成数据组装写入</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2.判断是否为TF_ONE_WAY异步单向请求，如果是线程不需要阻塞等待返回值，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 3.通过waitForResponse将数据传输到驱动并等待返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，<strong>通过Binder驱动完成一次Binder数据传输的主要流程是</strong>：</p>
<ol>
<li>先通过writeTransactionData函数完成传输数据binder_transaction_data的组装填充；</li>
<li>通过waitForResponse函数真正完成传输数据写入驱动并等待返回数据，具体实现会调用talkWithDriver函数，<strong>通过ioctl命令BINDER_WRITE_READ与Binder驱动通信</strong>，完成数据的传输写入，并读取返回数据。</li>
</ol>
<p>详细代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/binder/IPCThreadState.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 组装binder_transaction_data</span></span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用talkWithDriver真正完成传输数据写入驱动并等待返回数据</span></span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;About to read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">        <span class="comment">// 通过ioctl命令BINDER_WRITE_READ与Binder驱动通信</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Binder服务实现举例"><a href="#C-Binder服务实现举例" class="headerlink" title="C++ Binder服务实现举例"></a>C++ Binder服务实现举例</h2><p>上面的理论知识可能比较枯燥和抽象，下面以Android系统中的一个系统Binder服务为例，结合上面的理论具体分析一下。 我们以实现系统图像合成显示的核心进程服务SurfaceFlinger为例，来分析C++的Binder服务如何实现。下图是SurfaceFlinger C++ Binder服务实现类图：</p>
<p><img src="/images/android_binder_sufrafce_flinger.png" alt="img"></p>
<p>ISurfaceComposer定义了SurfaceFlinger对外提供的功能接口，其子类都继承了这些接口。</p>
<ul>
<li>BpSurfaceComposer是提供给客户端调用的远程接口，先通过remote方法获取到指向服务实现方的句柄，然后通过transact方法发送具体请求。</li>
<li>BnSurfaceComposer中只有一个onTransact方法，该方法根据请求的code来对接每个请求，并直接调用SurfaceFlinger中对应的方法。</li>
<li>SurfaceFlinger是服务接口功能真正的实现。</li>
</ul>
<h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><p>主要包括BnSurfaceComposer和SurfaceFlinger两个类，SurfaceFlinger是BnSurfaceComposer的子类，因此在BnSurfaceComposer中调用自身的virtual方法其实都是在子类SurfaceFlinger类中实现的。BnSurfaceComposer类要做的就是复写onTransact方法，这个方法的职责是：<strong>根据请求的code区分具体调用的是那个接口，然后按顺序从Parcel中读出打包好的参数，接着调用留待子类实现的虚函数</strong>。我们看一下BnSurfaceComposer::onTransact中的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/gui/ISurfaceComposer.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BnSurfaceComposer::onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(code) &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">case</span> CREATE_DISPLAY: &#123;</span><br><span class="line">            <span class="built_in">CHECK_INTERFACE</span>(ISurfaceComposer, data, reply);</span><br><span class="line">            String8 displayName = data.<span class="built_in">readString8</span>();</span><br><span class="line">            <span class="keyword">bool</span> secure = <span class="built_in"><span class="keyword">bool</span></span>(data.<span class="built_in">readInt32</span>());</span><br><span class="line">            <span class="function">sp&lt;IBinder&gt; <span class="title">display</span><span class="params">(createDisplay(displayName, secure))</span></span>;</span><br><span class="line">            reply-&gt;<span class="built_in">writeStrongBinder</span>(display);</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中我们看到了实现中是如何根据code区分接口，并通过Parcel读出调用参数，然后调用具体服务方的。而SurfaceFlinger这个类中的createDisplay方法才是真正实现创建显示设备的逻辑，详细代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/services/surfaceflinger/SurfaceFlinger.cpp*/</span></span><br><span class="line">sp&lt;IBinder&gt; SurfaceFlinger::createDisplay(<span class="keyword">const</span> String8&amp; displayName, bool secure) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DisplayToken</span> : <span class="type">public BBinder &#123;</span></span></span><br><span class="line">        sp&lt;SurfaceFlinger&gt; flinger;</span><br><span class="line">        virtual ~DisplayToken() &#123;</span><br><span class="line">             <span class="comment">// no more references, this display must be terminated</span></span><br><span class="line">             Mutex::Autolock _l(flinger-&gt;mStateLock);</span><br><span class="line">             flinger-&gt;mCurrentState.displays.removeItem(<span class="keyword">this</span>);</span><br><span class="line">             flinger-&gt;setTransactionFlags(eDisplayTransactionNeeded);</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        explicit DisplayToken(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span><br><span class="line">            : flinger(flinger) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;BBinder&gt; token = new DisplayToken(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="comment">// Display ID is assigned when virtual display is allocated by HWC.</span></span><br><span class="line">    DisplayDeviceState state;</span><br><span class="line">    state.isSecure = secure;</span><br><span class="line">    state.displayName = displayName;</span><br><span class="line">    mCurrentState.displays.add(token, state);</span><br><span class="line">    mInterceptor-&gt;saveDisplayCreation(state);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>服务实现完成之后，并不是立即就能让别人使用的。而是需要先通过Binder驱动向ServiceManager中注册服务，表明可以对外提供服务。下面我们看看SurfaceFlinger服务注册发布的具体代码实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp*/</span></span><br><span class="line">int main(int, <span class="built_in">char</span>**) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// When SF is launched in its own process, limit the number of</span></span><br><span class="line">    <span class="comment">// binder threads to 4.</span></span><br><span class="line">    ProcessState::<span class="keyword">self</span>()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.启动Binder线程池</span></span><br><span class="line">    <span class="comment">// start the thread pool</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::<span class="keyword">self</span>());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instantiate surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::createSurfaceFlinger();</span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize before clients can connect</span></span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.通过IServiceManager::addService在ServiceManager中注册服务，此处服务的名称为“SurfaceFlinger”</span></span><br><span class="line">    <span class="comment">// publish surface flinger</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>,</span><br><span class="line">                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run surface flinger in this thread</span></span><br><span class="line">    flinger-&gt;run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，<strong>发布Binder服务需要先启动Binder线程池，然后通过IServiceManager::addService在ServiceManager中进行服务的注册。</strong></p>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><p>BpSurfaceComposer需要实现ISurfaceComposer中的所有接口。我们以上文提到的createDisplay接口为例，来看看BpSurfaceComposer::createDisplay方法代码是如何实现的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/gui/ISurfaceComposer.cpp*/</span></span><br><span class="line">virtual sp&lt;IBinder&gt; createDisplay(<span class="keyword">const</span> String8&amp; displayName, bool secure)</span><br><span class="line">&#123;</span><br><span class="line">    Parcel <span class="keyword">data</span>, reply;</span><br><span class="line">    <span class="comment">// 1.填写服务接口的唯一描述信息descriptor</span></span><br><span class="line">    <span class="keyword">data</span>.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">    <span class="comment">// 2.通过Parcel写入发送参数</span></span><br><span class="line">    <span class="keyword">data</span>.writeString8(displayName);</span><br><span class="line">    <span class="keyword">data</span>.writeInt32(secure ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3\. 调用remote()-&gt;transact将请求发送出去</span></span><br><span class="line">    remote()-&gt;transact(BnSurfaceComposer::CREATE_DISPLAY, <span class="keyword">data</span>, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> reply.readStrongBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，逻辑就是：<strong>通过Parcel写入调用参数进行打包，然后调用remote()-&gt;transact将请求发送出去。</strong></p>
<h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><p><strong>客户端在使用服务端的服务之前，需要先根据服务的名称向ServiceManager中查询获取到访问服务的句柄</strong>，才能通过BpSurfaceComposer::remote()函数拿到远端服务的代理后调用transact方法完成一次Binder数据发送。详细代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framworks/native/libs/gui/SurfaceComposerClient.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComposerService::connectLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1\. 需要查找的远端Binder服务名称为&quot;SurfaceFlinger&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> String16 <span class="title">name</span><span class="params">(<span class="string">&quot;SurfaceFlinger&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 2 .调用IServiceManager::getService封装接口获取远端服务代理并封装到BpSurfaceComposer中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getService</span>(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">250000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/native/include/binder/IServiceManager.h*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">getService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, sp&lt;INTERFACE&gt;* outService)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// 1\. 获取到ServiceManager的代理以访问ServiceManager</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IServiceManager&gt; sm = <span class="built_in">defaultServiceManager</span>();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 2\. 通过getService获取具体的服务句柄，并使用interface_cast转换获取到BpSurfaceComposer对象</span></span><br><span class="line">        *outService = interface_cast&lt;INTERFACE&gt;(sm-&gt;<span class="built_in">getService</span>(name));</span><br><span class="line">        <span class="keyword">if</span> ((*outService) != <span class="literal">nullptr</span>) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NAME_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/native/libs/binder/IServiceManager.cpp*/</span></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(gSmOnce, []() &#123;</span><br><span class="line">        sp&lt;AidlServiceManager&gt; sm = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//ProcessState::getContextObject(nullptr)获取到ServiceManager的访问句柄</span></span><br><span class="line">            sm = interface_cast&lt;AidlServiceManager&gt;(ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">nullptr</span>));</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/native/libs/binder/ProcessState.cpp*/</span></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// 此处的参数“0”代表查找的是ServiceManager服务，这个是个特殊的地址，用于标识ServiceManager</span></span><br><span class="line">    sp&lt;IBinder&gt; context = <span class="built_in">getStrongProxyForHandle</span>(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过interface_cast这个方法来获取服务的接口对象，由这个方法本身根据是否是在同一个进程，来自动确定返回一个本地Binder还是远程Binder</strong>。interface_cast是一个模板方法，其源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/binder/include/binder/IInterface.h*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; <span class="title">interface_cast</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::<span class="built_in">asInterface</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ISurfaceComposer来说，其实就是ISurfaceComposer::asInterface(obj)，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/binder/include/binder/IInterface.h*/</span></span><br><span class="line"> ::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::<span class="built_in">asInterface</span>(              \</span><br><span class="line">         <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line"> &#123;                                                                   \</span><br><span class="line">     ::android::sp&lt;I##INTERFACE&gt; intr;                               \</span><br><span class="line">     <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;                                           \</span><br><span class="line">         <span class="comment">//1.先使用queryLocalInterface尝试获取本地同一进程中的Binder对象</span></span><br><span class="line">         intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">             obj-&gt;<span class="built_in">queryLocalInterface</span>(                               \</span><br><span class="line">                     I##INTERFACE::descriptor).<span class="built_in">get</span>());               \</span><br><span class="line">         <span class="comment">//2.失败则创建并返回远端Binder对象，封装成BpSurfaceComposer</span></span><br><span class="line">         <span class="keyword">if</span> (intr == <span class="literal">nullptr</span>) &#123;                                      \</span><br><span class="line">             intr = <span class="keyword">new</span> Bp##<span class="built_in">INTERFACE</span>(obj);                          \</span><br><span class="line">         &#125;                                                           \</span><br><span class="line">     &#125;                                                               \</span><br><span class="line">     <span class="keyword">return</span> intr;                                                    \</span><br><span class="line"> &#125;   </span><br></pre></td></tr></table></figure>

<p>由于都是模板定义，所以在理解的时候，将“##”替换成SurfaceComposer即可。</p>
<h1 id="ServiceManager——Binder服务“大管家”"><a href="#ServiceManager——Binder服务“大管家”" class="headerlink" title="ServiceManager——Binder服务“大管家”"></a>ServiceManager——Binder服务“大管家”</h1><p>ServerManager(简称SM)的功能可以类比互联网中的DNS服务器，“IP地址”为0。<strong>每一个Binder服务都需要有一个唯一的名称，由SM来管理这些服务的注册和查找</strong>。另外，和DNS服务器本身也是服务器一样，SM也是一个标准的Binder Server，且Binder驱动中，也会通过特定handle = 0这个位置来访问ServiceManager。因此，分析SM我们可以完整的看到一个上层应用如何通过Binder驱动来构建一个Binder Server的过程。下面我们分析SM模块的的具体实现。</p>
<h2 id="ServiceManager进程的启动"><a href="#ServiceManager进程的启动" class="headerlink" title="ServiceManager进程的启动"></a>ServiceManager进程的启动</h2><p>SM作为Binder服务的“大管家”，必须要保证在系统所有Binder服务启动之前就已经启动并处于正常工作状态。所以SM是在开机时由init程序解析init.rc加载时直接启动。如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/cmds/servicemanager/servicemanager.rc*/</span></span><br><span class="line">service servicemanager /system/bin/servicemanager<span class="comment">// 1.servicemanager是一个独立可执行文件</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span> <span class="title">animation</span></span></span><br><span class="line">    user system</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote<span class="comment">// 2.servicemanager重启后会导致zygote重启</span></span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger<span class="comment">// 3.servicemanager重启后会导致surfaceflinger重启</span></span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    onrestart restart thermalservice</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>

<p>由上可见，<strong>servicemanager是一个独立可执行文件，由C++编写，是一个独立运行的native进程，在系统开机时有init进程直接拉起</strong>。源码路径如下：</p>
<blockquote>
<p>/framework/native/cmds/servicemanager/*</p>
</blockquote>
<p>其main函数主要逻辑如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/cmds/servicemanager/main.cpp*/</span></span><br><span class="line">int main(int argc, <span class="built_in">char</span>** argv) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">&quot;usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; [binder driver]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>* driver = argc == <span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    <span class="comment">//1.通过initWithDriver会完成打开/dev/binder下的binder驱动设备和mmap内存映射动作</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps = ProcessState::initWithDriver(driver);</span><br><span class="line">    ps-&gt;setThreadPoolMaxThreadCount(<span class="number">0</span>);</span><br><span class="line">    ps-&gt;setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);</span><br><span class="line">    <span class="comment">//2.创建ServiceManager对象，并通过addService接口将自己注册为名为“manager”的Binder Server</span></span><br><span class="line">    sp&lt;ServiceManager&gt; manager = new ServiceManager(std::make_unique&lt;Access&gt;());</span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;addService(<span class="string">&quot;manager&quot;</span>, manager, <span class="literal">false</span> <span class="comment">/*allowIsolated*/</span>, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">&quot;Could not self register servicemanager&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPCThreadState::<span class="keyword">self</span>()-&gt;setTheContextObject(manager);</span><br><span class="line">    ps-&gt;becomeContextManager(nullptr, nullptr);<span class="comment">// 3.通知binder驱动将自己注册为binder服务大管家</span></span><br><span class="line"></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::prepare(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>);</span><br><span class="line"></span><br><span class="line">    BinderCallback::setupTo(looper);</span><br><span class="line">    ClientCallbackCallback::setupTo(looper, manager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(-<span class="number">1</span>);<span class="comment">// 4.循环等待其它模块请求服务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should not be reached</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了如下四件事情：</p>
<ol>
<li>通过调用ProcessState的initWithDriver静态接口，这其中会<strong>创建SM进程的ProcessState对象并完成进程的Binder初始化</strong>：先调用open_driver动作打开Binder驱动，然后调用mmap动作通知Binder驱动完成binder_mmap物理内存分配和虚拟内存映射的操作；</li>
<li>创建ServiceManager对象，并通过addService接口将SM自身注册为名为“manager”的Binder Server服务，<strong>也进一步说明SM自身本质上也是一个C++写的Binder Server服务进程</strong>；</li>
<li>调用ProcessState的becomeContextManager接口，<strong>通过binder_ioctl协议命令BINDER_SET_CONTEXT_MGR通知Binder设备驱动，将SM注册为binder服务“大管家”</strong>；</li>
<li>进入循环等待Binder Client进程的客户端进程访问请求。</li>
</ol>
<h2 id="ServiceManager进程Binder服务接口"><a href="#ServiceManager进程Binder服务接口" class="headerlink" title="ServiceManager进程Binder服务接口"></a>ServiceManager进程Binder服务接口</h2><p>我们看看ServiceManager.h接口文件的代码定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/cmds/servicemanager/ServiceManager.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManager</span> :</span> <span class="keyword">public</span> os::BnServiceManager, <span class="keyword">public</span> IBinder::DeathRecipient &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ServiceManager</span>(std::unique_ptr&lt;Access&gt;&amp;&amp; access);</span><br><span class="line">    ~<span class="built_in">ServiceManager</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// getService will try to start any services it cannot find</span></span><br><span class="line">    <span class="comment">// 1.根据名称查询Binder Server服务</span></span><br><span class="line">    <span class="function">binder::Status <span class="title">getService</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">binder::Status <span class="title">checkService</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> <span class="keyword">override</span></span>;</span><br><span class="line">     <span class="comment">// 2.注册Binder Server服务</span></span><br><span class="line">    <span class="function">binder::Status <span class="title">addService</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">bool</span> allowIsolated, <span class="keyword">int32_t</span> dumpPriority)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// 3.遍历列出所有已注册的Binder Server服务</span></span><br><span class="line">    <span class="function">binder::Status <span class="title">listServices</span><span class="params">(<span class="keyword">int32_t</span> dumpPriority, std::vector&lt;std::string&gt;* outList)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上一节对Binder framework C++层的分析我们可以看到：<strong>ServiceManager继承自BnServiceManager,是一个Binder Server服务端实现。对客户端提供getService查询Service服务、addService注册Service服务以及listServices遍历所有已注册服务等核心功能接口</strong>。 其内部具体的实现是通过一个全局的名为mNameToService的ServiceMap类型（本质上还是一个map类型的集合）的变量记录维护着服务名称和具体的服务代理之间映射关系；以addService注册服务的实现代码为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*framework/native/cmds/servicemanager/ServiceManager.cpp*/</span></span><br><span class="line"><span class="function">Status <span class="title">ServiceManager::addService</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">bool</span> allowIsolated, <span class="keyword">int32_t</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> entry = mNameToService.<span class="built_in">emplace</span>(name, Service &#123;</span><br><span class="line">        .binder = binder,</span><br><span class="line">        .allowIsolated = allowIsolated,</span><br><span class="line">        .dumpPriority = dumpPriority,</span><br><span class="line">        .debugPid = ctx.debugPid,</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="libbinder中对访问ServiceManager接口的封装"><a href="#libbinder中对访问ServiceManager接口的封装" class="headerlink" title="libbinder中对访问ServiceManager接口的封装"></a>libbinder中对访问ServiceManager接口的封装</h2><p>源码路径：</p>
<blockquote>
<p>frameworks/native/include/binder/IServiceManager.h frameworks/native/libs/binder/IServiceManager.cpp</p>
</blockquote>
<p><strong>这块逻辑相当于是Binder framework C++层的libbinder库作为Binder客户端对ServiceManager进程所提供的Binder服务端接口访问的封装。</strong></p>
<p>IServiceManager的C++接口定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/include/binder/IServiceManager.h*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">IServiceManager</span> : <span class="title">public</span> <span class="title">IInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.根据名称查询Binder Server服务</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve an existing service, blocking for a few seconds</span></span><br><span class="line"><span class="comment">     * if it doesn&#x27;t yet exist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt;         <span class="title">getService</span>(<span class="params"> <span class="keyword">const</span> String16&amp; name</span>) <span class="keyword">const</span></span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve an existing service, non-blocking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt;         <span class="title">checkService</span>(<span class="params"> <span class="keyword">const</span> String16&amp; name</span>) <span class="keyword">const</span></span> = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 2.注册Binder Server服务</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// NOLINTNEXTLINE(google-default-arguments)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span>(<span class="params"><span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="built_in">bool</span> allowIsolated = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="built_in">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_DEFAULT</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.遍历列出所有已注册的Binder Server服务</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return list of all existing services.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// NOLINTNEXTLINE(google-default-arguments)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt; <span class="title">listServices</span>(<span class="params"><span class="built_in">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_ALL</span>)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Efficiently wait for a service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns nullptr only for permission problem or fatal error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">waitForService</span>(<span class="params"><span class="keyword">const</span> String16&amp; name</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>普通的Binder服务我们需要通过ServiceManager来获取接口才能调用，那么ServiceManager的接口又该如何获得呢？<strong>在libbinder中，提供了一个defaultServiceManager方法来获取ServiceManager的代理，并且这个方法不需要传入参数</strong>。原因我们在驱动篇中也已经讲过了：Binder的实现中，为ServiceManager留了一个特殊的位置，不需要像普通服务那样通过标识去查找。defaultServiceManager代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/binder/IServiceManager.cpp*/</span></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(gSmOnce, []() &#123;</span><br><span class="line">        sp&lt;AidlServiceManager&gt; sm = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            sm = interface_cast&lt;AidlServiceManager&gt;(ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">nullptr</span>));</span><br><span class="line">            <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;Waiting 1s on context object on %s.&quot;</span>, ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getDriverName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gDefaultServiceManager = <span class="keyword">new</span> <span class="built_in">ServiceManagerShim</span>(sm);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Binder-Framework-Java层"><a href="#Binder-Framework-Java层" class="headerlink" title="Binder Framework Java层"></a>Binder Framework Java层</h1><h2 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h2><p>Android应用使用Java语言开发，Binder Framework框架自然也是提供了相关Java接口。<strong>前面我们已经分析了Binder Framework C++层的完整实现。因此Java层完全不用重复实现，而是通过虚拟机提供的JNI机制，直接调用而复用C++层的实现</strong>。下面借用一张图描述Binder Framework Java层到C++层的调用关系。</p>
<p><img src="/images/android_binder_frame_work_java_struct.png" alt="img"></p>
<h2 id="JNI衔接调用"><a href="#JNI衔接调用" class="headerlink" title="JNI衔接调用"></a>JNI衔接调用</h2><p><strong>JNI全称是Java Native Interface，这个是由Java虚拟机提供的机制。这个机制使得native代码可以和Java代码互相通讯</strong>。简单来说就是：我们可以在C/C++端调用Java代码，也可以在Java端调用C/C++代码。实际上，在Android中很多的服务或者机制都是在C/C++层实现的，想要将这些实现复用到Java层，就必须通过JNI进行衔接。其实这里面就是解决两个方向的调用问题：</p>
<ol>
<li><strong>Java端的代码是如何调用的libbinder中的C++方法的？</strong> 以BinderProxy.java中的transact方法为例，其功能是实现Java层的Binder客户端使用服务端的远端代理完成一次Binder数据发送传输，简化代码实现如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/os/BinderProxy.java*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ..</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Native implementation of transact() for proxies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transactNative</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到方法transactNative是用native关键字修饰的，并且没有方法实现体，这些方法其实都是在C++中实现的。在android_util_Binder.cpp文件中的下面这段代码，定义了Java方法与C++方法的对应关系，并定义了真正的实现，简化代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/jni/android_util_Binder.cpp*/</span></span><br><span class="line"><span class="comment">// 集合中定义了Java方法与C++方法的对应关系</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gBinderProxyMethods[] = &#123;</span><br><span class="line">     <span class="comment">/* name, signature, funcPtr */</span></span><br><span class="line">     ...</span><br><span class="line">    &#123;<span class="string">&quot;transactNative&quot;</span>,      <span class="string">&quot;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderProxy_transact&#125;,</span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.获取BpBinder对象</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2.调用libbinder中的BpBinder的transact接口实现真正的Binder传输</span></span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>libbinder如何能够通知调用到Java层呢？</strong> 下面以libbinder中的BBinder::onTransact如何调用到Java中的Binder::onTransact为例进行分析：这段逻辑是在android_util_Binder.cpp中JavaBBinder::onTransact（<strong>JavaBBinder是BBinder子类</strong>）中<strong>借用虚拟机提供的CallBooleanMethod接口实现native方法调用Java Object上的方法实现</strong>。简化代码实现如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/jni/android_util_Binder.cpp*/</span></span><br><span class="line"><span class="comment">// JavaBBinder是BBinder的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBBinder</span> :</span> <span class="keyword">public</span> BBinder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 1\. CallBooleanMethod这个方法是由虚拟机提供的实现native方法来调用一个Java Object上的方法。这一行代码其实是在调用mObject上offset为mExecTransact的方法,</span></span><br><span class="line">        jboolean res = env-&gt;<span class="built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">            code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderPathName = <span class="string">&quot;android/os/Binder&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderPathName);</span><br><span class="line">    <span class="comment">// 2\. 找到android/os/Binder.java中的execTransact方法</span></span><br><span class="line">    gBinderOffsets.mExecTransact = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;execTransact&quot;</span>, <span class="string">&quot;(IJJI)Z&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, <span class="built_in">NELEM</span>(gBinderMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/os/Binder.java*/</span></span><br><span class="line"> <span class="comment">// Entry point from android_util_Binder.cpp&#x27;s onTransact</span></span><br><span class="line">    @<span class="function">UnsupportedAppUsage</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> boolean <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">execTransactInternal</span>(code, dataObj, replyObj, flags, callingUid);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            ThreadLocalWorkSource.<span class="built_in">restore</span>(origWorkSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">execTransactInternal</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> callingUid)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; FLAG_COLLECT_NOTED_APP_OPS) != <span class="number">0</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用到java层的onTransact实现</span></span><br><span class="line">                res = <span class="built_in">onTransact</span>(code, data, reply, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span> (RemoteException|RuntimeException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-Binder服务实现举例"><a href="#Java-Binder服务实现举例" class="headerlink" title="Java Binder服务实现举例"></a>Java Binder服务实现举例</h2><p>和C++层一样，这里我们还是通过一个具体的实例来看一下Java层的Binder服务是如何实现的。 以系统框架system_server进程的核心服务ActivityManager为例，下面是其实现的类图结构：</p>
<p><img src="/images/android_binder_java_binder_example.png" alt="img"></p>
<p>Binder_ActivityManager.png</p>
<p>IActivityManager接口定义了ActivityManager对外提供的功能接口，其子类都继承了这些接口。</p>
<ul>
<li>IActivityManager.Stub.Proxy是提供给客户端调用的远程接口，<strong>获取到指向服务实现方的句柄BinderProxy，然后通过transact方法发送具体请求</strong>。</li>
<li>IActivityManager.Stub是服务端的实现，<strong>其中只有一个onTransact方法，该方法根据请求的code来对接每个请求，并直接调用ActivityManagerService中对应的方法</strong>。</li>
<li>ActivityManagerService是服务端接口功能真正的实现。</li>
</ul>
<p><strong>可以看到，这种组织架构和4.4.4小结中Binder C++层SurfaceFlinger服务基本是一样的</strong>。对于Android应用程序的开发者来说，系统对这些类进行了封装，所以我们不会直接接触到上图中的几个类，而是使用android.app.ActivityManager中的接口。那ActivityManager中的接口与上图的实现是什么关系呢。我们选取其中的一个方法来看一下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityManager.java*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;RunningAppProcessInfo&gt; <span class="title">getRunningAppProcesses</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getService().getRunningAppProcesses();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的实现调用了getService()中的方法，因此我们在来看一下getService()返回到到底是什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityManager.java*/</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">            <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 1.通过访问ServiceManager按照服务名“activity”查询获取到远端服务的代理IBinder对象</span></span><br><span class="line">                    <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                    <span class="comment">// 2.调用asInterface将获取到的远端服务代理IBinder对象转换封装成客户端IActivityManager接口对象</span></span><br><span class="line">                    <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    <span class="keyword">return</span> am;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<p>这里其实是先通过IBinder b = ServiceManager.getService(“activity”); 向 ServiceManager查询获取到ActivityManager的远端服务代理Binder对象（<strong>该AMS系统核心服务在系统开机过程中提前在ServiceManager Binder“大管家”进程中注册，且服务名为“activity”</strong>）;接着我们再来看一下asInterface(b)的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*gen/android/app/IActivityManager.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.app.<span class="function">IActivityManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">      <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> android.app.IActivityManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.app.IActivityManager)iin);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> android.app.IActivityManager.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先通过queryLocalInterface确定有没有本地Binder，如果有的话直接返回，否则创建一个android.app.IActivityManager.Stub.Proxy客户端代理对象。</p>
<h2 id="AIDL机制"><a href="#AIDL机制" class="headerlink" title="AIDL机制"></a>AIDL机制</h2><p>Android应用开发者对AIDL机制应该不会陌生，AIDL全称是Android Interface Definition Language，它是Android SDK提供的一种机制。借助这个机制，应用可以提供跨进程的服务供其他应用使用。<strong>aidl文件使用Java语言的语法来定义，每个.aidl文件只能包含一个interface，并且要包含interface的所有方法声明。</strong>。 下面是一个aidl文件的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterface.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.myapplication;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">long</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(in <span class="keyword">int</span>[] numbers)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件中包含了两个接口add和sum。<strong>对于包含.aidl文件的工程，Android IDE在编译项目的时候，会为aidl文件生成对应的Java文件</strong>。针对上面这个aidl文件编译后生成的java文件中包含的结构如下图所示：</p>
<p><img src="/images/android_binder_aidl_my_aidl.png" alt="img"></p>
<p>在这个生成的Java文件中，包括了：</p>
<ol>
<li><strong>公共接口定义</strong>：一个名称为IMyAildInterface的interface，该interface继承自android.os.IInterface并且包含了我们在aidl文件中声明的接口方法add和sum。</li>
<li><strong>Binder服务端实现封装</strong>：IMyAildInterface中包含了一个名称为Stub的静态内部类，这个类是一个抽象类，<strong>它继承自android.os.Binder并且实现了IMyAildInterface接口。这个类中包含了一个onTransact方法</strong>。</li>
<li><strong>Binder客户端实现封装</strong>：Stub内部又包含了一个名称为Proxy的静态内部类，<strong>Proxy类同样实现了IMyAildInterface接口，内部通过持有android.os.IBinder类型的mRemote远程服务代理对象</strong>，调用其transact方法实现Binder访问。</li>
</ol>
<p><strong>从这个过程也可以看出，AIDL是典型的代理设计模式的思想体现，本质上是对Java层Binder逻辑在编译时自动简化封装，省去应用开发者去写公共且繁琐的实现代理模式相关代码。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们基本上从下到上完整的分析了整个Binder进程间通信机制的全貌，这可以说是Android系统中最复杂的模块之一了，也是整个系统运行的基石。建议每一位有志于成为Android开发专家的读者都有必要好好研读一下本章节的全部内容。最后借用一张业界大佬绘制的Binder IPC机制整体数据传输架构图来结束本章节的全部内容。</p>
<p><img src="/images/android_binder_end_summary.png" alt="img"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>转载参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b47caded149a">https://www.jianshu.com/p/b47caded149a</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6/" rel="tag"># 系统机制</a>
              <a href="/tags/IPC/" rel="tag"># IPC</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/05/08/algorithm_dynamic_program_base/" rel="prev" title="动态规划解题套路示例">
                  <i class="fa fa-chevron-left"></i> 动态规划解题套路示例
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/06/25/android_binder_faq/" rel="next" title="Android Binder机制相关的灵魂发问">
                  Android Binder机制相关的灵魂发问 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">贾俊辉</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  





</body>
</html>
