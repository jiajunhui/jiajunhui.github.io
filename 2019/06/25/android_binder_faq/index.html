<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="Binder机制是Android系统中最重要的系统机制之一，关于Binder机制的细节问题更是多入牛毛。对于常见的一些问题整理如下：">
<meta property="og:type" content="article">
<meta property="og:title" content="Android Binder机制相关的灵魂发问">
<meta property="og:url" content="http://example.com/2019/06/25/android_binder_faq/index.html">
<meta property="og:site_name" content="奔跑的蜗牛">
<meta property="og:description" content="Binder机制是Android系统中最重要的系统机制之一，关于Binder机制的细节问题更是多入牛毛。对于常见的一些问题整理如下：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/android_binder_faq_binder_ref_add_logic.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_two_binder_ref_tree.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_one_copy.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_sys_binder_and_bind_service.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_app_support_binder.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_binder_wake_stack_list01.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_binder_wake_stack_list02.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_binder_wake_stack_list03.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_br_bc.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_transport_cover.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_native_bbinder_java_binder.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_service_connection.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_bind_service_global_flow.png">
<meta property="og:image" content="http://example.com/images/android_binder_faq_bind_service_flow.png">
<meta property="article:published_time" content="2019-06-25T15:19:00.000Z">
<meta property="article:modified_time" content="2023-01-04T07:34:02.252Z">
<meta property="article:author" content="小贾">
<meta property="article:tag" content="系统机制">
<meta property="article:tag" content="总结">
<meta property="article:tag" content="IPC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/android_binder_faq_binder_ref_add_logic.png">


<link rel="canonical" href="http://example.com/2019/06/25/android_binder_faq/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;2019&#x2F;06&#x2F;25&#x2F;android_binder_faq&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;06&#x2F;25&#x2F;android_binder_faq&#x2F;&quot;,&quot;title&quot;:&quot;Android Binder机制相关的灵魂发问&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Android Binder机制相关的灵魂发问 | 奔跑的蜗牛</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">奔跑的蜗牛</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">为什么要引入多进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-IPC-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">Android中常见的跨进程通信(IPC)的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBinder"><span class="nav-number">3.</span> <span class="nav-text">什么是Binder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServiceManager%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">ServiceManager进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Client%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">Client进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Server%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">Server进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">Binder机制中的一次拷贝原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AIDL%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">AIDL中的代理模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AIDL%E7%9A%84%E8%B7%A8%E8%BF%9B%E7%A8%8B%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">AIDL的跨进程具体实现过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E5%A6%82%E4%BD%95%E7%B2%BE%E7%A1%AE%E5%88%B6%E5%AF%BC%EF%BC%8C%E6%89%BE%E5%88%B0%E7%9B%AE%E6%A0%87Binder%E5%AE%9E%E4%BD%93%EF%BC%8C%E5%B9%B6%E5%94%A4%E9%86%92%E8%BF%9B%E7%A8%8B%E6%88%96%E8%80%85%E7%BA%BF%E7%A8%8B"><span class="nav-number">10.</span> <span class="nav-text">Binder如何精确制导，找到目标Binder实体，并唤醒进程或者线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binder-proc%E4%B8%BA%E4%BD%95%E4%BC%9A%E6%9C%89%E4%B8%A4%E6%A3%B5binder-ref%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">11.</span> <span class="nav-text">binder_proc为何会有两棵binder_ref红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E4%B8%80%E6%AC%A1%E6%8B%B7%E8%B4%9D%E5%8E%9F%E7%90%86"><span class="nav-number">12.</span> <span class="nav-text">Binder一次拷贝原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6"><span class="nav-number">13.</span> <span class="nav-text">Binder传输数据的大小限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E4%B8%8EbindService%E7%AD%89%E5%90%AF%E5%8A%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">系统服务与bindService等启动的服务的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E7%BA%BF%E7%A8%8B%E3%80%81Binder%E4%B8%BB%E7%BA%BF%E7%A8%8B%E3%80%81Client%E8%AF%B7%E6%B1%82%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-number">15.</span> <span class="nav-text">Binder线程、Binder主线程、Client请求线程的概念与区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E8%AF%B7%E6%B1%82%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="nav-number">16.</span> <span class="nav-text">Binder请求的同步与异步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-APP%E8%BF%9B%E7%A8%8B%E5%A4%A9%E7%94%9F%E6%94%AF%E6%8C%81Binder%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">17.</span> <span class="nav-text">Android APP进程天生支持Binder通信的原理是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-APP%E6%9C%89%E5%A4%9A%E5%B0%91Binder%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">Android APP有多少Binder线程，是固定的么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%AF%B7%E6%B1%82%E5%BF%85%E5%AE%9A%E6%98%AF%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%8D%B3%E4%BD%BF%E6%98%AF%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82-oneway"><span class="nav-number">19.</span> <span class="nav-text">同一个线程的请求必定是顺序执行，即使是异步请求(oneway)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Client%E7%AB%AF%E7%BA%BF%E7%A8%8B%E7%9D%A1%E7%9C%A0%E5%9C%A8%E5%93%AA%E4%B8%AA%E9%98%9F%E5%88%97%E4%B8%8A%EF%BC%8C%E5%94%A4%E9%86%92Server%E7%AB%AF%E5%93%AA%E4%B8%AA%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E4%B8%8A%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">20.</span> <span class="nav-text">Client端线程睡眠在哪个队列上，唤醒Server端哪个等待队列上的线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E5%8D%8F%E8%AE%AE%E4%B8%ADBC%E4%B8%8EBR%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">21.</span> <span class="nav-text">Binder协议中BC与BR的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E5%9C%A8%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%A6%82%E4%BD%95%E5%B1%82%E5%B1%82%E5%B0%81%E8%A3%85%E7%9A%84%E2%80%93%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B0%81%E8%A3%85%EF%BC%89"><span class="nav-number">22.</span> <span class="nav-text">Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binder%E9%A9%B1%E5%8A%A8%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E9%87%8A%E6%94%BE%EF%BC%88%E9%87%8A%E6%94%BE%E6%97%B6%E6%9C%BA%EF%BC%89"><span class="nav-number">23.</span> <span class="nav-text">Binder驱动传递数据的释放（释放时机）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServiceManager-addService%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">24.</span> <span class="nav-text">ServiceManager addService的限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bindService%E5%90%AF%E5%8A%A8Service%E4%B8%8EBinder%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BD%93%E7%9A%84%E6%B5%81%E7%A8%8B-%EF%BC%88ActivityManagerService%EF%BC%89"><span class="nav-number">25.</span> <span class="nav-text">bindService启动Service与Binder服务实体的流程 （ActivityManagerService）</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小贾"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">小贾</p>
  <div class="site-description" itemprop="description">Just do IT</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jiajunhui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiajunhui" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:junhui_jia@163.com" title="E-Mail → mailto:junhui_jia@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/jiajunhui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/06/25/android_binder_faq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="小贾">
      <meta itemprop="description" content="Just do IT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔跑的蜗牛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android Binder机制相关的灵魂发问
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-25 23:19:00" itemprop="dateCreated datePublished" datetime="2019-06-25T23:19:00+08:00">2019-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Binder机制是Android系统中最重要的系统机制之一，关于Binder机制的细节问题更是多入牛毛。对于常见的一些问题整理如下：</p>
<span id="more"></span>

<h2 id="为什么要引入多进程"><a href="#为什么要引入多进程" class="headerlink" title="为什么要引入多进程"></a>为什么要引入多进程</h2><p>第一点：Android系统为每个APP会分配固定大小的内存。如果一个APP需要更多的内存空间，要么就可以引入多进程，让某些模块运行在另外的进程中，获取更大的内存；</p>
<p>第二点：由于每个APP运行在不同的进程中，若共享APP中的某些数据的时候，例如通讯录等。</p>
<h2 id="Android中常见的跨进程通信-IPC-的方式"><a href="#Android中常见的跨进程通信-IPC-的方式" class="headerlink" title="Android中常见的跨进程通信(IPC)的方式"></a>Android中常见的跨进程通信(IPC)的方式</h2><ul>
<li>Bundle：常用于四大组件之间的通信，实现了Parcelable接口；</li>
<li>ContentProvider：存储和获取数据，不同APP之间共享数据；</li>
<li>文件共享：常用于无并发，交换数据实时性不高；</li>
<li>Messenger：在不同进程通过Message传输，只支持Bundle支持的数据类型，不支持RPC（远程过程调用：Client调用Server的方法）；低并发的一对多的串行通信（串行的方式接收Client发出的消息）；最底层基于AIDL；</li>
<li>AIDL：一对多并发通信（Server支持同时处理大量消息），支持RPC；</li>
<li>Socket：网络数据交换</li>
</ul>
<h2 id="什么是Binder"><a href="#什么是Binder" class="headerlink" title="什么是Binder"></a>什么是Binder</h2><p>在Linux系统中，会将虚拟空间分为用户空间和内核空间。系统每启动一个APP，就会给APP在用户空间创建一个进程；由于Android系统对每个APP是有内存限制，如果想给该APP申请更大的内存，同样也可以在该APP中额外创建一个进程来运行其他模块。</p>
<p>由于进程间是不能互相访问的，只能通过内核空间进行中转，而Binder机制就是Android系统中的一种跨进程通信的方式。</p>
<p>Binder机制需要四部分组成：<strong>Server、Client、ServiceManager</strong>以及Binder驱动。前三个运行在用户空间，Binder驱动运行在内核空间。<strong>Server、Client、ServiceManager</strong>之间进行数据通信，都需要通过Binder驱动进行中转。</p>
<p>相对于Linux其他IPC方式来说，Binder机制只需要拷贝一次数据，并且在用Binder驱动传递数据的时候，分配和传输数据一样大的内存，节省了内存和时间。（因为Linux系统的其他IPC因为不知道传输数据的大小，所以目标进程为了能够有足够的空间来存放数据，通常会分配尽可能大的空间；或者有的IPC通过先解析消息头的信息来获取消息体的大小，例如Socket，浪费空间或时间）。</p>
<h2 id="ServiceManager进程"><a href="#ServiceManager进程" class="headerlink" title="ServiceManager进程"></a>ServiceManager进程</h2><p>用来管理Service的注册和查询。将字符串转换层对应的Binder引用。该进程为系统启动的时候，有init进程创建出来的。在ServiceManager进程创建的过程中，会执行两步操作：</p>
<ul>
<li>第一步：通过binder_open()打开“/dev/binder”设备文件，获取一个文件描述符，才可以与Binder驱动进行交互；</li>
<li>第二步：通过mmap将该设备文件映射到用户空间的虚拟内存，同时系统调用到内核，也在内核空间分配虚拟内存，同时申请一块物理内存，同时映射到用户空间对应的虚拟内存和内核空间对应的虚拟内存中；</li>
<li>第三步：通过ioctl发送指令，告诉Binder驱动，该进程为ServiceManager进程；</li>
<li>第四步：通过binder_loop()，开启一个循环，时刻等待Binder驱动发送过来的消息；</li>
<li>第五步：当接收Binder驱动发送的消息时，通过binder_parse()解析和处理消息。</li>
</ul>
<h2 id="Client进程"><a href="#Client进程" class="headerlink" title="Client进程"></a>Client进程</h2><p>通常APP进程会作为Client进程。</p>
<p>当Android系统启动的时候，启动的第一个用户进程为init进程，init进程fork出Zygote进程，Android的其他进程都是有Zygote进程fork出来的。</p>
<p>一个进程要经历创建、初始化以及加载功能。那么Zygote进程有init进程创建出来的，在完成初始化加载功能的时候，会创建一个Socket通信的ZygoteServer，用来接收AMS发出创建进程的请求；同时fork出system_server进程，完成system_server进程初始化、功能加载：system_server进程主要就是启动一些系统Service，如AMS、PMS、WMS等。</p>
<p>当Zygote进程接收到AMS创建APP进程的时候，维护的循环中就会通过Zygote进程fork出一个进程，完成APP进程的初始化、功能加载：主要加载了APP的入口类ActivityThread，通过维护的循环消息机制来完成对Activity、Broadcast、Service等操作。</p>
<p>APP进程需要通过Binder驱动与其他进程通信，同样需要获取“/dev/binder”设备文件的描述符，并且在用户空间分配虚拟内存，在内核空间对应分配虚拟内存，同时申请一块物理内存，完成映射。区别于ServiceManager进程，该APP进程会设置Binder驱动的最大连接数，默认的为15个，只会创建binder主线程，其他的线程有Binder驱动来控制创建。</p>
<h2 id="Server进程"><a href="#Server进程" class="headerlink" title="Server进程"></a>Server进程</h2><p>在APP中都是通过AMS来启动Service，在启动Service之前会判断该Service的进程是否和APP的进程一致，如果跟APP的进程一致，则直接通过ActivityThread中维护的消息队列来启动该Service；如果不在APP的进程中，则会通过AMS的startProcessLocked()，最终将进程的信息写入到与Zygote进程的socket通道中，Zygote进程收到消息之后，同样会通过Zygote进程fork出一个进程，并完成该进程的初始化、功能加载，同样也是加载了一个ActivityThread类。</p>
<p>只不过bindService在创建完进程之后，还会发送通过ActivityThread的消息机制完成Service的bind过程。</p>
<p>扩展几个小问题：</p>
<p>1.为什么Zygote进程与system_server进程之间的通信采用Socket，而不是Binder</p>
<ul>
<li>（1）Binder机制的前提的是ServiceManager进程创建出来，而SeviceManager进程和Zygote进程都是有init进程创建的，并且Zygote进程会先在ServiceManager进程前面一点点，而Zygote进程在fork出system_server进程的进程的时候，不能完全保证ServiceManager进程已经创建完。</li>
<li>（2）Zygote进程与system_server进程之间的socket的所有者是root，group是system，只有系统权限的用户才能读写，增加了安全保障。</li>
</ul>
<p>2.为什么Zygote进程是fork出APP或者Service进程，而不是新建进程<br> 每个APP都运行在各自的Dalivk虚拟机中，APP每次启动的时候都要初始化和启动虚拟机，这个过程会很费时间。而Zygote进程通过fork把已经运行的虚拟机和内存信息共享，可以预加载资源和类，缩短启动时间</p>
<h2 id="Binder机制中的一次拷贝原理"><a href="#Binder机制中的一次拷贝原理" class="headerlink" title="Binder机制中的一次拷贝原理"></a>Binder机制中的一次拷贝原理</h2><p>进程之间使用Binder驱动来进行通信，需要首先获取一个dev/binder设备文件的文件描述符，才可以与Binder驱动交互。Binder驱动会为每个进程创建一个binder_proc的结构体，然后将该结构体放到全局的hash队列binder_procs中，只要遍历该队列，就知道当前有多少进程在使用Binder通信。</p>
<p>其次还需要利用mmap内存映射，可以将/dev/binder设备文件映射到用户空间的虚拟内存中。系统在为该文件内存映射的时候，不仅在用户空间分配虚拟内存，并且还会在内核空间分配虚拟内存，并且Kernel还会申请一块物理内存同时映射到用户空间对应的虚拟内存和在内核空间对应的虚拟内存；这样如果将数据拷贝到用户空间，都是相当于拷贝到内核空间，反之亦然。</p>
<p>在将数据从发送进程传递到目标进程的时候：</p>
<ul>
<li>（1）首先将数据从发送进程的用户空间对应的虚拟内存拷贝到内核空间对应的虚拟内存中；</li>
<li>（2）然后使用Binder驱动传递数据的时候，Binder驱动会为该数据创建一个数据接收缓冲区，而该缓冲区是从目标进程在内核空间对应的虚拟内存开始分配虚拟内存，那么当把数据从发送进程对应的虚拟内存拷贝到Binder驱动的数据缓冲区的时候，其实就相当于直接拷贝到目标进程在内核空间对应的虚拟内存中。</li>
<li>（3）由于前面创建目标进程的时候，由于进程在用户空间分配的虚拟内存和在内核空间对应的虚拟内存存在映射关系，实际上上面的过程就是直接拷贝到了目标进程在用户空间分配的虚拟内存中。</li>
<li>（4）目标进程将数据从内核空间对应的虚拟内存拷贝到用户空间对应的虚拟内存。</li>
</ul>
<p>这样就完成了Binder机制中的一次拷贝，我觉得所谓的Binder机制的一次拷贝，指的是用Binder驱动传递数据的时候只需要拷贝一次数据。</p>
<h2 id="AIDL中的代理模式"><a href="#AIDL中的代理模式" class="headerlink" title="AIDL中的代理模式"></a>AIDL中的代理模式</h2><p>两个进程之间的跨进程通信必须通过Binder驱动进行中转。在应用层创建的AIDL文件，最终会将该文件编译成一个java文件。该文件包括三部分的内容：</p>
<ul>
<li>（1）公共接口：制定Server进程所要实现功能的标准，为代理模式的公共接口；</li>
<li>（2）Stub：继承Binder，用于Server进程来访问Binder驱动；实现公共接口的抽象类（这里还是一个适配器模式），实现公共接口的具体功能，为代理模式的被代理类；</li>
<li>（3）Stub.Proxy：实现公共接口，并持有Stub的对象（这个只不过是Binder驱动的本地对象BinderProxy，该BinderProxy对象用于Client进程来访问Binder驱动），实现两个进程的RPC，为代理模式的代理类。</li>
</ul>
<h2 id="AIDL的跨进程具体实现过程"><a href="#AIDL的跨进程具体实现过程" class="headerlink" title="AIDL的跨进程具体实现过程"></a>AIDL的跨进程具体实现过程</h2><p>AIDL服务是应用层的Service，区别与系统Service，系统Service是通过ServiceManager进程来管理，而应用Service是通过AMS来管理。</p>
<p>Client和Server之所以能够实现跨进程通信，都是通过Binder驱动进行中转。Android系统在Framework层和Native层对Binder驱动进行封装，使得应用层可以通过API调用到Binder驱动。</p>
<p><strong>在native层封装体现：</strong></p>
<ul>
<li>（1）进程在Native层会通过ProcessState初始化进程主要会完成下面内容：<br> 通过ProcessState来获取Binder驱动的设备文件”/dev/binder”的文件描述符，完成内存映射；<br> 开启Binder线程池，创建线程池中的第一个Binder主线程IPCThreadState；<br> 在该Binder主线程中维护一个循环，来读取Binder驱动发送过来的消息。</li>
<li>（2）Binder驱动在向进程中binder_read_thread的时候，都会先看下有没有空闲的Binder线程，如果没有则通知ProcesState的Binder线程池创建一个Binder非主线程来发送消息；</li>
<li>（3）进程通过IPCThreadState调用ioctl来与Binder驱动进行传递信息。Client进程通过BpBinder来调用到ioctl完成向Binder驱动发送数据，而在Server进程通过BBinder，准确的说是JavaBBinder完成向Binder驱动发送数据。<br> 在应用层主要是通过Framework封装的API来完成IPC的，在Framework层封装体现：</li>
<li>（1）Client通过bindService将ServiceConnection给到Server，当Server创建成功的时候，通过onBind将BinderProxy返回给Client；</li>
<li>（2）在Client进程就是通过BinderProxy来向Binder驱动发送数据，在Server进程会继承Stub，也是Binder的子类，通过Binder来向Binder驱动传递数据；<br> 当Client要访问Server进程的RPC（Remote Process Call远程过程调用）的时候：</li>
<li>（1）Client进程调用BinderProxy的transact()，通过jni调用到BpBinder的transact()，然后调用到IPCThreadState向Binder驱动发送数据；</li>
<li>（2）Binder驱动接收到Client进程发送的指令的时候，就会通过BBinder的ransact()调用到JavaBBinder的onTransact()，通过jni调用到Server进程的Binder的onTransact()，最终调用到Stub中对应的接口方法，完成RPC。</li>
</ul>
<h2 id="Binder如何精确制导，找到目标Binder实体，并唤醒进程或者线程"><a href="#Binder如何精确制导，找到目标Binder实体，并唤醒进程或者线程" class="headerlink" title="Binder如何精确制导，找到目标Binder实体，并唤醒进程或者线程"></a>Binder如何精确制导，找到目标Binder实体，并唤醒进程或者线程</h2><p>Binder实体服务其实有两种，一是通过addService注册到ServiceManager中的服务，比如ActivityManagerService、PackageManagerService、PowerManagerService等，一般都是系统服务；还有一种是通过bindService拉起的一些服务，一般是开发者自己实现的服务。这里先看通过addService添加的被ServiceManager所管理的服务。有很多分析ServiceManager的文章，本文不分析ServiceManager，只是简单提一下，ServiceManager是比较特殊的服务，所有应用都能直接使用，因为ServiceManager对于Client端来说Handle句柄是固定的，都是0，所以ServiceManager服务并不需要查询，可以直接使用。</p>
<p>理解Binder定向制导的关键是理解Binder的四棵红黑树，先看一下binder_proc结构体，在它内部有四棵红黑树，threads，nodes，refs_by_desc，refs_by_node，nodes就是Binder实体在内核中对应的数据结构，binder_node里记录进程相关的binder_proc，还有Binder实体自身的地址等信息，nodes红黑树位于binder_proc，可以知道Binder实体其实是进程内可见，而不是线程内。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span></span><br><span class="line">    。。。</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">    。。。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在假设存在一堆Client与Service，Client如何才能访问Service呢？首先Service会通过addService将binder实体注册到ServiceManager中去，Client如果想要使用Servcie，就需要通过getService向ServiceManager请求该服务。在Service通过addService向ServiceManager注册的时候，ServiceManager会将服务相关的信息存储到自己进程的Service列表中去，同时在ServiceManager进程的binder_ref红黑树中为Service添加binder_ref节点，这样ServiceManager就能获取Service的Binder实体信息。而当Client通过getService向ServiceManager请求该Service服务的时候，ServiceManager会在注册的Service列表中查找该服务，如果找到就将该服务返回给Client，在这个过程中，ServiceManager会在Client进程的binder_ref红黑树中添加binder_ref节点，可见<strong>本进程中的binder_ref红黑树节点都不是本进程自己创建的，要么是Service进程将binder_ref插入到ServiceManager中去，要么是ServiceManager进程将binder_ref插入到Client中去</strong>。之后，Client就能通过Handle句柄获取binder_ref，进而访问Service服务。</p>
<p><img src="/images/android_binder_faq_binder_ref_add_logic.png" alt="img"></p>
<p>binder_ref添加逻辑</p>
<p>getService之后，便可以获取binder_ref引用，进而获取到binder_proc与binder_node信息，之后Client便可有目的的将binder_transaction事务插入到binder_proc的待处理列表，并且，如果进程正在睡眠，就唤起进程，其实这里到底是唤起进程还是线程也有讲究，对于Client向Service发送请求的状况，一般都是唤醒binder_proc上睡眠的线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node_entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> desc;</span><br><span class="line">    <span class="keyword">int</span> strong;</span><br><span class="line">    <span class="keyword">int</span> weak;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="binder-proc为何会有两棵binder-ref红黑树"><a href="#binder-proc为何会有两棵binder-ref红黑树" class="headerlink" title="binder_proc为何会有两棵binder_ref红黑树"></a>binder_proc为何会有两棵binder_ref红黑树</h2><p>binder_proc中存在两棵binder_ref红黑树，其实两棵红黑树中的节点是复用的，只是查询方式不同，一个通过handle句柄，一个通过node节点查找。个人理解：refs_by_node红黑树主要是为了<br> binder驱动往用户空间写数据所使用的，而refs_by_desc是用户空间向Binder驱动写数据使用的，只是方向问题。比如在服务addService的时候，binder驱动会在在ServiceManager进程的binder_proc中查找binder_ref结构体，如果没有就会新建binder_ref结构体，再比如在Client端getService的时候，binder驱动会在Client进程中通过 binder_get_ref_for_node为Client创建binder_ref结构体，并分配句柄，同时插入到refs_by_desc红黑树中，可见refs_by_node红黑树，主要是给binder驱动往用户空间写数据使用的。相对的refs_by_desc主要是为了用户空间往binder驱动写数据使用的，当用户空间已经获得Binder驱动为其创建的binder_ref引用句柄后，就可以通过binder_get_ref从refs_by_desc找到响应binder_ref，进而找到目标binder_node。可见有两棵红黑树主要是区分使用对象及数据流动方向，看下面的代码就能理解：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据32位的uint32_t desc来查找，可以看到，binder_get_ref不会新建binder_ref节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span> *binder_get_ref(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                     uint32_t desc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span> *n = proc-&gt;refs_by_desc.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span> *<span class="keyword">ref</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">ref</span> = rb_entry(n, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span>, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (desc &lt; <span class="keyword">ref</span>-&gt;desc)</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (desc &gt; <span class="keyword">ref</span>-&gt;desc)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">ref</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到binder_get_ref并具备binder_ref的创建功能，相对应的看一下binder_get_ref_for_node，binder_get_ref_for_node红黑树主要通过binder_node进行查找，如果找不到，就新建binder_ref，同时插入到两棵红黑树中去</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span> *binder_get_ref_for_node(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                          <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span></span> *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span> *n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span> **p = &amp;proc-&gt;refs_by_node.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span> *parent = NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span> *<span class="keyword">ref</span>, *new_ref;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        <span class="keyword">ref</span> = rb_entry(parent, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span>, rb_node_node);</span><br><span class="line">        <span class="keyword">if</span> (node &lt; <span class="keyword">ref</span>-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node &gt; <span class="keyword">ref</span>-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">ref</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_ref 可以在两棵树里面，但是，两棵树的查询方式不同，并且通过desc查询，不具备新建功能</span></span><br><span class="line">    new_ref = kzalloc(sizeof(*<span class="keyword">ref</span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (new_ref == NULL)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    binder_stats_created(BINDER_STAT_REF);</span><br><span class="line">    new_ref-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    new_ref-&gt;proc = proc;</span><br><span class="line">    new_ref-&gt;node = node;</span><br><span class="line">    rb_link_node(&amp;new_ref-&gt;rb_node_node, parent, p);</span><br><span class="line">    <span class="comment">// 插入到proc-&gt;refs_by_node红黑树中去</span></span><br><span class="line">    rb_insert_color(&amp;new_ref-&gt;rb_node_node, &amp;proc-&gt;refs_by_node);</span><br><span class="line">    <span class="comment">// 是不是ServiceManager的</span></span><br><span class="line">    new_ref-&gt;desc = (node == binder_context_mgr_node) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 分配Handle句柄，为了插入到refs_by_desc</span></span><br><span class="line">    <span class="keyword">for</span> (n = rb_first(&amp;proc-&gt;refs_by_desc); n != NULL; n = rb_next(n)) &#123;</span><br><span class="line">        <span class="keyword">ref</span> = rb_entry(n, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span>, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">ref</span>-&gt;desc &gt; new_ref-&gt;desc)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        new_ref-&gt;desc = <span class="keyword">ref</span>-&gt;desc + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到目标位置</span></span><br><span class="line">    p = &amp;proc-&gt;refs_by_desc.rb_node;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        <span class="keyword">ref</span> = rb_entry(parent, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span>, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (new_ref-&gt;desc &lt; <span class="keyword">ref</span>-&gt;desc)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (new_ref-&gt;desc &gt; <span class="keyword">ref</span>-&gt;desc)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    rb_link_node(&amp;new_ref-&gt;rb_node_desc, parent, p);</span><br><span class="line">    <span class="comment">// 插入到refs_by_desc红黑树中区</span></span><br><span class="line">    rb_insert_color(&amp;new_ref-&gt;rb_node_desc, &amp;proc-&gt;refs_by_desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        hlist_add_head(&amp;new_ref-&gt;node_entry, &amp;node-&gt;refs);</span><br><span class="line">        binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">                 <span class="string">&quot;binder: %d new ref %d desc %d for &quot;</span></span><br><span class="line">                 <span class="string">&quot;node %d\n&quot;</span>, proc-&gt;pid, new_ref-&gt;debug_id,</span><br><span class="line">                 new_ref-&gt;desc, node-&gt;debug_id);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">                 <span class="string">&quot;binder: %d new ref %d desc %d for &quot;</span></span><br><span class="line">                 <span class="string">&quot;dead node\n&quot;</span>, proc-&gt;pid, new_ref-&gt;debug_id,</span><br><span class="line">                  new_ref-&gt;desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用在binder_transaction函数中，其实就是在binder驱动访问target_proc的时候，这也也很容易理解，Handle句柄对于跨进程没有任何意义，进程A中的Handle，放到进程B中是无效的。</p>
<p><img src="/images/android_binder_faq_two_binder_ref_tree.png" alt="img"></p>
<p>两棵binder_ref红黑树</p>
<h2 id="Binder一次拷贝原理"><a href="#Binder一次拷贝原理" class="headerlink" title="Binder一次拷贝原理"></a>Binder一次拷贝原理</h2><p>Android选择Binder作为主要进程通信的方式同其性能高也有关系，Binder只需要一次拷贝就能将A进程用户空间的数据为B进程所用。这里主要涉及两个点：</p>
<ul>
<li><p>Binder的map函数，会将内核空间直接与用户空间对应，用户空间可以直接访问内核空间的数据</p>
</li>
<li><p>A进程的数据会被直接拷贝到B进程的内核空间（一次拷贝）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))</span></span><br><span class="line"></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>()</span><br><span class="line">    : <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>())</span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mManagesContexts</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">NULL</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">NULL</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">   ...</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>mmap函数属于系统调用，mmap会从当前进程中获取用户态可用的虚拟地址空间（vm_area_struct *vma），并在mmap_region中真正获取vma，然后调用file-&gt;f_op-&gt;mmap(file, vma)，进入驱动处理，之后就会在内存中分配一块连续的虚拟地址空间，并预先分配好页表、已使用的与未使用的标识、初始地址、与用户空间的偏移等等，通过这一步之后，就能把Binder在内核空间的数据直接通过指针地址映射到用户空间，供进程在用户空间使用，这是一次拷贝的基础，一次拷贝在内核中的标识如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line"><span class="comment">// 四棵比较重要的树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span> <span class="comment">//虚拟地址空间，用户控件传过来</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vma_vm_mm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line"><span class="keyword">int</span> deferred_work;</span><br><span class="line"><span class="keyword">void</span> *buffer; <span class="comment">//初始地址</span></span><br><span class="line"><span class="keyword">ptrdiff_t</span> user_buffer_offset; <span class="comment">//这里是偏移</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffers</span>;</span><span class="comment">//这个列表连接所有的内存块，以地址的大小为顺序，各内存块首尾相连</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">free_buffers</span>;</span><span class="comment">//连接所有的已建立映射的虚拟内存块，以内存的大小为index组织在以该节点为根的红黑树下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">allocated_buffers</span>;</span><span class="comment">//连接所有已经分配的虚拟内存块，以内存块的开始地址为index组织在以该节点为根的红黑树下</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是在APP启动的时候开启的地址映射，但并未涉及到数据的拷贝，下面看数据的拷贝操作。<strong>当数据从用户空间拷贝到内核空间的时候，是直从当前进程的用户空间接拷贝到目标进程的内核空间，这个过程是在请求端线程中处理的，操作对象是目标进程的内核空间</strong>。看如下代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void binder_transaction(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span></span> *thread,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span> *tr, int reply)&#123;</span><br><span class="line">                   ...</span><br><span class="line">        在通过进行binder事物的传递时，如果一个binder事物（用<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span></span>结构体表示）需要使用到内存，</span><br><span class="line">        就会调用binder_alloc_buf函数分配此次binder事物需要的内存空间。</span><br><span class="line">        需要注意的是：这里是从目标进程的binder内存空间分配所需的内存</span><br><span class="line">        <span class="comment">//从target进程的binder内存空间分配所需的内存大小,这也是一次拷贝，完成通信的关键，直接拷贝到目标进程的内核空间</span></span><br><span class="line">        <span class="comment">//由于用户空间跟内核空间仅仅存在一个偏移地址，所以也算拷贝到用户空间</span></span><br><span class="line">        t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">            tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">        t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">        <span class="comment">//该binder_buffer对应的事务    </span></span><br><span class="line">        t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">        <span class="comment">//该事物对应的目标binder实体 ,因为目标进程中可能不仅仅有一个Binder实体</span></span><br><span class="line">        t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">        trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">        <span class="keyword">if</span> (target_node)</span><br><span class="line">            binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, NULL);</span><br><span class="line">        <span class="comment">// 计算出存放flat_binder_object结构体偏移数组的起始地址，4字节对齐。</span></span><br><span class="line">        offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));</span><br><span class="line">           <span class="comment">// struct flat_binder_object是binder在进程之间传输的表示方式 //</span></span><br><span class="line">           <span class="comment">// 这里就是完成binder通讯单边时候在用户进程同内核buffer之间的一次拷贝动作 //</span></span><br><span class="line">          <span class="comment">// 这里的数据拷贝，其实是拷贝到目标进程中去，因为t本身就是在目标进程的内核空间中分配的，</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">            binder_user_error(<span class="string">&quot;binder: %d:%d got transaction with invalid &quot;</span></span><br><span class="line">                <span class="string">&quot;data ptr\n&quot;</span>, proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            goto err_copy_data_failed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到binder_alloc_buf(target_proc, tr-&gt;data_size,tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY))函数在申请内存的时候，是从target_proc进程空间中去申请的，这样在做数据拷贝的时候copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size))，就会直接拷贝target_proc的内核空间，而由于Binder内核空间的数据能直接映射到用户空间，这里就不在需要拷贝到用户空间。这就是一次拷贝的原理。内核空间的数据映射到用户空间其实就是添加一个偏移地址，并且将数据的首地址、数据的大小都复制到一个用户空间的Parcel结构体，具体可以参考Parcel.cpp的Parcel::ipcSetDataReference函数。</p>
<p><img src="/images/android_binder_faq_one_copy.png" alt="img"></p>
<p>Binder一次拷贝原理.jpg</p>
<h2 id="Binder传输数据的大小限制"><a href="#Binder传输数据的大小限制" class="headerlink" title="Binder传输数据的大小限制"></a>Binder传输数据的大小限制</h2><p>虽然APP开发时候，Binder对程序员几乎不可见，但是作为Android的数据运输系统，Binder的影响是全面性的，所以有时候如果不了解Binder的一些限制，在出现问题的时候往往是没有任何头绪，比如在Activity之间传输BitMap的时候，如果Bitmap过大，就会引起问题，比如崩溃等，这其实就跟Binder传输数据大小的限制有关系，在上面的一次拷贝中分析过，mmap函数会为Binder数据传递映射一块连续的虚拟地址，这块虚拟内存空间其实是有大小限制的，不同的进程可能还不一样。</p>
<p>普通的由Zygote孵化而来的用户进程，所映射的Binder内存大小是不到1M的，准确说是 1<em>1024</em>1024) - (4096 *2) ：这个限制定义在ProcessState类中，如果传输说句超过这个大小，系统就会报错，因为Binder本身就是为了进程间频繁而灵活的通信所设计的，并不是为了拷贝大数据而使用的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))</span></span><br></pre></td></tr></table></figure>

<p>而在内核中，其实也有个限制，是4M，不过由于APP中已经限制了不到1M，这里的限制似乎也没多大用途：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int binder_mmap(<span class="class"><span class="keyword">struct</span> <span class="title">file</span></span> *filp, <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span> *vma)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span></span> *area;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span> *failure_string;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span> *buffer;</span><br><span class="line">    <span class="comment">//限制不能超过4M</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line">    。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>有个特殊的进程ServiceManager进程，它为自己申请的Binder内核空间是128K，这个同ServiceManager的用途是分不开的，ServcieManager主要面向系统Service，只是简单的提供一些addServcie，getService的功能，不涉及多大的数据传输，因此不需要申请多大的内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅仅申请了128k</span></span><br><span class="line">    bs = <span class="built_in">binder_open</span>(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">binder_become_context_manager</span>(bs)) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    svcmgr_handle = svcmgr;</span><br><span class="line">    <span class="built_in">binder_loop</span>(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="系统服务与bindService等启动的服务的区别"><a href="#系统服务与bindService等启动的服务的区别" class="headerlink" title="系统服务与bindService等启动的服务的区别"></a>系统服务与bindService等启动的服务的区别</h2><p>服务可分为系统服务与普通服务，系统服务一般是在系统启动的时候，由SystemServer进程创建并注册到ServiceManager中的。而普通服务一般是通过ActivityManagerService启动的服务，或者说通过四大组件中的Service组件启动的服务。这两种服务在实现跟使用上是有不同的，主要从以下几个方面：</p>
<ul>
<li>服务的启动方式</li>
<li>服务的注册与管理</li>
<li>服务的请求使用方式</li>
</ul>
<p>首先看一下服务的启动上，系统服务一般都是SystemServer进程负责启动，比如AMS，WMS，PKMS，电源管理等，这些服务本身其实实现了Binder接口，作为Binder实体注册到ServiceManager中，被ServiceManager管理，而SystemServer进程里面会启动一些Binder线程，主要用于监听Client的请求，并分发给响应的服务实体类，可以看出，这些系统服务是位于SystemServer进程中（有例外，比如Media服务）。在来看一下bindService类型的服务，这类服务一般是通过Activity的startService或者其他context的startService启动的，这里的Service组件只是个封装，主要的是里面Binder服务实体类，这个启动过程不是ServcieManager管理的，而是通过ActivityManagerService进行管理的，同Activity管理类似。</p>
<p>再来看一下服务的注册与管理：系统服务一般都是通过ServiceManager的addService进行注册的，这些服务一般都是需要拥有特定的权限才能注册到ServiceManager，而bindService启动的服务可以算是注册到ActivityManagerService，只不过ActivityManagerService管理服务的方式同ServiceManager不一样，而是采用了Activity的管理模型，详细的可以自行分析</p>
<p>最后看一下使用方式，使用系统服务一般都是通过ServiceManager的getService得到服务的句柄，这个过程其实就是去ServiceManager中查询注册系统服务。而bindService启动的服务，主要是去ActivityManagerService中去查找相应的Service组件，最终会将Service内部Binder的句柄传给Client。</p>
<p><img src="/images/android_binder_faq_sys_binder_and_bind_service.png" alt="img"></p>
<p>系统服务与bindService启动服务的区别.jpg</p>
<h2 id="Binder线程、Binder主线程、Client请求线程的概念与区别"><a href="#Binder线程、Binder主线程、Client请求线程的概念与区别" class="headerlink" title="Binder线程、Binder主线程、Client请求线程的概念与区别"></a>Binder线程、Binder主线程、Client请求线程的概念与区别</h2><p>Binder线程是执行Binder服务的载体，只对于服务端才有意义，对请求端来说，是不需要考虑Binder线程的，但Android系统的处理机制其实大部分是互为C/S的。比如APP与AMS进行交互的时候，都互为对方的C与S，这里先不讨论这个问题，先看Binder线程的概念。</p>
<p>Binder线程就是执行Binder实体业务的线程，一个普通线程如何才能成为Binder线程呢？很简单，只要开启一个监听Binder字符设备的Loop线程即可，在Android中有很多种方法，不过归根到底都是监听Binder，换成代码就是通过ioctl来进行监听。</p>
<p>拿ServerManager进程来说，其主线就是Binder线程，其做法是通过binder_loop实现不死线程：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void binder_loop(struct binder_state *bs, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">    <span class="comment">&lt;!--关键点1--&gt;</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">     <span class="comment">&lt;!--关键点2--&gt;</span></span><br><span class="line">        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);</span><br><span class="line">        。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的关键代码1就是阻塞监听客户端请求，2 就是处理请求，并且这是一个死循环，不退出。再来看SystemServer进程中的线程，在Android4.3（6.0以后打代码就不一样了）中SystemSever主线程便是Binder线程，同时一个Binder主线程，Binder线程与Binder主线程的区别是：线程是否可以终止Loop，不过目前启动的Binder线程都是无法退出的，其实可以全部看做是Binder主线程，其实现原理是，<strong>在SystemServer主线程执行到最后的时候，Loop监听Binder设备，变身死循环线程</strong>，关键代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> status_t system_init()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ALOGI(<span class="string">&quot;System server: entering thread pool.\n&quot;</span>);</span><br><span class="line">    ProcessState::<span class="keyword">self</span>()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::<span class="keyword">self</span>()-&gt;joinThreadPool();</span><br><span class="line">    ALOGI(<span class="string">&quot;System server: exiting thread pool.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState::self()-&gt;startThreadPool()是新建一个Binder主线程，而PCThreadState::self()-&gt;joinThreadPool()是将当前线程变成Binder主线程。其实startThreadPool最终也会调用joinThreadPool，看下其关键函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::joinThreadPool</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> cmd;</span><br><span class="line">        ...关键点<span class="number">1</span> </span><br><span class="line">        result = <span class="built_in">talkWithDriver</span>();</span><br><span class="line">        <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">           ...关键点<span class="number">2</span> </span><br><span class="line">            result = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非主线程的可以退出</span></span><br><span class="line">        <span class="keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 死循环，不完结，调用了这个，就好比是开启了Binder监听循环，</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ...关键点<span class="number">3</span> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">   &#125;   </span><br></pre></td></tr></table></figure>

<p>先看关键点1 talkWithDriver，其实质还是去掉用ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)去不断的监听Binder字符设备，获取到Client传输的数据后，再通过executeCommand去执行相应的请求，joinThreadPool是普通线程化身Binder线程最常见的方式。不信，就再看一个MediaService,看一下main_mediaserver的main函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, <span class="built_in">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">   。。。</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::<span class="keyword">self</span>());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        MediaPlayerService::instantiate();</span><br><span class="line">        CameraService::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        registerExtensions();</span><br><span class="line">        ProcessState::<span class="keyword">self</span>()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::<span class="keyword">self</span>()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实还是通过joinThreadPool变身Binder线程，至于是不是主线程，看一下下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::joinThreadPool</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessState::spawnPooledThread</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = <span class="built_in">makeBinderThreadName</span>();</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Spawning new pooled thread, name=%s\n&quot;</span>, name.<span class="built_in">string</span>());</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> <span class="built_in">PoolThread</span>(isMain);</span><br><span class="line">        t-&gt;<span class="built_in">run</span>(name.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实关键就是就是传递给joinThreadPool函数的isMain是否是true，不过是否是Binder主线程并没有什么用，因为源码中并没有为这两者的不同处理留入口，感兴趣可以去查看一下binder中的TIMED_OUT。</p>
<p>最后来看一下普通Client的binder请求线程，比如我们APP的主线程，在startActivity请求AMS的时候，APP的主线程成其实就是Binder请求线程，在进行Binder通信的过程中，Client的Binder请求线程会一直阻塞，知道Service处理完毕返回处理结果。</p>
<h2 id="Binder请求的同步与异步"><a href="#Binder请求的同步与异步" class="headerlink" title="Binder请求的同步与异步"></a>Binder请求的同步与异步</h2><p>很多人都会说，Binder是对Client端同步，而对Service端异步，其实并不完全正确，在单次Binder数据传递的过程中，其实都是同步的。只不过，Client在请求Server端服务的过程中，是需要返回结果的，即使是你看不到返回数据，其实还是会有个成功与失败的处理结果返回给Client，这就是所说的Client端是同步的。至于说服务端是异步的，可以这么理解：在服务端在被唤醒后，就去处理请求，处理结束后，服务端就将结果返回给正在等待的Client线程，将结果写入到Client的内核空间后，服务端就会直接返回了，不会再等待Client端的确认，这就是所说的服务端是异步的，可以从源码来看一下：</p>
<ul>
<li><p>Client端同步阻塞请求</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">         err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">     &#125; ...</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Client在请求服务的时候 Parcel* reply基本都是非空的（还没见过空用在什么位置），非空就会执行waitForResponse(reply)，如果看过几篇Binder分析文章的人应该都会知道，在A端向B写完数据之后，A会返回给自己一个BR_TRANSACTION_COMPLETE命令，告知自己数据已经成功写入到B的Binder内核空间中去了，如果是需要回复，在处理完BR_TRANSACTION_COMPLETE命令后会继续阻塞等待结果的返回：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">     cmd = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (cmd) &#123;</span><br><span class="line">       &lt;!--关键点<span class="number">1</span> --&gt;</span><br><span class="line">      <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     &lt;!--关键点<span class="number">2</span> --&gt;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                  <span class="comment">// free buffer，先设置数据，直接</span></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 牵扯到数据利用，与内存释放</span></span><br><span class="line">                        reply-&gt;<span class="built_in">ipcSetDataReference</span>(...)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line"> finish:</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点1就是处理BR_TRANSACTION_COMPLETE，如果需要等待reply，还要通过talkWithDriver等待结果返回，最后执行关键点2，处理返回数据。<strong>对于服务端来说，区别就在于关键点1</strong>，来看一下服务端Binder线程的代码，拿常用的joinThreadPool来看，在talkWithDriver后，会执行executeCommand函数，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::joinThreadPool</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> cmd;</span><br><span class="line">        ...关键点<span class="number">1</span> </span><br><span class="line">        result = <span class="built_in">talkWithDriver</span>();</span><br><span class="line">        <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">           ...关键点<span class="number">2</span> </span><br><span class="line">            result = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非主线程的可以退出</span></span><br><span class="line">        <span class="keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 死循环，不完结，调用了这个，就好比是开启了Binder监听循环，</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>executeCommand会进一步调用sendReply函数，看一下这里的特点waitForResponse(NULL, NULL)，这里传递的都是null，在上面的关键点1的地方我们知道，这里不需要等待Client返回，因此会直接 goto finish，这就是所说的Client同步，而服务端异步的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BC_REPLY</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::sendReply</span><span class="params">(<span class="keyword">const</span> Parcel&amp; reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// flag 0</span></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">status_t</span> statusBuffer;</span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_REPLY, flags, <span class="number">-1</span>, <span class="number">0</span>, reply, &amp;statusBuffer);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">waitForResponse</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line"> <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line"> <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>请求同步最好的例子就是在Android6.0之前，国产ROM权限的申请都是同步的，在申请权限的时候，APP申请权限的线程会阻塞，就算是UI线程也会阻塞，ROM为了防止ANR，都会为权限申请设置一个倒计时，不操作，就给个默认操作，有兴趣可以自己分析。</p>
<h2 id="Android-APP进程天生支持Binder通信的原理是什么"><a href="#Android-APP进程天生支持Binder通信的原理是什么" class="headerlink" title="Android APP进程天生支持Binder通信的原理是什么"></a>Android APP进程天生支持Binder通信的原理是什么</h2><p>Android APP进程都是由Zygote进程孵化出来的。常见场景：点击桌面icon启动APP，或者startActivity启动一个新进程里面的Activity，最终都会由AMS去调用Process.start()方法去向Zygote进程发送请求，让Zygote去fork一个新进程，Zygote收到请求后会调用Zygote.forkAndSpecialize()来fork出新进程,之后会通过RuntimeInit.nativeZygoteInit来初始化Andriod APP运行需要的一些环境，而binder线程就是在这个时候新建启动的，看下面的源码（Android 4.3）：</p>
<p>这里不分析Zygote，只是给出其大概运行机制，Zygote在启动后，就会通过runSelectLoop不断的监听socket，等待请求来fork进程，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">()</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    FileDescriptor[] fdArray = <span class="keyword">new</span> FileDescriptor[<span class="number">4</span>];</span><br><span class="line">    ...     </span><br><span class="line">   <span class="keyword">int</span> loopCount = GC_LOOP_COUNT;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">         ...</span><br><span class="line">            <span class="keyword">boolean</span> done;</span><br><span class="line">            done = peers.get(index).runOnce();</span><br><span class="line">            ...</span><br><span class="line">        &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>每次fork请求到来都会调用ZygoteConnection的runOnce()来处理请求，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor[] descriptors;   </span><br><span class="line">        。。。</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       ...关键点<span class="number">1</span> </span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">         ...关键点<span class="number">2</span></span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>runOnce()有两个关键点，<strong>关键点1</strong> Zygote.forkAndSpecialize就是通过fork系统调用来新建进程，<strong>关键点2</strong> handleChildProc就是对新建的APP进程进行一些初始化工作，为Android Java进程创建一些必须的场景。Zygote.forkAndSpecialize没什么可看的，就是Linux中的fork进程，这里主要看一下handleChildProc</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//从Process.start启动的parsedArgs.runtimeInit一般都是true            if (parsedArgs.runtimeInit) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                    parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                    pipeFd, parsedArgs.remainingArgs);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Android应用启动都走该分支</span></span><br><span class="line">       RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                    parsedArgs.remainingArgs); </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看 RuntimeInit.zygoteInit函数</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> final <span class="keyword">void</span> zygoteInit(int targetSdkVersion, <span class="built_in">String</span>[] argv)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    redirectLogStreams();</span><br><span class="line">    commonInit();</span><br><span class="line">    &lt;!--关键点<span class="number">1</span>--&gt;</span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">     &lt;!--关键点<span class="number">2</span>--&gt;</span><br><span class="line">    applicationInit(targetSdkVersion, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看关键点1，nativeZygoteInit属于Native方法，该方法位于AndroidRuntime.cpp中，其实就是调用调用到app_main.cpp中的onZygoteInit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;<span class="built_in">onZygoteInit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键就是onZygoteInit</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> void onZygoteInit()</span><br><span class="line">&#123;</span><br><span class="line">    sp proc = ProcessState::<span class="keyword">self</span>();</span><br><span class="line">    <span class="comment">//启动新binder线程loop</span></span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，ProcessState::self()函数会调用open()打开/dev/binder设备，这个时候Client就能通过Binder进行远程通信；其次，proc-&gt;startThreadPool()负责新建一个binder线程，监听Binder设备，这样进程就具备了作为Binder服务端的资格。每个APP的进程都会通过onZygoteInit打开Binder，既能作为Client，也能作为Server，这就是Android进程天然支持Binder通信的原因。</p>
<p><img src="/images/android_binder_faq_app_support_binder.png" alt="img"></p>
<p>Android APP进程天然支持Binder通信.png</p>
<h2 id="Android-APP有多少Binder线程，是固定的么？"><a href="#Android-APP有多少Binder线程，是固定的么？" class="headerlink" title="Android APP有多少Binder线程，是固定的么？"></a>Android APP有多少Binder线程，是固定的么？</h2><p>通过上一个问题我们知道了Android APP线程为什么天然支持Binder通信，并且可以作为Binder的Service端，同时也对Binder线程有了一个了解，那么在一个Android APP的进程里面究竟有多少个Binder线程呢？是固定的吗。在分析上一个问题的时候，我们知道Android APP进程在Zygote fork之初就为它新建了一个Binder主线程，使得APP端也可以作为Binder的服务端，这个时候Binder线程的数量就只有一个，假设我们的APP自身实现了很多的Binder服务，一个线程够用的吗？这里不妨想想一下SystemServer进程，SystemServer拥有很多系统服务，一个线程应该是不够用的，如果看过SystemServer代码可能会发现，对于Android4.3的源码，其实一开始为该服务开启了两个Binder线程。还有个分析Binder常用的服务，media服务，也是在一开始的时候开启了两个线程。</p>
<p>先看下SystemServer的开始加载的线程：通过 ProcessState::self()-&gt;startThreadPool()新加了一个Binder线程，然后通过IPCThreadState::self()-&gt;joinThreadPool();将当前线程变成Binder线程，注意这里是针对Android4.3的源码，android6.0的这里略有不同。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> status_t system_init()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ALOGI(<span class="string">&quot;System server: entering thread pool.\n&quot;</span>);</span><br><span class="line">    ProcessState::<span class="keyword">self</span>()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::<span class="keyword">self</span>()-&gt;joinThreadPool();</span><br><span class="line">    ALOGI(<span class="string">&quot;System server: exiting thread pool.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下Media服务,同SystemServer类似，也是开启了两个Binder线程：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, <span class="built_in">char</span>** argv)</span><br><span class="line">&#123;      ...</span><br><span class="line">        ProcessState::<span class="keyword">self</span>()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::<span class="keyword">self</span>()-&gt;joinThreadPool();</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>

<p>可以看出Android APP上层应用的进程一般是开启一个Binder线程，而对于SystemServer或者media服务等使用频率高，服务复杂的进程，一般都是开启两个或者更多。来看第二个问题，<strong>Binder线程的数目是固定的吗？答案是否定的，</strong>驱动会根据目标进程中是否存在足够多的Binder线程来告诉进程是不是要新建Binder线程，详细逻辑，首先看一下新建Binder线程的入口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 可以根据内核返回数据创建新的binder线程</span></span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;<span class="built_in">spawnPooledThread</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>executeCommand一定是从Bindr驱动返回的BR命令，这里是BR_SPAWN_LOOPER，什么时候，Binder驱动会向进程发送BR_SPAWN_LOOPER呢？全局搜索之后，发现只有一个地方binder_thread_read，<strong>如果直观的想一下，什么时候需要新建Binder线程呢？很简单，不够用的时候</strong>，注意上面使用的是spawnPooledThread(false)，也就是说这里启动的都是普通Binder线程。为了了解启动时机，先看一些binder_proc内部判定参数的意义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> max_threads;                <span class="comment">// 进程所能启动的最大非主Binder线程数目</span></span><br><span class="line">    <span class="keyword">int</span> requested_threads;          <span class="comment">// 请求启动的非主线程数</span></span><br><span class="line">    <span class="keyword">int</span> requested_threads_started;<span class="comment">//已经启动的非主线程数</span></span><br><span class="line">    <span class="keyword">int</span> ready_threads;              <span class="comment">// 当前可用的Binder线程数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再来看binder_thread_read函数中是么时候会去请求新建Binder线程，以Android APP进程为例子，通过前面的分析知道APP进程天然支持Binder通信，因为它有一个Binder主线程，启动之后就会阻塞等待Client请求,这里会更新proc-&gt;ready_threads，第一次阻塞等待的时候proc-&gt;ready_threads=1，之后睡眠。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">binder_thread_read（）&#123;</span><br><span class="line">  ...</span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">//当前线程todo队列为空且transaction栈为空，则代表该线程是空闲的 ，看看是不是自己被复用了</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;</span><br><span class="line">        list_empty(&amp;thread-&gt;todo);</span><br><span class="line"> ...<span class="comment">//可用线程个数+1</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads++; </span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="comment">//当进程todo队列没有数据,则进入休眠等待状态</span></span><br><span class="line">            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//当线程todo队列没有数据，则进入休眠等待状态</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;    </span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    <span class="comment">//被唤醒可用线程个数-1</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads--; </span><br><span class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        uint32_t cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span> tr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span> *w;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span></span> *t = NULL;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先考虑从线程todo队列获取事务数据</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo)) &#123;</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span>, entry);</span><br><span class="line">        <span class="comment">//线程todo队列没有数据, 则从进程todo对获取事务数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) &#123;</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span>, entry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">         ..</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            cmd = BR_TRANSACTION;  <span class="comment">//设置命令为BR_TRANSACTION</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmd = BR_REPLY; <span class="comment">//设置命令为BR_REPLY</span></span><br><span class="line">        &#125;</span><br><span class="line">        .. </span><br><span class="line">done:</span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line">    <span class="comment">//创建线程的条件</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">         BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">         <span class="comment">//需要新建的数目线程数+1</span></span><br><span class="line">        proc-&gt;requested_threads++;</span><br><span class="line">        <span class="comment">// 生成BR_SPAWN_LOOPER命令，用于创建新的线程</span></span><br><span class="line">        put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被Client唤醒后proc-&gt;ready_threads会-1，之后变成0，这样在执行到done的时候，就会发现proc-&gt;requested_threads + proc-&gt;ready_threads == 0，这是新建Binder线程的一个必须条件，再看下其他几个条件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">            (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">             BINDER_LOOPER_STATE_ENTERED)))  </span><br></pre></td></tr></table></figure>

<ul>
<li>proc-&gt;requested_threads + proc-&gt;ready_threads == 0 ：<strong>如果目前还没申请新建Binder线程，并且proc-&gt;ready_threads空闲Binder线程也是0，就需要新建一个Binder线程，其实就是为了保证有至少有一个空闲的线程</strong>。</li>
<li>proc-&gt;requested_threads_started &lt; proc-&gt;max_threads：<strong>目前启动的普通Binder线程数requested_threads_started还没达到上限（默认APP进程是15）</strong></li>
<li>thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED) 当先线程是Binder线程，这个是一定满足的，不知道为什么列出来</li>
</ul>
<p>proc-&gt;max_threads是多少呢？不同的进程其实设置的是不一样的，看普通的APP进程，在ProcessState::self()新建ProcessState单利对象的时候会调用ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);设置上限,可以看到默认设置的上限是15。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/binder&quot;</span>, O_RDWR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">size_t</span> maxThreads = <span class="number">15</span>;</span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果满足新建的条件，就会将proc-&gt;requested_threads加1，并在驱动执行完毕后，利用put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)；通知服务端在用户空间发起新建Binder线程的操作，新建的是普通Binder线程，最终再进入binder_thread_write的BC_REGISTER_LOOPER:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">binder_thread_write</span>(<span class="params"><span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">void</span> __user *buffer, <span class="built_in">int</span> size, signed <span class="built_in">long</span> *consumed</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</span><br><span class="line">              ...</span><br><span class="line">                <span class="comment">// requested_threads -- </span></span><br><span class="line">                proc-&gt;requested_threads--;</span><br><span class="line">                proc-&gt;requested_threads_started++;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会将proc-&gt;requested_threads复原，其实就是-1，并且启动的Binder线程数+1。</p>
<p>个人理解，之所以采用动态新建Binder线程的意义有两点，第一：如果没有Client请求服务，就保持线程数不变，减少资源浪费，需要的时候再分配新线程。第二：有请求的情况下，保证至少有一个空闲线程是给Client端，以提高Server端响应速度。</p>
<p>不过这里有一点要注意，对于同一个线程的请求，如果是阻塞的，那么没什么问题，肯定是等待上一个请求结束才能处理下一个，但是对于oneway方式的binder请求呢，这里就会存在这么一个场景，对于oneway的请求，如果上一个还没处理完，同一个线程的新的oneway请求会被塞到同一个目标线程等待执行，而不会触发创建新的Binder线程，因为这并不会妨碍另一端的处理，因为它压根无需等待，但是这可能会造成服务端单个线程任务繁重，而其他线程保持空闲，不过在一定程度上实现了同一种任务的顺序执行，可能也有一定的好处吧。</p>
<h2 id="同一个线程的请求必定是顺序执行，即使是异步请求-oneway"><a href="#同一个线程的请求必定是顺序执行，即使是异步请求-oneway" class="headerlink" title="同一个线程的请求必定是顺序执行，即使是异步请求(oneway)"></a>同一个线程的请求必定是顺序执行，即使是异步请求(oneway)</h2><p>一般而言，Client同步阻塞请求Service，直到Service提供完服务后才返回，不过，也有特殊的，比如请求用ONE_WAY方式，这种场景一般主要是用来通知，至于通知被谁消费，是否被消费压根不会关心。拿ContentService服务为例子，它是一个全局的通知中心，负责转发通知，而且，一般是群发，由于在转发的时候，ContentService被看做Client，如果这个时候采用普通的同步阻塞势必会造成通知的延时发送，所以这里的Client采用了oneway，异步。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IContentObserver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="markdown"><span class="comment">     <span class="emphasis">* This method is called when </span></span></span>an<span class="markdown"><span class="strong"><span class="emphasis"> update occurs to </span></span></span>the<span class="markdown"><span class="strong"><span class="emphasis"> cursor that is being</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="markdown"><span class="comment">     *</span> observed. selfUpdate is true if </span></span>the<span class="markdown"><span class="strong"> update was caused by </span></span>a<span class="markdown"><span class="strong"> call to</span></span></span></span><br><span class="line"><span class="strong"><span class="markdown"><span class="comment">     <span class="emphasis">* commit on </span></span></span>the<span class="markdown"><span class="strong"><span class="emphasis"> cursor that is being observed.</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="markdown"><span class="comment">     *</span>/</span></span></span></span><br><span class="line">    oneway <span class="keyword">void</span> onChange(boolean selfUpdate, <span class="keyword">in</span> <span class="built_in">Uri</span> uri, <span class="built_in">int</span> userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种机制可能也会影响Service的性能，比如<strong>同一个线程中的Client</strong>请求的服务是一个耗时操作的时候，通过oneway的方式发送请求的话，如果之前的请求还没被执行完，则Service不会启动新的线程去响应，该请求线程的所有操作都会被放到同一个Binder线程中依次执行，这样其实没有利用Binder机制的动态线程池，如果是多个线程中的Client并发请求，则还是会动态增加Binder线程的，大概这个是为了保证同一个线程中的Binder请求要依次执行吧，这种表现好像是反过来了，Client异步，而Service阻塞了，也就是说虽然解决了Client请求不被阻塞的问题，但是请求的处理并未被加速。</p>
<h2 id="Client端线程睡眠在哪个队列上，唤醒Server端哪个等待队列上的线程"><a href="#Client端线程睡眠在哪个队列上，唤醒Server端哪个等待队列上的线程" class="headerlink" title="Client端线程睡眠在哪个队列上，唤醒Server端哪个等待队列上的线程"></a>Client端线程睡眠在哪个队列上，唤醒Server端哪个等待队列上的线程</h2><p>先看第一部分：发送端线程睡眠在哪个队列上？</p>
<p><strong>发送端线程一定睡眠在自己binder_thread的等待队列上，并且，该队列上有且只有自己一个睡眠线程</strong></p>
<p>再看第二部分：在Binder驱动去唤醒线程的时候，唤醒的是哪个等待队列上的线程？</p>
<p>理解这个问题需要理解binder_thread中的 struct binder_transaction * transaction_stack栈，这个栈规定了transaction的执行顺序：栈顶的一定先于栈内执行。</p>
<p>如果本地操作是BC_REPLY,一定是唤醒之前发送等待的线程，这个是100%的，但是如果是BC_TRANSACTION，那就不一定了,尤其是当两端互为服务相互请求的时候，场景如下：</p>
<ul>
<li>进程A的普通线程AT1请求B进程的B1服务，唤醒B进程的Binder线程，AT1睡眠等待服务结束</li>
<li>B进程的B1服务在执行的的时候，需要请求进程A的A1服务，则B进程的Binder线程BT1睡眠，等待服务结束。</li>
</ul>
<p>这个时候就会遇到一个问题：唤醒哪个线程比较合适？是睡眠在进程队列上的线程，还是之前睡眠的线程AT1？答案是：之前睡眠等待B服务返回的线程AT1，具体看下面的图解分析</p>
<p>首先第一步A普通线程去请求B进程的B1服务，这个时候在A进程的AT1线程的binder_ref中会将binder_transaction1入栈，而同样B的Binder线程在读取binder_work之后，也会将binder_transaction1加入自己的堆栈，如下图：</p>
<p><img src="/images/android_binder_faq_binder_wake_stack_list01.png" alt="img"></p>
<p>binder_transaction堆栈及唤醒那个队列1.jpg</p>
<p>而当B的Binder线程被唤醒后，执行Binder实体中的服务时，发现服务函数需要反过来去请求A端的A1服务，那就需要通过Binder向A进程发送请求，并新建binder_transaction2压入自己的binder_transaction堆栈，这个没有任何问题。但是，在A端入栈的时候，会面临一个抉择，写入那个队列？是binder_proc上的队列，还是正在等候B1服务返回的AT1线程的队列？</p>
<p><img src="/images/android_binder_faq_binder_wake_stack_list02.png" alt="img"></p>
<p>binder_transaction堆栈及唤醒那个队列2.jpg</p>
<p>结果已经说过，是AT1的队列，为什么呢？因为AT1队列上的之前的binder_transaction1在等待B进程执行完，但是B端执行binder_transaction1时候，需要等待binder_transaction2执行完，也就是说，在binder_transaction2执行完毕前，A端的binder_transaction1一定是不会被执行的，也就是线程AT1在B执行binder_transaction2的时候，一定是空闲的，那么，不妨唤醒AT1线程，让它帮忙执行完binder_transaction2，执行完之后，AT1又会睡眠等待B端返回，这样，既不妨碍binder_transaction1的执行，同样也能提高AT1线程利用率，出栈的过程其实就简单了，</p>
<ul>
<li>AT1 执行binder_transaction2，唤醒B端BT1 Binder线程，并且AT1继续睡眠（因为还有等待的transaction）</li>
<li>BT1 处理binder_transaction2结果，并执行完binder_transaction1，唤醒AT1</li>
<li>AT1处理binder_transaction1返回结果 执行结束</li>
</ul>
<p>不妨再深入一点，如果A端binder_transaction2又需要B进程B2服务，这个时候是什么效果唤醒谁，答案是BT1，这就杜绝了两端循环请求的，不断增加线程池容量。</p>
<p><img src="/images/android_binder_faq_binder_wake_stack_list03.png" alt="img"></p>
<p>binder_transaction堆栈及唤醒那个队列3.jpg</p>
<p>从这里可以看出，Binder其实设计的还是很巧妙的，让线程复用，提高了效率，还避免了新建不必要的Binder线程，这段优化在binder驱动实现代码如下：其实就是根据binder_transaction记录，处理入栈唤醒问题</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void binder_transaction(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span></span> *thread,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span> *tr, int reply)</span><br><span class="line">    &#123;..</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                    <span class="comment">// 找到对方正在等待自己进程的线程，如果线程没有在等待自己进程的返回，就不要找了</span></span><br><span class="line">        </span><br><span class="line">                    <span class="comment">// 判断是不target_proc中，是不是有线程，等待当前线程</span></span><br><span class="line">                    <span class="comment">// thread-&gt;transaction_stack，这个时候，</span></span><br><span class="line">                    <span class="comment">// 是binder线程的，不是普通线程 B去请求A服务，</span></span><br><span class="line">                    <span class="comment">// 在A服务的时候，又请求了B，这个时候，A的服务一定要等B处理完，才能再返回B，可以放心用B</span></span><br><span class="line">                        <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</span><br><span class="line">                            target_thread = tmp-&gt;from;</span><br><span class="line">                        tmp = tmp-&gt;from_parent;</span><br><span class="line">          ...           &#125;</span><br><span class="line">        &#125; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binder协议中BC与BR的区别"><a href="#Binder协议中BC与BR的区别" class="headerlink" title="Binder协议中BC与BR的区别"></a>Binder协议中BC与BR的区别</h2><p>BC与BR主要是标志数据及Transaction流向，其中BC是从用户空间流向内核，而BR是从内核流线用户空间，比如Client向Server发送请求的时候，用的是BC_TRANSACTION，当数据被写入到目标进程后，target_proc所在的进程被唤醒，在内核空间中，会将BC转换为BR，并将数据与操作传递该用户空间。</p>
<p><img src="/images/android_binder_faq_br_bc.png" alt="img"></p>
<p>BR与BC区别</p>
<h2 id="Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装）"><a href="#Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装）" class="headerlink" title="Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装）"></a>Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装）</h2><p>内核中，与用户空间对应的结构体对象都需要新建，但传输数据的数据只拷贝一次，就是一次拷贝的时候。</p>
<p>从Client端请求开始分析，暂不考虑java层，只考虑Native，以ServiceManager的addService为例，具体看一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayerService::<span class="built_in">instantiate</span>();</span><br></pre></td></tr></table></figure>

<p>MediaPlayerService会新建Binder实体，并将其注册到ServiceManager中:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MediaPlayerService::instantiate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">defaultServiceManager</span>()-&gt;<span class="built_in">addService</span>(</span><br><span class="line">            <span class="built_in">String16</span>(<span class="string">&quot;media.player&quot;</span>), <span class="keyword">new</span> <span class="built_in">MediaPlayerService</span>());</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>这里defaultServiceManager其实就是获取ServiceManager的远程代理：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将代码简化其实就是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> gDefaultServiceManager = <span class="built_in">BpServiceManager</span> (<span class="keyword">new</span> <span class="built_in">BpBinder</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>addService就是调用BpServiceManager的addService，</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">virtual status_t addService(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span><br><span class="line">        bool allowIsolated)</span><br><span class="line">&#123;</span><br><span class="line">    Parcel <span class="keyword">data</span>, reply;</span><br><span class="line">    <span class="keyword">data</span>.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    <span class="keyword">data</span>.writeString16(name);</span><br><span class="line">    <span class="keyword">data</span>.writeStrongBinder(service);</span><br><span class="line">    <span class="keyword">data</span>.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, <span class="keyword">data</span>, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会开始第一步的封装，数据封装，其实就是讲具体的传输数据写入到Parcel对象中，与Parcel对应是ADD_SERVICE_TRANSACTION等具体操作。比较需要注意的就是data.writeStrongBinder，这里其实就是把Binder实体压扁：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status_t Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="keyword">val</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), <span class="keyword">val</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体做法就是转换成flat_binder_object，以传递Binder的类型、指针之类的信息：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">status_t flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line">    </span><br><span class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder *local = binder-&gt;localBinder();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> int32_t handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = local-&gt;getWeakRefs();</span><br><span class="line">            obj.cookie = local;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="literal">NULL</span>;</span><br><span class="line">        obj.cookie = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); 在上面的环境中，remote()函数返回的就是BpBinder(0)，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后通过  IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags)进行进一步封装:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">            err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; </span><br><span class="line">        ..</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);是进一步封装的入口，在这个函数中Parcel&amp; data、handle、code、被进一步封装成binder_transaction_data对象，并拷贝到mOut的data中去，同时也会将BC_TRANSACTION命令也写入mOut，这里与binder_transaction_data对应的CMD是BC_TRANSACTION，binder_transaction_data也存储了数据的指引新信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; ..</span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mOut封装结束后，会通过waitForResponse调用talkWithDriver继续封装：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    <span class="comment">// Is the read buffer empty? 这里会有同时返回两个命令的情况 BR_NOOP、BR_COMPLETE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line">    <span class="comment">// We don&#x27;t want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.<span class="built_in">data</span>();      <span class="comment">// This is what we&#x27;ll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        。。</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR；</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; (<span class="keyword">ssize_t</span>)mOut.<span class="built_in">dataSize</span>())</span><br><span class="line">                mOut.<span class="built_in">remove</span>(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mOut.<span class="built_in">setDataSize</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.<span class="built_in">setDataSize</span>(bwr.read_consumed);</span><br><span class="line">            mIn.<span class="built_in">setDataPosition</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>talkWithDriver会将mOut中的数据与命令继续封装成binder_write_read对象，其中bwr.write_buffer就是mOut中的data（binder_transaction_data+BC_TRRANSACTION），之后就会通过ioctl与binder驱动交互，进入内核，这里与binder_write_read对象对应的CMD是BINDER_WRITE_READ，进入驱动后，是先写后读的顺序，所以才叫BINDER_WRITE_READ命令，与BINDER_WRITE_READ层级对应的几个命令码一般都是跟线程、进程、数据整体传输相关的操作，不涉及具体的业务处理,比如BINDER_SET_CONTEXT_MGR是将线程编程ServiceManager线程，并创建0号Handle对应的binder_node、BINDER_SET_MAX_THREADS是设置最大的非主Binder线程数，而BINDER_WRITE_READ就是表示这是一次读写操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_CURRENT_PROTOCOL_VERSION 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ _IOWR(<span class="meta-string">&#x27;b&#x27;</span>, 1, struct binder_write_read)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_TIMEOUT _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 3, int64_t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 5, size_t)</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_PRIORITY _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 6, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 7, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 8, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION _IOWR(<span class="meta-string">&#x27;b&#x27;</span>, 9, struct binder_version)</span></span><br></pre></td></tr></table></figure>

<p>详细看一下binder_ioctl对于BINDER_WRITE_READ的处理，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">    switch (cmd) &#123;</span><br><span class="line">    case BINDER_WRITE_READ: &#123;</span><br><span class="line">        struct binder_write_read bwr;</span><br><span class="line">        ..</span><br><span class="line">        <span class="comment">&lt;!--拷贝binder_write_read对象到内核空间--&gt;</span></span><br><span class="line">        if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            goto err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">&lt;!--根据是否需要写数据处理是不是要写到目标进程中去--&gt;</span></span><br><span class="line">        if (bwr.write_size &gt; 0) &#123;</span><br><span class="line">            ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">&lt;!--根据是否需要写数据处理是不是要读，往自己进程里读数据--&gt;</span></span><br><span class="line">        if (bwr.read_size &gt; 0) &#123;</span><br><span class="line">            ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            <span class="comment">&lt;!--是不是要同时唤醒进程上的阻塞队列--&gt;</span></span><br><span class="line">            if (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case BINDER_SET_MAX_THREADS:</span><br><span class="line">        if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case BINDER_SET_CONTEXT_MGR:</span><br><span class="line">       .. break;</span><br><span class="line">    case BINDER_THREAD_EXIT:</span><br><span class="line">        binder_free_thread(proc, thread);</span><br><span class="line">        thread = NULL;</span><br><span class="line">        break;</span><br><span class="line">    case BINDER_VERSION:</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_thread_write(proc, thread, (void __user <em>)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed)这里其实就是把解析的binder_write_read对象再剥离，*<em>bwr.write_buffer</em></em> 就是上面的（BC_TRANSACTION+ binder_transaction_data），</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// binder_transaction_data  BC_XXX+binder_transaction_data</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get_user</span>(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))  (BC_TRANSACTION)</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (cmd) &#123;</span><br><span class="line">        ..</span><br><span class="line">        <span class="keyword">case</span> BC_FREE_BUFFER: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;tr, ptr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(tr);</span><br><span class="line">            <span class="built_in">binder_transaction</span>(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</span><br><span class="line">            ..</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_EXIT_LOOPER:</span><br><span class="line">        <span class="comment">// 这里会修改读取的数据，</span></span><br><span class="line">        *consumed = ptr - buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_thread_write会进一步根据CMD剥离出binder_transaction_data tr，交给binder_transaction处理，其实到binder_transaction数据几乎已经剥离极限，剩下的都是业务相关的，但是这里牵扯到一个Binder实体与Handle的转换过程，同城也牵扯两个进程在内核空间共享一些数据的问题，因此这里又进行了一次进一步的封装与拆封装，这里新封装了连个对象 binder_transaction与binder_work，有所区别的是binder_work可以看做是进程私有，但是binder_transaction是两个交互的进程共享的：binder_work是插入到线程或者进程的work todo队列上去的:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> looper;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction_stack</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error; <span class="comment">/* Write failed, return error code in read buf */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error2; <span class="comment">/* Write failed, return error code in read */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里主要关心一下<strong>binder_transaction</strong>：binder_transaction主要记录了当前transaction的来源，去向，同时也为了返回做准备，buffer字段是一次拷贝后数据在Binder的内存地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">from_parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">to_parent</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</span><br><span class="line">    <span class="keyword">long</span>    priority;</span><br><span class="line">    <span class="keyword">long</span>    saved_priority;</span><br><span class="line">    <span class="keyword">uid_t</span>   sender_euid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>binder_transaction函数主要负责的工作：</p>
<ul>
<li><p>新建binder_transaction对象，并插入到自己的binder_transaction堆栈中</p>
</li>
<li><p>新建binder_work对象，插入到目标队列</p>
</li>
<li><p>Binder与Handle的转换 (flat_binder_object)</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">static</span> <span class="keyword">void</span> binder_transaction(struct binder_proc *proc,</span><br><span class="line">                    struct binder_thread *thread,</span><br><span class="line">                    struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span><br><span class="line"> &#123;</span><br><span class="line">     struct binder_transaction *t;</span><br><span class="line">     struct binder_work *tcomplete;</span><br><span class="line">     size_t *offp, *off_end;</span><br><span class="line">     struct binder_proc *target_proc;</span><br><span class="line">     struct binder_thread *target_thread = <span class="literal">NULL</span>;</span><br><span class="line">     struct binder_node *target_node = <span class="literal">NULL</span>;</span><br><span class="line">  **关键点<span class="number">1</span>** </span><br><span class="line"> <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">     in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">     thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">     target_thread = in_reply_to-&gt;from;</span><br><span class="line">     target_proc = target_thread-&gt;proc;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">         struct binder_ref * ref;</span><br><span class="line">             ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">             target_node = ref-&gt;node;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             target_node = binder_context_mgr_node;</span><br><span class="line">         &#125;</span><br><span class="line">       ..。</span><br><span class="line"> **关键点<span class="number">2</span>**</span><br><span class="line">  t = kzalloc(sizeof( * t), GFP_KERNEL); </span><br><span class="line">  ...</span><br><span class="line">  tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);</span><br><span class="line">  </span><br><span class="line">**关键点<span class="number">3</span> **</span><br><span class="line"> off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">     struct flat_binder_object *fp;</span><br><span class="line">     fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">     <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">     <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">     <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">         struct binder_ref *ref;</span><br><span class="line">         struct binder_node *node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">         <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">         &#125;..</span><br><span class="line">         ref = (target_proc, node);                 <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">             fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">         fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">     &#125; <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">     <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">         struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</span><br><span class="line">         <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">             <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">                 fp-&gt;type = BINDER_TYPE_BINDER;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">             fp-&gt;binder = ref-&gt;node-&gt;ptr;</span><br><span class="line">             fp-&gt;cookie = ref-&gt;node-&gt;cookie;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             struct binder_ref *new_ref;</span><br><span class="line">             new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">             fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">break</span>;</span><br><span class="line">     </span><br><span class="line">**关键点<span class="number">4</span>** 将binder_work 插入到目标队列</span><br><span class="line"></span><br><span class="line"> t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line"> list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line"> tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line"> list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line"> <span class="keyword">if</span> (target_wait)</span><br><span class="line">     wake_up_interruptible(target_wait);</span><br><span class="line"> <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>}</p>
</li>
</ul>
<p>关键点1，找到目标进程，关键点2 创建binder_transaction与binder_work，关键点3 处理Binder实体与Handle转化，关键点4，将binder_work插入目标队列，并唤醒相应的等待队列，在处理Binder实体与Handle转化的时候，有下面几点注意的：</p>
<ul>
<li>第一次注册Binder实体的时候，是向别的进程注册的，ServiceManager，或者SystemServer中的AMS服务</li>
<li>Client请求服务的时候，一定是由Binder驱动为Client分配binder_ref，如果本进程的线程请求，fp-&gt;type = BINDER_TYPE_BINDER，否则就是fp-&gt;type = BINDER_TYPE_HANDLE。</li>
<li>Android中的Parcel里面的对象一定是flat_binder_object</li>
</ul>
<p>如此下来，写数据的流程所经历的数据结构就完了。再简单看一下被唤醒一方的读取流程，读取从阻塞在内核态的binder_thread_read开始，以传递而来的BC_TRANSACTION为例，binder_thread_read会根据一些场景添加BRXXX参数，标识驱动传给用户空间的数据流向：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BinderDriverReturnProtocol</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> BR_ERROR = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">0</span>, int),</span><br><span class="line"> BR_OK = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>),</span><br><span class="line"> BR_TRANSACTION = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">2</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span>),</span><br><span class="line"> BR_REPLY = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">3</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span>),</span><br><span class="line"></span><br><span class="line"> BR_ACQUIRE_RESULT = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">4</span>, int),</span><br><span class="line"> BR_DEAD_REPLY = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">5</span>),</span><br><span class="line"> BR_TRANSACTION_COMPLETE = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">6</span>),</span><br><span class="line"> BR_INCREFS = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">7</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ptr_cookie</span></span>),</span><br><span class="line"></span><br><span class="line"> BR_ACQUIRE = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">8</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ptr_cookie</span></span>),</span><br><span class="line"> BR_RELEASE = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">9</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ptr_cookie</span></span>),</span><br><span class="line"> BR_DECREFS = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">10</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ptr_cookie</span></span>),</span><br><span class="line"> BR_ATTEMPT_ACQUIRE = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">11</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_pri_ptr_cookie</span></span>),</span><br><span class="line"></span><br><span class="line"> BR_NOOP = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">12</span>),</span><br><span class="line"> BR_SPAWN_LOOPER = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">13</span>),</span><br><span class="line"> BR_FINISHED = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">14</span>),</span><br><span class="line"> BR_DEAD_BINDER = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">15</span>, void *),</span><br><span class="line"></span><br><span class="line"> BR_CLEAR_DEATH_NOTIFICATION_DONE = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">16</span>, void *),</span><br><span class="line"> BR_FAILED_REPLY = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">17</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后，read线程根据binder_transaction新建binder_transaction_data对象，再通过copy_to_user，传递给用户空间，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int</span><br><span class="line">binder_thread_read(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc, <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span></span> *thread,</span><br><span class="line">    void  __user *buffer, int size, signed long *consumed, int non_block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            uint32_t cmd;</span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span> tr ;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span> *w;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span></span> *t = NULL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span>, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span>, entry);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                goto retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 数据大小</span></span><br><span class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// 偏移地址要加上</span></span><br><span class="line">        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset;</span><br><span class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *));</span><br><span class="line">    <span class="comment">// 写命令</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">// 写数据结构体到用户空间，</span></span><br><span class="line">        ptr += sizeof(uint32_t);</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, sizeof(tr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += sizeof(tr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上层通过ioctrl等待的函数被唤醒,假设现在被唤醒的是服务端，一般会执行请求,这里首先通过Parcel的ipcSetDataReference函数将数据将数据映射到Parcel对象中，之后再通过BBinder的transact函数处理具体需求；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// read到了数据请求，这里是需要处理的逻辑 ，处理完毕，</span></span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">     ...</span><br><span class="line"> <span class="comment">// 这里是处理 如果非空，就是数据有效，</span></span><br><span class="line">    <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">        <span class="comment">// 这里什么是tr.cookie</span></span><br><span class="line">        <span class="function">sp&lt;BBinder&gt; <span class="title">b</span><span class="params">((BBinder*)tr.cookie)</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;<span class="built_in">transact</span>(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">        <span class="keyword">if</span> (error &lt; NO_ERROR) reply.<span class="built_in">setError</span>(error);</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure>

<p>这里的 b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);就同一开始Client调用transact( mHandle, code, data, reply, flags)函数对应的处理类似，进入相对应的业务逻辑。</p>
<p><img src="/images/android_binder_faq_transport_cover.png" alt="img"></p>
<p>Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装.jpg</p>
<h2 id="Binder驱动传递数据的释放（释放时机）"><a href="#Binder驱动传递数据的释放（释放时机）" class="headerlink" title="Binder驱动传递数据的释放（释放时机）"></a>Binder驱动传递数据的释放（释放时机）</h2><p>在Binder通信的过程中，数据是从发起通信进程的用户空间直接写到目标进程内核空间，而这部分数据是直接映射到用户空间，必须等用户空间使用完数据才能释放，也就是说<strong>Binder通信中内核数据的释放时机应该是用户空间控制的</strong>，内种中释放内存空间的函数是binder_free_buf，其他的数据结构其实可以直接释放掉，执行这个函数的命令是BC_FREE_BUFFER。上层用户空间常用的入口是IPCThreadState::freeBuffer：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::freeBuffer</span><span class="params">(Parcel* parcel, <span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> <span class="keyword">size_t</span>* objects, <span class="keyword">size_t</span> objectsSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">void</span>* cookie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) parcel-&gt;<span class="built_in">closeFileDescriptors</span>();</span><br><span class="line">    IPCThreadState* state = <span class="built_in">self</span>();</span><br><span class="line">    state-&gt;mOut.<span class="built_in">writeInt32</span>(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.<span class="built_in">writeInt32</span>((<span class="keyword">int32_t</span>)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那什么时候会调用这个函数呢？在之前分析数据传递的时候，有一步是将binder_transaction_data中的数据映射到Parcel中去，其实这里是关键</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            <span class="comment">// 注意这里是没有传输数据拷贝的，只有一个指针跟数据结构的拷贝，</span></span><br><span class="line">            err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line">            <span class="built_in">ALOG_ASSERT</span>(err == NO_ERROR, <span class="string">&quot;Not enough command data for brREPLY&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="comment">// free buffer，先设置数据，直接</span></span><br><span class="line">            <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 牵扯到数据利用，与内存释放</span></span><br><span class="line">                    reply-&gt;<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>),</span><br><span class="line">                        freeBuffer, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>Parcel 的ipcSetDataReference函数不仅仅能讲数据映射到Parcel对象，同时还能将数据的清理函数映射进来</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parcel::ipcSetDataReference</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">size_t</span>* objects, <span class="keyword">size_t</span> objectsCount, release_func relFunc, <span class="keyword">void</span>* relCookie)</span></span></span><br></pre></td></tr></table></figure>

<p>看函数定义中的release_func relFunc参数，这里就是指定内存释放函数，这里指定了IPCThreadState::freeBuffer函数，在Native层，Parcel在使用完，并走完自己的生命周期后，就会调用自己的析构函数，在其析构函数中调用了freeDataNoInit()，这个函数会间接调用上面设置的内存释放函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parcel::~<span class="built_in">Parcel</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">freeDataNoInit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是数据释放的入口，进入内核空间后，执行binder_free_buf，将这次分配的内存释放，同时更新binder_proc的binder_buffer表，重新标记那些内存块被使用了，哪些没被使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void binder_free_buf(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span> *buffer)</span><br><span class="line">&#123;</span><br><span class="line">    size_t size, buffer_size;</span><br><span class="line">    buffer_size = binder_buffer_size(proc, buffer);</span><br><span class="line">    size = ALIGN(buffer-&gt;data_size, sizeof(void *)) +</span><br><span class="line">        ALIGN(buffer-&gt;offsets_size, sizeof(void *));</span><br><span class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">             <span class="string">&quot;binder: %d: binder_free_buf %p size %zd buffer&quot;</span></span><br><span class="line">             <span class="string">&quot;_size %zd\n&quot;</span>, proc-&gt;pid, buffer, size, buffer_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;async_transaction) &#123;</span><br><span class="line">        proc-&gt;free_async_space += size + sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span>);</span><br><span class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</span><br><span class="line">                 <span class="string">&quot;binder: %d: binder_free_buf size %zd &quot;</span></span><br><span class="line">                 <span class="string">&quot;async free %zd\n&quot;</span>, proc-&gt;pid, size,</span><br><span class="line">                 proc-&gt;free_async_space);</span><br><span class="line">    &#125;</span><br><span class="line">    binder_update_page_range(proc, <span class="number">0</span>,</span><br><span class="line">        (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data),</span><br><span class="line">        (void *)(((uintptr_t)buffer-&gt;data + buffer_size) &amp; PAGE_MASK),</span><br><span class="line">        NULL);</span><br><span class="line">    rb_erase(&amp;buffer-&gt;rb_node, &amp;proc-&gt;allocated_buffers);</span><br><span class="line">    buffer-&gt;free = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!list_is_last(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span> *next = list_entry(buffer-&gt;entry.next,</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span>, entry);</span><br><span class="line">        <span class="keyword">if</span> (next-&gt;free) &#123;</span><br><span class="line">            rb_erase(&amp;next-&gt;rb_node, &amp;proc-&gt;free_buffers);</span><br><span class="line">            binder_delete_free_buffer(proc, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;buffers.next != &amp;buffer-&gt;entry) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span> *prev = list_entry(buffer-&gt;entry.prev,</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span>, entry);</span><br><span class="line">        <span class="keyword">if</span> (prev-&gt;free) &#123;</span><br><span class="line">            binder_delete_free_buffer(proc, buffer);</span><br><span class="line">            rb_erase(&amp;prev-&gt;rb_node, &amp;proc-&gt;free_buffers);</span><br><span class="line">            buffer = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_insert_free_buffer(proc, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层类似，通过JNI调用Parcel的freeData()函数释放内存，在用户空间，每次执行BR_TRANSACTION或者BR_REPLY，都会利用freeBuffer发送请求，去释放内核中的内存</p>
<h2 id="ServiceManager-addService的限制"><a href="#ServiceManager-addService的限制" class="headerlink" title="ServiceManager addService的限制"></a>ServiceManager addService的限制</h2><p>并非所有服务都能通过addService添加到ServiceManager</p>
<p>ServiceManager其实主要的面向对象是系统服务，大部分系统服务都是由SystemServer进程总添加到ServiceManager中去的，在通过ServiceManager添加服务的时候，是有些权限校验的，源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svc_can_register</span><span class="params">(<span class="keyword">unsigned</span> uid, <span class="keyword">uint16_t</span> *name)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n;</span><br><span class="line">    <span class="comment">// 谁有权限add_service 0进程，或者 AID_SYSTEM进程</span></span><br><span class="line">    <span class="keyword">if</span> ((uid == <span class="number">0</span>) || (uid == AID_SYSTEM))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(allowed) / <span class="built_in"><span class="keyword">sizeof</span></span>(allowed[<span class="number">0</span>]); n++)</span><br><span class="line">        <span class="keyword">if</span> ((uid == allowed[n].uid) &amp;&amp; <span class="built_in">str16eq</span>(name, allowed[n].name))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 (uid == 0) 或者 (uid == AID_SYSTEM)的进程都是可以添加服务的，uid=0，代表root用户，而uid=AID_SYSTEM，代表系统用户    。或者是一些特殊的配置进程。SystemServer进程在被Zygote创建的时候，就被分配了UID 是AID_SYSTEM（1000），</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,3001,3002,3003,3006,3007&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--capabilities=130104352,130104352&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--runtime-init&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>Android每个APP的UID，都是不同的，用了Linux的UID那一套，但是没完全沿用，这里不探讨，<strong>总之，普通的进程是没有权限注册到ServiceManager中的，那么APP平时通过bindService启动的服务怎么注册于查询的呢？接管这个任务的就是SystemServer的ActivityManagerService</strong>。</p>
<h2 id="bindService启动Service与Binder服务实体的流程-（ActivityManagerService）"><a href="#bindService启动Service与Binder服务实体的流程-（ActivityManagerService）" class="headerlink" title="bindService启动Service与Binder服务实体的流程 （ActivityManagerService）"></a>bindService启动Service与Binder服务实体的流程 （ActivityManagerService）</h2><ul>
<li>bindService的框架</li>
<li>binder服务实例化与转化</li>
<li>业务逻辑的唤醒</li>
<li>请求代理的转化与唤醒</li>
</ul>
<p>bindService比startService多了一套Binder通信，其余的流程基本相同，而startService的流程，同startActivity差不多，四大组件的启动流程这里不做分析点，主要看bindService中C/S通信的建立流程，在这个流程里面，APP与服务端互为C/S的特性更明显，在APP开发的时候，binder服务是通过Service来启动的。Service的启动方式有两种startService，与bindService，这里只考虑后者，另外启动的binder服务也分为两种情况：第一种，client同server位于同一进程，可以看做内部服务，第二种，Client与Server跨进程，即使是位于同一个APP，第一桶可以不用AIDL来编写，但是第二种必须通过AIDL实现跨进程通信，看一个最简单的AIDL例子，首先在定义一个aidl接口：</p>
<blockquote>
<p>IMyAidlInterface.aidl</p>
</blockquote>
<p>interface IMyAidlInterface {<br> void communicate(int count);<br> }</p>
<p>IMyAidlInterface.aidl定义了通信的借口，通过build之后，构建工具会自动为IMyAidlInterface.aidl生成一些辅助类，这些辅助类主要作用是生成Binder通信协议框架，必须保证两方通信需要指令相同，才能解析通信内容。天王盖地虎，宝塔镇河妖。Java层Binder的对应关系Binder与BinderProxy从这里可以看出，binder采用了代理模式 stub与proxy对应，使用aidl实现的服务时候，Client如果想要获得Binder实体的代理可以通过asInterface来处理，比如如果在同一进程就是实体，不在就新建代理对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">snail</span>.<span class="title">labaffinity</span>.<span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">&quot;com.snail.labaffinity.IMyAidlInterface&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.snail.labaffinity.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.snail.labaffinity.IMyAidlInterface))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.snail.labaffinity.IMyAidlInterface) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.snail.labaffinity.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_communicate: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">int</span> _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    <span class="keyword">this</span>.communicate(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">snail</span>.<span class="title">labaffinity</span>.<span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">communicate</span><span class="params">(<span class="keyword">int</span> count)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(count);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_communicate, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_communicate = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">communicate</span><span class="params">(<span class="keyword">int</span> count)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动Binder服务端封装Service，之所以成为封装Service，是因为Service对于Binder实体的最大作用是个作为新建服务的入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AidlService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BBinderService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BBinderService</span> <span class="keyword">extends</span> <span class="title">IMyAidlInterface</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">communicate</span><span class="params">(<span class="keyword">int</span> count)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而启动的入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Intent intent = createExplicitFromImplicitIntent(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> Intent(<span class="string">&quot;com.snail.labaffinity.service.AidlService&quot;</span>));</span><br><span class="line">    bindService(intent, <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</span><br><span class="line">            IMyAidlInterface  iMyAidlInterface = IMyAidlInterface.Stub.asInterface(iBinder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上四个部分就组成了AIDL跨进程服务的基本组件，现在从ActivitybindService入口开始分析：bindService大部分的流程与startActivity类似，其实都是通过AMS启动组件，这里只将一些不同的地方，Activity启动只需要Intent就可以了，而Service的bind需要一个ServiceConnection对象，这个对象其实是为了AMS端在启动Service后回调用的，ServiceConnection是个接口，其实例在ContextImpl的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  UserHandle user)</span> </span>&#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;connection is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</span><br><span class="line">                mMainThread.getHandler(), flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Not supported in system context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags &amp; BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess();</span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">                mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">                sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">&quot;Not allowed to bind to service &quot;</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mPackageInfo是一个LoadApk类，通过它的getServiceDispatcher获得一个IServiceConnection对象，这个对象一个Binder实体，看一下具体原理</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">IServiceConnection</span> getServiceDispatcher(<span class="type">ServiceConnection</span> c,</span><br><span class="line">        <span class="type">Context</span> context, <span class="type">Handler</span> handler, int flags) &#123;</span><br><span class="line">    synchronized (mServices) &#123;</span><br><span class="line">        <span class="type">LoadedApk</span>.<span class="type">ServiceDispatcher</span> sd <span class="operator">=</span> null;</span><br><span class="line">        <span class="type">ArrayMap</span>&lt;<span class="type">ServiceConnection</span>, <span class="type">LoadedApk</span>.<span class="type">ServiceDispatcher</span>&gt; map <span class="operator">=</span> mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map <span class="operator">!=</span> null) &#123;</span><br><span class="line">            sd <span class="operator">=</span> map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd <span class="operator">==</span> null) &#123;</span><br><span class="line">            sd <span class="operator">=</span> new <span class="type">ServiceDispatcher</span>(c, context, handler, flags);</span><br><span class="line">            <span class="keyword">if</span> (map <span class="operator">==</span> null) &#123;</span><br><span class="line">                map <span class="operator">=</span> new <span class="type">ArrayMap</span>&lt;<span class="type">ServiceConnection</span>, <span class="type">LoadedApk</span>.<span class="type">ServiceDispatcher</span>&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在LoadApk中IServiceConnection对象是通过context键值来存储ServiceDispatcher对象，而ServiceDispatcher对象内存会有个InnerConnection对象，该对象就是getServiceDispatcher的返回对象。因此bindServiceCommon最终调用<br> ActivityManagerNative.getDefault().bindService(x,x,x,x,x sd, x, x, x) 的时候，传递的参数sd其实就是一个InnerConnection对象，这是个Binder实体。但是，Binder.java中的Binder只是对native层BBinder的一个简单封装,真正的实例化还是通过JNI到native层去创建一个JavaBBinderHolder对象，并初始化gBinderOffsets，让其能映射Java层Binder对象，而JavaBBinderHolder中又可以实例化BBinder的实例JavaBBinder，不过BBinder的实例化时机并不在这里，而是在Parcel对象writeStrongBinder的时候，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bindernative_offsets_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Class state.</span></span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mExecTransact;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object state.</span></span><br><span class="line">    jfieldID mObject;</span><br><span class="line"></span><br><span class="line">&#125; gBinderOffsets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Binder_init</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JavaBBinderHolder* jbh = <span class="keyword">new</span> <span class="built_in">JavaBBinderHolder</span>();</span><br><span class="line">    jbh-&gt;<span class="built_in">incStrong</span>((<span class="keyword">void</span>*)android_os_Binder_init);</span><br><span class="line">    env-&gt;<span class="built_in">SetIntField</span>(obj, gBinderOffsets.mObject, (<span class="keyword">int</span>)jbh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往下看bindService，会调用到ActivityManagerProxy的bindService</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> int bindService(IApplicationThread caller, IBinder token,</span><br><span class="line">        Intent service, String resolvedType, IServiceConnection connection,</span><br><span class="line">        int flags, int userId) throws RemoteException &#123;</span><br><span class="line">    Parcel <span class="keyword">data</span> = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    <span class="keyword">data</span>.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    <span class="keyword">data</span>.writeStrongBinder(caller != <span class="literal">null</span> ? caller.asBinder() : <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">data</span>.writeStrongBinder(token);</span><br><span class="line">    service.writeToParcel(<span class="keyword">data</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">data</span>.writeString(resolvedType);</span><br><span class="line">    <span class="keyword">data</span>.writeStrongBinder(connection.asBinder());</span><br><span class="line">    <span class="keyword">data</span>.writeInt(flags);</span><br><span class="line">    <span class="keyword">data</span>.writeInt(userId);</span><br><span class="line">    mRemote.transact(BIND_SERVICE_TRANSACTION, <span class="keyword">data</span>, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    int res = reply.readInt();</span><br><span class="line">    <span class="keyword">data</span>.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用Parcel的writeStrongBinder会将Binder实体写入到Parcel中去，这里首先看一下 Parcel data = Parcel.obtain();在java层Parcel只是一个容器，具体Parcel相关的操作都在Native层</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_os_Parcel_create</span><span class="params">(JNIEnv* env, jclass clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">new</span> <span class="built_in">Parcel</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jint&gt;(parcel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的返回值，其实就是Parcel对象的地址，被赋值给了Parcel.java的mNativePtr成员变量，方便Native调用，接着看writeStrongBinder的实现，其实就是调用Parcel.cpp中的对应方法，通过flatten_binder将Binder实体对象打扁，创建flat_binder_object写入Parcel中，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Parcel_writeStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jint nativePtr, jobject object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">status_t</span> err = parcel-&gt;<span class="built_in">writeStrongBinder</span>(<span class="built_in">ibinderForJavaObject</span>(env, object));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">signalExceptionForError</span>(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ibinderForJavaObject主要为Java层Binder实例化native binder对象：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="keyword">return</span> jbh != <span class="literal">NULL</span> ? jbh-&gt;get(env, obj) : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (IBinder*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果BBinder还没实例化，要通过JavaBBinderHolder的get函数实例化一个BBinder对象，这里就是<strong>JavaBBinder</strong>对象，综上分析Java层与Native的Binder其对应关系如下：</p>
<p><img src="/images/android_binder_faq_native_bbinder_java_binder.png" alt="img"></p>
<p>Java层Binder与native 层BBiner.png</p>
<p>BBinder对象被Parcel转换成flat_binder_object，经过一次拷贝写入目标进程，并执行BINDER_TYPE_BINDER与BINDER_TYPE_HANDLE的转换，如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static</span> <span class="keyword">void</span></span><br><span class="line">binder_transaction(struct binder_proc *proc, struct binder_thread *thread,</span><br><span class="line">    struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span><br><span class="line">    ...</span><br><span class="line"> fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;..</span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;..</span><br><span class="line">            struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</span><br><span class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_BINDER;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                struct binder_ref *new_ref;</span><br><span class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核中，bindService中的InnerConnection会由BINDER_TYPE_BINDER转换成BINDER_TYPE_HANDLE，之后，AMS线程被唤醒后，执行后面的流程，在前文分析Parcel数据转换的时候，在Binder线程被唤醒继续执行的时候，会将数据映射到一个natvie Parcel对象中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (cmd) &#123;</span><br><span class="line">     ..</span><br><span class="line">    <span class="comment">// read到了数据请求，这里是需要处理的逻辑 ，处理完毕，</span></span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line">            Parcel buffer;</span><br><span class="line">            &lt;!--关键点<span class="number">1</span> --&gt;</span><br><span class="line">            buffer.<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">            ...</span><br><span class="line">          &lt;!--关键点<span class="number">2</span> --&gt;</span><br><span class="line">        <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">            <span class="function">sp&lt;BBinder&gt; <span class="title">b</span><span class="params">((BBinder*)tr.cookie)</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;<span class="built_in">transact</span>(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            <span class="keyword">if</span> (error &lt; NO_ERROR) reply.<span class="built_in">setError</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        ..</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;        </span><br></pre></td></tr></table></figure>

<p>首先看一下关键点1 ，这里将内核数据映射到一个用户空间的Parcel对象中去，之后在调用目标Service的transact函数，进而调用他的onTrasanct函数 , 通过前面的分析知道，Java层Binder在注册时候，最终注册的是JavaBBinder对象，看一下它的onTrasanct函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JNIEnv* env = <span class="built_in">javavm_to_jnienv</span>(mVM);</span><br><span class="line">        IPCThreadState* thread_state = IPCThreadState::<span class="built_in">self</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> strict_policy_before = thread_state-&gt;<span class="built_in">getStrictModePolicy</span>();</span><br><span class="line">        thread_state-&gt;<span class="built_in">setLastTransactionBinderFlags</span>(flags);</span><br><span class="line">        ..</span><br><span class="line">        jboolean res = env-&gt;<span class="built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">            code, (<span class="keyword">int32_t</span>)&amp;data, (<span class="keyword">int32_t</span>)reply, flags);</span><br><span class="line">        ..</span><br><span class="line">        <span class="keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>关键代码只有一句：env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, (int32_t)&amp;data, (int32_t)reply, flags)，其实就是调用Binder.java的execTransact函数，该函数首先将Native的Parcel映射成Jave层Parcel，之后调用BBinder子类的onTransact函数执行对应的业务逻辑，最后会通过data.recycle通知释放内存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">int</span> dataObj, <span class="keyword">int</span> replyObj,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        Parcel data = Parcel.obtain(dataObj);</span><br><span class="line">        Parcel reply = Parcel.obtain(replyObj);</span><br><span class="line">        <span class="keyword">boolean</span> res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            res = onTransact(code, data, reply, flags);</span><br><span class="line">        &#125; ...</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>对于AMS而bindService对应的操作如下</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean onTransact(int code, Parcel <span class="keyword">data</span>, Parcel reply, int flags)</span><br><span class="line">    throws RemoteException &#123;</span><br><span class="line">    。。</span><br><span class="line">    case BIND_SERVICE_TRANSACTION: &#123;</span><br><span class="line">    <span class="keyword">data</span>.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder b = <span class="keyword">data</span>.readStrongBinder();</span><br><span class="line">    IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">    IBinder token = <span class="keyword">data</span>.readStrongBinder();</span><br><span class="line">    Intent service = Intent.CREATOR.createFromParcel(<span class="keyword">data</span>);</span><br><span class="line">    String resolvedType = <span class="keyword">data</span>.readString();</span><br><span class="line">    b = <span class="keyword">data</span>.readStrongBinder();</span><br><span class="line">    int fl = <span class="keyword">data</span>.readInt();</span><br><span class="line">    int userId = <span class="keyword">data</span>.readInt();</span><br><span class="line">    IServiceConnection conn = IServiceConnection.Stub.asInterface(b);</span><br><span class="line">    int res = bindService(app, token, service, resolvedType, conn, fl, userId);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    reply.writeInt(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b = data.readStrongBinder()会先读取Binder对象，这里会调用本地函数nativeReadStrongBinder(mNativePtr)，mNativePtr就是Native层Parcel的首地址：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title">readStrongBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nativeReadStrongBinder(mNativePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeReadStrongBinder(mNativePtr)会将本地Binder对象转化成Java层对象，其实就是将传输的InnerConnection读取出来，不过由于Binder驱动将BINDER_TYPE_BINDER转换成了BINDER_TYPE_HANDLE，对于AMS其实是实例化BinderProxy</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_Parcel_readStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jint nativePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// /parcel-&gt;readStrongBinder() 其实就会创建BpBInder、</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">javaObjectForIBinder</span>(env, parcel-&gt;<span class="built_in">readStrongBinder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会利用Parcel.cpp的parcel-&gt;readStrongBinder()，读取binder对象，这里会根据flat_binder_object的类型，分别进行BBinder与BpBinder映射，如果是Binder实体直接将指针赋值out，如果不是，则根据handle获取或者新建BpBinder返回给out。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">unflatten_binder</span><span class="params">(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.<span class="built_in">readObject</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">static_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finish_unflatten_binder</span>(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                *out = proc-&gt;<span class="built_in">getStrongProxyForHandle</span>(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finish_unflatten_binder</span>(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;<span class="built_in">get</span>()), *flat, in);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后会牵扯一个将native binder转换成java层Binder的操作，javaObjectForIBinder，这个函数很关键，是理解Java层BinderProxy或者BBinder实体的关键：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">jobject javaObjectForIBinder(JNIEnv* env, const sp<span class="tag">&lt;<span class="name">IBinder</span>&gt;</span>&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    if (val == NULL) return NULL;</span><br><span class="line">    <span class="comment">&lt;!--关键点1--&gt;</span></span><br><span class="line">    if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">    AutoMutex _l(mProxyLock);</span><br><span class="line">    <span class="comment">&lt;!--关键点2--&gt;</span></span><br><span class="line">    jobject object = (jobject)val-&gt;findObject(&amp;gBinderProxyOffsets);</span><br><span class="line">    if (object != NULL) &#123;</span><br><span class="line">        android_atomic_dec(&amp;gNumProxyRefs);</span><br><span class="line">        val-&gt;detachObject(&amp;gBinderProxyOffsets);</span><br><span class="line">        env-&gt;DeleteGlobalRef(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">&lt;!--关键点3--&gt;</span></span><br><span class="line">    object = env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);</span><br><span class="line">    if (object != NULL) &#123;</span><br><span class="line">        env-&gt;SetIntField(object, gBinderProxyOffsets.mObject, (int)val.get());</span><br><span class="line">        val-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line">        jobject refObject = env-&gt;NewGlobalRef(</span><br><span class="line">                env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf));</span><br><span class="line">        val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject,</span><br><span class="line">                jnienv_to_javavm(env), proxy_cleanup);</span><br><span class="line">        sp<span class="tag">&lt;<span class="name">DeathRecipientList</span>&gt;</span> drl = new DeathRecipientList;</span><br><span class="line">        drl-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line">        env-&gt;SetIntField(object, gBinderProxyOffsets.mOrgue, reinterpret_cast<span class="tag">&lt;<span class="name">jint</span>&gt;</span>(drl.get()));</span><br><span class="line">        android_atomic_inc(&amp;gNumProxyRefs);</span><br><span class="line">        incRefsCreated(env);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看关键点1， checkSubclass默认返回false，但是JavaBBinder，该类对此函数进行了覆盖，如果是JavaBBinder，就会返回true，但入股是BpBinder，则会返回false，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span>    <span class="title">checkSubclass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* subclassID)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subclassID == &amp;gBinderOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看关键点2，如果是BpBinder，则需要首先在gBinderProxyOffsets中查找，是不是已经新建了Java层代理BinderProxy对象，如果没有，则新建即可，如果新建就看是否还存在缓存有效的BinderProxy。最后看关键点3 ：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;NewObject(gBinderProxyOffsets<span class="selector-class">.mClass</span>, gBinderProxyOffsets<span class="selector-class">.mConstructor</span>)</span><br></pre></td></tr></table></figure>

<p>其实就是新建BinderProxy对象，Java层的BinderProxy都是Native新建的，Java层并没有BinderProxy的新建入口，之后，再通过IServiceConnection.Stub.asInterface(b)进行转换，实例化一个IServiceConnection.Proxy代理对，该对象在Binder通信的基础上封装了业务逻辑，其实就是一些具体的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> XXXAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">           <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> XXXAidlInterface))) &#123;</span><br><span class="line">               <span class="keyword">return</span> ((XXXAidlInterface) iin);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> XXXAidlInterface.Stub.Proxy(obj);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这里注意一点杜宇BinderProxy，obj.queryLocalInterface(DESCRIPTOR)返回为null，对于Binder实体，返回的是Binder自身，这样就能为上层区分出是生成代理还是存根自身，整体对象转换流程如下：</p>
<p><img src="/images/android_binder_faq_service_connection.png" alt="img"></p>
<p>ServiceConnection的回调作用</p>
<p>到这里分析了一半，Java层命令及回调Binder入口已经被传递给AMS，AMS之后需要负责启动Service，并通过回调入口为Client绑定服务，跟踪到AMS源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token,</span></span></span><br><span class="line"><span class="params"><span class="function">        Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="params"><span class="function">        IServiceConnection connection, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service, resolvedType,</span><br><span class="line">                connection, flags, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用ActiveService的bindServiceLocked，这里会分三中情况，</p>
<ul>
<li>Service已经经启动</li>
<li>Service未启动，但是进程已经启动</li>
<li>Service与进程君未启动</li>
</ul>
<p>不过这里只讨论“ Service未启动，但是进程已经启动的情况”，关键代码如下</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> int <span class="function"><span class="title">bindServiceLocked</span>(<span class="params">IApplicationThread caller, IBinder token,</span></span></span><br><span class="line"><span class="params"><span class="function">            Intent service, <span class="built_in">String</span> resolvedType,</span></span></span><br><span class="line"><span class="params"><span class="function">            IServiceConnection connection, int flags, int userId</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            .。。</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">                s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">          &lt;!--关键点<span class="number">1</span>--&gt;</span><br><span class="line">                <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), <span class="literal">false</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &lt;!--关键点<span class="number">2</span>--&gt;</span><br><span class="line">           ..</span><br><span class="line">           requestServiceBindingLocked(s, b.intent, <span class="literal">false</span>);</span><br><span class="line">           ..</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点1其实就是启动Service，主要是通过ApplicationThread的binder通信通知App端启动Service，这个流程同Activity启动一样。关键点2是Service特有的：requestServiceBindingLocked，这个命令是告诉APP端：“在Service启动后需要向AMS发消息，之后AMS才能向其他需要绑定该Service的Client发送反馈”。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">AMS端</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean requestServiceBindingLocked(ServiceRecord r,</span><br><span class="line">        IntentBindRecord i, boolean rebind) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       ..</span><br><span class="line">          r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind);</span><br><span class="line">       ..</span><br><span class="line">      &#125;        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> APP端</span><br><span class="line"> <span class="keyword">private</span> void handleBindService(BindServiceData <span class="keyword">data</span>) &#123;</span><br><span class="line">    Service s = mServices.<span class="keyword">get</span>(<span class="keyword">data</span>.token);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">data</span>.rebind) &#123;</span><br><span class="line">        IBinder binder = s.onBind(<span class="keyword">data</span>.intent);</span><br><span class="line">        ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                <span class="keyword">data</span>.token, <span class="keyword">data</span>.intent, binder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityManagerNative.getDefault().publishService会将启动的Binder服务实体传递给AMS，上面分析过Binder实体传输，这里的原理是一样的，AMS端在传输结束后，会获得Service端服务实体的引用，这个时候，就能通过最初的InnerConnection的回调将这个服务传递给Client端。Binder实体与引用的整体流程图如下：</p>
<p><img src="/images/android_binder_faq_bind_service_global_flow.png" alt="img"></p>
<p>bindSerivce整体流程图</p>
<p>如果要深究Activity的bindService流程，可以按以下几步来分析</p>
<ul>
<li>1、Activity调用bindService：通过Binder通知ActivityManagerService，要启动哪个Service</li>
<li>2、ActivityManagerService创建ServiceRecord，并利用ApplicationThreadProxy回调，通知APP新建并启动Service启动起来</li>
<li>3、ActivityManagerService把Service启动起来后，继续通过ApplicationThreadProxy，通知APP，bindService，其实就是让Service返回一个Binder对象给ActivityManagerService，以便AMS传递给Client</li>
<li>4、ActivityManagerService把从Service处得到这个Binder对象传给Activity，这里是通过IServiceConnection binder实现。</li>
<li>5、Activity被唤醒后通过Binder Stub的asInterface函数将Binder转换为代理Proxy，完成业务代理的转换，之后就能利用Proxy进行通信了。</li>
</ul>
<p><img src="/images/android_binder_faq_bind_service_flow.png" alt="img"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6/" rel="tag"># 系统机制</a>
              <a href="/tags/%E6%80%BB%E7%BB%93/" rel="tag"># 总结</a>
              <a href="/tags/IPC/" rel="tag"># IPC</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/06/01/android_binder/" rel="prev" title="Android进程间通信Binder机制原理">
                  <i class="fa fa-chevron-left"></i> Android进程间通信Binder机制原理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/07/02/kotlin_base/" rel="next" title="Kotlin基础">
                  Kotlin基础 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小贾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  





</body>
</html>
