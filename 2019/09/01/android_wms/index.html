<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="WMS（WindowManagerService）窗口管理服务，是系统核心服务。简单来讲，它是窗口管理员。窗口是一个抽象的概念，从用户的角度来讲，它是一个界面。从SufaceFlinger的角度来讲，它是一个Layer,承载着和界面有关的数据和属性。所以它是一个WindowState，用于管理和界面有关的状态。 WMS也是系统服务，由SystemServer启动。直到关机时才会退出。发生异常时必须">
<meta property="og:type" content="article">
<meta property="og:title" content="Android WMS核心分析">
<meta property="og:url" content="http://example.com/2019/09/01/android_wms/index.html">
<meta property="og:site_name" content="奔跑的蜗牛">
<meta property="og:description" content="WMS（WindowManagerService）窗口管理服务，是系统核心服务。简单来讲，它是窗口管理员。窗口是一个抽象的概念，从用户的角度来讲，它是一个界面。从SufaceFlinger的角度来讲，它是一个Layer,承载着和界面有关的数据和属性。所以它是一个WindowState，用于管理和界面有关的状态。 WMS也是系统服务，由SystemServer启动。直到关机时才会退出。发生异常时必须">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/android_wms_window_manager_wms.png">
<meta property="og:image" content="http://example.com/images/android_wms_example_window.png">
<meta property="og:image" content="http://example.com/images/android_wms_window_types.png">
<meta property="og:image" content="http://example.com/images/android_wms_application_window.png">
<meta property="og:image" content="http://example.com/images/android_wms_subwindow_popupwindow.png">
<meta property="og:image" content="http://example.com/images/android_wms_system_window.png">
<meta property="og:image" content="http://example.com/images/android_wms_window_zorder.png">
<meta property="og:image" content="http://example.com/images/android_wms_window_maanger.png">
<meta property="og:image" content="http://example.com/images/android_wms_activity_phonewindow_decorview.png">
<meta property="og:image" content="http://example.com/images/android_wms_activity_phonewindow_decorview01.png">
<meta property="og:image" content="http://example.com/images/android_wms_wm_wmimpl_wmglobal.png">
<meta property="og:image" content="http://example.com/images/android_wms_wm_wmimpl_wmglobal01.png">
<meta property="og:image" content="http://example.com/images/android_wms_viewrootimpl_wms.png">
<meta property="og:image" content="http://example.com/images/android_wms_wms01.png">
<meta property="og:image" content="http://example.com/images/android_wms_service_start.png">
<meta property="og:image" content="http://example.com/images/android_wms_window_add.png">
<meta property="og:image" content="http://example.com/images/android_wms_window_remove.png">
<meta property="og:image" content="http://example.com/images/android_wms_input_event01.png">
<meta property="og:image" content="http://example.com/images/android_wms_input_event_hub.webp">
<meta property="og:image" content="http://example.com/images/android_wms_surfacce_add.png">
<meta property="og:image" content="http://example.com/images/android_wms_surface_add_layer_create.png">
<meta property="og:image" content="http://example.com/images/android_wms_surface_handle.webp">
<meta property="article:published_time" content="2019-09-01T11:43:00.000Z">
<meta property="article:modified_time" content="2023-01-04T07:32:59.312Z">
<meta property="article:author" content="小贾">
<meta property="article:tag" content="系统机制">
<meta property="article:tag" content="WMS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/android_wms_window_manager_wms.png">


<link rel="canonical" href="http://example.com/2019/09/01/android_wms/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;2019&#x2F;09&#x2F;01&#x2F;android_wms&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;09&#x2F;01&#x2F;android_wms&#x2F;&quot;,&quot;title&quot;:&quot;Android WMS核心分析&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Android WMS核心分析 | 奔跑的蜗牛</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">奔跑的蜗牛</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#WMS%E4%B8%BB%E4%BD%93%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">WMS主体描述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Window"><span class="nav-number">2.</span> <span class="nav-text">Window</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84window"><span class="nav-number">2.1.</span> <span class="nav-text">常见的window</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Window%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.2.</span> <span class="nav-text">Window的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Application-Window"><span class="nav-number">2.2.1.</span> <span class="nav-text">Application Window</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sub-Window"><span class="nav-number">2.2.2.</span> <span class="nav-text">Sub Window</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-Window"><span class="nav-number">2.2.3.</span> <span class="nav-text">System Window</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Window%E7%9A%84%E6%AC%A1%E5%BA%8F"><span class="nav-number">2.3.</span> <span class="nav-text">Window的次序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Window-Flag"><span class="nav-number">2.4.</span> <span class="nav-text">Window Flag</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WindowManager"><span class="nav-number">3.</span> <span class="nav-text">WindowManager</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity%E4%B8%8E-PhoneWindow%E4%B8%8EDecorView%E5%85%B3%E7%B3%BB"><span class="nav-number">3.1.</span> <span class="nav-text">Activity与 PhoneWindow与DecorView关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WindowManager%E3%80%81WindowManagerImpl%E3%80%81WindowManagerGlobal"><span class="nav-number">3.2.</span> <span class="nav-text">WindowManager、WindowManagerImpl、WindowManagerGlobal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ViewRootImpl%E4%B8%8EWindowManagerService"><span class="nav-number">3.3.</span> <span class="nav-text">ViewRootImpl与WindowManagerService</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity%E4%B8%8EWindow%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90"><span class="nav-number">3.4.</span> <span class="nav-text">Activity与Window关联分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WindowManagerService"><span class="nav-number">4.</span> <span class="nav-text">WindowManagerService</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WMS%E7%9A%84%E9%87%8D%E8%A6%81%E6%88%90%E5%91%98"><span class="nav-number">4.1.</span> <span class="nav-text">WMS的重要成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-mPolicy%EF%BC%9AWindowManagerPolicy"><span class="nav-number">4.1.1.</span> <span class="nav-text">1. mPolicy：WindowManagerPolicy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-mSessions%EF%BC%9AArraySet-lt-Session-gt"><span class="nav-number">4.1.2.</span> <span class="nav-text">2. mSessions：ArraySet&lt;**Session**&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-mWindowMap%EF%BC%9AWindowHashMap"><span class="nav-number">4.1.3.</span> <span class="nav-text">3. mWindowMap：WindowHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-mFinishedStarting%EF%BC%9AArrayList-lt-AppWindowToken-gt"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.mFinishedStarting：ArrayList&lt;**AppWindowToken**&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-mResizingWindows%EF%BC%9AArrayList-lt-WindowState-gt"><span class="nav-number">4.1.5.</span> <span class="nav-text">5.mResizingWindows：ArrayList&lt;**WindowState**&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-mInputManager%EF%BC%9AInputManagerService"><span class="nav-number">4.1.6.</span> <span class="nav-text">6.mInputManager：InputManagerService</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WindowManagerService%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">5.</span> <span class="nav-text">WindowManagerService的启动</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Window%E7%9A%84%E6%B7%BB%E5%8A%A0%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-number">6.</span> <span class="nav-text">Window的添加与删除</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Window%E7%9A%84%E6%B7%BB%E5%8A%A0"><span class="nav-number">6.1.</span> <span class="nav-text">Window的添加</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E6%A3%80%E6%9F%A5"><span class="nav-number">6.1.1.</span> <span class="nav-text">窗口检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WindowToken%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86"><span class="nav-number">6.1.2.</span> <span class="nav-text">WindowToken相关处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WindowState%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-number">6.1.3.</span> <span class="nav-text">WindowState的创建和处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Display%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE"><span class="nav-number">6.1.4.</span> <span class="nav-text">Display的创建和配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Window%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">6.2.</span> <span class="nav-text">Window的删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="nav-number">6.2.1.</span> <span class="nav-text">检查线程的正确性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewRootImpl%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4"><span class="nav-number">6.2.2.</span> <span class="nav-text">ViewRootImpl相关数据删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%88%A0%E9%99%A4"><span class="nav-number">6.2.3.</span> <span class="nav-text">判断是否立即执行删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">7.</span> <span class="nav-text">输入事件处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%8D%93%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">安卓输入事件整体流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputManagerService"><span class="nav-number">7.2.</span> <span class="nav-text">InputManagerService</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WindowInputEventReceiver%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="nav-number">7.3.</span> <span class="nav-text">WindowInputEventReceiver输入事件监听</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EventHub%E8%AE%BE%E5%A4%87%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="nav-number">7.4.</span> <span class="nav-text">EventHub设备事件监听</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputReader%E8%AF%BB%E5%8F%96%E4%BA%8B%E4%BB%B6"><span class="nav-number">7.5.</span> <span class="nav-text">InputReader读取事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InputDispatcher%E8%AF%BB%E5%8F%96%E4%BA%8B%E4%BB%B6"><span class="nav-number">7.6.</span> <span class="nav-text">InputDispatcher读取事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E7%9B%AE%E6%A0%87%E7%AA%97%E5%8F%A3"><span class="nav-number">7.7.</span> <span class="nav-text">寻找目标窗口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Surface%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%93%8D%E4%BD%9C"><span class="nav-number">8.</span> <span class="nav-text">Surface的创建与操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Surface%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">8.1.</span> <span class="nav-text">Surface的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Surface%E5%9C%A8%E5%BA%94%E7%94%A8%E7%AB%AF%E7%9A%84%E6%96%B0%E5%BB%BA"><span class="nav-number">8.1.1.</span> <span class="nav-text">Surface在应用端的新建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SurfaceControl"><span class="nav-number">8.1.2.</span> <span class="nav-text">SurfaceControl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%B1%82Layer%E5%88%9B%E5%BB%BA"><span class="nav-number">8.1.3.</span> <span class="nav-text">图层Layer创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Surface%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">8.2.</span> <span class="nav-text">Surface的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Surface%E6%93%8D%E4%BD%9C%E7%AE%80%E4%BB%8B"><span class="nav-number">8.2.1.</span> <span class="nav-text">Surface操作简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%94%BB%E5%B8%83%E6%93%8D%E4%BD%9C"><span class="nav-number">8.2.2.</span> <span class="nav-text">对画布操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E7%94%BB%E5%B8%83%E5%86%85%E5%AE%B9"><span class="nav-number">8.2.3.</span> <span class="nav-text">提交画布内容</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小贾"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">小贾</p>
  <div class="site-description" itemprop="description">Just do IT</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jiajunhui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiajunhui" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:junhui_jia@163.com" title="E-Mail → mailto:junhui_jia@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/jiajunhui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/01/android_wms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="小贾">
      <meta itemprop="description" content="Just do IT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔跑的蜗牛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android WMS核心分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-01 19:43:00" itemprop="dateCreated datePublished" datetime="2019-09-01T19:43:00+08:00">2019-09-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>WMS（WindowManagerService）窗口管理服务，是系统核心服务。简单来讲，它是窗口管理员。窗口是一个抽象的概念，从用户的角度来讲，它是一个界面。从SufaceFlinger的角度来讲，它是一个Layer,承载着和界面有关的数据和属性。所以它是一个WindowState，用于管理和界面有关的状态。</p>
<p>WMS也是系统服务，由SystemServer启动。直到关机时才会退出。发生异常时必须重启。</p>
<span id="more"></span>

<h1 id="WMS主体描述"><a href="#WMS主体描述" class="headerlink" title="WMS主体描述"></a>WMS主体描述</h1><p><strong>Window</strong>：在Android视图体系中Window就是一个窗口的概念。Android中所有的视图都是依赖于Window显示的。</p>
<p><strong>WindowManager</strong>：对Window的管理，包括新增、更新和删除等。</p>
<p><strong>WMS</strong>：窗口的最终管理者，它负责窗口的启动、添加和删除，另外窗口的大小和层级也是由WMS进行管理。</p>
<p><img src="/images/android_wms_window_manager_wms.png" alt="Window_WindowManager_WMS"></p>
<h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><h2 id="常见的window"><a href="#常见的window" class="headerlink" title="常见的window"></a>常见的window</h2><p><img src="/images/android_wms_example_window.png" alt="example_window"></p>
<h2 id="Window的分类"><a href="#Window的分类" class="headerlink" title="Window的分类"></a>Window的分类</h2><p><img src="/images/android_wms_window_types.png" alt="wms_window_types"></p>
<p><strong>Application Window</strong>：Activity就是一个典型的应用程序窗口。</p>
<p><strong>Sub Window</strong>：子窗口，顾名思义，它不能独立存在，需要附着在其他窗口才可以，PopupWindow就属于子窗口。</p>
<p><strong>System Window</strong>：输入法窗口、系统音量条窗口、系统错误窗口都属于系统窗口。</p>
<h3 id="Application-Window"><a href="#Application-Window" class="headerlink" title="Application Window"></a>Application Window</h3><p><img src="/images/android_wms_application_window.png" alt="wms_application_window"></p>
<p>如代码中的以下类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_APPLICATION_WINDOW = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_BASE_APPLICATION   = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION        = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_STARTING = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_DRAWN_APPLICATION = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_APPLICATION_WINDOW = <span class="number">99</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Sub-Window"><a href="#Sub-Window" class="headerlink" title="Sub Window"></a>Sub Window</h3><p>什么是子窗口？</p>
<p>在 PhoneWindow 与 WindowManagerImpl 创建好了以后，我们自己也可以调用 <code>WindowManagerImpl#addView</code> 来添加一个 View 树，也叫添加窗口。</p>
<p>当它的窗口类型处于 WindowManager.LayoutParams.FIRST_SUB_WINDOW 与 WindowManager.LayoutParams.LAST_SUB_WINDOW 之间时，我们称这个直接添加的窗口为子窗口。</p>
<p>那这些直接通过 <code>WindowManagerImpl#addView</code> 创建的窗口，共用同一个 PhoneWindow 以及 WindowManagerImpl 对象，窗口类型不同决定了它们在 WMS 上的一个 z-order 顺序。</p>
<p>典型的子窗口PopupWindow</p>
<p><img src="/images/android_wms_subwindow_popupwindow.png" alt="wms_subwindow_popupwindow"></p>
<p>如代码中的以下类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SUB_WINDOW = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">2</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA_OVERLAY  = FIRST_SUB_WINDOW + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SUB_WINDOW = <span class="number">1999</span>;</span><br></pre></td></tr></table></figure>

<p>接下来让我们看看子窗口是如何添加的，以 PopupWindow 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: PopupWindow.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mWindowLayoutType = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAtLocation</span><span class="params">(View parent, <span class="keyword">int</span> gravity, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  mParentRootView = <span class="keyword">new</span> WeakReference&lt;&gt;(parent.getRootView());</span><br><span class="line">  <span class="comment">//这个getWindowToken返回的就是ViewRootImpl里的mWindow对象</span></span><br><span class="line">  showAtLocation(parent.getWindowToken(), gravity, x, y);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAtLocation</span><span class="params">(IBinder token, <span class="keyword">int</span> gravity, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isShowing() || mContentView == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  detachFromAnchor();</span><br><span class="line"> </span><br><span class="line">  mIsShowing = <span class="keyword">true</span>;</span><br><span class="line">  mIsDropdown = <span class="keyword">false</span>;</span><br><span class="line">  mGravity = gravity;</span><br><span class="line">  <span class="comment">//创建窗口属性，配置窗口类型</span></span><br><span class="line">  <span class="keyword">final</span> WindowManager.LayoutParams p = createPopupLayoutParams(token);</span><br><span class="line">  preparePopup(p);</span><br><span class="line"> </span><br><span class="line">  p.x = x;</span><br><span class="line">  p.y = y;</span><br><span class="line"> </span><br><span class="line">  invokePopup(p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> WindowManager.<span class="function">LayoutParams <span class="title">createPopupLayoutParams</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> WindowManager.LayoutParams p = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">  p.gravity = computeGravity();</span><br><span class="line">  p.flags = computeFlags(p.flags);</span><br><span class="line">  p.type = mWindowLayoutType;</span><br><span class="line">  p.token = token;</span><br><span class="line">  p.softInputMode = mSoftInputMode;</span><br><span class="line">  p.windowAnimations = computeAnimationResource();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加窗口</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokePopup</span><span class="params">(WindowManager.LayoutParams p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    p.packageName = mContext.getPackageName();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> PopupDecorView decorView = mDecorView;</span><br><span class="line">  decorView.setFitsSystemWindows(mLayoutInsetDecor);</span><br><span class="line"> </span><br><span class="line">  setLayoutDirectionFromAnchor();</span><br><span class="line">  <span class="comment">//添加窗口</span></span><br><span class="line">  mWindowManager.addView(decorView, p);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mEnterTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    decorView.requestEnterTransition(mEnterTransition);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以看到 PopupWindow 通过 WindowManagerImpl 直接添加了一个类型为 WindowManager.LayoutParams.TYPE_APPLICATION_PANEL 类型的窗口。<br>这个 mWindowManager 就是 Activity 的 WindowManager, 也就是 Activity 内 PhoneWindow 的 WindowManagerImpl。所以，这个窗口要依附于 Activity。Application 没有 WindowManager 所以不能被依附。<br>另一方面, 这个窗口类型恰好是一个 FIRST_SUB_WINDOW 类型，所以 PopupWindow 是一个真正的子窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: WindowManager.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;</span><br></pre></td></tr></table></figure>

<p>那么问题来了，Dialog是子窗口吗？</p>
<p>接下来看看Dialog的部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: Dialog.java</span></span><br><span class="line"> </span><br><span class="line">Dialog(<span class="meta">@NonNull</span> Context context, <span class="meta">@StyleRes</span> <span class="keyword">int</span> themeResId, <span class="keyword">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">  mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">  <span class="comment">//创建PhoneWindow</span></span><br><span class="line">  <span class="keyword">final</span> Window w = <span class="keyword">new</span> PhoneWindow(mContext);</span><br><span class="line">  mWindow = w;</span><br><span class="line">  w.setCallback(<span class="keyword">this</span>);</span><br><span class="line">  w.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">  w.setOnWindowSwipeDismissedCallback(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCancelable) &#123;</span><br><span class="line">      cancel();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  w.setWindowManager(mWindowManager, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  w.setGravity(Gravity.CENTER);</span><br><span class="line"> </span><br><span class="line">  mListenersHandler = <span class="keyword">new</span> ListenersHandler(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mShowing) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">          mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">      &#125;</span><br><span class="line">      mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  onStart();</span><br><span class="line">  mDecor = mWindow.getDecorView();</span><br><span class="line"> </span><br><span class="line">  WindowManager.LayoutParams l = mWindow.getAttributes();</span><br><span class="line">  <span class="comment">//添加窗口</span></span><br><span class="line">  mWindowManager.addView(mDecor, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Dialog 与 PopupWindow 不同，它有自己的 PhoneWindow 对象，同时 Dialog 的窗口类型为 TYPE_APPLICATION，所以Dialog不能视为一个子窗口。</p>
<h3 id="System-Window"><a href="#System-Window" class="headerlink" title="System Window"></a>System Window</h3><p><img src="/images/android_wms_system_window.png" alt="wms_system_window"></p>
<p>如代码中的以下类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SYSTEM_WINDOW     = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_STATUS_BAR         = FIRST_SYSTEM_WINDOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SEARCH_BAR         = FIRST_SYSTEM_WINDOW+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_PHONE              = FIRST_SYSTEM_WINDOW+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SYSTEM_ALERT       = FIRST_SYSTEM_WINDOW+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_KEYGUARD           = FIRST_SYSTEM_WINDOW+<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_TOAST              = FIRST_SYSTEM_WINDOW+<span class="number">5</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SYSTEM_WINDOW      = <span class="number">2999</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Window的次序"><a href="#Window的次序" class="headerlink" title="Window的次序"></a>Window的次序</h2><p><img src="/images/android_wms_window_zorder.png" alt="wms_window_zorder"></p>
<h2 id="Window-Flag"><a href="#Window-Flag" class="headerlink" title="Window Flag"></a>Window Flag</h2><p>Window的Flag是跟随Window的显示并控制了一些特征与属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 Window 可见时允许锁屏  FLAG_ALLOW_LOCK_WHILE_SCREEN_ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的</span></span><br><span class="line"><span class="comment">// Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL</span></span><br><span class="line"> FLAG_NOT_FOCUSABLE = <span class="number">0x00000008</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件</span></span><br><span class="line"><span class="comment">// Window 之外的 view 也是可以响应 touch 事件。</span></span><br><span class="line"> FLAG_NOT_TOUCH_MODAL  = <span class="number">0x00000020</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口。 FLAG_NOT_TOUCHABLE ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 Window 可见时屏幕就会一直亮着 FLAG_KEEP_SCREEN_ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许 Window 超过屏幕之外 FLAG_LAYOUT_NO_LIMITS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件  FLAG_IGNORE_CHEEK_PRESSES ;</span></span><br><span class="line"><span class="comment">// 窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替</span></span><br><span class="line"> FLAG_SHOW_WHEN_LOCKED = <span class="number">0x00080000</span>;</span><br></pre></td></tr></table></figure>

<h1 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h1><p><img src="/images/android_wms_window_maanger.png" alt="wms_window_maanger"></p>
<h2 id="Activity与-PhoneWindow与DecorView关系"><a href="#Activity与-PhoneWindow与DecorView关系" class="headerlink" title="Activity与 PhoneWindow与DecorView关系"></a>Activity与 PhoneWindow与DecorView关系</h2><p>Activity是系统可视化交互组件，四大组件都由AMS统一管理生命周期，事实上它的职责只是生命周期的管理，由设计模式的单一职责的原则，那势必需要将Activity和其上的视图View进行解耦，那么就引入Window的概念，它是个抽象类，对于Activity来说，它的具体实现类是PhoneWindow，在Activity执行attach的时候，会创建一个PhoneWindow对象。PhoneWindow作为装载根视图DecorView的顶级容器，Activity通过setContentView实际上是调用PhoneWindow来创建DecorView，并解析xml布局加载到DecorView的contentView部分。</p>
<p>DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图</p>
<p><img src="/images/android_wms_activity_phonewindow_decorview.png" alt="activity_phonewindow_decorview"></p>
<p><img src="/images/android_wms_activity_phonewindow_decorview01.png" alt="activity_phonewindow_decorview01"></p>
<h2 id="WindowManager、WindowManagerImpl、WindowManagerGlobal"><a href="#WindowManager、WindowManagerImpl、WindowManagerGlobal" class="headerlink" title="WindowManager、WindowManagerImpl、WindowManagerGlobal"></a>WindowManager、WindowManagerImpl、WindowManagerGlobal</h2><p>WindowManager是一个接口类，继承自接口ViewManager，负责窗口的管理(增、删、改)。它的实现类是WindowManagerImpl，而具体操作实际上又会交给WindowManagerGlobal来处理，它是个单例，进程唯一。WindowManagerGlobal执行addView的方法中会传入DecorView, 还会初始化一个ViewRootImpl。WindowManagerGlobal因为是单例的，它内部会有两个List来分别保存这两个对象，来统一管理。</p>
<p><img src="/images/android_wms_wm_wmimpl_wmglobal.png" alt="wms_wm_wmimpl_wmglobal"></p>
<p><img src="/images/android_wms_wm_wmimpl_wmglobal01.png" alt="wms_wm_wmimpl_wmglobal01"></p>
<h2 id="ViewRootImpl与WindowManagerService"><a href="#ViewRootImpl与WindowManagerService" class="headerlink" title="ViewRootImpl与WindowManagerService"></a>ViewRootImpl与WindowManagerService</h2><p>ViewRootImpl是View树的树根并管理View树，触发View的测量、布局和绘制，输入响应的中转站，负责与WMS进行进程间通信。</p>
<p>WindowManagerGlobal负责对DecorView和对应的ViewRootImpl进行统一管理，而具体功能是由ViewRootImpl来处理。<br>以addView为例，具体window是由WMS统一管理的，所以这里会进行binder IPC。<br>IWindowSession: 应用程序通过Session与WMS通信，并且每个应用程序进程都会对应一个Session。<br>IWindow: 作为WMS主动与应用程序通信的client端，因为不同的Window是不同的client，因此它也被作为识别window的key。</p>
<p><img src="/images/android_wms_viewrootimpl_wms.png" alt="wms_viewrootimpl_wms"></p>
<h2 id="Activity与Window关联分析"><a href="#Activity与Window关联分析" class="headerlink" title="Activity与Window关联分析"></a>Activity与Window关联分析</h2><p>Activity与Window联系是非常紧密，很多显示相关操作需要两者密切配合，那么如何保证他们的一致性呢？Android通过token来保证两者的一致性校验：<br>token流向简单归纳如下：<br>1）new ActivityRecord的时候会new一个token与之对应。<br>2）ApplicationThread scheduleLaunchActivity的时候，ActivityClientRecord 接收这个token。<br>3）activity.attach传入该token。<br>4）setWindowManager的时候传入该token,最终由Window的AppToken接收。<br>5）在WindowManagerGlobal的addView方法中，执行adjustLayoutParamsForSubWindow，将WindowManager.LayoutParams wp,wp.token赋值appToken,并在之后的流程中，WindowManager.LayoutParams wp作为参数传入WMS的addWindow方法对应attrs.token。<br>6）WMS中通过WindowToken与之对应。<br>那么其实，Activity的token，Window中的token，连传入addWindow的attrs.token，都是同一个token，都是ActivityRecord构造函数中创建的Token对象。这样做保证了一致性，主要体现在如下两点：<br>将AMS中创建的ActivityRecord和Window挂钩，当前的window明确知道自己是哪一个Activity创建的。<br>Window和AMS有联系，同时又和WMS有关系，appToken则保证了这种同步机制。</p>
<h1 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h1><p>该系统服务是集窗口管理、窗口动画、输入系统中转站、Surface管理等功能于一体的综合管理。</p>
<p><strong>窗口管理</strong><br>是窗口的管理者，它负责窗口的启动、添加和删除。另外窗口的大小和层级也是由 <strong>WMS</strong> 进行管理的。<br><strong>窗口动画</strong><br>窗口间进行切换时，使用动画可以显得更炫一些，窗口动画由 <strong>WMS</strong> 的动画子系统来负责，动画子系统的管理者为 <strong>WindowAnimator</strong>。<br><strong>输入系统中转站</strong><br>通过对窗口的触摸从而产生触摸事件，<strong>InputManagerService(IMS)</strong> 会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，<strong>WMS</strong> 是窗口的管理者，它作为输入系统的中转站再合适不过了。<br><strong>Surface 管理</strong><br>窗口不具备绘制功能，因此每个窗口都需要有一块 <strong>Surface</strong> 来供自己绘制，为每个窗口分配 <strong>Surface</strong> 是由<strong>WMS</strong> 来完成的。</p>
<p><img src="/images/android_wms_wms01.png" alt="wms"></p>
<p>从上图我们了解到 <strong>WMS</strong> 整个是很复杂的，与它关联的有<strong>窗口管理、窗口动画、输入系统中转站和 Surface</strong> 管理, 它们每一个都是重要且复杂的系统，本章就对窗口管理来进行分析，因为它跟我们应用开发关系真的是太紧密了。<br>整个界面就像由N个演员参与的话剧：<br>ViewRootImpl就是各个演员的<strong>长相</strong>和<strong>表情</strong>，取决于它们各自的条件与努力。<br>WMS就是<strong>导演</strong>，它要负责话剧的舞台效果、演员站位；<br>SurfaceFling是<strong>摄像机</strong>，它只负责客观的捕捉当前的画面，然后真实的呈现给观众；<br>可见，WMS与SurfaceFling的一个重要区别就是——后者只做与“显示”相关的事情，而WMS要处理对输入事件的派发。</p>
<h2 id="WMS的重要成员"><a href="#WMS的重要成员" class="headerlink" title="WMS的重要成员"></a>WMS的重要成员</h2><h3 id="1-mPolicy：WindowManagerPolicy"><a href="#1-mPolicy：WindowManagerPolicy" class="headerlink" title="1. mPolicy：WindowManagerPolicy"></a>1. mPolicy：WindowManagerPolicy</h3><p>WindowManagerPolicy（WMP）类型的变量。WindowManagerPolicy是窗口管理策略的接口类，用来定义一个窗口策略所要遵循的通用规范，并提供了WindowManager所有的特定的UI行为。它的具体实现类为PhoneWindowManager，这个实现类在WMS创建时被创建。WMP允许定制窗口层级和特殊窗口类型以及关键的调度和布局。</p>
<h3 id="2-mSessions：ArraySet-lt-Session-gt"><a href="#2-mSessions：ArraySet-lt-Session-gt" class="headerlink" title="2. mSessions：ArraySet&lt;**Session**&gt;"></a>2. mSessions：ArraySet&lt;**Session**&gt;</h3><p>ArraySet类型的变量，元素类型为Session。它主要用于进程间通信，其他的应用程序进程想要和WMS进程进行通信就需要经过Session，并且每个应用程序进程都会对应一个Session，WMS保存这些Session用来记录所有向WMS提出窗口管理服务的客户端。</p>
<h3 id="3-mWindowMap：WindowHashMap"><a href="#3-mWindowMap：WindowHashMap" class="headerlink" title="3. mWindowMap：WindowHashMap"></a>3. mWindowMap：WindowHashMap</h3><p>WindowHashMap类型的变量，WindowHashMap继承了HashMap，它限制了HashMap的key值的类型为IBinder，value值的类型为WindowState。WindowState用于保存窗口的信息，在WMS中它用来描述一个窗口。综上得出结论，mWindowMap就是用来保存WMS中各种窗口的集合。</p>
<h3 id="4-mFinishedStarting：ArrayList-lt-AppWindowToken-gt"><a href="#4-mFinishedStarting：ArrayList-lt-AppWindowToken-gt" class="headerlink" title="4.mFinishedStarting：ArrayList&lt;**AppWindowToken**&gt;"></a>4.mFinishedStarting：ArrayList&lt;**AppWindowToken**&gt;</h3><p>ArrayList类型的变量，元素类型为AppWindowToken，它是WindowToken的子类。要想理解mFinishedStarting的含义，需要先了解WindowToken是什么。<br><strong>WindowToken</strong>：</p>
<ul>
<li>可以理解为窗口令牌，当应用程序想要向WMS申请新创建一个窗口，则需要向WMS出示有效的WindowToken。AppWindowToken作为WindowToken的子类，主要用来描述应用程序的</li>
<li>WindowToken结构，<br>应用程序中每个Activity都对应一个AppWindowToken。<br>WindowToken会将相同组件（比如Acitivity）的窗口（WindowState）集合在一起，方便管理。<br><strong>WindowState</strong>:<br>WindowState表示一个窗口的所有属性，且存在于WMS端，所以它是WMS中事实上的窗口。APP端一个Window，就会在WMS端就会有一个WindowState。</li>
</ul>
<h3 id="5-mResizingWindows：ArrayList-lt-WindowState-gt"><a href="#5-mResizingWindows：ArrayList-lt-WindowState-gt" class="headerlink" title="5.mResizingWindows：ArrayList&lt;**WindowState**&gt;"></a>5.mResizingWindows：ArrayList&lt;**WindowState**&gt;</h3><p>   ArrayList类型的变量，元素类型为WindowState。<br>   mResizingWindows是用来存储正在调整大小的窗口的列表</p>
<h3 id="6-mInputManager：InputManagerService"><a href="#6-mInputManager：InputManagerService" class="headerlink" title="6.mInputManager：InputManagerService"></a>6.mInputManager：InputManagerService</h3><p>InputManagerService类型的变量，输入系统的管理者。InputManagerService（IMS）会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口的管理者，因此，WMS“理所应当”的成为了输入系统的中转站，</p>
<h1 id="WindowManagerService的启动"><a href="#WindowManagerService的启动" class="headerlink" title="WindowManagerService的启动"></a>WindowManagerService的启动</h1><p>WMS的知识点非常多，在了解这些知识点前，我们十分有必要知道WMS是如何产生的。WMS是在SyetemServer进程中启动的。</p>
<p><strong>frameworks/base/services/java/com/android/server/SystemServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法中只调用了SystemServer的run方法，如下所示。<br><strong>frameworks/base/services/java/com/android/server/SystemServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);<span class="comment">//1</span></span><br><span class="line">          ...</span><br><span class="line">          mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);<span class="comment">//2</span></span><br><span class="line">          mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">          LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">          <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">          SystemServerInitThreadPool.get();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          traceBeginAndSlog(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">          startBootstrapServices();<span class="comment">//3</span></span><br><span class="line">          startCoreServices();<span class="comment">//4</span></span><br><span class="line">          startOtherServices();<span class="comment">//5</span></span><br><span class="line">          SystemServerInitThreadPool.shutdown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">          Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          traceEnd();</span><br><span class="line">      &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>run方法代码很多，这里截取了关键的部分，在注释1处加载了libandroid_servers.so。在注释2处创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理。接下来的代码会启动系统的各种服务，在注释3中的startBootstrapServices方法中用SystemServiceManager启动了ActivityManagerService、PowerManagerService、PackageManagerService等服务。在注释4处的方法中则启动了BatteryService、UsageStatsService和WebViewUpdateService。注释5处的startOtherServices方法中则启动了CameraService、AlarmManagerService、VrManagerService等服务，这些服务的父类为SystemService。从注释3、4、5的方法名称可以看出，官方把大概80多个系统服务分为了三种类型，分别是引导服务、核心服务和其他服务，其中其他服务为一些非紧要和一些不需要立即启动的服务，WMS就是其他服务的一种。<br>我们来查看startOtherServices方法是如何启动WMS的：</p>
<p><strong>frameworks/base/services/java/com/android/server/SystemServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;InitWatchdog&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance();<span class="comment">//1</span></span><br><span class="line">            watchdog.init(context, mActivityManagerService);<span class="comment">//2</span></span><br><span class="line">            traceEnd();</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartInputManagerService&quot;</span>);</span><br><span class="line">            inputManager = <span class="keyword">new</span> InputManagerService(context);<span class="comment">//3</span></span><br><span class="line">            traceEnd();</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartWindowManagerService&quot;</span>);</span><br><span class="line">            ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">            mSensorServiceStart = <span class="keyword">null</span>;</span><br><span class="line">            wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">                    mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                    !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager());<span class="comment">//4</span></span><br><span class="line">            ServiceManager.addService(Context.WINDOW_SERVICE, wm);<span class="comment">//5</span></span><br><span class="line">            ServiceManager.addService(Context.INPUT_SERVICE, inputManager);<span class="comment">//6</span></span><br><span class="line">            traceEnd();   </span><br><span class="line">           ... </span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            wm.displayReady();<span class="comment">//7</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;making display ready&quot;</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            wm.systemReady();<span class="comment">//8</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;making Window Manager Service ready&quot;</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">            ...      </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>startOtherServices方法用于启动其他服务，其他服务大概有70多个，上面的代码只列出了WMS以及和它相关的IMS的启动逻辑，剩余的其他服务的启动逻辑也都大同小异。在注释1、2处分别得到Watchdog实例并对它进行初始化，Watchdog用来监控系统的一些关键服务的运行状况，后文会再次提到它。在注释3处创建了IMS，并赋值给IMS类型的inputManager对象。注释4处执行了WMS的main方法，其内部会创建WMS，需要注意的是main方法其中一个传入的参数就是注释1处创建的IMS，WMS是输入事件的中转站，其内部包含了IMS引用并不意外。结合上文，我们可以得知WMS的main方法是运行在SystemServer的run方法中，换句话说就是运行在”system_server”线程”中，后面会再次提到”system_server”线程。注释5和注释6处分别将WMS和IMS注册到ServiceManager中，这样如果某个客户端想要使用WMS，就需要先去ServiceManager中查询信息，然后根据信息与WMS所在的进程建立通信通路，客户端就可以使用WMS了。注释7处用来初始化显示信息，注释8处则用来通知WMS，系统的初始化工作已经完成，其内部调用了WindowManagerPolicy的systemReady方法。我们来查看注释4处WMS的main方法，如下所示。</p>
<p><strong>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">final</span> <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">final</span> <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="keyword">boolean</span> onlyCore,</span></span></span><br><span class="line"><span class="params"><span class="function">           WindowManagerPolicy policy)</span> </span>&#123;</span><br><span class="line">       DisplayThread.getHandler().runWithScissors(() -&gt;<span class="comment">//1</span></span><br><span class="line">               sInstance = <span class="keyword">new</span> WindowManagerService(context, im, haveInputMethods, showBootMsgs,</span><br><span class="line">                       onlyCore, policy), <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> sInstance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处调用了DisplayThread的getHandler方法，用来得到DisplayThread的Handler实例。DisplayThread是一个单例的前台线程，这个线程用来处理需要低延时显示的相关操作，并只能由WindowManager、DisplayManager和InputManager实时执行快速操作。注释1处的runWithScissors方法中使用了Java8中的Lambda表达式，它等价于如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DisplayThread.getHandler().runWithScissors(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         sInstance = <span class="keyword">new</span> WindowManagerService(context, im, haveInputMethods, showBootMsgs,</span><br><span class="line">                    onlyCore, policy);<span class="comment">//2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在注释2处创建了WMS的实例，这个过程运行在Runnable的run方法中，而Runnable则传入到了DisplayThread对应Handler的runWithScissors方法中，说明WMS的创建是运行在“android.display”线程中。需要注意的是，runWithScissors方法的第二个参数传入的是0，后面会提到。来查看Handler的runWithScissors方法里做了什么：<br><strong>frameworks/base/core/java/android/os/Handler.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runWithScissors</span><span class="params">(<span class="keyword">final</span> Runnable r, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;runnable must not be null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout must be non-negative&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (Looper.myLooper() == mLooper) &#123;<span class="comment">//1</span></span><br><span class="line">           r.run();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       BlockingRunnable br = <span class="keyword">new</span> BlockingRunnable(r);</span><br><span class="line">       <span class="keyword">return</span> br.postAndWait(<span class="keyword">this</span>, timeout);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>开头对传入的Runnable和timeout进行了判断，如果Runnable为null或者timeout小于0则抛出异常。注释1处根据每个线程只有一个Looper的原理来判断当前的线程（”system_server”线程）是否是Handler所指向的线程（”android.display”线程），如果是则直接执行Runnable的run方法，如果不是则调用BlockingRunnable的postAndWait方法，并将当前线程的Runnable作为参数传进去 ，BlockingRunnable是Handler的内部类，代码如下所示。<strong>frameworks/base/core/java/android/os/Handler.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mTask;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mDone;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BlockingRunnable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mTask.run();<span class="comment">//1</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mDone = <span class="keyword">true</span>;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postAndWait</span><span class="params">(Handler handler, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!handler.post(<span class="keyword">this</span>)) &#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> expirationTime = SystemClock.uptimeMillis() + timeout;</span><br><span class="line">                    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                        <span class="keyword">long</span> delay = expirationTime - SystemClock.uptimeMillis();</span><br><span class="line">                        <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// timeout</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(delay);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait();<span class="comment">//3</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>注释2处将当前的BlockingRunnable添加到Handler的任务队列中。前面runWithScissors方法的第二个参数为0，因此timeout等于0，这样如果mDone为false的话会一直调用注释3处的wait方法使得当前线程（”system_server”线程）进入等待状态，那么等待的是哪个线程呢？我们往上看，注释1处，执行了传入的Runnable的run方法（运行在”android.display”线程），执行完毕后在finally代码块中将mDone设置为true，并调用notifyAll方法唤醒处于等待状态的线程，这样就不会继续调用注释3处的wait方法。因此得出结论，”system_server”线程线程等待的就是”android.display”线程，一直到”android.display”线程执行完毕再执行”system_server”线程，这是因为”android.display”线程内部执行了WMS的创建，显然WMS的创建优先级更高些。WMS的创建就讲到这，最后我们来查看WMS的构造方法：<br><strong>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WindowManagerService</span><span class="params">(Context context, InputManagerService inputManager,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       mInputManager = inputManager;<span class="comment">//1</span></span><br><span class="line">       ...</span><br><span class="line">        mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line">        mDisplays = mDisplayManager.getDisplays();<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">for</span> (Display display : mDisplays) &#123;</span><br><span class="line">            createDisplayContentLocked(display);<span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">        mActivityManager = ActivityManagerNative.getDefault();<span class="comment">//4</span></span><br><span class="line">       ...</span><br><span class="line">        mAnimator = <span class="keyword">new</span> WindowAnimator(<span class="keyword">this</span>);<span class="comment">//5</span></span><br><span class="line">        mAllowTheaterModeWakeFromLayout = context.getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_allowTheaterModeWakeFromWindowLayout);</span><br><span class="line">        LocalServices.addService(WindowManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">        initPolicy();<span class="comment">//6</span></span><br><span class="line">        <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">        Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);<span class="comment">//7</span></span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注释1处用来保存传进来的IMS，这样WMS就持有了IMS的引用。注释2处通过DisplayManager的getDisplays方法得到Display数组（每个显示设备都有一个Display实例），接着遍历Display数组，在注释3处的createDisplayContentLocked方法会将Display封装成DisplayContent，DisplayContent用来描述一快屏幕。注释4处得到AMS实例，并赋值给mActivityManager ，这样WMS就持有了AMS的引用。注释5处创建了WindowAnimator，它用于管理所有的窗口动画。注释6处初始化了窗口管理策略的接口类WindowManagerPolicy（WMP），它用来定义一个窗口策略所要遵循的通用规范。注释7处将自身也就是WMS通过addMonitor方法添加到Watchdog中，Watchdog用来监控系统的一些关键服务的运行状况（比如传入的WMS的运行状况），这些被监控的服务都会实现Watchdog.Monitor接口。Watchdog每分钟都会对被监控的系统服务进行检查，如果被监控的系统服务出现了死锁，则会杀死Watchdog所在的进程，也就是SystemServer进程。</p>
<p>查看注释6处的initPolicy方法，如下所示。<strong>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     UiThread.getHandler().runWithScissors(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line">             mPolicy.init(mContext, WindowManagerService.<span class="keyword">this</span>, WindowManagerService.<span class="keyword">this</span>);<span class="comment">//1</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>initPolicy方法和此前讲的WMS的main方法的实现类似，注释1处执行了WMP的init方法，WMP是一个接口，init方法的具体实现在PhoneWindowManager（PWM）中。PWM的init方法运行在”android.ui”线程中，它的优先级要高于initPolicy方法所在的”android.display”线程，因此”android.display”线程要等PWM的init方法执行完毕后，处于等待状态的”android.display”线程才会被唤醒从而继续执行下面的代码。<br>在本文中共提到了3个线程，分别是”system_server”、”android.display”和”android.ui”，为了便于理解，下面给出这三个线程之间的关系。</p>
<p><img src="/images/android_wms_service_start.png" alt="wms_service_start"></p>
<p>“system_server”线程中会调用WMS的main方法，main方法中会创建WMS，创建WMS的过程运行在”android.display”线程中，它的优先级更高一些，因此要等创建WMS完毕后才会唤醒处于等待状态的”system_server”线程。<br>WMS初始化时会执行initPolicy方法，initPolicy方法会调用PWM的init方法，这个init方法运行在”android.ui”线程，并且优先级更高，因此要先执行完PWM的init方法后，才会唤醒处于等待状态的”android.display”线程。<br>PWM的init方法执行完毕后会接着执行运行在”system_server”线程的代码，比如本文前部分提到WMS的<br>systemReady方法。</p>
<h1 id="Window的添加与删除"><a href="#Window的添加与删除" class="headerlink" title="Window的添加与删除"></a>Window的添加与删除</h1><h2 id="Window的添加"><a href="#Window的添加" class="headerlink" title="Window的添加"></a>Window的添加</h2><p>WMS#addWindow方法返回的是addWindow的各种状态，比如添加Window成功，无效的Display等，这些状态被定义在WindowManagerGlobal中。在方法里面主要做了四个事情，如果所示：<br><img src="/images/android_wms_window_add.png" alt="wms_window_add"></p>
<h3 id="窗口检查"><a href="#窗口检查" class="headerlink" title="窗口检查"></a>窗口检查</h3><p>对参数进行进行检查是非常有必要的第一个步骤，大部分函数中都是这样做的，这个很好理解，毕竟如果传入的参数都是错的，后面做过多的内容都是无用功。<br>WMS#addWindow对窗口参数主要做了哪些检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,</span><br><span class="line">          appOp);</span><br></pre></td></tr></table></figure>

<p>mPolicy是窗口管理策略的接口，实现类是PhoneWindowManager。在PhoneWindowManager中对窗口的type合法性做了检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!((type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW)</span><br><span class="line">                || (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW)</span><br><span class="line">                || (type &gt;= FIRST_SYSTEM_WINDOW &amp;&amp; type &lt;= LAST_SYSTEM_WINDOW))) &#123;</span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的话通过DisplayId来获取窗口要添加到哪个DisplayContentshang，如果没有找到DisplayContent， 则返回错误状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);</span><br></pre></td></tr></table></figure>
<p>如果窗口是子窗口类型，然后是对父窗口的信息做一些检查，如果为空或者父窗口也是子窗口类型则检查不通过，返回错误类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">    			<span class="comment">//通过token获取获取父窗口的信息</span></span><br><span class="line">                parentWindow = windowForClientLocked(<span class="keyword">null</span>, attrs.token, <span class="keyword">false</span>);</span><br><span class="line">    			<span class="comment">//如果父窗口为空输入返回信息</span></span><br><span class="line">                <span class="keyword">if</span> (parentWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ProtoLog.w(WM_ERROR, <span class="string">&quot;Attempted to add window with token that is not a window: &quot;</span></span><br><span class="line">                            + <span class="string">&quot;%s.  Aborting.&quot;</span>, attrs.token);</span><br><span class="line">                    <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">                &#125;</span><br><span class="line">    			<span class="comment">//如果父窗口也是子窗口类型</span></span><br><span class="line">                <span class="keyword">if</span> (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW</span><br><span class="line">                        &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">                    ProtoLog.w(WM_ERROR, <span class="string">&quot;Attempted to add window with token that is a sub-window: &quot;</span></span><br><span class="line">                            + <span class="string">&quot;%s.  Aborting.&quot;</span>, attrs.token);</span><br><span class="line">                    <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">                &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="WindowToken相关处理"><a href="#WindowToken相关处理" class="headerlink" title="WindowToken相关处理"></a>WindowToken相关处理</h3><p>在WindowToken相关处理这部分内容中，我们先通过DisplayContent尝试获取WindowToken，token为空且有父窗口，则用父窗口的token，token为空没有父窗口自己新建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过DisplayContent获取到WindowToken</span></span><br><span class="line">WindowToken token = displayContent.getWindowToken(</span><br><span class="line">                    hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">            <span class="comment">// If this is a child window, we want to apply the same type checking rules as the</span></span><br><span class="line">            <span class="comment">// parent window type.</span></span><br><span class="line">			..........</span><br><span class="line">            <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">                .........</span><br><span class="line">                <span class="keyword">if</span> (hasParent) &#123;</span><br><span class="line">                    <span class="comment">// Use existing parent window token for child windows.</span></span><br><span class="line">                    <span class="comment">//有父窗口的用父窗口的Token</span></span><br><span class="line">                    token = parentWindow.mToken;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//没有父窗口自己新建一个WindowToken，WindowToken翻译过来是令牌，用于标识一组窗口。</span></span><br><span class="line">                    <span class="keyword">final</span> IBinder binder = attrs.token != <span class="keyword">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">                    token = <span class="keyword">new</span> WindowToken(<span class="keyword">this</span>, binder, type, <span class="keyword">false</span>, displayContent,</span><br><span class="line">                            session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="WindowState的创建和处理"><a href="#WindowState的创建和处理" class="headerlink" title="WindowState的创建和处理"></a>WindowState的创建和处理</h3><p>WindowState是WMS端的事实窗口，通过new的方式新建好一个WindowState之后就进行了相关的判断，比如请求添加窗口的客户端是否死亡、窗口的DisplayContent是否失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">final</span> WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token, parentWindow,</span><br><span class="line">                    appOp[<span class="number">0</span>], seq, attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                    session.mCanAddInternalSystemWindow);</span><br><span class="line"><span class="comment">//窗口是否死亡</span></span><br><span class="line"><span class="keyword">if</span> (win.mDeathRecipient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ProtoLog.w(WM_ERROR, <span class="string">&quot;Adding window client %s&quot;</span></span><br><span class="line">                        + <span class="string">&quot; that is dead, aborting.&quot;</span>, client.asBinder());</span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DisplayContent是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (win.getDisplayContent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ProtoLog.w(WM_ERROR, <span class="string">&quot;Adding window to Display that has been removed.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line"><span class="comment">//调用WMP的方法，此方法会根据窗口的Type对LayoutParams的一些成员进行修改</span></span><br><span class="line">displayPolicy.adjustWindowParamsLw(win, win.mAttrs, callingPid, callingUid);</span><br><span class="line">.......</span><br><span class="line"><span class="comment">// 将窗口添加到系统中</span></span><br><span class="line">res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</span><br><span class="line">.......</span><br><span class="line"><span class="comment">// windowState保存到Map中</span></span><br><span class="line">mWindowMap.put(client.asBinder(), win);</span><br><span class="line">.......</span><br><span class="line"><span class="comment">// 绑定Token和WindowState关系</span></span><br><span class="line">win.mToken.addWindow(win);</span><br></pre></td></tr></table></figure>

<h3 id="Display的创建和配置"><a href="#Display的创建和配置" class="headerlink" title="Display的创建和配置"></a>Display的创建和配置</h3><p>创建和配置DisplayContent，完成窗口添加到系统前的准备工作。</p>
<h2 id="Window的删除"><a href="#Window的删除" class="headerlink" title="Window的删除"></a>Window的删除</h2><p>Window的删除过程，本文中从WindowManagerImpl开始讲起，主要做了四个事情如图右所示。<br><img src="/images/android_wms_window_remove.png" alt="wms_window_remove"></p>
<h3 id="检查线程的正确性"><a href="#检查线程的正确性" class="headerlink" title="检查线程的正确性"></a>检查线程的正确性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                    <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewRootImpl相关数据删除"><a href="#ViewRootImpl相关数据删除" class="headerlink" title="ViewRootImpl相关数据删除"></a>ViewRootImpl相关数据删除</h3><p>在WindowManagerGlobal方法中，会删除相关的一些数据，如ViewRootImpl、LayoutParams、DecorView，并将DecorView加入到死亡列表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRemoveView</span><span class="params">(ViewRootImpl root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">//从ViewRootImpl获取到索引值</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = mRoots.indexOf(root);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//删除ViewRootImpl列表中的数据</span></span><br><span class="line">                mRoots.remove(index);</span><br><span class="line">                <span class="comment">//删除LayoutParams列表中的数据</span></span><br><span class="line">                mParams.remove(index);</span><br><span class="line">                <span class="comment">//删除DecorView列表中的数据</span></span><br><span class="line">                <span class="keyword">final</span> View view = mViews.remove(index);</span><br><span class="line">                <span class="comment">//DecorView加入到死亡列表</span></span><br><span class="line">                mDyingViews.remove(view);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否立即执行删除"><a href="#判断是否立即执行删除" class="headerlink" title="判断是否立即执行删除"></a>判断是否立即执行删除</h3><p>这ViewRootImpl中die方法中，会先判断是否立即执行删除，如果被判处死刑且立即执行则调用doDie方法，如果不是则通过Handler方法执行死刑的信号，判个缓刑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span></span><br><span class="line">      <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span></span><br><span class="line"><span class="comment">//immediate 是否立即执行 为ture则立即执行</span></span><br><span class="line">      <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">          doDie();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">......</span><br><span class="line">   </span><br><span class="line">    	<span class="comment">//通过Handler发送死亡信息，判处死缓</span></span><br><span class="line">      mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//检查线程</span></span><br><span class="line">        checkThread();</span><br><span class="line">        <span class="keyword">if</span> (LOCAL_LOGV) Log.v(mTag, <span class="string">&quot;DIE in &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; of &quot;</span> + mSurface);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否删除</span></span><br><span class="line">            <span class="keyword">if</span> (mRemoved) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止重复调用</span></span><br><span class="line">            mRemoved = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (mAdded) &#123;</span><br><span class="line">                <span class="comment">//做数据清除 注销操作，调用session的remove方法</span></span><br><span class="line">                dispatchDetachedFromWindow();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123;</span><br><span class="line">                destroyHardwareRenderer();</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> viewVisibility = mView.getVisibility();</span><br><span class="line">                    <span class="keyword">boolean</span> viewVisibilityChanged = mViewVisibility != viewVisibility;</span><br><span class="line">                    <span class="keyword">if</span> (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                        <span class="comment">// If layout params have been changed, first give them</span></span><br><span class="line">                        <span class="comment">// to the window manager to make sure it has the correct</span></span><br><span class="line">                        <span class="comment">// animation info.</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((relayoutWindow(mWindowAttributes, viewVisibility, <span class="keyword">false</span>)</span><br><span class="line">                                    &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;</span><br><span class="line">                                mWindowSession.finishDrawing(</span><br><span class="line">                                        mWindow, <span class="keyword">null</span> <span class="comment">/* postDrawTransaction */</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">    				<span class="comment">//销毁画布</span></span><br><span class="line">                    destroySurface();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            mAdded = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用WindowManagerGlobal移除方法</span></span><br><span class="line">        WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在ViewRootImpl的dispatchDetachedFromWindow方法中会调用Session与WMS进行通信，然后执行移除的操作。<br>在WMS的removeWindow函数中，先会通过Session和Client获取到当前窗口在WMS的副本也就是WindowState，如果不为空则执行删除操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeWindow</span><span class="params">(Session session, IWindow client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">           	<span class="comment">//获取WindowState</span></span><br><span class="line">            WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (win != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//执行删除</span></span><br><span class="line">                win.removeIfPossible();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove embedded window map if the token belongs to an embedded window</span></span><br><span class="line">            mEmbeddedWindowController.remove(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>win.removeIfPossible方法和它的名字一样，并不是直接执行删除操作，而是进行多个条件判断过滤，满足其中一个条件就会return，推迟删除操作。比如V正在运行一个动画，这是就会推迟删除操作知道动画完成。然后调用removeImmediately方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeImmediately</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.removeImmediately();</span><br><span class="line">        <span class="comment">//已经删除</span></span><br><span class="line">        <span class="keyword">if</span> (mRemoved) &#123;</span><br><span class="line">            <span class="comment">// Nothing to do.</span></span><br><span class="line">            ProtoLog.v(WM_DEBUG_ADD_REMOVE,</span><br><span class="line">                    <span class="string">&quot;WS.removeImmediately: %s Already removed...&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除标记</span></span><br><span class="line">        mRemoved = <span class="keyword">true</span>;</span><br><span class="line">        ......</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> DisplayContent dc = getDisplayContent();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//policy做移除操作</span></span><br><span class="line">        dc.getDisplayPolicy().removeWindowLw(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//关闭输入事件渠道</span></span><br><span class="line">        disposeInputChannel();</span><br><span class="line">        </span><br><span class="line">        mWinAnimator.destroyDeferredSurfaceLocked();</span><br><span class="line">        mWinAnimator.destroySurfaceLocked();</span><br><span class="line">        <span class="comment">//Session集合冲移除WindowState</span></span><br><span class="line">        mSession.windowRemovedLocked();</span><br><span class="line">        .....</span><br><span class="line">      	<span class="comment">//集中处理清除工作</span></span><br><span class="line">        mWmService.postWindowRemoveCleanupLocked(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="输入事件处理"><a href="#输入事件处理" class="headerlink" title="输入事件处理"></a>输入事件处理</h1><h2 id="安卓输入事件整体流程"><a href="#安卓输入事件整体流程" class="headerlink" title="安卓输入事件整体流程"></a>安卓输入事件整体流程</h2><p>Android 系统是由事件驱动的，而 input 是最常见的事件之一，用户的点击、滑动、长按等操作，都属于 input 事件驱动，其中的核心就是 InputReader 和 InputDispatcher。<br>InputReader 和 InputDispatcher 是跑在 SystemServer进程中的两个 native 循环线程，负责读取和分发 Input 事件。整个处理过程大致流程如下：<br><img src="/images/android_wms_input_event01.png" alt="wms_input_event"></p>
<h2 id="InputManagerService"><a href="#InputManagerService" class="headerlink" title="InputManagerService"></a>InputManagerService</h2><p>在SystemServer的startOtherServices函数中，会新建一个InputManagerService对象，然后会作为参数传入到WMS中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">......</span><br><span class="line">wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">                    <span class="keyword">new</span> PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);</span><br></pre></td></tr></table></figure>

<h2 id="WindowInputEventReceiver输入事件监听"><a href="#WindowInputEventReceiver输入事件监听" class="headerlink" title="WindowInputEventReceiver输入事件监听"></a>WindowInputEventReceiver输入事件监听</h2><p>在ViewRootImpl的setView函数中，会先建立一个InputChannel对象。inputChannel是输入事件的信道，它ViewRootImpl和InputManagerService的沟通桥梁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputChannel inputChannel = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                       &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">     inputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inputChannel会通过mWindowSession.addToDisplayAsUser方法传入到WMS侧，并且与当前新建窗口WindowState建立起关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if  (openInputChannels) &#123;</span><br><span class="line">	//WindowState与InputChannel关联上了</span><br><span class="line">    win.openInputChannel(outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后代码运行到ViewRootImpl侧，这个时候就开始生成监听对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                        mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                    &#125;</span><br><span class="line">   					<span class="comment">// 输入事件的监听对象</span></span><br><span class="line">                    mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(inputChannel,</span><br><span class="line">                            Looper.myLooper());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EventHub设备事件监听"><a href="#EventHub设备事件监听" class="headerlink" title="EventHub设备事件监听"></a>EventHub设备事件监听</h2><p>它主要是利用Linux的inotify和epoll机制，监听设备事件：包括设备插拔及各种触摸、按钮事件等，可以看做是一个不同设备的集线器，主要面向的是/dev/input目录下的设备节点，比如说/dev/input/event0上的事件就是输入事件：<br><img src="/images/android_wms_input_event_hub.webp" alt="wms_input_event_hub"></p>
<h2 id="InputReader读取事件"><a href="#InputReader读取事件" class="headerlink" title="InputReader读取事件"></a>InputReader读取事件</h2><p>InputReader主要是负责不断的从EventHub读取事件，通知派发给InputDispatcher。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="keyword">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="keyword">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    &#123; </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 读取EventHub中的事件</span></span><br><span class="line">    <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// 通知派发给InputDispatcher</span></span><br><span class="line">   mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InputDispatcher读取事件"><a href="#InputDispatcher读取事件" class="headerlink" title="InputDispatcher读取事件"></a>InputDispatcher读取事件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 被唤醒 ，处理Input消息</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">       .....</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    <span class="comment">//睡眠等到事件</span></span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是派发线程的模型，dispatchOnceInnerLocked是具体的派发处理逻辑，这里看其中一个分支，触摸事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnceInnerLocked</span><span class="params">(<span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        ...</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::dispatchMotionLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    ...     </span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">bool</span> conflictingPointerActions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">    &lt;!--关键点<span class="number">1</span> 找到目标Window--&gt;</span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;!--关键点<span class="number">2</span>  派发--&gt;</span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，对于触摸事件会首先通过findTouchedWindowTargetsLocked找到目标Window，进而通过dispatchEventLocked将消息发送到目标窗口，下面看一下如何找到目标窗口，以及这个窗口列表是如何维护的。</p>
<h2 id="寻找目标窗口"><a href="#寻找目标窗口" class="headerlink" title="寻找目标窗口"></a>寻找目标窗口</h2><p>Android系统能够同时支持多块屏幕，每块屏幕被抽象成一个DisplayContent对象，内部维护一个WindowList列表对象，用来记录当前屏幕中的所有窗口，包括状态栏、导航栏、应用窗口、子窗口等。对于触摸事件，我们比较关心可见窗口<br>那么，如何找到触摸事件对应的窗口呢，是状态栏、导航栏还是应用窗口呢，这个时候DisplayContent的WindowList就发挥作用了，DisplayContent握着所有窗口的信息，因此，可以<strong>根据触摸事件的位置及窗口的属性来确定将事件发送到哪个窗口</strong>，当然其中的细节比一句话复杂的多，跟窗口的状态、透明、分屏等信息都有关系，下面简单瞅一眼，达到主观理解的流程就可以了，然后会调用到InputDispatcher#findTouchedWindowAtLocked</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历所有窗口 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle : windowHandles) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputWindowInfo* windowInfo = windowHandle-&gt;getInfo();</span><br><span class="line">        <span class="keyword">if</span> (windowInfo-&gt;displayId == displayId) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> flags = windowInfo-&gt;layoutParamsFlags;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (windowInfo-&gt;visible) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; InputWindowInfo::FLAG_NOT_TOUCHABLE)) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> isTouchModal = (flags &amp;</span><br><span class="line">                                         (InputWindowInfo::FLAG_NOT_FOCUSABLE |</span><br><span class="line">                                          InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isTouchModal || windowInfo-&gt;touchableRegionContainsPoint(x, y)) &#123;</span><br><span class="line">                        <span class="keyword">int32_t</span> portalToDisplayId = windowInfo-&gt;portalToDisplayId;</span><br><span class="line">                        ......</span><br><span class="line">                        <span class="comment">// Found window. 找到目标窗口</span></span><br><span class="line">                        <span class="keyword">return</span> windowHandle;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>mWindowHandles代表着所有窗口，找到了目标窗口，同时也将事件封装好了，剩下的就是通知目标窗口，可是有个最明显的问题就是，目前所有的逻辑都是在SystemServer进程，而要通知的窗口位于APP端的用户进程，那么如何通知呢？这里面采用的都是Socket的通信方式。</p>
<h1 id="Surface的创建与操作"><a href="#Surface的创建与操作" class="headerlink" title="Surface的创建与操作"></a>Surface的创建与操作</h1><h2 id="Surface的创建"><a href="#Surface的创建" class="headerlink" title="Surface的创建"></a>Surface的创建</h2><p>在Android系统中每个Activity都有一个独立的画布（在应用侧称为Surface,在SurfaceFlinger侧称为Layer）， 无论这个Activity安排了多么复杂的view结构，它们最终都是被画在了所属Activity的这块画布上。</p>
<h3 id="Surface在应用端的新建"><a href="#Surface在应用端的新建" class="headerlink" title="Surface在应用端的新建"></a>Surface在应用端的新建</h3><p>在 ViewRootImpl 创建时同时会 new 一个 Surface 对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_wms_surfacce_add.png" alt="wms_surfacce_add"><br>Surface其实是广义上的画布，真正意义上的画图是Canvas，也就是在View的onDraw方法里面的Canvas。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Canvas mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewRootImpl直接新建的Surface并没有直接大小</p>
<h3 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a>SurfaceControl</h3><p>SurfaceControl是创建Surface的辅助管理类，它在ViewRootImpl创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SurfaceControl mSurfaceControl = <span class="keyword">new</span> SurfaceControl();</span><br></pre></td></tr></table></figure>

<p>在setView的时候会调用relayoutWindow函数，由mWindowSession将内容传递给WMS端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">          <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(mWindow, mSeq, params,</span><br><span class="line">              (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">              (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>), viewVisibility,</span><br><span class="line">              insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>, frameNumber,</span><br><span class="line">              mTmpFrame, mTmpRect, mTmpRect, mTmpRect, mPendingBackDropFrame,</span><br><span class="line">              mPendingDisplayCutout, mPendingMergedConfiguration, mSurfaceControl, mTempInsets,</span><br><span class="line">              mTempControls, mSurfaceSize, mBlastSurfaceControl);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着代码的执行让我们把视角切换到system_server进程（WMS的relayoutWindow函数）,这里会调用createSurfaceControl去创建一个SurfaceControl：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq, LayoutParams attrs,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">long</span> frameNumber, Rect outFrame, Rect outContentInsets,</span></span></span><br><span class="line"><span class="params"><span class="function">           Rect outVisibleInsets, Rect outStableInsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="params"><span class="function">           DisplayCutout.ParcelableWrapper outCutout, MergedConfiguration mergedConfiguration,</span></span></span><br><span class="line"><span class="params"><span class="function">           SurfaceControl outSurfaceControl, InsetsState outInsetsState,</span></span></span><br><span class="line"><span class="params"><span class="function">           InsetsSourceControl[] outActiveControls, Point outSurfaceSize,</span></span></span><br><span class="line"><span class="params"><span class="function">           SurfaceControl outBLASTSurfaceControl)</span> </span>&#123;</span><br><span class="line">    	......</span><br><span class="line">	result = createSurfaceControl(outSurfaceControl, outBLASTSurfaceControl, result, win, winAnimator);</span><br><span class="line">    	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceControl的创建过程，注意这里创建工作是调用winAnimator来完成的，注意下面那句surfaceController.getSurfaceControl会把创建出来的SurfaceControl通过形参outSurfaceControl传出去：</p>
<p>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(SurfaceControl outSurfaceControl,</span></span></span><br><span class="line"><span class="params"><span class="function">            SurfaceControl outBLASTSurfaceControl, <span class="keyword">int</span> result,</span></span></span><br><span class="line"><span class="params"><span class="function">            WindowState win, WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    WindowSurfaceController surfaceController;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;createSurfaceControl&quot;</span>);</span><br><span class="line">        surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurfaceControl(outSurfaceControl);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看下创建过程，创建了一个WindowSurfaceController，进而再创建SurfaceControll:<br>frameworks/base/services/core/java/com/android/server/wm/WindowStateAnimator.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">(<span class="keyword">int</span> windowType, <span class="keyword">int</span> ownerUid)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/*WindowSurfaceController mSurfaceController;*/</span></span><br><span class="line">    mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(attrs.getTitle().toString(), width,</span><br><span class="line">                    height, format, flags, <span class="keyword">this</span>, windowType, ownerUid);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowSurfaceController.java (frameworks\base\services\core\java\com\android\server\wm)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WindowSurfaceController(String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format,</span><br><span class="line">            <span class="keyword">int</span> flags, WindowStateAnimator animator, <span class="keyword">int</span> windowType, <span class="keyword">int</span> ownerUid) &#123;</span><br><span class="line">     ......</span><br><span class="line">     <span class="keyword">final</span> SurfaceControl.Builder b = win.makeSurface()</span><br><span class="line">                .setParent(win.getSurfaceControl())</span><br><span class="line">                .setName(name)</span><br><span class="line">                .setBufferSize(w, h)</span><br><span class="line">                .setFormat(format)</span><br><span class="line">                .setFlags(flags)</span><br><span class="line">                .setMetadata(METADATA_WINDOW_TYPE, windowType)</span><br><span class="line">                .setMetadata(METADATA_OWNER_UID, ownerUid)</span><br><span class="line">                .setCallsite(<span class="string">&quot;WindowSurfaceController&quot;</span>);</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在WMS端SurfaceControl以形参outSurfaceControl传出，然后在ViewRootImpl侧，通过Surface的copyFrom方法，将内容写入到mSurface，此时surface正式新建完毕。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceControl.isValid()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!useBLAST()) &#123;</span><br><span class="line">                    mSurface.copyFrom(mSurfaceControl);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图层Layer创建"><a href="#图层Layer创建" class="headerlink" title="图层Layer创建"></a>图层Layer创建</h3><p><img src="/images/android_wms_surface_add_layer_create.png" alt="wms_surface_add_layer_create"><br><strong>具体流程如下：</strong><br>在SurfaceControl的构造方法中通过JNI去创建C端对象</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SurfaceControl</span>(<span class="params">SurfaceSession session, String name, <span class="built_in">int</span> w, <span class="built_in">int</span> h, <span class="built_in">int</span> format, <span class="built_in">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">            SurfaceControl parent, SparseIntArray metadata, WeakReference&lt;View&gt; localOwnerView,</span></span></span><br><span class="line"><span class="params"><span class="function">            String callsite</span>)</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags,</span><br><span class="line">                    parent != <span class="literal">null</span> ? parent.mNativeObject : <span class="number">0</span>, metaParcel);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>android_view_SurfaceControl.cpp (frameworks\base\core\jni)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject metadataParcel)</span> </span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;<span class="comment">//Surface名字， 在SurfaceFlinger侧就是Layer的名字</span></span><br><span class="line">    ......</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">status_t</span> err = client-&gt;<span class="built_in">createSurfaceChecked</span>(</span><br><span class="line">            <span class="built_in">String8</span>(name.<span class="built_in">c_str</span>()), w, h, format, &amp;surface, flags, parent, std::<span class="built_in">move</span>(metadata));</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C层的Surface在创建时去调用SurfaceComposerClient的createSurface去创建, 这个SurfaceComposerClient可以看作是SurfaceFlinger在Client端的代表</p>
<p>android_view_SurfaceControl.cpp (frameworks\base\core\jni）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceComposerClient::createSurfaceChecked</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     sp&lt;SurfaceControl&gt;* outSurface, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     SurfaceControl* parent, LayerMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="keyword">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      err = mClient-&gt;<span class="built_in">createSurface</span>(name, w, h, format, flags, parentHandle, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                     &amp;handle, &amp;gbp, &amp;transformHint);</span><br><span class="line">      ......</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>SurfaceComposerClient.cpp (frameworks\native\libs\gui)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">SurfaceComposerClient::createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        SurfaceControl* parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        LayerMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        <span class="keyword">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; s;</span><br><span class="line">    <span class="built_in">createSurfaceChecked</span>(name, w, h, format, &amp;s, flags, parent, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                         outTransformHint);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceComposerClient::createSurfaceChecked</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     sp&lt;SurfaceControl&gt;* outSurface, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     SurfaceControl* parent, LayerMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="keyword">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">      .......</span><br><span class="line">      err = mClient-&gt;<span class="built_in">createSurface</span>(name, w, h, format, flags, parentHandle, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                     &amp;handle, &amp;gbp, &amp;transformHint);</span><br><span class="line">      .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跨进程呼叫SurfaceFlinger：</p>
<p>ISurfaceComposerClient.cpp (frameworks\native\libs\gui)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height, PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; parent, LayerMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                           sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">uint32_t</span>* outTransformHint)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> callRemote&lt;<span class="keyword">decltype</span>(&amp;ISurfaceComposerClient::createSurface)&gt;(Tag::CREATE_SURFACE,</span><br><span class="line">                               name, width, height,</span><br><span class="line">                               format, flags, parent,</span><br><span class="line">                               std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                               handle, gbp,</span><br><span class="line">                               outTransformHint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后流程就来到了SurfaceFlinger进程，由于SurfaceFlinger支持很多不同类型的Layer, 这里我们只以BufferQueueLayer为例， 当SurfaceFlinger收到这个远程调用后会new 一个BufferQueueLayer出来。</p>
<p>SurfaceFlinger.cpp (frameworks\native\services\surfaceflinger)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">tatus_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">const</span> sp&lt;Client&gt;&amp; client, <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; parentHandle, <span class="keyword">const</span> sp&lt;Layer&gt;&amp; parentLayer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">            result = <span class="built_in">createBufferQueueLayer</span>(client, std::<span class="built_in">move</span>(uniqueName), w, h, flags,</span><br><span class="line">                                            std::<span class="built_in">move</span>(metadata), format, handle, gbp, &amp;layer);</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Surface的操作"><a href="#Surface的操作" class="headerlink" title="Surface的操作"></a>Surface的操作</h2><h3 id="Surface操作简介"><a href="#Surface操作简介" class="headerlink" title="Surface操作简介"></a>Surface操作简介</h3><p>Surface对象后怎么就能拿到帧缓冲区的操作接口呢？我们来看Surface的实现：<br>Surface.java (frameworks\base\core\java\android\view)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeLockCanvas</span><span class="params">(<span class="keyword">long</span> nativeObject, Canvas canvas, Rect dirty)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> OutOfResourcesException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(<span class="keyword">long</span> nativeObject, Canvas canvas)</span></span>;</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeLockCanvas这个方法对应的是出队dequeueBuffer，从队列中取到Buffer也就是画布；<br>nativeUnlockCanvasAndPost这个方法对应的是入队queueBuffer，将buffer提交到队列中去；</p>
<h3 id="对画布操作"><a href="#对画布操作" class="headerlink" title="对画布操作"></a>对画布操作</h3><p>当我们接收到同步信号的时候会调用ViewRootImpl的performTraversals，最后会调用到drawSoftware，在这个函数中会拿到画布然后分发draw事件，之后的内容就是WMS第一堂课中10.1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//拿到画布</span></span><br><span class="line"> canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//mView是DecorView向下分发事件</span></span><br><span class="line">    mView.draw(canvas);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在View的onDraw方法中，会将界面信息转化为RenderNode，类似于Html的Element。<br>View.java (frameworks\base\core\java\android\view)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">     <span class="keyword">final</span> RecordingCanvas canvas = renderNode.beginRecording(width, height);<span class="comment">//这里开始displaylist的record</span></span><br><span class="line">     ......</span><br><span class="line">     draw(canvas);</span><br><span class="line">     ......</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的RecordingCanvas就是扮演一个绘图指令的记录员角色，它会将这个View通过draw函数绘制的指令以displaylist形式记录下来。<br>在Android的设计里View会对应一个RenderNode, RenderNode里的一个重要数据结构是DisplayList, 每个DisplayList都会包含一系列DisplayListData.  这些DisplayList也会同样以树形结构组织在一起。<br>当UI线程完成它的绘制工作后，它工作的产物是一堆DisplayListData, 我们可以将其理解为是一堆绘图指令的集合，每一个DisplayListData都是在描绘这个View长什么样子，所以一个View树也可能理解为它的样子由对应的DisplayListData构成的树来描述：<br><img src="/images/android_wms_surface_handle.webp" alt="wms_surface_handle"><br>我们再来看下DisplayListData是长什么样子，它定义在下面这个文件中：<br>RecordingCanvas.h (frameworks\base\libs\hwui)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayListData</span> <span class="keyword">final</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPath</span><span class="params">(<span class="keyword">const</span> SkPath&amp;, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(<span class="keyword">const</span> SkRect&amp;, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawRegion</span><span class="params">(<span class="keyword">const</span> SkRegion&amp;, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawOval</span><span class="params">(<span class="keyword">const</span> SkRect&amp;, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawArc</span><span class="params">(<span class="keyword">const</span> SkRect&amp;, SkScalar, SkScalar, <span class="keyword">bool</span>, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">push</span><span class="params">(<span class="keyword">size_t</span>, Args&amp;&amp;...)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    SkAutoTMalloc&lt;<span class="keyword">uint8_t</span>&gt; fBytes;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的组成大体可以看成三个部分，第一部分是一堆以draw打头的函数，它们是最基本的绘图指令，比如画一条线， 画一个矩形，画一段圆弧等等，上面我们摘取了其中几个,后面我们将以drawRect为例来看它是如何工作的； 第二部分是一个push模版函数，后面我们会看到它的作用； 第三个是一块存储区fBytes，它会根据需要放大存储区的大小。<br>通过上面的了解，我们知道了UI线程并没有将应用设计的View转换成像素点数据，而是将每个View的绘图指令存入了内存中，我们通常称这些绘图指令为DisplayList, 下面让我们跳出这些细节，再次回到宏观一些的角度。</p>
<h3 id="提交画布内容"><a href="#提交画布内容" class="headerlink" title="提交画布内容"></a>提交画布内容</h3><p>当所有的View的displaylist建立完成后，代码会来到：<br>RenderProxy.cpp (frameworks\base\libs\hwui\renderthread)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenderProxy::syncAndDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.<span class="built_in">drawFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DrawFrameTask.cpp (frameworks\base\libs\hwui\renderthread)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::postAndWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>().<span class="built_in">post</span>([<span class="keyword">this</span>]() &#123; <span class="built_in">run</span>(); &#125;);<span class="comment">//丢任务到RenderThread线程</span></span><br><span class="line">    mSignal.<span class="built_in">wait</span>(mLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边可以看到UI线程的工作到此结束，它丢了一个叫DrawFrameTask的任务到RenderThread线程中去，之后画面绘制的工作转移到RenderThread中来：<br>DrawFrameTask.cpp (frameworks\base\libs\hwui\renderthread)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    context-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CanvasContext.cpp (frameworks\base\libs\hwui\renderthread)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void CanvasContext::draw() &#123;</span><br><span class="line">    ......</span><br><span class="line">    Frame frame = mRenderPipeline-&gt;getFrame();<span class="comment">//这句会调用到Surface的dequeueBuffer</span></span><br><span class="line">    ......</span><br><span class="line">     <span class="built_in">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,</span><br><span class="line">                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,</span><br><span class="line">                                      &amp;(profiler()));</span><br><span class="line">    ......</span><br><span class="line">    waitOnFences();</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">bool</span> didSwap =</span><br><span class="line">            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);<span class="comment">//这句会调用到Surface的queueBuffer</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中完成了三个重要的动作，一个是通过getFrame调到了Surface的dequeueBuffer向SurfaceFlinger申请了画布， 第二是通过mRenderPipeline-&gt;draw将画面画到申请到的画布上， 第三是通过调mRenderPipeline-&gt;swapBuffers把画布提交到SurfaceFlinger去显示。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%B3%BB%E7%BB%9F%E6%9C%BA%E5%88%B6/" rel="tag"># 系统机制</a>
              <a href="/tags/WMS/" rel="tag"># WMS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/08/29/android_pms/" rel="prev" title="Android PKMS核心分析">
                  <i class="fa fa-chevron-left"></i> Android PKMS核心分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/09/07/kotlin_internal_method/" rel="next" title="Kotlin-巧用内置函数">
                  Kotlin-巧用内置函数 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小贾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  





</body>
</html>
