<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;always&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script>
<meta name="description" content="热修复是指，在应用上线后出现 bug 需要及时修复时，不用再发新的安装包，只需要发布补丁包，在客户无感知下修复掉 bug。补丁包需要由开发者生成，由服务器管理并下发补丁包到用户的设备上执行热修复。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 热修复方案和原理">
<meta property="og:url" content="http://example.com/2019/11/24/android_hot_fix/index.html">
<meta property="og:site_name" content="奔跑的蜗牛">
<meta property="og:description" content="热修复是指，在应用上线后出现 bug 需要及时修复时，不用再发新的安装包，只需要发布补丁包，在客户无感知下修复掉 bug。补丁包需要由开发者生成，由服务器管理并下发补丁包到用户的设备上执行热修复。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/android_hot_fix01.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix02.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix03.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix04.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix05.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix06.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix07.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix08.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix09.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix10.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix11.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix12.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix13.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix14.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix15.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix16.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix17.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix18.png">
<meta property="og:image" content="http://example.com/images/android_hot_fix19.png">
<meta property="article:published_time" content="2019-11-24T12:14:00.000Z">
<meta property="article:modified_time" content="2023-01-04T07:27:13.110Z">
<meta property="article:author" content="小贾">
<meta property="article:tag" content="热修复">
<meta property="article:tag" content="HotFix">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/android_hot_fix01.png">


<link rel="canonical" href="http://example.com/2019/11/24/android_hot_fix/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;http:&#x2F;&#x2F;example.com&#x2F;2019&#x2F;11&#x2F;24&#x2F;android_hot_fix&#x2F;&quot;,&quot;path&quot;:&quot;2019&#x2F;11&#x2F;24&#x2F;android_hot_fix&#x2F;&quot;,&quot;title&quot;:&quot;Android 热修复方案和原理&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Android 热修复方案和原理 | 奔跑的蜗牛</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">奔跑的蜗牛</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88"><span class="nav-number">1.</span> <span class="nav-text">热修复方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AndFix"><span class="nav-number">1.1.</span> <span class="nav-text">AndFix</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Robust"><span class="nav-number">1.2.</span> <span class="nav-text">Robust</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tinker"><span class="nav-number">1.3.</span> <span class="nav-text">Tinker</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">热修复的兼容问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-N%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91"><span class="nav-number">2.1.</span> <span class="nav-text">Android N混合编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dalvik-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84-CLASS-ISPREVERIFIED-%E6%A0%87%E8%AE%B0"><span class="nav-number">2.2.</span> <span class="nav-text">Dalvik 虚拟机的 CLASS_ISPREVERIFIED 标记</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Gradle-%E6%8F%92%E4%BB%B6%E6%89%93%E8%A1%A5%E4%B8%81%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">自定义 Gradle 插件打补丁包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">3.1.</span> <span class="nav-text">实现思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8-AGP-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.2.</span> <span class="nav-text">创建与使用 AGP 的基本步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A-Gradle-%E4%B8%8E-AGP-%E7%89%88%E6%9C%AC"><span class="nav-number">3.2.1.</span> <span class="nav-text">确定 Gradle 与 AGP 版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-buildSrc-%E7%9B%AE%E5%BD%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">创建 buildSrc 目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-AGP-%E6%8F%92%E4%BB%B6"><span class="nav-number">3.2.3.</span> <span class="nav-text">使用 AGP 插件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.3.</span> <span class="nav-text">插件功能实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%89%A9%E5%B1%95%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE"><span class="nav-number">3.3.1.</span> <span class="nav-text">创建扩展并进行配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">3.3.2.</span> <span class="nav-text">获取配置信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%B7%B7%E6%B7%86"><span class="nav-number">3.3.3.</span> <span class="nav-text">处理混淆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9%EF%BC%8C%E7%94%9F%E6%88%90%E8%A1%A5%E4%B8%81"><span class="nav-number">3.3.4.</span> <span class="nav-text">字节码插桩，生成补丁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B0%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.3.5.</span> <span class="nav-text">创建新任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-number">3.4.</span> <span class="nav-text">测试结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="nav-number">3.5.</span> <span class="nav-text">调试技巧</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小贾"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">小贾</p>
  <div class="site-description" itemprop="description">Just do IT</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">88</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">56</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/jiajunhui" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jiajunhui" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:junhui_jia@163.com" title="E-Mail → mailto:junhui_jia@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/jiajunhui" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/11/24/android_hot_fix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="小贾">
      <meta itemprop="description" content="Just do IT">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="奔跑的蜗牛">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android 热修复方案和原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-24 20:14:00" itemprop="dateCreated datePublished" datetime="2019-11-24T20:14:00+08:00">2019-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>热修复是指，在应用上线后出现 bug 需要及时修复时，不用再发新的安装包，只需要发布补丁包，在客户无感知下修复掉 bug。补丁包需要由开发者生成，由服务器管理并下发补丁包到用户的设备上执行热修复。</p>
<span id="more"></span>

<h1 id="热修复方案"><a href="#热修复方案" class="headerlink" title="热修复方案"></a>热修复方案</h1><p>热修复解决方案对比：</p>
<p><img src="/images/android_hot_fix01.png" alt="热修复对比"></p>
<p>框架都会用到反射 + 类加载技术，只不过使用方式不同呈现的效果也不同。通过类替换实现的热修复方案都不是即时生效的，需要重启应用后才能生效，而非类替换的方案可以做到即时生效，但实现方式有所不同，下面简单看看各方案的实现原理。</p>
<h2 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h2><p>AndFix 会在 native 层动态替换 Java 层的方法属性，通过 native 层 hook Java 层的代码。</p>
<p>首先，在补丁包的源文件中要对需要修改的方法打上 @MethodReplace 注解，注明要替换的类名和方法名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodReplace &#123;</span><br><span class="line">	<span class="function">String <span class="title">clazz</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法写好后编译生成 class 再打包成 dex 文件。然后 AndFix 会在 Java 层通过 DexFile 加载这个补丁包中的 dex 文件，遍历其中的 Class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            patch file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment"> *            classloader of class that will be fixed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classes</span></span><br><span class="line"><span class="comment"> *            classes will be fixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(File file, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="params"><span class="function">		List&lt;String&gt; classes)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		File optfile = <span class="keyword">new</span> File(mOptDir, file.getName());</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加载补丁包 dex 文件</span></span><br><span class="line">		<span class="keyword">final</span> DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),</span><br><span class="line">				optfile.getAbsolutePath(), Context.MODE_PRIVATE);</span><br><span class="line"></span><br><span class="line">		ClassLoader patchClassLoader = <span class="keyword">new</span> ClassLoader(classLoader) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">protected</span> Class&lt;?&gt; findClass(String className)</span><br><span class="line">					<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">				Class&lt;?&gt; clazz = dexFile.loadClass(className, <span class="keyword">this</span>);</span><br><span class="line">				<span class="keyword">if</span> (clazz == <span class="keyword">null</span></span><br><span class="line">						&amp;&amp; className.startsWith(<span class="string">&quot;com.alipay.euler.andfix&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> Class.forName(className);<span class="comment">// annotation’s class</span></span><br><span class="line">													<span class="comment">// not found</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(className);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> clazz;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 获取 dex 文件中的所有 Class 对象 </span></span><br><span class="line">		Enumeration&lt;String&gt; entrys = dexFile.entries();</span><br><span class="line">		Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 遍历 dex 中的所有 Class</span></span><br><span class="line">		<span class="keyword">while</span> (entrys.hasMoreElements()) &#123;</span><br><span class="line">			String entry = entrys.nextElement();</span><br><span class="line">			<span class="keyword">if</span> (classes != <span class="keyword">null</span> &amp;&amp; !classes.contains(entry)) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">// skip, not need fix</span></span><br><span class="line">			&#125;</span><br><span class="line">			clazz = dexFile.loadClass(entry, patchClassLoader);</span><br><span class="line">			<span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 开始执行类内方法的修复</span></span><br><span class="line">				fixClass(clazz, classLoader);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		Log.e(TAG, <span class="string">&quot;pacth&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历类里面声明的所有方法，筛选出被 @MethodReplace 注解标记的方法，从中获得要替换的类名+方法名，以便进行替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixClass</span><span class="params">(Class&lt;?&gt; clazz, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 clazz 内声明的所有方法</span></span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    MethodReplace methodReplace;</span><br><span class="line">    String clz;</span><br><span class="line">    String meth;</span><br><span class="line">    <span class="comment">// 遍历 methods，筛选出被 @MethodReplace 注解标记的方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        methodReplace = method.getAnnotation(MethodReplace.class);</span><br><span class="line">        <span class="keyword">if</span> (methodReplace == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 从 @MethodReplace 注解上获取类和方法名</span></span><br><span class="line">        clz = methodReplace.clazz();</span><br><span class="line">        meth = methodReplace.method();</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty(clz) &amp;&amp; !isEmpty(meth)) &#123;</span><br><span class="line">            <span class="comment">// 开始替换</span></span><br><span class="line">            replaceMethod(classLoader, clz, meth, method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>replaceMethod() 会对已经修复过的类做缓存处理，真正执行修复操作的是 addReplaceMethod()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存，&lt;类名@ClassLoader名，Class对象&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Class&lt;?&gt;&gt; mFixedClass = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * replace method</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader classloader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clz class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> meth name of target method </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method source method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceMethod</span><span class="params">(ClassLoader classLoader, String clz,</span></span></span><br><span class="line"><span class="params"><span class="function">		String meth, Method method)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 缓存的 key 是类名@ClassLoader名</span></span><br><span class="line">		String key = clz + <span class="string">&quot;@&quot;</span> + classLoader.toString();</span><br><span class="line">		<span class="comment">// 先去缓存中找 clazz</span></span><br><span class="line">		Class&lt;?&gt; clazz = mFixedClass.get(key);</span><br><span class="line">		<span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;<span class="comment">// class not load</span></span><br><span class="line">			Class&lt;?&gt; clzz = classLoader.loadClass(clz);</span><br><span class="line">			<span class="comment">// initialize target class</span></span><br><span class="line">			clazz = AndFix.initTargetClass(clzz);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 缓存没找到</span></span><br><span class="line">		<span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;<span class="comment">// initialize class OK</span></span><br><span class="line">			mFixedClass.put(key, clazz);</span><br><span class="line">			Method src = clazz.getDeclaredMethod(meth,</span><br><span class="line">					method.getParameterTypes());</span><br><span class="line">			<span class="comment">// 真正的执行替换</span></span><br><span class="line">			AndFix.addReplaceMethod(src, method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		Log.e(TAG, <span class="string">&quot;replaceMethod&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 addReplaceMethod() 中会通过一个 native 方法执行方法体的替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * replace method&#x27;s body</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">	 *            source method</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> dest</span></span><br><span class="line"><span class="comment">	 *            target method</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addReplaceMethod</span><span class="params">(Method src, Method dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        replaceMethod(src, dest);</span><br><span class="line">        initFields(dest.getDeclaringClass());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;addReplaceMethod&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">replaceMethod</span><span class="params">(Method dest, Method src)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ative 的 replaceMethod() 主要是对 ArtMethod 结构体的属性进行替换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace_4_4</span><span class="params">(JNIEnv* env, jobject src, jobject dest)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 分别获取源方法和目标方法的 ArtMethod 结构体，进行对应属性替换</span></span><br><span class="line">	art::mirror::ArtMethod* smeth =</span><br><span class="line">			(art::mirror::ArtMethod*) env-&gt;<span class="built_in">FromReflectedMethod</span>(src);</span><br><span class="line"></span><br><span class="line">	art::mirror::ArtMethod* dmeth =</span><br><span class="line">			(art::mirror::ArtMethod*) env-&gt;<span class="built_in">FromReflectedMethod</span>(dest);</span><br><span class="line"></span><br><span class="line">	dmeth-&gt;declaring_class_-&gt;class_loader_ =</span><br><span class="line">			smeth-&gt;declaring_class_-&gt;class_loader_; <span class="comment">//for plugin classloader</span></span><br><span class="line">	dmeth-&gt;declaring_class_-&gt;clinit_thread_id_ =</span><br><span class="line">			smeth-&gt;declaring_class_-&gt;clinit_thread_id_;</span><br><span class="line">	dmeth-&gt;declaring_class_-&gt;status_ = smeth-&gt;declaring_class_-&gt;status_<span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//for reflection invoke</span></span><br><span class="line">	<span class="keyword">reinterpret_cast</span>&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;super_class_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	smeth-&gt;declaring_class_ = dmeth-&gt;declaring_class_;</span><br><span class="line">    smeth-&gt;dex_cache_initialized_static_storage_ = dmeth-&gt;dex_cache_initialized_static_storage_;</span><br><span class="line">    smeth-&gt;access_flags_ = dmeth-&gt;access_flags_  | <span class="number">0x0001</span>;</span><br><span class="line">    smeth-&gt;dex_cache_resolved_types_ = dmeth-&gt;dex_cache_resolved_types_;</span><br><span class="line">    smeth-&gt;dex_cache_resolved_methods_ = dmeth-&gt;dex_cache_resolved_methods_;</span><br><span class="line">    smeth-&gt;dex_cache_strings_ = dmeth-&gt;dex_cache_strings_;</span><br><span class="line">    smeth-&gt;code_item_offset_ = dmeth-&gt;code_item_offset_;</span><br><span class="line">    smeth-&gt;core_spill_mask_ = dmeth-&gt;core_spill_mask_;</span><br><span class="line">    smeth-&gt;fp_spill_mask_ = dmeth-&gt;fp_spill_mask_;</span><br><span class="line">    smeth-&gt;method_dex_index_ = dmeth-&gt;method_dex_index_;</span><br><span class="line">    smeth-&gt;mapping_table_ = dmeth-&gt;mapping_table_;</span><br><span class="line">    smeth-&gt;method_index_ = dmeth-&gt;method_index_;</span><br><span class="line">    smeth-&gt;gc_map_ = dmeth-&gt;gc_map_;</span><br><span class="line">    smeth-&gt;frame_size_in_bytes_ = dmeth-&gt;frame_size_in_bytes_;</span><br><span class="line">    smeth-&gt;native_method_ = dmeth-&gt;native_method_;</span><br><span class="line">    smeth-&gt;vmap_table_ = dmeth-&gt;vmap_table_;</span><br><span class="line"></span><br><span class="line">    smeth-&gt;entry_point_from_compiled_code_ = dmeth-&gt;entry_point_from_compiled_code_;</span><br><span class="line">    </span><br><span class="line">    smeth-&gt;entry_point_from_interpreter_ = dmeth-&gt;entry_point_from_interpreter_;</span><br><span class="line">    </span><br><span class="line">    smeth-&gt;method_index_ = dmeth-&gt;method_index_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从 AndFix 的源码中能看出，ART 虚拟机（从 4.4 开始）上的每一个系统版本都需要对 ArtMethod 结构体进行适配，在适配到 7.0 之后 AndFix 便停更了。</p>
<h2 id="Robust"><a href="#Robust" class="headerlink" title="Robust"></a>Robust</h2><p>Robust 也是会即时生效的热修复框架，但是它是在 Java 层实现的，并没有 native 的处理。</p>
<p>Robust 会在编译打包阶段对每个方法自动插入一段代码（字节码插桩），类似于代理，将方法执行的代码重定向到其它方法，这个插入过程对业务开发是完全透明的。</p>
<p>比如说 State.java 的 getIndex() 内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 Robust 处理后变成下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ChangeQuickRedirect changeQuickRedirect;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(changeQuickRedirect != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//PatchProxy中封装了获取当前className和methodName的逻辑，并在其内部最终调用了changeQuickRedirect的对应函数</span></span><br><span class="line">        <span class="keyword">if</span>(PatchProxy.isSupport(<span class="keyword">new</span> Object[<span class="number">0</span>], <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Long)PatchProxy.accessDispatch(<span class="keyword">new</span> Object[<span class="number">0</span>], <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>)).longValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Robust 为每个 class 增加了一个类型为 ChangeQuickRedirect 的静态成员，在每个方法前都插入了使用 changeQuickRedirect 相关的逻辑。当 changeQuickRedirect 不为 null 时，可能会执行到 accessDispatch 从而替换掉之前老的逻辑，达到 fix 的目的。</p>
<p>想要修改 getIndex() 的返回值，补丁包中需要包含如下两个源文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchesInfoImpl</span> <span class="keyword">implements</span> <span class="title">PatchesInfo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PatchedClassInfo&gt; <span class="title">getPatchedClassesInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;PatchedClassInfo&gt; patchedClassesInfos = <span class="keyword">new</span> ArrayList&lt;PatchedClassInfo&gt;();</span><br><span class="line">        <span class="comment">// 需要打补丁的类名，com.meituan.sample.d 是混淆后的类名</span></span><br><span class="line">        PatchedClassInfo patchedClass = <span class="keyword">new</span> PatchedClassInfo(<span class="string">&quot;com.meituan.sample.d&quot;</span>, StatePatch.class.getCanonicalName());</span><br><span class="line">        patchedClassesInfos.add(patchedClass);</span><br><span class="line">        <span class="keyword">return</span> patchedClassesInfos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatch</span> <span class="keyword">implements</span> <span class="title">ChangeQuickRedirect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">accessDispatch</span><span class="params">(String methodSignature, Object[] paramArrayOfObject)</span> </span>&#123;</span><br><span class="line">        String[] signature = methodSignature.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.equals(signature[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>)) &#123;<span class="comment">//long getIndex() -&gt; a</span></span><br><span class="line">        	<span class="comment">// 修改 getIndex() 的返回值为 106</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">106</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSupport</span><span class="params">(String methodSignature, Object[] paramArrayOfObject)</span> </span>&#123;</span><br><span class="line">        String[] signature = methodSignature.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.equals(signature[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>)) &#123;<span class="comment">//long getIndex() -&gt; a</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打补丁的主要过程为：</p>
<ol>
<li>ClassLoader 加载补丁的 dex 文件，拿到 PatchesInfoImpl.class 并创建一个对应的 Class 对象</li>
<li>反射调用 getPatchedClassesInfo()，拿到需要打补丁的类名，再反射拿到这个类的 Class 对象</li>
<li>反射上一步中 Class 对象的 changeQuickRedirect 字段，并赋值为补丁包 dex 文件中 StatePatch.class new 出来的对象。</li>
</ol>
<p>以上过程没有动系统的 ClassLoader，都是直接使用，兼容性得以保证。</p>
<p>更详细内容可以直接参考美团技术团队对 Robust 的介绍文章链接<a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/09/14/android-robust.html">Android热更新方案Robust</a>。</p>
<h2 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a>Tinker</h2><p>Tinker 的补丁包与前两者不同，它是一个差分包而不是完整的 dex 文件。这个差分包是计算了指定的 base apk（一般就是设备正在运行的 apk）的 dex 与修改后 apk 的 dex 的区别的描述，运行时将 base apk 的 dex 与差分包进行合成，重启后加载全新合成的 dex 文件：<br><img src="/images/android_hot_fix02.png" alt="img"></p>
<p>图片来源：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286384&idx=1&sn=f1aff31d6a567674759be476bcd12549&scene=4#wechat_redirect">微信Tinker的一切都在这里，包括源码(一)</a></p>
<p>Tinker 实现热修复的原理，是将补丁包的 dex 文件存放到系统的 PathClassLoader 的 pathList 字段的 dexElements 数组的前面：</p>
<p><img src="/images/android_hot_fix03.png" alt="img"></p>
<p>由于 ClassLoader 加载 dexElements 数组中的类是按照由先到后的顺序，且加载过的类不会重复加载，所以补丁包的 Key.class 生效，原本 Classes2.dex 中的 Key.class 不会被加载，使得修复生效。参考 Tinker 代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tinker/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectDexesInternal</span><span class="params">(ClassLoader cl, List&lt;File&gt; dexFiles, File optimizeDir)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 针对不同系统需要做出兼容处理，我们看V23的</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        V23.install(cl, dexFiles, optimizeDir);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        V19.install(cl, dexFiles, optimizeDir);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        V14.install(cl, dexFiles, optimizeDir);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V4.install(cl, dexFiles, optimizeDir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V23</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="params"><span class="function">                                File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">    NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 找到 loader 中的 pathList 字段，并拿到 pathList 对象</span></span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(loader, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        <span class="comment">// expandFieldArray() 会将 makePathElements() 得到的 Element 数组放在 dexPathList 对象 dexElements 的前面</span></span><br><span class="line">        ShareReflectUtil.expandFieldArray(dexPathList, <span class="string">&quot;dexElements&quot;</span>, makePathElements(dexPathList,</span><br><span class="line">                                                                                       <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                                                                                       suppressedExceptions));</span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                ShareTinkerLog.w(TAG, <span class="string">&quot;Exception in makePathElement&quot;</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 反射调用 makePathElements() 或者 makeDexElements()，将补丁包中的 dex 文件转换成 Element 数组。</span></span><br><span class="line"><span class="comment">         * 系统源码在不同版本中使用的方法形式不同，版本由高到低的形式为 makePathElements(List,File,List)、</span></span><br><span class="line"><span class="comment">         * makeDexElements(ArrayList,File,ArrayList)、makeDexElements(List,File,List)。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makePathElements(</span><br><span class="line">        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        Method makePathElements;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">&quot;makePathElements&quot;</span>, List.class, File.class,</span><br><span class="line">                                                           List.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            ShareTinkerLog.e(TAG, <span class="string">&quot;NoSuchMethodException: makePathElements(List,File,List) failure&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">&quot;makePathElements&quot;</span>, ArrayList.class, File.class, ArrayList.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e1) &#123;</span><br><span class="line">                ShareTinkerLog.e(TAG, <span class="string">&quot;NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ShareTinkerLog.e(TAG, <span class="string">&quot;NoSuchMethodException: try use v19 instead&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> V19.makeDexElements(dexPathList, files, optimizedDirectory, suppressedExceptions);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e2) &#123;</span><br><span class="line">                    ShareTinkerLog.e(TAG, <span class="string">&quot;NoSuchMethodException: makeDexElements(List,File,List) failure&quot;</span>);</span><br><span class="line">                    <span class="keyword">throw</span> e2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Object[]) makePathElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="热修复的兼容问题"><a href="#热修复的兼容问题" class="headerlink" title="热修复的兼容问题"></a>热修复的兼容问题</h1><p>从上述热修复框架的介绍中不难发现，热修复对兼容性的要求是很高的，最明显的就是，如果反射了系统源码，就要跟随版本对系统源码的变化做兼容处理。除了源码的变化，系统机制的变化也会对热修复的兼容性产生影响。</p>
<h2 id="Android-N混合编译"><a href="#Android-N混合编译" class="headerlink" title="Android N混合编译"></a>Android N混合编译</h2><p>ART 虚拟机是在 Android KitKat（4.4） 被引入的，并从 Android L（5.0） 开始被设为默认运行环境。</p>
<p>Android N（7.0）之前，ART 在安装 apk 时会采用 AOT（Ahead of time：提前编译、静态编译）预编译为机器码。</p>
<p>而从 Android N 开始，使用混合编译模式，即安装 apk 时不编译，运行时解释字节码，同时在 JIT （Just-In-Time：即时编译）编译热点代码（即频繁执行的代码）并将这些代码信息记录至 Profile 文件，在设备空闲时使用 AOT（All-Of-the-Time compilation：全时段编译）编译生成名为 app_image 的 base.art（类对象映像）文件，该文件会在 apk 下次启动时自动加载（相当于缓存）。</p>
<p>根据 Android 的类加载机制，已经被加载过的类无法被替换，使得无法通过热修复修正这些类（启动 apk 时，在 ActivityThread 创建 PathClassLoader 时就会先加载 app_image 中的类，随后才执行热修复的代码，所以被编译进 app_image 的类无法被热修复）。</p>
<p>Tinker 的解决方案是自己创建一个 PathClassLoader 替换掉系统的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoaderAdder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installDexes</span><span class="params">(Application application, ClassLoader loader, File dexOptDir, List&lt;File&gt; files,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">boolean</span> isProtectedApp, <span class="keyword">boolean</span> useDLC)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">            files = createSortedAdditionalPathEntries(files);</span><br><span class="line">            ClassLoader classLoader = loader;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span> &amp;&amp; !isProtectedApp) &#123;</span><br><span class="line">            	<span class="comment">// 从 7.0 开始要用自己创建的 PathClassLoader 替换掉系统的</span></span><br><span class="line">                classLoader = NewClassLoaderInjector.inject(application, loader, dexOptDir, useDLC, files);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 7.0 以下</span></span><br><span class="line">                injectDexesInternal(classLoader, files, dexOptDir);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dalvik-虚拟机的-CLASS-ISPREVERIFIED-标记"><a href="#Dalvik-虚拟机的-CLASS-ISPREVERIFIED-标记" class="headerlink" title="Dalvik 虚拟机的 CLASS_ISPREVERIFIED 标记"></a>Dalvik 虚拟机的 CLASS_ISPREVERIFIED 标记</h2><p>我们仿照 Tinker 写一个热修复 Demo，在 4.4 系统上运行（4.4 默认用的还是 Dalvik 虚拟机）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、获取程序的PathClassLoader对象</span></span><br><span class="line"><span class="comment">     * 2、反射获得PathClassLoader父类BaseDexClassLoader的pathList对象</span></span><br><span class="line"><span class="comment">     * 3、反射获取pathList的dexElements对象 （oldElement）</span></span><br><span class="line"><span class="comment">     * 4、把补丁包变成Element数组：patchElement（反射执行makePathElements）</span></span><br><span class="line"><span class="comment">     * 5、合并patchElement+oldElement = newElement （Array.newInstance）</span></span><br><span class="line"><span class="comment">     * 6、反射把oldElement赋值成newElement</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installPatch</span><span class="params">(Application application, File patch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、获取程序的PathClassLoader对象</span></span><br><span class="line">    ClassLoader classLoader = application.getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoaderInjector.inject(application, classLoader, patchs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、反射获得PathClassLoader父类BaseDexClassLoader的pathList对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(classLoader, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">        Object pathList = pathListField.get(classLoader);</span><br><span class="line">        <span class="comment">//3、反射获取pathList的dexElements对象 （oldElement）</span></span><br><span class="line">        Field dexElementsField = ShareReflectUtil.findField(pathList, <span class="string">&quot;dexElements&quot;</span>);</span><br><span class="line">        Object[] oldElements = (Object[]) dexElementsField.get(pathList);</span><br><span class="line">        <span class="comment">//4、把补丁包变成Element数组：patchElement（反射执行makePathElements）</span></span><br><span class="line">        Object[] patchElements = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            Method makePathElements = ShareReflectUtil.findMethod(pathList, <span class="string">&quot;makePathElements&quot;</span>,</span><br><span class="line">                                                                  List.class, File.class,</span><br><span class="line">                                                                  List.class);</span><br><span class="line">            ArrayList&lt;IOException&gt; ioExceptions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            patchElements = (Object[])</span><br><span class="line">                makePathElements.invoke(pathList, patchs, application.getCacheDir(), ioExceptions);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            Method makePathElements = ShareReflectUtil.findMethod(pathList, <span class="string">&quot;makeDexElements&quot;</span>,</span><br><span class="line">                                                                  ArrayList.class, File.class, ArrayList.class);</span><br><span class="line">            ArrayList&lt;IOException&gt; ioExceptions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            patchElements = (Object[])</span><br><span class="line">                makePathElements.invoke(pathList, patchs, application.getCacheDir(), ioExceptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、合并patchElement+oldElement = newElement （Array.newInstance）</span></span><br><span class="line">        <span class="comment">//创建一个新数组，大小 oldElements+patchElements</span></span><br><span class="line">        Object[] newElements = (Object[]) Array.newInstance(oldElements.getClass().getComponentType(),</span><br><span class="line">                                                            oldElements.length + patchElements.length);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(patchElements, <span class="number">0</span>, newElements, <span class="number">0</span>, patchElements.length);</span><br><span class="line">        System.arraycopy(oldElements, <span class="number">0</span>, newElements, patchElements.length, oldElements.length);</span><br><span class="line">        <span class="comment">//6、反射把oldElement赋值成newElement</span></span><br><span class="line">        dexElementsField.set(pathList, newElements);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现抛出如下错误：</p>
<p><img src="/images/android_hot_fix04.png" alt="img"></p>
<p>这是因为，被标记了 CLASS_ISPREVERIFIED 的类，引用了不在同一个 dex 文件中的类。如果一个类只引用了（正向调用，反射不算，因为反射不需要一个类的引用就用获取到该类对象）同一个 dex 文件中的类，那么在打包 dex 文件时，这个类就会被打上 CLASS_ISPREVERIFIED 标记（这个机制属于 Dalvik 虚拟机的一个优化)：<br><img src="/images/android_hot_fix05.png" alt="img"></p>
<p>比如说 MainActivity 只引用了 Utils，且二者在同一个 dex 文件中，那么 MainActivity.class 就会被打上 CLASS_ISPREVERIFIED 标记。</p>
<p>在热修复时，会用 patch.dex 中的 Utils.class 去替换 classes.dex 中的 Utils.class，导致 MainActivity 引用了不同 dex 文件中的类，就会抛出 IllegalAccessError。</p>
<p>如何规避掉这个错误呢？那就尝试让 MainActivity 引用不同 dex 文件中的类，这样它就打不上 CLASS_ISPREVERIFIED 标记，再引用其它 dex 中的类也就不会出错了。具体做法是：</p>
<ol>
<li>在补丁包中创建一个专门被引用的空类 AntiLazyLoad</li>
<li>通过字节码插桩的方式在 MainActivity.class 的构造方法中添加引用 AntiLazyLoad 的代码</li>
<li>将 AntiLazyLoad 这个类添加到负责加载 classes.dex 的那个 ClassLoader 中</li>
</ol>
<p>上述过程可以通过打补丁包的方式实现，做法是：</p>
<p><img src="/images/android_hot_fix06.png" alt="img"></p>
<h1 id="自定义-Gradle-插件打补丁包"><a href="#自定义-Gradle-插件打补丁包" class="headerlink" title="自定义 Gradle 插件打补丁包"></a>自定义 Gradle 插件打补丁包</h1><p>我们写一个通过 Gradle 插件 + ASM 字节码插桩的自动化补丁 Demo 来解决上面的问题。</p>
<p>实现自动化补丁需要有两个前置知识：</p>
<ol>
<li>熟悉 Android Gradle Plugin（AGP）的基础知识（可参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/7092367604211253256">为什么说 Gradle 是 Android 进阶绕不去的坎</a>）</li>
<li>知道如何通过 ASM 实现字节码插桩（可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/tmacfrank/article/details/124964043">ASM 字节码插桩入门</a>）</li>
</ol>
<p>此外，由于 AGP 的向后兼容性很弱，所以这里先声明 Demo 中使用的 Gradle 版本是 4.10.1，AGP 版本是 3.3.1（版本确实老了点），如果你所使用的版本高于上述版本，可能部分 API 不兼容（比如说你的 AS 升级到了 AS BumbleBee，其支持最低的 Gradle 版本为 6.1.1，那么本文章中的示例代码就无法运行），但是处理问题的思路应该是大致相同的。关于 Gradle 与 AGP 的版本对照表，可以参考下图：<br><img src="/images/android_hot_fix07.png" alt="img"></p>
<p>此外，下面做 Demo 演示时只会编译 debug 版本，所以涉及到的任务名都是以 debug 为准，比如编译 Java 源文件为 class 文件的任务名，在编译 debug 时为 compileDebugJavaWithJavac，而编译 Release 版本时就为 compileReleaseJavaWithJavac，如果还配置了其它变体，如 Xxx，那么编译该变体的任务就是 compileXxxJavaWithJavac。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>我们的目的是自定义一个 Gradle 任务，自动为两次编译之间发生了变化的 class 文件进行字节码插桩，再通过 dx/d8 命令将 class 文件打包成 dex 文件后放入补丁包。</p>
<p><img src="/images/android_hot_fix08.png" alt="img"></p>
<p>如上图所示，在由 Java 源文件生成 dex 文件的过程中，其实是经过了几个 Gradle 任务处理的：</p>
<ol>
<li>compileDebugJavaWithJavac 将 Java 源文件编译成 class 文件</li>
<li>transformClassesAndResourcesWithProguardForDebug 对 class 文件进行混淆</li>
<li>transformClassesWithDexBuilderForDebug 将混淆后的 class 文件打包进 dex 文件</li>
</ol>
<p>每个任务都有输入和输出，以及 doFirst 和 doLast 两个监听：</p>
<p><img src="/images/android_hot_fix09.png" alt="img"></p>
<p>比如混淆任务 transformClassesAndResourcesWithProguardForDebug 的输入，是所有模块的 compileDebugJavaWithJavac 任务输出的 class 文件，输出就是混淆后的 class，这些 class 就是 transformClassesWithDexBuilderForDebug 任务的输入。</p>
<p>而 doFirst/doLast 可以理解为任务的入口/出口监听，会分别在刚进入任务还没开始执行任务功能、已经执行完任务功能即将结束任务时回调。在 Demo 中常用 doFirst 来获取上一个任务的输出文件，用 doLast 获取当前任务的输出文件，后面结合具体思路以及代码能看的更清楚些。</p>
<p>此外必须要明确的是，对于热修复而言，我们只需要在补丁包中加入相比于正式版本进行过修改的 class 文件，而不是本次编译生成的所有 class 文件，所以我们在每次编译时都应该用一个文件保存 class 文件的 md5 值，如果本次编译与正式版本的 md5 不同，那么该 class 文件才需要放进补丁包。</p>
<p>还有，如果编译开启了混淆，为了保证每次编译时，同一个文件被混淆成相同的名字，需要保存正式版本编译时使用的 mapping.txt 文件，并在后续编译中使用该 mapping。</p>
<p>经过以上论述呢，我们可以理出一个大致的思路：</p>
<ol>
<li>如果开启了混淆，transformClassesAndResourcesWithProguardForDebug 任务进行混淆时需要使用之前备份的 mapping 文件，并且在任务的 doLast 中备份本次混淆的 mapping 作为下次的参考</li>
<li>transformClassesWithDexBuilderForDebug 的输入是混淆后的 class/jar 文件，在将它们打包成 dex 之前，即在 doFirst 中，进行插桩，并通过与之前备份的 md5 值文件对比筛选出修改过的 class/jar，对它们用 dx/d8 命令打包成包含 dex 文件的补丁包</li>
</ol>
<h2 id="创建与使用-AGP-的基本步骤"><a href="#创建与使用-AGP-的基本步骤" class="headerlink" title="创建与使用 AGP 的基本步骤"></a>创建与使用 AGP 的基本步骤</h2><p>还是要简单提一下如何创建与使用一个 Android Plugin 插件，如果前面给出的参考链接中的内容已经掌握，可以跳过本节。</p>
<p>我们想在两个任务执行期间加入字节码插桩、补丁打包等操作，需要自定义一个 AGP 来实现。自定义 AGP 的方式有如下三种：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Build script 脚本</td>
<td>把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该 build.gradle 文件可见</td>
</tr>
<tr>
<td>buildSrc 目录</td>
<td>将插件源代码放在 buildSrc/src/main/ 中，只对该项目中可见</td>
</tr>
<tr>
<td>独立项目</td>
<td>一个独立的 Java 项目/模块，可以将文件包发布到仓库（Jcenter），使其他项目方便引入</td>
</tr>
</tbody></table>
<p>Build script 脚本只能在当前 build.gradle 文件中生效，复用性差；buildSrc 目录对当前项目生效，buildSrc 被作为系统保留的目录，编译时会最先编译该目录下的代码；独立项目的方式复用性最好，可以通过 Maven 实现远程共享。这里我们主要介绍 buildSrc 目录的方式。</p>
<h3 id="确定-Gradle-与-AGP-版本"><a href="#确定-Gradle-与-AGP-版本" class="headerlink" title="确定 Gradle 与 AGP 版本"></a>确定 Gradle 与 AGP 版本</h3><p>首先设置合适的 Gradle 与 Gradle 插件版本，Gradle 版本修改 /gradle/wrapper/gradle-wrapper.properties 文件：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https<span class="keyword">\:</span>//services.gradle.org/distributions/gradle-4.10.1-all.zip</span><br></pre></td></tr></table></figure>

<p>Gradle 插件版本修改项目的 build.gradle:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;com.android.tools.build:gradle:3.3.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-buildSrc-目录"><a href="#创建-buildSrc-目录" class="headerlink" title="创建 buildSrc 目录"></a>创建 buildSrc 目录</h3><p>在项目根目录下创建 buildSrc 目录（注意不是模块），然后新建 build.gradle 文件添加 Gradle 插件依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java-library&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 我们需要实现的 Plugin 接口在这个依赖中</span></span><br><span class="line">    implementation <span class="string">&#x27;com.android.tools.build:gradle:3.3.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 Java 语言编写自定义插件（其实用 Groovy 更方便一些），新建 PatchPlugin 实现 Plugin 接口来完成自定义插件，目录结构：</p>
<p><img src="/images/android_hot_fix10.png" alt="img"></p>
<p>PatchPlugin 实现 Plugin 接口时需要重写入口方法 apply，我们先只在 apply() 中添加一句 log：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Execute apply() in PatchPlugin.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-AGP-插件"><a href="#使用-AGP-插件" class="headerlink" title="使用 AGP 插件"></a>使用 AGP 插件</h3><p>当其它模块需要使用 AGP 插件时，需要在模块 build.gradle 中通过 apply plugin 声明插件的全类名：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> com.demo.plugin.PatchPlugin</span><br></pre></td></tr></table></figure>

<p>然后编译，在编译的输出信息中可以看到我们在 apply() 中加的 log：</p>
<p><img src="/images/android_hot_fix11.png" alt="img"></p>
<p>导入插件还有另一种形式，就是在 buildSrc 目录下，具体是在 buildSrc/src/main/resources/META-INF/gradle-plugins 目录下新建一个 xxx.properties 文件（xxx 文件名由你自己指定，但是后面在引用的时候要保持一致)，并将 implementation-class 属性指定为插件类的全类名：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class=com.demo.plugin.PatchPlugin</span><br></pre></td></tr></table></figure>

<p>然后在 app 模块中就可以通过单引号的方式引入该插件了：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个 xxx 要和 gradle-plugins 目录下定义的 xxx 文件名一致</span></span><br><span class="line">apply <span class="attr">plugin:</span><span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="插件功能实现"><a href="#插件功能实现" class="headerlink" title="插件功能实现"></a>插件功能实现</h2><p>下面正式进入 Demo 的代码。</p>
<h3 id="创建扩展并进行配置"><a href="#创建扩展并进行配置" class="headerlink" title="创建扩展并进行配置"></a>创建扩展并进行配置</h3><p>首先在插件执行的入口方法 apply() 中创建一个名为 patch 的扩展：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 作用在 application 插件上，而不是 library</span></span><br><span class="line">        <span class="keyword">if</span> (!project.getPlugins().hasPlugin(AppPlugin.class)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;本插件需要结合Android Application插件使用！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 patch 扩展，支持的属性定义在 PatchExtension 中，其它模块</span></span><br><span class="line">        <span class="comment">// 在 build.gradle 中引入本插件后，就可以用 patch&#123;&#125; 进行配置</span></span><br><span class="line">        project.getExtensions().create(<span class="string">&quot;patch&quot;</span>, PatchExtension.class);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 project 拿到 ExtensionContainer 并调用 create() 创建一个 patch 闭包，PatchExtension 是一个 JavaBean，定义了 patch 支持的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchExtension</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否在 debug 模式下开启热修复，默认为 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> debugOn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Application 的全类名。由于热修复一般是在 Application 中执行的，执行热修复代码时 Application</span></span><br><span class="line"><span class="comment">     * 已经被系统 ClassLoader 加载了，无法再替换，所以热修复时要刨除掉 Application 的 class 文件。</span></span><br><span class="line"><span class="comment">     * 虽然 Application 信息可以通过解析插件中的 AndroidManifest 获取，但是通过 Java 实现的插件</span></span><br><span class="line"><span class="comment">     * 解析 xml 很麻烦（Groovy 简单些），因此直接要求作为配置项获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可选项，补丁的输出目录，默认为 app/build/patch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String output;</span><br><span class="line"></span><br><span class="line">    getters and setters...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样需要打补丁包的模块就可以这样配置其 build.gradle 来使用我们的插件：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line"><span class="comment">// 引入我们的自定义插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.plugin.patch&#x27;</span></span><br><span class="line"></span><br><span class="line">patch &#123;</span><br><span class="line">	<span class="comment">// debug 模式下开启打补丁包</span></span><br><span class="line">    debugOn <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 本模块使用的 Application 全类名</span></span><br><span class="line">    applicationName <span class="string">&#x27;com.demo.plugin.Application&#x27;</span></span><br><span class="line">    <span class="comment">// 输出路径没配置，使用默认的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取配置信息"><a href="#获取配置信息" class="headerlink" title="获取配置信息"></a>获取配置信息</h3><p>接下来要获取所有配置信息为编译工作做准备了，这些操作要放在 Project 的 afterEvaluate() 回调中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 作用在 application 插件上，而不是 library</span></span><br><span class="line">    <span class="keyword">if</span> (!project.getPlugins().hasPlugin(AppPlugin.class)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;本插件需要结合Android Application插件使用！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 patch 扩展，支持的属性定义在 PatchExtension 中，其它模块</span></span><br><span class="line">    <span class="comment">// 在 build.gradle 中引入本插件后，就可以用 patch&#123;&#125; 进行配置</span></span><br><span class="line">    project.getExtensions().create(<span class="string">&quot;patch&quot;</span>, PatchExtension.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// afterEvaluate() 在 build.gradle 文件解析完成后回调</span></span><br><span class="line">    project.afterEvaluate(<span class="keyword">new</span> Action&lt;Project&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">            PatchExtension patchExtension = project.getExtensions().findByType(PatchExtension.class);</span><br><span class="line">            <span class="keyword">if</span> (patchExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// debug 模式下是否打补丁包</span></span><br><span class="line">                <span class="keyword">boolean</span> debugOn = patchExtension.isDebugOn();</span><br><span class="line">                project.getLogger().info(<span class="string">&quot;debugOn:&quot;</span> + debugOn + <span class="string">&quot;, ApplicationName:&quot;</span> + patchExtension.getApplicationName());</span><br><span class="line">                <span class="comment">// 获取 android 扩展</span></span><br><span class="line">                AppExtension android = project.getExtensions().getByType(AppExtension.class);</span><br><span class="line">                <span class="comment">// 遍历 android -&gt; buildTypes 下所有的变体，如 debug、release 等</span></span><br><span class="line">                android.getApplicationVariants().all(<span class="keyword">new</span> Action&lt;ApplicationVariant&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ApplicationVariant applicationVariant)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 如果编译的是 debug 版本并且已经配置了 debug 不需要生成补丁包，就不作处理</span></span><br><span class="line">                        <span class="keyword">if</span> (applicationVariant.getName().contains(<span class="string">&quot;debug&quot;</span>) &amp;&amp; !debugOn) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 开始编译配置与生成补丁工作</span></span><br><span class="line">                        configTasks(project, applicationVariant, patchExtension);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不在 afterEvaluate() 中获取配置信息，那么会拿不到 patchExtension 中的属性值。因为使用 PatchPlugin 插件的模块，在其 build.gradle 执行到 apply plugin: ‘com.plugin.patch’ 这句话时就去执行其 apply() 去获取 patch 扩展中配置的 patchExtension 的值，而此时 build.gradle 还没解析，所以拿不到 patch 配置的属性值。</p>
<p>configTasks() 作为接下来一系列工作的入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configTasks</span><span class="params">(Project project, ApplicationVariant variant, PatchExtension patchExtension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建补丁文件的输出路径</span></span><br><span class="line">    String variantName = variant.getName();</span><br><span class="line">    File outputDir = Utils.getOrCreateOutputDir(project, variantName, patchExtension);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取 Android 的混淆任务，并配置混淆任务使用的 mapping 文件</span></span><br><span class="line">    String variantCapName = Utils.capitalize(variantName);</span><br><span class="line">    Task proguardTask = project.getTasks().findByName(<span class="string">&quot;transformClassesAndResourcesWithProguardFor&quot;</span></span><br><span class="line">                                                      + variantCapName);</span><br><span class="line">    <span class="keyword">if</span> (proguardTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        configProguardTask(project, proguardTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.配置任务，进行字节码插桩和补丁生成</span></span><br><span class="line">    Task dexTask = getTransformTask(project, patchExtension, outputDir, variantCapName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.创建打补丁的任务 patchDebug/patchRelease，依赖于 dexTask</span></span><br><span class="line">    Task task = project.getTasks().create(<span class="string">&quot;patch&quot;</span> + variantCapName);</span><br><span class="line">    task.setGroup(<span class="string">&quot;patch&quot;</span>);</span><br><span class="line">    task.dependsOn(dexTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释已经标明，任务大致分为 4 步，第 1 步比较简单，就是根据配置创建补丁输出目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getOrCreateOutputDir</span><span class="params">(Project project, String variantName, PatchExtension patchExtension)</span> </span>&#123;</span><br><span class="line">    File outputDir;</span><br><span class="line">    <span class="comment">// 如果 build.gradle 中没有指定 patch -&gt; output 就用默认值 /build/patch/[variantName]</span></span><br><span class="line">    <span class="keyword">if</span> (!Utils.isEmpty(patchExtension.getOutput())) &#123;</span><br><span class="line">        outputDir = <span class="keyword">new</span> File(patchExtension.getOutput(), variantName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outputDir = <span class="keyword">new</span> File(project.getBuildDir(), <span class="string">&quot;patch/&quot;</span> + variantName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    project.getLogger().info(<span class="string">&quot;补丁输出路径：&quot;</span> + outputDir.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    outputDir.mkdirs();</span><br><span class="line">    <span class="keyword">return</span> outputDir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面 3 步下面详解。</p>
<h3 id="处理混淆"><a href="#处理混淆" class="headerlink" title="处理混淆"></a>处理混淆</h3><p>我们需要让混淆任务按照上一次混淆的映射关系 mapping.txt 进行（如果有），并且在本次混淆任务结束之后，保存本次混淆的 mapping 文件以备下次混淆时使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configProguardTask</span><span class="params">(Project project, Task proguardTask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proguardTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有备份的 mapping 文件，那么本次编译还要使用上次的 mapping</span></span><br><span class="line">    File backupMappingFile = <span class="keyword">new</span> File(project.getBuildDir(), <span class="string">&quot;mapping.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (backupMappingFile.exists()) &#123;</span><br><span class="line">        TransformTask task = (TransformTask) proguardTask;</span><br><span class="line">        ProGuardTransform transform = (ProGuardTransform) task.getTransform();</span><br><span class="line">        <span class="comment">// 相当于在 proguard-rules.pro 中配置了 -applymapping mapping.txt</span></span><br><span class="line">        transform.applyTestedMapping(backupMappingFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要开启了混淆，在混淆任务结束后就要把 mapping 文件备份</span></span><br><span class="line">    proguardTask.doLast(<span class="keyword">new</span> Action&lt;Task&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// mapping 文件在 proguardTask 的输出之中</span></span><br><span class="line">            TaskOutputs outputs = proguardTask.getOutputs();</span><br><span class="line">            Set&lt;File&gt; files = outputs.getFiles().getFiles();</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;mapping.txt&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 找出 mapping.txt 并备份</span></span><br><span class="line">                        FileUtils.copyFile(file, backupMappingFile);</span><br><span class="line">                        project.getLogger().info(<span class="string">&quot;mapping: &quot;</span> + backupMappingFile.getCanonicalPath());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码插桩，生成补丁"><a href="#字节码插桩，生成补丁" class="headerlink" title="字节码插桩，生成补丁"></a>字节码插桩，生成补丁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Task <span class="title">getTransformTask</span><span class="params">(Project project, PatchExtension patchExtension, File outputDir, String variantCapName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存 class 文件名及其 md5 值的文件</span></span><br><span class="line">    File hexFile = <span class="keyword">new</span> File(outputDir, <span class="string">&quot;hex.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 需要打补丁的类组成的 jar 包</span></span><br><span class="line">    File patchClassFile = <span class="keyword">new</span> File(outputDir, <span class="string">&quot;patchClass.jar&quot;</span>);</span><br><span class="line">    <span class="comment">// dx 命令打包 patchClassFile 后生成的补丁包，最终产物</span></span><br><span class="line">    File patchFile = <span class="keyword">new</span> File(outputDir, <span class="string">&quot;patch.jar&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取将 class 打包成 dex 的任务</span></span><br><span class="line">    Task dexTask = project.getTasks().findByName(<span class="string">&quot;transformClassesWithDexBuilderFor&quot;</span> + variantCapName);</span><br><span class="line">    <span class="comment">// 在开始打包之前，插桩并记录每个 class 的 md5 哈希值</span></span><br><span class="line">    dexTask.doFirst(<span class="keyword">new</span> Action&lt;Task&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 将 Application 全类名中的 . 替换成平台相关的斜杠，Windows 是 xx\xx\，Linux 是 xx/xx/</span></span><br><span class="line">            String applicationName = patchExtension.getApplicationName();</span><br><span class="line">            applicationName = applicationName.replaceAll(<span class="string">&quot;\\.&quot;</span>, Matcher.quoteReplacement(File.separator));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录类本次编译的 md5 值</span></span><br><span class="line">            Map&lt;String, String&gt; newHexes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 负责生成补丁</span></span><br><span class="line">            PatchGenerator patchGenerator = <span class="keyword">new</span> PatchGenerator(project, patchFile, patchClassFile, hexFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历 dexTask 任务的输入文件，对 class 和 jar 文件进行处理，像 app 中的 MainActivity</span></span><br><span class="line">            <span class="comment">// 的路径是：app\build\intermediates\transforms\proguard\debug\0.jar</span></span><br><span class="line">            Set&lt;File&gt; files = dexTask.getInputs().getFiles().getFiles();</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                String filePath = file.getAbsolutePath();</span><br><span class="line">                <span class="comment">// 插桩，并做 md5 值比较，不一致的放入补丁包</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                    processClass(project, applicationName, file, newHexes, patchGenerator);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filePath.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                    processJar(project, applicationName, file, newHexes, patchGenerator);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存本次编译的 md5</span></span><br><span class="line">            Utils.writeHex(newHexes, hexFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成补丁文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                patchGenerator.generate();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dexTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开头三个文件的作用：</p>
<ul>
<li>hexFile 保存每次编译生成的 class 文件，插桩之后的类名及 md5 值，这样才能比较出哪些文件有改动，进而被放入补丁包</li>
<li>patchClassFile 是所有需要被添加进补丁包的 class 文件打成的 jar 包，是一个中间产物，用来生成最终的补丁包</li>
<li>patchFile 是 dx/d8 命令对 patchClassFile 打包生成的 jar 包，也就是最终需要的补丁包</li>
</ul>
<p>在拿到 transformClassesWithDexBuilderForDebug 任务的一开始，先拿到模块的 applicationName 对应的全类名路径，因为热修复不会替换 Application，所以在后面处理时要剔除掉。</p>
<p>PatchGenerator 主要用来比较 md5 值以及执行打包的 dx/d8 命令，初始化时要获取 buildToolsVersion 以便动态获取 dx/d8 命令的执行路径，还要读取上次编译时备份的 hexFile：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PatchGenerator</span><span class="params">(Project project, File patchFile, File jarFile, File hexFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.project = project;</span><br><span class="line">    <span class="keyword">this</span>.patchFile = patchFile;</span><br><span class="line">    <span class="keyword">this</span>.jarFile = jarFile;</span><br><span class="line">    <span class="comment">// 从 android&#123;&#125; 中获取 buildToolsVersion 属性</span></span><br><span class="line">    buildToolsVersion = project.getExtensions().getByType(AppExtension.class).getBuildToolsVersion();</span><br><span class="line">    <span class="comment">// 从备份文件中读取上一次编译生成的 class 文件名和 md5 值</span></span><br><span class="line">    <span class="keyword">if</span> (hexFile.exists()) &#123;</span><br><span class="line">        prevHexes = Utils.readHex(hexFile);</span><br><span class="line">        project.getLogger().info(<span class="string">&quot;从备份文件 &quot;</span> + hexFile.getAbsolutePath() + <span class="string">&quot; 中读取md5值&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果备份文件不存在，可能是首次编译，直接创建备份文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hexFile.createNewFile()) &#123;</span><br><span class="line">                project.getLogger().info(<span class="string">&quot;创建备份文件成功：&quot;</span> + hexFile.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是对所有输入文件进行插桩和 md5 值的比较，由于输入的文件既可能是 class 也可能是 jar 包（没开混淆上一个任务传过来的就是 class，开了混淆传过来的就是 jar 包，具体路径看注释），所以才会用 processClass() 和 processJar() 分别处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 class 文件执行插桩，并记录插装后的 md5，与上一次编译的备份 md5</span></span><br><span class="line"><span class="comment">     * 做比较，如果比较结果不相同，说明文件发生了变化，需要打包进补丁包中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationName Application 全类名对应的路径名，如：com\demo\plugin\Application</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file            待处理的 class 文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHexes        记录 Map&lt;class,String&gt; 类名与对应 md5 值的 Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patchGenerator  生成补丁包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processClass</span><span class="params">(Project project, String applicationName, File file, Map&lt;String, String&gt; newHexes,</span></span></span><br><span class="line"><span class="params"><span class="function">                          PatchGenerator patchGenerator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 截取文件的绝对路径，仅保留包名之后的部分，比如 filePath 为</span></span><br><span class="line">    <span class="comment">// app\build\intermediates\javac\debug\compileDebugJavaWithJavac\classes\com\demo\plugin\Test.class，</span></span><br><span class="line">    <span class="comment">// 那么截取后的 classPath 就是 com\demo\plugin\Test.class</span></span><br><span class="line">    String filePath = file.getAbsolutePath();</span><br><span class="line">    String classPath = filePath.split(<span class="string">&quot;classes&quot;</span>)[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (classPath.startsWith(applicationName) || Utils.isAndroidClass(classPath)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        project.getLogger().info(<span class="string">&quot;开始处理 class 文件：&quot;</span> + filePath);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">        <span class="comment">// 插桩</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = ClassUtils.referHackWhenInit(fis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成这个 class 文件的 16 进制 md5</span></span><br><span class="line">        String hex = Utils.hex(bytes);</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出插桩后的 class 文件</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(filePath);</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将本次的 md5 值存入缓存，并与上一次的 md5 进行对比</span></span><br><span class="line">        newHexes.put(classPath, hex);</span><br><span class="line">        patchGenerator.checkClass(classPath, hex, bytes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 jar 包中的 class 文件执行插桩，并记录插装后的 md5，与上一次编译的备份 md5</span></span><br><span class="line"><span class="comment">     * 做比较，如果比较结果不相同，说明文件发生了变化，需要打包进补丁包中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file            条件限定，这个 file 是个 jar 包</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hexes           保存类名及其 md5 值的 Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patchGenerator  生成补丁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJar</span><span class="params">(Project project, String applicationName, File file, Map&lt;String, String&gt; hexes,</span></span></span><br><span class="line"><span class="params"><span class="function">                        PatchGenerator patchGenerator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        applicationName = applicationName.replaceAll(Matcher.quoteReplacement(File.separator), <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        File backupJar = <span class="keyword">new</span> File(file.getParent(), file.getName() + <span class="string">&quot;.bak&quot;</span>);</span><br><span class="line"></span><br><span class="line">        JarOutputStream jarOutputStream = <span class="keyword">new</span> JarOutputStream(<span class="keyword">new</span> FileOutputStream(backupJar));</span><br><span class="line"></span><br><span class="line">        JarFile jarFile = <span class="keyword">new</span> JarFile(file);</span><br><span class="line">        Enumeration&lt;JarEntry&gt; entries = jarFile.entries();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">            JarEntry jarEntry = entries.nextElement();</span><br><span class="line">            String className = jarEntry.getName();</span><br><span class="line">            jarOutputStream.putNextEntry(<span class="keyword">new</span> JarEntry(className));</span><br><span class="line">            InputStream inputStream = jarFile.getInputStream(jarEntry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (className.endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; !className.startsWith(applicationName) &amp;&amp;</span><br><span class="line">                !Utils.isAndroidClass(className) &amp;&amp; !className.startsWith(<span class="string">&quot;com/demo/patch&quot;</span>)) &#123;</span><br><span class="line">                project.getLogger().info(<span class="string">&quot;开始处理 jar 包中的 class 文件：&quot;</span> + className);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = ClassUtils.referHackWhenInit(inputStream);</span><br><span class="line">                String hex = Utils.hex(bytes);</span><br><span class="line">                hexes.put(className, hex);</span><br><span class="line">                <span class="comment">// 对比缓存的 md5，不一致则放入补丁</span></span><br><span class="line">                patchGenerator.checkClass(className, hex, bytes);</span><br><span class="line">                jarOutputStream.write(bytes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 输出到临时文件</span></span><br><span class="line">                jarOutputStream.write(IOUtils.toByteArray(inputStream));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inputStream.close();</span><br><span class="line">            jarOutputStream.closeEntry();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jarOutputStream.close();</span><br><span class="line">        jarFile.close();</span><br><span class="line">        file.delete();</span><br><span class="line">        backupJar.renameTo(file);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二者的处理思路大致相同，都是先插桩：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 向  class 文件的构造方法中插入一句 Class cls = AntiLazyLoad.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] referHackWhenInit(InputStream inputStream) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ClassReader classReader = <span class="keyword">new</span> ClassReader(inputStream);</span><br><span class="line">        ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        ClassVisitor classVisitor = <span class="keyword">new</span> ClassVisitor(Opcodes.ASM6, classWriter) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">                MethodVisitor methodVisitor = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">                methodVisitor = <span class="keyword">new</span> MethodVisitor(api, methodVisitor) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;&lt;init&gt;&quot;</span>.equals(name) &amp;&amp; opcode == Opcodes.RETURN) &#123;</span><br><span class="line">                            <span class="comment">// 在构造方法末尾插入 AntiLazyLoad 引用</span></span><br><span class="line">                            <span class="keyword">super</span>.visitLdcInsn(Type.getType(<span class="string">&quot;Lcom/demo/plugin/AntiLazyLoad;&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> methodVisitor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        classReader.accept(classVisitor, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> classWriter.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将插桩后的 md5 值存入 Map&lt;String, String&gt; newHexes 中，再通过 PatchGenerator 把 newHexes 和 hexFile 中的 md5 作比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查本次编译的 md5 与上一次的是否相同，如果不同说明文件</span></span><br><span class="line"><span class="comment">     * 有变化，需要打包进补丁包</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className class 文件全类名对应的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHex    新编译后 class 文件的 md5 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes     新编译后 class 文件的字节内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClass</span><span class="params">(String className, String newHex, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Utils.isEmpty(prevHexes)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 newHex 不在缓存中或者与缓存中的值不相等，就要放入补丁包</span></span><br><span class="line">    String oldHex = prevHexes.get(className);</span><br><span class="line">    <span class="keyword">if</span> (oldHex == <span class="keyword">null</span> || !oldHex.equals(newHex)) &#123;</span><br><span class="line">        JarOutputStream jarOutputStream = getJarOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jarOutputStream.putNextEntry(<span class="keyword">new</span> JarEntry(className));</span><br><span class="line">            jarOutputStream.write(bytes);</span><br><span class="line">            jarOutputStream.closeEntry();</span><br><span class="line">            project.getLogger().info(<span class="string">&quot;放入补丁包，文件路径：&quot;</span> + className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>md5 不一致的类会被放入 patchClassFile 中，最后再用 generate() 执行 dx/d8 命令，对 patchClassFile 执行打包，生成最终的补丁包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行 dx 命令将 class/jar 文件打包成 dex 文件，Java Runtime 和</span></span><br><span class="line"><span class="comment">     * Gradle 都提供了运行 Java 命令的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!jarFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关流 jar 包才会去写数据</span></span><br><span class="line">    getJarOutputStream().close();</span><br><span class="line"></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    File localPropFile = project.getRootProject().file(<span class="string">&quot;local.properties&quot;</span>);</span><br><span class="line">    <span class="comment">// dx 命令在 sdk 中，先获取 sdk 路径，再拼接出 dx 命令的绝对路径</span></span><br><span class="line">    String sdkDir;</span><br><span class="line">    <span class="keyword">if</span> (localPropFile.exists()) &#123;</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(localPropFile));</span><br><span class="line">        sdkDir = properties.getProperty(<span class="string">&quot;sdk.dir&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sdkDir = System.getenv(<span class="string">&quot;ANDROID_HOME&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Windows 使用 dx.bat 命令，linux/mac 使用 dx 命令</span></span><br><span class="line">    String cmdExt = Os.isFamily(Os.FAMILY_WINDOWS) ? <span class="string">&quot;.bat&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String dxPath = sdkDir + <span class="string">&quot;/build-tools/&quot;</span> + buildToolsVersion + <span class="string">&quot;/dx&quot;</span> + cmdExt;</span><br><span class="line">    String patch = <span class="string">&quot;--output=&quot;</span> + patchFile.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">    project.exec(<span class="keyword">new</span> Action&lt;ExecSpec&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ExecSpec execSpec)</span> </span>&#123;</span><br><span class="line">            execSpec.commandLine(dxPath, <span class="string">&quot;--dex&quot;</span>, patch, jarFile.getAbsolutePath());</span><br><span class="line">            project.getLogger().info(<span class="string">&quot;执行了命令：&quot;</span> + (dxPath + <span class="string">&quot; --dex&quot;</span> + patch + jarFile.getAbsolutePath()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 class 组成的 jar 包</span></span><br><span class="line">    jarFile.delete();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*// 使用 Java Runtime 执行 dx 命令</span></span><br><span class="line"><span class="comment">        final String cmd = dxPath + &quot; --dex &quot; + patch + &quot; &quot; + jarFile.getAbsolutePath();</span></span><br><span class="line"><span class="comment">        Process process = Runtime.getRuntime().exec(cmd);</span></span><br><span class="line"><span class="comment">        process.waitFor();</span></span><br><span class="line"><span class="comment">        // 命令执行失败</span></span><br><span class="line"><span class="comment">        if (process.exitValue() != 0) &#123;</span></span><br><span class="line"><span class="comment">            throw new IOException(&quot;generate patch error:&quot; + cmd);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    project.getLogger().info(<span class="string">&quot;\npatch generated in : &quot;</span> + patchFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建新任务"><a href="#创建新任务" class="headerlink" title="创建新任务"></a>创建新任务</h3><p>最后就是创建一个新任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.创建打补丁的任务 patchDebug，依赖于 dex 打包任务</span></span><br><span class="line">Task task = project.getTasks().create(<span class="string">&quot;patch&quot;</span> + variantCapName);</span><br><span class="line">task.setGroup(<span class="string">&quot;patch&quot;</span>);</span><br><span class="line">task.dependsOn(dexTask);</span><br></pre></td></tr></table></figure>

<p>如果编译的是 debug 版本，任务名就是 patchDebug，属于 patch 组别，依赖于将混淆后的 class 打包成 dex 的任务 transformClassesWithDexBuilderForDebug，由于 Gradle 会根据所有任务之间的依赖关系形成一个有向无环图，所以执行 patchDebug 任务，就会按照依赖关系将其前面的编译-&gt;混淆-&gt;插桩-&gt;打补丁包-&gt;生成 dex 这一系列任务都执行，进而得到补丁包了：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> 执行所有模块的 patchDebug</span><br><span class="line">&gt;gradlew patchDebug</span><br><span class="line"><span class="params">#</span> 执行 app 模块的 patchDebug</span><br><span class="line">&gt;gradlew :app:patchDebug</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>设置 debug 编译也生成补丁包，没有开混淆的情况下，初次编译会生成一个 hex.txt 文件：</p>
<p><img src="/images/android_hot_fix12.png" alt="img"></p>
<p>接着修改 app 模块中的 Test.java 文件，随便增加个测试语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 增加的语句</span></span><br><span class="line">        Class clazz = Test.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次编译，发现 hex.txt 中 Test.class 的 md5 值发生了变化，并且在 patch/debug 下会生成 patch.jar 文件，也就是补丁包：</p>
<p><img src="/images/android_hot_fix13.png" alt="img"></p>
<p>使用 jadx 工具打开 patch.jar，发现里面只有 Test 文件，并且在构造方法的尾部被字节码插桩引入了 AntiLazyLoad.class，证明 Demo 的基本功能还是实现了：</p>
<p><img src="/images/android_hot_fix14.png" alt="img"></p>
<p>如果开启了混淆，那么 app 模块中的类被编译成 class 文件后，还会再被打包进一个 jar 包，再传递给 transformClassesWithDexBuilderForDebug 任务。首次编译的 hex.txt 以及备份的 mapping.txt 如下：</p>
<p><img src="/images/android_hot_fix15.png" alt="img"></p>
<p>对上述文件做出更改，让 MainActivity 调用 Test 中新增的方法 newMethod() 后再次编译，结果如下：</p>
<p><img src="/images/android_hot_fix16.png" alt="img"></p>
<p>查看 patch.jar 的内容也确实是与修改内容相符，并且两个修改的类的构造方法都被插桩引用了 AntiLazyLoad.class：</p>
<p><img src="/images/android_hot_fix17.png" alt="img"></p>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>主要有二，加 log 和打断点。</p>
<p>Demo 中有很多地方加了类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project.getLogger().info(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这是添加了 Gradle log，执行任务时会在控制台输出，log 的级别从低到高为：DEBUG、INFO、LIFECYCLE、WARNING、QUITE、ERROR，默认情况下控制台只会输出 LIFECYCLE 以及更高级别的 log，在执行命令时可以通过添加参数来改变 log 的输出级别：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">#</span> 输出 INFO 及更高级别的 log，还可以 -q、-d 等，分别对应 QUITE、DEBUG</span><br><span class="line">&gt; gradlew -i patchDebug</span><br></pre></td></tr></table></figure>

<p>除了加 log 我们还可以打断点，先在 Run/Debug Configurations 中点击 + 添加一个 Remote 类型的 Configuration：</p>
<p><img src="/images/android_hot_fix18.png" alt="img"></p>
<p>然后在命令行中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 比如说上图中新建的 Remote 名字为 GradleDebug，那么 TaskName 填 GradleDebug 即可</span><br><span class="line">&gt; gradlew [TaskName] -Dorg.gradle.debug=true --no-daemon</span><br></pre></td></tr></table></figure>

<p>最后点击 debug 按钮就可以进行断点调试了：</p>
<p><img src="/images/android_hot_fix19.png" alt="img"></p>
<p>Demo 代码地址：<a target="_blank" rel="noopener" href="https://github.com/tmacfrank/GradlePluginDemo/">GradlePluginDemo</a></p>
<p>参考文章：<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a">安卓App热补丁动态修复技术介绍</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286341&idx=1&sn=054d595af6e824cbe4edd79427fc2706&scene=0#wechat_redirect">Android N混合编译与对热补丁影响解析</a><br><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/09/14/android-robust.html">Android热更新方案Robust</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286384&idx=1&sn=f1aff31d6a567674759be476bcd12549&scene=4#wechat_redirect">微信Tinker的一切都在这里，包括源码(一)</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/" rel="tag"># 热修复</a>
              <a href="/tags/HotFix/" rel="tag"># HotFix</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/11/03/android_anr_analyze/" rel="prev" title="Android ANR原理分析及解决办法">
                  <i class="fa fa-chevron-left"></i> Android ANR原理分析及解决办法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/11/24/android_screen_adjust/" rel="next" title="Android 屏幕适配">
                  Android 屏幕适配 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小贾</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  





</body>
</html>
