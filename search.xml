<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++实现二分查找</title>
    <url>/2017/10/17/algorithm_binary_search/</url>
    <content><![CDATA[<p>二分查找又称折半查找，二分查找是针对有序数组所用的一种快速查找元素的方法。</p>
<span id="more"></span>

<h1 id="二分查找的条件及优缺点"><a href="#二分查找的条件及优缺点" class="headerlink" title="二分查找的条件及优缺点"></a>二分查找的条件及优缺点</h1><p>条件：针对有序数组（元素从小到大或从大到小）<br>优点：查询速度较快，时间复杂度为O（n）<br>缺点：有硬性条件的限制，而且即使查到后，插入与删除困难。</p>
<h1 id="二分查找的图解"><a href="#二分查找的图解" class="headerlink" title="二分查找的图解"></a>二分查找的图解</h1><p><img src="/images/algorithm_binary_seach_pic_desc.jpg" alt="img"></p>
<h1 id="二分查找的C-实现"><a href="#二分查找的C-实现" class="headerlink" title="二分查找的C++实现"></a>二分查找的C++实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *array, <span class="keyword">int</span> aSize, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( array == <span class="literal">nullptr</span> || aSize == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = aSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( low &lt;= high )</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low + high )/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( array[mid] &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( array[mid] &gt; key )</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> array[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">50</span>; i++)</span><br><span class="line">        array[i] = i;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;pos = &quot;</span>&lt;&lt;<span class="built_in">binarySearch</span>(array, <span class="number">50</span>, <span class="number">17</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法解题套路示例</title>
    <url>/2019/04/19/algorithm_back_track_base/</url>
    <content><![CDATA[<p>回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的细微差别是：<strong>回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」</strong>。</p>
<span id="more"></span>

<p>直接上回溯算法框架，解决一个回溯问题，实际上就是一个决策树的遍历过程，站在回溯树的一个节点上，你只需要思考 3 个问题：</p>
<p>1、路径：也就是已经做出的选择。</p>
<p>2、选择列表：也就是你当前可以做的选择。</p>
<p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p>
<p>回溯算法伪代码套路：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong>。</p>
<p>下面通过全排列问题和N皇后问题展开进行理解。</p>
<h1 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h1><h2 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p>示例 1：<br>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<p>示例 2：<br>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]</p>
<p>示例 3：<br>输入：nums = [1]<br>输出：[[1]]</p>
<blockquote>
<p>提示：<br>1 &lt;= nums.length &lt;= 6<br>-10 &lt;= nums[i] &lt;= 10<br>nums 中的所有整数 互不相同</p>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>我们在高中的时候就做过排列组合的数学题，我们也知道 <code>n</code> 个不重复的数，全排列共有 <code>n!</code> 个。那么我们当时是怎么穷举全排列的呢？</p>
<p>比方说给三个数 <code>[1,2,3]</code>，你肯定不会无规律地乱穷举，一般是这样：</p>
<p>先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……</p>
<p>其实这就是回溯算法，如下这棵回溯树：</p>
<p><img src="/images/algorithm_back_track_base01.png" alt="img"></p>
<p>只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。<strong>我们不妨把这棵树称为回溯算法的「决策树」</strong>。</p>
<p><strong>为啥说这是决策树呢，因为你在每个节点上其实都在做决策</strong>。</p>
<p>比如现在到了第二层的节点2，你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。</p>
<p><strong>现在可以解答开头的几个名词：<code>[2]</code> 就是「路径」，记录你已经做过的选择；<code>[1,3]</code> 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层叶子节点，这里也就是选择列表为空的时候</strong>。</p>
<p>如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个蓝色节点的属性：</p>
<p><img src="/images/algorithm_back_track_base02.png" alt="img"></p>
<p><strong>我们定义的 <code>backtrack</code> 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层叶子节点，其「路径」就是一个全排列</strong>。</p>
<p>再进一步，如何遍历一棵树？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.childern) &#123;</span><br><span class="line">        <span class="comment">// 前序位置需要的操作</span></span><br><span class="line">        traverse(child);</span><br><span class="line">        <span class="comment">// 后序位置需要的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们只要在递归之前做出选择，在递归之后撤销刚才的选择</strong>，就能正确得到每个节点的选择列表和路径。</p>
<p>下面，直接看全排列代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    backtrack(nums, track, used);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素（used[i] 为 false）</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track, <span class="keyword">boolean</span>[] used)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(track.size() == nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//排除不合法的选择，nums[i]已经在track中，跳过</span></span><br><span class="line">        <span class="keyword">if</span>(used[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        used[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track, used);</span><br><span class="line">        <span class="comment">//取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">        used[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h1><h2 id="题面描述-1"><a href="#题面描述-1" class="headerlink" title="题面描述"></a>题面描述</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/images/algorithm_back_track_base03.png" alt="img"></p>
<p>输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。</p>
<p>示例 2：<br>输入：n = 1<br>输出：[[“Q”]]</p>
<blockquote>
<p>提示：<br>1 &lt;= n &lt;= 9</p>
</blockquote>
<h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p>
<p>直接先上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; resQueens;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    resQueens = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = n;</span><br><span class="line">    <span class="comment">// &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘</span></span><br><span class="line">    <span class="keyword">final</span> StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; board = <span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">                add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    backTrackQueens(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> resQueens;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrackQueens</span><span class="params">(List&lt;String&gt; board, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="comment">//触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span>(board.size() == row)&#123;</span><br><span class="line">        resQueens.add(<span class="keyword">new</span> ArrayList&lt;&gt;(board));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = board.get(row).length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">        <span class="comment">//排除不合法的选项</span></span><br><span class="line">        <span class="keyword">if</span>(!isValid(board, row, col))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        String rowStr = board.get(row);</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        board.set(row, setIndexChar(rowStr, col, <span class="string">&#x27;Q&#x27;</span>));</span><br><span class="line">        <span class="comment">//进入下一行决策</span></span><br><span class="line">        backTrackQueens(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        board.set(row, setIndexChar(rowStr, col, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 是否可以在 board[row][col] 放置皇后？ */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(List&lt;String&gt; board, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.size();</span><br><span class="line">    <span class="comment">//同一列检测</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;Q&#x27;</span>==(board.get(i).charAt(column)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左上检测</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">1</span>, j=column-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;Q&#x27;</span>==(board.get(i).charAt(j)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右上检测</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row-<span class="number">1</span>, j=column+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&lt;n;i--,j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;Q&#x27;</span>==(board.get(i).charAt(j)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">setIndexChar</span><span class="params">(String rowStr, <span class="keyword">int</span> index, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = rowStr.toCharArray();</span><br><span class="line">    chars[index] = c;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>backtrack</code> 依然像个在决策树上游走的指针，通过 <code>row</code> 和 <code>col</code> 就可以表示函数遍历到的位置，通过 <code>isValid</code> 函数可以将不符合条件的情况剪枝：</p>
<p><code>N</code> 行棋盘中，第一行有 <code>N</code> 个位置可能可以放皇后，第二行有 <code>N - 1</code> 个位置，第三行有 <code>N - 2</code> 个位置，以此类推，再叠加每次放皇后之前 <code>isValid</code> 函数所需的 O(N) 复杂度，所以总的时间复杂度上界是 O(N! * N)，而且没有什么明显的冗余计算可以优化效率。你可以试试 <code>N = 10</code> 的时候，计算就已经很耗时了。</p>
<p>当然，因为有 <code>isValid</code> 函数剪枝，并不会真的在每个位置都尝试放皇后，所以实际的执行效率会高一些。但是这个时间复杂度作为上界是没问题的。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树基础算法</title>
    <url>/2018/12/27/algorithm_binary_tree_base/</url>
    <content><![CDATA[<p>二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着回溯算法核心框架和动态规划核心框架。</p>
<span id="more"></span>

<h1 id="示例一：二叉树的最大深度"><a href="#示例一：二叉树的最大深度" class="headerlink" title="示例一：二叉树的最大深度"></a>示例一：二叉树的最大深度</h1><h2 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h2><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>9  20</span><br><span class="line">  /  <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>这题的思路是什么？显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，<strong>这就是遍历二叉树计算答案的思路</strong>。<br>解法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录最大深度</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录遍历到的节点的深度</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	traverse(root);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 前序位置</span></span><br><span class="line">	depth++;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达叶子节点，更新最大深度</span></span><br><span class="line">		res = Math.max(res, depth);</span><br><span class="line">    &#125;</span><br><span class="line">	traverse(root.left);</span><br><span class="line">	traverse(root.right);</span><br><span class="line">	<span class="comment">// 后序位置</span></span><br><span class="line">	depth--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法应该很好理解，但为什么需要在前序位置增加 <code>depth</code>，在后序位置减小 <code>depth</code>？<br>因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，<code>depth</code> 记录当前递归到的节点深度，你把 <code>traverse</code> 理解成在二叉树上游走的一个指针，所以当然要这样维护。<br>至于对 <code>res</code> 的更新，你放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即 <code>depth</code> 自增之后，自减之前）就行了。<br>当然，你也很容易发现一棵二叉树的最大深度可以通过子树的最大深度推导出来，<strong>这就是分解问题计算答案的思路</strong>。</p>
<p>解法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义：输入根节点，返回这棵二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 利用定义，计算左右子树的最大深度</span></span><br><span class="line">	<span class="keyword">int</span> leftMax = maxDepth(root.left);</span><br><span class="line">	<span class="keyword">int</span> rightMax = maxDepth(root.right);</span><br><span class="line">	<span class="comment">// 整棵树的最大深度等于左右子树的最大深度取最大值，</span></span><br><span class="line">    <span class="comment">// 然后再加上根节点自己</span></span><br><span class="line">	<span class="keyword">int</span> res = Math.max(leftMax, rightMax) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？<br>因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。</p>
<h1 id="示例二：二叉树的直径"><a href="#示例二：二叉树的直径" class="headerlink" title="示例二：二叉树的直径"></a>示例二：二叉树的直径</h1><h2 id="题面描述-1"><a href="#题面描述-1" class="headerlink" title="题面描述"></a>题面描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p>示例 :<br>给定二叉树</p>
<pre><code>      1
     / \
    2   3
   / \     
  4   5    
</code></pre>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p>
<h2 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h2><p>所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度。最长「直径」并不一定要穿过根结点，比如上面这棵二叉树，它的最长直径是 [4,2,1,3] 或者 [5,2,1,3]。<br>解决这题的关键在于，<strong>每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和</strong>。<br>现在让我求整棵树中的最长「直径」，那直截了当的思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的「直径」，最后把所有「直径」求个最大值即可。<br>最大深度的算法我们刚才实现过了，上述思路就可以写出以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录最大直径的长度</span></span><br><span class="line"><span class="keyword">int</span> maxDiameter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对每个节点计算直径，求最大直径</span></span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> maxDiameter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个节点计算直径</span></span><br><span class="line">    <span class="keyword">int</span> leftMax = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">int</span> myDiameter = leftMax + rightMax;</span><br><span class="line">    <span class="comment">// 更新全局最大直径</span></span><br><span class="line">    maxDiameter = Math.max(maxDiameter, myDiameter);</span><br><span class="line">    </span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算二叉树的最大深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leftMax = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法是正确的，但是运行时间很长，原因也很明显，<code>traverse</code> 遍历每个节点的时候还会调用递归函数 <code>maxDepth</code>，而 <code>maxDepth</code> 是要遍历子树的所有节点的，所以最坏时间复杂度是 O(N^2)。<br>这就出现了刚才探讨的情况，<strong>前序位置无法获取子树信息，所以只能让每个节点调用 <code>maxDepth</code> 函数去算子树的深度</strong>。<br>那如何优化？我们应该把计算「直径」的逻辑放在后序位置，准确说应该是放在 <code>maxDepth</code> 的后序位置，因为 <code>maxDepth</code> 的后序位置是知道左右子树的最大深度的。<br>所以，稍微改一下代码逻辑即可得到更好的解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录最大直径的长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> maxDiameter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    maxDepth(root);</span><br><span class="line">    <span class="keyword">return</span> maxDiameter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax = maxDepth(root.right);</span><br><span class="line">    <span class="comment">// 后序位置，顺便计算最大直径</span></span><br><span class="line">    maxDiameter = Math.max(maxDiameter, leftMax + rightMax);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax ,rightMax) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这下时间复杂度只有 <code>maxDepth</code> 函数的 O(N) 了。</p>
<h1 id="示例三：在每个树行中找最大值"><a href="#示例三：在每个树行中找最大值" class="headerlink" title="示例三：在每个树行中找最大值"></a>示例三：在每个树行中找最大值</h1><h2 id="题面描述-2"><a href="#题面描述-2" class="headerlink" title="题面描述"></a>题面描述</h2><p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p>
<p><strong>示例1：</strong></p>
<p><img src="/images/algorithm_binary_tree_base01.png" alt="img"></p>
<p>输入: root = [1,3,2,5,3,null,9]<br>输出: [1,3,9]<br>示例2：</p>
<p>输入: root = [1,2,3]<br>输出: [1,3]</p>
<blockquote>
<p>提示：<br>二叉树的节点个数的范围是 [0,10^4]<br>-2^31 &lt;= Node.val &lt;= 2^31 - 1</p>
</blockquote>
<h2 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h2><p>既然是找每一层中的最大值，那就必须执行过程中树的每层数据是清晰明了的，然后找出最大值。</p>
<p>这就要说一下二叉树的层序遍历了，而层序遍历属于迭代遍历，也比较简单，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            TreeNode poll = queue.poll();</span><br><span class="line">            System.out.print(poll.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span>(poll.left!=<span class="keyword">null</span>)</span><br><span class="line">                queue.offer(poll.left);</span><br><span class="line">            <span class="keyword">if</span>(poll.right!=<span class="keyword">null</span>)</span><br><span class="line">                queue.offer(poll.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面 while 循环和 for 循环分管从上到下和从左到右的遍历：</p>
<p><img src="/images/algorithm_binary_tree_base02.png" alt="image"></p>
<p>层序遍历搞清楚后，那上面的问题就好处理了，只需要找出每层的最大值即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">largestValues</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">int</span> max = queue.peek().val;</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            TreeNode poll = queue.poll();</span><br><span class="line">            <span class="comment">//更新最大值</span></span><br><span class="line">            max = Math.max(max, poll.val);</span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span>(poll.left!=<span class="keyword">null</span>)</span><br><span class="line">                queue.offer(poll.left);</span><br><span class="line">            <span class="keyword">if</span>(poll.right!=<span class="keyword">null</span>)</span><br><span class="line">                queue.offer(poll.right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>数组算法-双指针技巧</title>
    <url>/2019/04/07/algorithm_array_double_point/</url>
    <content><![CDATA[<p>在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：左右指针和快慢指针。<br>所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行，一快一慢。<br>在数组中并没有真正意义上的指针，但我们可以把索引当做数组中的指针，这样也可以在数组中施展双指针技巧</p>
<span id="more"></span>

<h1 id="示例一：删除有序数组中的重复项"><a href="#示例一：删除有序数组中的重复项" class="headerlink" title="示例一：删除有序数组中的重复项"></a>示例一：删除有序数组中的重复项</h1><h2 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h2><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。<br>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。<br>将最终结果插入 nums 的前 k 个位置后返回 k 。<br>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。<br>判题标准:<br>系统会用下面的代码来测试你的题解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] nums = [...]; <span class="comment">// 输入数组</span></span><br><span class="line"><span class="keyword">int</span>[] expectedNums = [...]; <span class="comment">// 长度正确的期望答案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = removeDuplicates(nums); <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> k == expectedNums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="keyword">assert</span> nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p>示例 1：</p>
<p>输入：nums = [1,1,2]<br>输出：2, nums = [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p>
<p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p>
<blockquote>
<p>提示：<br>1 &lt;= nums.length &lt;= 3 * 10^4<br>-10^4 &lt;= nums[i] &lt;= 10^4<br>nums 已按 升序 排列</p>
</blockquote>
<h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>简单解释一下什么是原地修改：<br>如果不是原地修改的话，我们直接 new 一个 <code>int[]</code> 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。<br>但是现在题目让你原地删除，不允许 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。<br>由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。但如果毎找到一个重复元素就立即原地删除它，由于数组中删除元素涉及数据搬移，整个时间复杂度是会达到 <code>O(N^2)</code>。<br>高效解决这道题就要用到快慢指针技巧：<br>我们让慢指针 <code>slow</code> 走在后面，快指针 <code>fast</code> 走在前面探路，找到一个不重复的元素就赋值给 <code>slow</code> 并让 <code>slow</code> 前进一步。<br>这样，就保证了 <code>nums[0..slow]</code> 都是无重复的元素，当 <code>fast</code> 指针遍历完整个数组 <code>nums</code> 后，<code>nums[0..slow]</code> 就是整个数组去重之后的结果。<br>看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[slow]!=nums[fast])&#123;</span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] 无重复</span></span><br><span class="line">            nums[++slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组长度为索引 + 1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例二：移除元素"><a href="#示例二：移除元素" class="headerlink" title="示例二：移除元素"></a>示例二：移除元素</h1><h2 id="题面描述-1"><a href="#题面描述-1" class="headerlink" title="题面描述"></a>题面描述</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例 1：</p>
<p>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。<br>示例 2：</p>
<p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br>输出：5, nums = [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p>
<blockquote>
<p>提示：<br>0 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 50<br>0 &lt;= val &lt;= 100</p>
</blockquote>
<h2 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h2><p>题目要求我们把 <code>nums</code> 中所有值为 <code>val</code> 的元素原地删除，依然需要使用快慢指针技巧：</p>
<p>如果 <code>fast</code> 遇到值为 <code>val</code> 的元素，则直接跳过，否则就赋值给 <code>slow</code> 指针，并让 <code>slow</code> 前进一步。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast&lt;nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例三：移动零"><a href="#示例三：移动零" class="headerlink" title="示例三：移动零"></a>示例三：移动零</h1><h2 id="题面描述-2"><a href="#题面描述-2" class="headerlink" title="题面描述"></a>题面描述</h2><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>示例 1:</p>
<p>输入: nums = [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p>
<p>输入: nums = [0]<br>输出: [0]</p>
<blockquote>
<p>提示:<br>1 &lt;= nums.length &lt;= 104<br>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</p>
</blockquote>
<h2 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h2><p>题目让我们将所有 0 移到最后，其实就相当于移除 <code>nums</code> 中的所有 0，然后再把后面的元素都赋值为 0 即可。</p>
<p>所以我们可以复用上一题的 <code>removeElement</code> 函数，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast&lt;nums.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!=<span class="number">0</span>)&#123;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将slow以后的索引为赋值为0</span></span><br><span class="line">    <span class="keyword">while</span> (slow&lt;nums.length)&#123;</span><br><span class="line">        nums[slow++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例四：两数之和-II-输入有序数组"><a href="#示例四：两数之和-II-输入有序数组" class="headerlink" title="示例四：两数之和 II - 输入有序数组"></a>示例四：两数之和 II - 输入有序数组</h1><h2 id="题面描述-3"><a href="#题面描述-3" class="headerlink" title="题面描述"></a>题面描述</h2><p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。<br>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。<br>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。<br>你所设计的解决方案必须只使用常量级的额外空间。</p>
<p>示例 1：</p>
<p>输入：numbers = [2,7,11,15], target = 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。<br>示例 2：</p>
<p>输入：numbers = [2,3,4], target = 6<br>输出：[1,3]<br>解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。<br>示例 3：</p>
<p>输入：numbers = [-1,0], target = -1<br>输出：[1,2]<br>解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</p>
<blockquote>
<p>提示：<br>2 &lt;= numbers.length &lt;= 3 * 10^4<br>-1000 &lt;= numbers[i] &lt;= 1000<br>numbers 按 非递减顺序 排列<br>-1000 &lt;= target &lt;= 1000<br>仅存在一个有效答案</p>
</blockquote>
<h2 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h2><p>只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 <code>left</code> 和 <code>right</code> 就可以调整 <code>sum</code> 的大小：</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            <span class="comment">// 题目要求的索引是从 1 开始的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">            <span class="comment">// 让 sum 大一点</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 让 sum 小一点</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例五：反转字符串"><a href="#示例五：反转字符串" class="headerlink" title="示例五：反转字符串"></a>示例五：反转字符串</h1><h2 id="题面描述-4"><a href="#题面描述-4" class="headerlink" title="题面描述"></a>题面描述</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。<br>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>示例 1：</p>
<p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：s = [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<blockquote>
<p>提示：<br>1 &lt;= s.length &lt;= 10^5<br>s[i] 都是 ASCII 码表中的可打印字符</p>
</blockquote>
<h2 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h2><p>同样使用左右指针可迎刃而解，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一左一右两个指针相向而行</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="comment">// 交换 s[left] 和 s[right]</span></span><br><span class="line">        <span class="keyword">char</span> temp = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="示例六：最长回文子串"><a href="#示例六：最长回文子串" class="headerlink" title="示例六：最长回文子串"></a>示例六：最长回文子串</h1><h2 id="题面描述-5"><a href="#题面描述-5" class="headerlink" title="题面描述"></a>题面描述</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。<br>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p>示例 1：</p>
<p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p>
<p>输入：s = “cbbd”<br>输出：”bb”</p>
<blockquote>
<p>提示：<br>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母组成</p>
</blockquote>
<h2 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h2><p>找回文串的难点在于，回文串的的长度可能是奇数也可能是偶数，解决该问题的核心是<strong>从中心向两端扩散的双指针技巧</strong>。</p>
<p>如果回文串的长度为奇数，则它有一个中心字符；如果回文串的长度为偶数，则可以认为它有两个中心字符。所以我们可以先实现这样一个函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">palindrome</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止索引越界</span></span><br><span class="line">    <span class="keyword">while</span> (l &gt;=<span class="number">0</span> &amp;&amp; r &lt; s.length()</span><br><span class="line">            &amp;&amp; s.charAt(l) == s.charAt(r))&#123;</span><br><span class="line">        <span class="comment">// 双指针，向两边展开</span></span><br><span class="line">        l--;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回以 s[l] 和 s[r] 为中心的最长回文串</span></span><br><span class="line">    <span class="keyword">return</span> s.substring(l+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果输入相同的 <code>l</code> 和 <code>r</code>，就相当于寻找长度为奇数的回文串，如果输入相邻的 <code>l</code> 和 <code>r</code>，则相当于寻找长度为偶数的回文串。</p>
<p>最终代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="comment">// 以 s[i] 为中心的最长回文子串</span></span><br><span class="line">        String s1 = palindrome(s, i, i);</span><br><span class="line">        <span class="comment">// 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line">        String s2 = palindrome(s, i, i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//比较找到的回文串，更新最大值</span></span><br><span class="line">        res = res.length() &gt; s1.length()?res:s1;</span><br><span class="line">        res = res.length() &gt; s2.length()?res:s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划解题套路示例</title>
    <url>/2019/05/08/algorithm_dynamic_program_base/</url>
    <content><![CDATA[<p><strong>动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。</p>
<p>既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p>
<span id="more"></span>

<p>虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出<strong>正确的「状态转移方程」</strong>，才能正确地穷举。而且，你需要判断算法问题是否<strong>具备「最优子结构」</strong>，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多人觉得动态规划问题困难的原因。</p>
<p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code>dp</code> 数组/函数的含义</strong>。</p>
<p>按上面的套路走，最后的解法代码就会是如下的框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自顶向下递归的动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">状态<span class="number">1</span>, 状态<span class="number">2</span>, ...</span>):</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 所有可能的选择:</span><br><span class="line">        <span class="comment"># 此时的状态已经因为做了选择而改变</span></span><br><span class="line">        result = 求最值(result, dp(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自底向上迭代的动态规划</span></span><br><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base case</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="示例：凑零钱问题"><a href="#示例：凑零钱问题" class="headerlink" title="示例：凑零钱问题"></a>示例：凑零钱问题</h1><h2 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。<br>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。<br>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1</p>
<p>示例 2：</p>
<p>输入：coins = [2], amount = 3<br>输出：-1<br>示例 3：</p>
<p>输入：coins = [1], amount = 0<br>输出：0</p>
<blockquote>
<p>提示：<br>1 &lt;= coins.length &lt;= 12<br>1 &lt;= coins[i] &lt;= 2^31 - 1<br>0 &lt;= amount &lt;= 10^4</p>
</blockquote>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// coins 中是可选硬币面值，amount 是目标金额</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>;</span><br></pre></td></tr></table></figure>

<p>比如说 <code>k = 3</code>，面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p>
<h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？用一个直观的例子来讲解。</p>
<p>比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。</p>
<p>得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，「每门科目考到最高」这些子问题是互相独立，互不干扰的。</p>
<p>但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，不能同时达到满分，数学分数高，语文分数就会降低，反之亦然。</p>
<p>这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为「每门科目考到最高」的子问题并不独立，语文数学成绩户互相影响，无法同时最优，所以最优子结构被破坏。</p>
<p>回到凑零钱问题，为什么说它符合最优子结构呢？假设你有面值为 <code>1, 2, 5</code> 的硬币，你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10, 9, 6</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 <code>1, 2, 5</code> 的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p>
<p>那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？</p>
<p><strong>1、确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p>
<p><strong>2、确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p>
<p><strong>3、确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p>
<p><strong>4、明确 <code>dp</code> 函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。</p>
<p><strong>所以我们可以这样定义 <code>dp</code> 函数：<code>dp(n)</code> 表示，输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 所需的最少硬币数量</strong>。</p>
<p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪码框架</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 题目要求的最终结果是 dp(amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(coins, amount)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做选择，选择需要硬币最少的那个结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        res = min(res, <span class="number">1</span> + dp(coins, n - coin))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp(coins, amount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">        <span class="comment">//计算子问题的结果</span></span><br><span class="line">        <span class="keyword">int</span> subResult = dp(coins, amount - coin);</span><br><span class="line">        <span class="comment">//子问题无解，则跳过</span></span><br><span class="line">        <span class="keyword">if</span>(subResult == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//在子问题中选择最优解，然后+1</span></span><br><span class="line">        res = Math.min(res, subResult + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res==Integer.MAX_VALUE?-<span class="number">1</span>:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = &#123;1,2,5&#125;</code> 时画出递归树看看：</p>
<p><img src="/images/algorithm_dynamic_program01.png" alt="img"></p>
<p><strong>递归算法的时间复杂度分析：子问题总数 x 解决每个子问题所需的时间</strong>。</p>
<p>子问题总数为递归树的节点个数，但算法会进行剪枝，剪枝的时机和题目给定的具体硬币面额有关，所以可以想象，这棵树生长的并不规则，确切算出树上有多少节点是比较困难的。对于这种情况，我们一般的做法是按照最坏的情况估算一个时间复杂度的上界。</p>
<p>假设目标金额为 <code>n</code>，给定的硬币个数为 <code>k</code>，那么递归树最坏情况下高度为 <code>n</code>（全用面额为 1 的硬币），然后再假设这是一棵满 <code>k</code> 叉树，则节点的总数在 <code>k^n</code> 这个数量级。</p>
<p>接下来看每个子问题的复杂度，由于每次递归包含一个 for 循环，复杂度为 <code>O(k)</code>，相乘得到总时间复杂度为 <code>O(k^n)</code>，指数级别。</p>
<h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>其实就是通过上文说的通过dp table来记录子问题结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange2</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//备忘录初始化一个不会被取到的特殊值，代表还未被计算。</span></span><br><span class="line">    Arrays.fill(memo, -<span class="number">666</span>);</span><br><span class="line">    <span class="keyword">return</span> dp2(coins, amount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//查询备忘录，防止重复计算</span></span><br><span class="line">    <span class="keyword">if</span>(memo[amount]!=-<span class="number">666</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[amount];</span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">        <span class="comment">//计算子问题的结果</span></span><br><span class="line">        <span class="keyword">int</span> subResult = dp2(coins, amount - coin);</span><br><span class="line">        <span class="comment">//子问题无解，则跳过</span></span><br><span class="line">        <span class="keyword">if</span>(subResult==-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//在子问题中选择最优解，然后+1</span></span><br><span class="line">        res = Math.min(res, subResult + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把计算结果存入备忘录</span></span><br><span class="line">    memo[amount] = res == Integer.MAX_VALUE?-<span class="number">1</span>:res;</span><br><span class="line">    <span class="keyword">return</span> memo[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 <code>O(n)</code>。处理一个子问题的时间不变，仍是 <code>O(k)</code>，所以总的时间复杂度是 <code>O(kn)</code>。</p>
<h2 id="dp数组的迭代解法"><a href="#dp数组的迭代解法" class="headerlink" title="dp数组的迭代解法"></a>dp数组的迭代解法</h2><p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p>
<p><strong><code>dp</code> 数组的定义：当目标金额为 <code>i</code> 时，至少需要 <code>dp[i]</code> 枚硬币凑出</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChangeDp</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组大小为amount+1，初始值也为amount+1</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++)&#123;</span><br><span class="line">        <span class="comment">// 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">            <span class="comment">// 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i - coin &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount]==amount + <span class="number">1</span>)?-<span class="number">1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为啥 <code>dp</code> 数组中的值都初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。为啥不直接初始化为 int 型的最大值 <code>Integer.MAX_VALUE</code> 呢？因为后面有 <code>dp[i - coin] + 1</code>，这就会导致整型溢出。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>使用链表实现LRU cache</title>
    <url>/2018/11/07/algorithm_linkedlist/</url>
    <content><![CDATA[<p>LRU（Least Recently Used，最近最少使用）算法是一种淘汰策略，简单来讲实现的是如下工作：将一些元素放在一个容量固定的容器中进行存取，由于容器的容量有限，该容器就要保证那些最近才被用到的元素始终在容器内，而将已经很久没有用的元素剔除，实现容器内元素的动态维护。这种算法是一种缓存维护策略，因为缓存空间有限，让缓存中存储的都是最近才被用到的元素可以实现系统缓存的高效运作。</p>
<span id="more"></span>

<h1 id="结构与设计"><a href="#结构与设计" class="headerlink" title="结构与设计"></a>结构与设计</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>实现一个类LRUCache。</p>
<blockquote>
<p><strong>1</strong>.实现类的构造方法，使得该类的使用者可以通过设置初始化容量来创建一个指定容量的LRUCache。<br><strong>2</strong>.实现该类对象的外部操作接口 —— get()成员函数。该函数的作用是查找一个指定的关键字是否在LRUCache对象中，如果在，返回该关键字的值，否则返回-1。即输入参数为一个int值key，返回一个int，代表LRUCache中关键字key对应的值。<br><strong>3</strong>.实现该类对象的外部操作接口 —— put()成员函数。该函数的作用是将一个指定的键值对放入LRUCache对象中，该函数不需要向外返回任何值。即输入参数为一个int值key和一个int值value（代表一个键值对key-value），如果LRUCache中已存在该关键字key，则用参数列表中的value值更新LRUCache中key关键字对应的value，如果缓存中不存在该关键字key，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过缓存的初始容量 capacity ，则应该从缓存中删除最久未使用的关键字。</p>
</blockquote>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>根据以上要求，我们可以确定：</p>
<ol>
<li><p>LRUCache本身需要用一个具体的存储容器来实现，该容器内部存储的元素形式是键值对的形式，并且该容器查找元素是通过输入键，返回键所对应的值来实现的，因此可以确定，LRUCache容器本身可以使用哈希表这种数据结构来实现。并且根据键与值的参数类型可以确定，该哈希表的键和值都是int类型。</p>
</li>
<li><p>LRUCache的int get(int key)接口完成的操作是哈希表本身就可以完成的操作。同时，该接口定义了缓存中元素被使用的含义，即最近一次通过get接口被查询到的键值对元素是缓存中最近一次被使用到的元素。</p>
</li>
<li><p>LRUCache的void put(int key, int value)接口完成的操作隐含了动态维护LRUCache中元素的需求。动态维护的方法就是LRU算法，即将LRUCache中的元素（int键值对）按照使用的时间顺序排列。同时需要特别注意的是，该接口操作也定义了缓存中元素另一种被使用的含义，即最近一次通过put接口被放入缓存中的元素是缓存中最近一次被使用到的元素。<br>可以通过双向链表来实现LRU算法，细节如下：</p>
</li>
<li><p>双向链表的节点存储内容是用来实现LRUCache容器的哈希表元素（int类型键值对）</p>
</li>
<li><p>双向链表存在界限，即最大节点数就是LRUCache的容量。</p>
</li>
<li><p>每次通过int get(int key)接口查询到LRUCache中的一个元素，就将该元素在双向链表中移动到头部。</p>
</li>
<li><p>操作LRUCache的void put(int key, int value)接口可能会使得双向链表的节点数增加（当缓存中没有该key值，且缓存容量未满时），每次put操作（无论是存在key，只是更新value，还是不存在key，插入新的key-value对）都会将该put操作的key-value元素在双向链表中移动到头部</p>
</li>
<li><p>通过上述操作，双向链表的尾节点一定是LRUCache中最久没有被使用过的元素，则当双向链表超出限定长度后，删除超长的尾节点<br>要实现以上的双向链表操作，需要自己定义双向链表节点和相应的节点移动操作，在C++中可以通过自定义一个结构体或类来实现，其成员属性如下：</p>
</li>
</ol>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，双向链表中的节点类，key理解为页面号，val理解为页面内容</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Entry&lt;K, V&gt; prev;</span><br><span class="line">        <span class="keyword">public</span> Entry&lt;K, V&gt; next;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V val;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key, V val)</span> </span>&#123; <span class="keyword">this</span>.key = key; <span class="keyword">this</span>.val = val; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Entry&lt;K, V&gt; head, tail; <span class="comment">// 虚拟头节点和虚拟尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;     <span class="comment">// 缓存容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;               <span class="comment">// 缓存占用量</span></span><br><span class="line">    Map&lt;K, Entry&lt;K, V&gt;&gt; cache;      <span class="comment">// 哈希表，记录双向列表节点的地址值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        initCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化LRU缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> Entry&lt;&gt;();</span><br><span class="line">        tail = <span class="keyword">new</span> Entry&lt;&gt;();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="keyword">this</span>.capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K, V&gt; entry = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            moveToTail(entry);</span><br><span class="line">            <span class="keyword">return</span> entry.val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K, V&gt; entry = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span>(entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓存命中</span></span><br><span class="line">            entry.val = val;</span><br><span class="line">            moveToTail(entry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存未命中</span></span><br><span class="line">            <span class="keyword">if</span>(size == capacity) &#123;</span><br><span class="line">                <span class="comment">// 缓存已满，删除链表头部节点</span></span><br><span class="line">                Entry&lt;K, V&gt; h = head.next;</span><br><span class="line">                deleteEntry(h);</span><br><span class="line">                cache.remove(h.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加新页面到链表尾部</span></span><br><span class="line">            Entry&lt;K, V&gt; newEntry = <span class="keyword">new</span> Entry&lt;&gt;(key, val);</span><br><span class="line">            addToTail(newEntry);</span><br><span class="line">            cache.put(key, newEntry);</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToTail</span><span class="params">(Entry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">        deleteEntry(entry);</span><br><span class="line">        addToTail(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToTail</span><span class="params">(Entry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry.next = tail;</span><br><span class="line">            entry.prev = tail.prev;</span><br><span class="line">            tail.prev.next = entry;</span><br><span class="line">            tail.prev = entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K, V&gt; entry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry.prev.next = entry.next;</span><br><span class="line">            entry.next.prev = entry.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>,<span class="string">&quot;可口可乐&quot;</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>,<span class="string">&quot;雪碧&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;页面1的内容：&quot;</span> + cache.get(<span class="number">1</span>));</span><br><span class="line">        cache.put(<span class="number">3</span>,<span class="string">&quot;果粒橙&quot;</span>); <span class="comment">// 此时缓存已满，且页面2最久未被使用（因为cache.get(1)访问了页面1），页面2被置换成页面3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;页面2的内容：&quot;</span> + cache.get(<span class="number">2</span>)); <span class="comment">// 页面2已被换出，访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>C++实现贪心算法</title>
    <url>/2017/11/01/algorithm_greedy/</url>
    <content><![CDATA[<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解</p>
<span id="more"></span>

<h1 id="贪心算法思想"><a href="#贪心算法思想" class="headerlink" title="贪心算法思想"></a>贪心算法思想</h1><p><strong>1</strong>.贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。<br><strong>2</strong>.贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素。<br><strong>3</strong>.当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响。贪心算法对每个子问题的解决方案都做出选择，不能回退。<br><strong>4</strong>.贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止。<br><strong>5</strong>.实际上，贪心算法适用的情贪心算法(贪婪算法)况很少。一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。</p>
<p><strong>该算法存在的问题</strong><br>1.不能保证求得的最后解是最佳的<br>2.不能用来求最大值或最小值的问题<br>3.只能求满足某些约束条件的可行解的范围</p>
<p><strong>贪心算法的应用</strong></p>
<p>选择排序、平衡字符串、买股票最佳时机、无重叠区间</p>
<p>下文将分别展示这几种的应用。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>我们熟知的选择排序，其采用的就是贪心策略。 它所采用的贪心策略即为每次从未排序的数据中选取最小值，并把最小值放在未排序数据的起始位置，直到未排序的数据为0，则结束排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[minIndex])</span><br><span class="line">                minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr, minIndex, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="平衡字符串"><a href="#平衡字符串" class="headerlink" title="平衡字符串"></a>平衡字符串</h1><p>问题描述：<br>在一个 平衡字符串 中，‘L’ 和 ‘R’ 字符的数量是相同的。<br>给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。<br>注意：分割得到的每个字符串都必须是平衡字符串，且分割得到的平衡字符串是原平衡字符串的连续子串。<br>返回可以通过分割得到的平衡字符串的 最大数量 。</p>
<p>输入：s = “RLLLLRRRLR”<br>输出：3<br>解释：s 可以分割为 “RL”、”LLLRRR”、”LR” ，每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’ 。<br>解题思路: 不要有嵌套的平衡，只要达到平衡，就立即分割(贪心策略).我们假设 ‘R’ == 1, ‘L’ == -1 .只要累加等于 0 就算分割一次.</p>
<p><img src="/images/algorithm_greedy_etc_balance.png" alt="algorithm_greedy_etc_balance"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> balance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> i : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">            --balance;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++balance;</span><br><span class="line">        <span class="keyword">if</span>(balance == <span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="买股票最佳时机"><a href="#买股票最佳时机" class="headerlink" title="买股票最佳时机"></a>买股票最佳时机</h1><p>问题描述：<br>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>贪心策略：<br>连续上涨交易日：第一天买最后一天卖收益最大，等价于每天都买卖。<br>连续下降交易日：不买卖收益最大，即不会亏钱。<br>故可以遍历整个股票交易日价格列表，在所有上涨交易日都买卖（赚到所有利润），所有下降交易日都不买卖（永不亏钱）</p>
<p><img src="/images/algorithm_greedy_buy_shares.jpg" alt="algorithm_greedy_buy_shares"></p>
<p>例如从10到50是连续上涨的5天，可以第一天买入，最后一天卖出，利润为40，等价于第一天买入第二天卖出，第二天再买入。。。以此类推</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(prices[i] &lt;= prices[i+<span class="number">1</span>])</span><br><span class="line">			profit += prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h1><p>问题描述：<br>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:<br>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br>贪心策略：<br>法一：与上题活动选择类似，用总区间数减去最大可同时进行的区间数即为结果。<br>法二： 当按照起点先后顺序考虑区间时，利用一个prev指针追踪刚刚添加到最终列表中的区间。遍历时，可能遇到三种情况：<br>情况1：当前考虑的两个区间不重叠。这种情况下不移除任何区间，将prev赋值为后面的区间，移除区间数量不变。</p>
<p><img src="/images/algorithm_greedy_no_overlap_01.jpg" alt="algorithm_greedy_no_overlap_01"></p>
<p>情况2：两个区间重叠，后一个区间的终点在前一个区间的终点之前。由于后一个区间的长度更小，可以留下更多空间，容纳更多区间，将prev更新为当前区间，移除区间的数量+1</p>
<p><img src="/images/algorithm_greedy_no_overlap_02.jpg" alt="algorithm_greedy_no_overlap_02"></p>
<p>情况3：两个区间重叠，后一个区间的终点在前一个区间的终点之后。直接移除后一个区间，留下更多空间。因此，prev不变，移除区间的数量+1</p>
<p><img src="/images/algorithm_greedy_no_overlap_03.jpg" alt="algorithm_greedy_no_overlap_03"></p>
<p>代码实现： 法一：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; s1, vector&lt;<span class="keyword">int</span>&gt;&amp; s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1[<span class="number">1</span>] &lt; s2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), <span class="built_in">cmp</span>());</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; intervals.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[j][<span class="number">0</span>] &gt;= intervals[i][<span class="number">1</span>])&#123;</span><br><span class="line">                i = j;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.<span class="built_in">size</span>() - num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; s1, vector&lt;<span class="keyword">int</span>&gt;&amp; s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1[<span class="number">1</span>] &lt; s2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), <span class="built_in">cmp</span>());</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="comment">//情况1 不冲突</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt;= intervals[prev][<span class="number">1</span>])&#123;</span><br><span class="line">                prev = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>] &lt; intervals[prev][<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//情况2</span></span><br><span class="line">                    prev = i;</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法练习-巧用双指针</title>
    <url>/2017/09/07/algorithm_double_pointer/</url>
    <content><![CDATA[<p>看题：</p>
<span id="more"></span>

<h2 id="首尾双指针"><a href="#首尾双指针" class="headerlink" title="首尾双指针"></a>首尾双指针</h2><p>调整数组顺序使奇数位于偶数前面</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<p>对于这道题，最直接的想法就是遍历，然后相邻元素判断是否为一奇数一偶数，如果满足则交换，直至到尾部。有没有更好的解法呢？</p>
<p>这道题可以使用一个首尾双指针解决：</p>
<ol>
<li>定义头指针 left ，尾指针 right .</li>
<li>left 一直往右移，直到它指向的值为偶数</li>
<li>right 一直往左移， 直到它指向的值为奇数</li>
<li>交换 nums[left] 和 nums[right] .</li>
<li>重复上述操作，直到 left == right .</li>
</ol>
<p><img src="/images/algorithm_double_pointer_start_end_pointer.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]%<span class="number">2</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!(nums[right]%<span class="number">2</span>))&#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[left++], nums[right--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h2><p>链表中倒数第k个节点</p>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<p><img src="/images/algorithm_double_pointer_fast_slow_pointer.png" alt="image-20210705164118371"></p>
<p>快慢指针，先让快指针走k步，然后两个指针同步走，当快指针走到头时，慢指针就是链表倒数第k个节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">while</span>(n &lt; k)&#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;next)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-合并K个有序链表</title>
    <url>/2017/08/07/algorithm_linkedlist_mergeklist/</url>
    <content><![CDATA[<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<span id="more"></span>

<p>示例 1：</p>
<p>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>示例 2：</p>
<p>输入：lists = []<br>输出：[]<br>示例 3：</p>
<p>输入：lists = [[]]<br>输出：[]</p>
<hr>
<p>合并 <code>k</code> 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 <code>k</code> 个节点中的最小节点，接到结果链表上？</p>
<p>这里我们就要用到 <strong>优先级队列（PriorityQueue）</strong>这种数据结构，把链表节点放入一个最小堆，就可以每次获得 <code>k</code> 个节点中的最小节点：</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    <span class="comment">// 优先级队列，最小堆</span></span><br><span class="line">    PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(lists.length, <span class="keyword">new</span> Comparator&lt;ListNode&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> l1.val - l2.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 将 k 个链表的头结点加入最小堆</span></span><br><span class="line">    <span class="keyword">for</span>(ListNode listNode:lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)</span><br><span class="line">            queue.add(listNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 获取最小节点，接到结果链表中</span></span><br><span class="line">        ListNode node = queue.poll();</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="keyword">if</span>(node.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(node.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法是面试常考题，它的时间复杂度是多少呢？</p>
<p>优先队列 <code>pq</code> 中的元素个数最多是 <code>k</code>，所以一次 <code>poll</code> 或者 <code>add</code> 方法的时间复杂度是 <code>O(logk)</code>；所有的链表节点都会被加入和弹出 <code>pq</code>，<strong>所以算法整体的时间复杂度是 <code>O(Nlogk)</code>，其中 <code>k</code> 是链表的条数，<code>N</code> 是这些链表的节点总数</strong>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-计算两个链表是否相交</title>
    <url>/2017/11/15/algorithm_linkedlist_intersection_node/</url>
    <content><![CDATA[<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<span id="more"></span> 

<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="/images/android_linkedlist_intersection_node01.png" alt="img"></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<hr>
<p>那么我们的算法应该返回 <code>c1</code> 这个节点。</p>
<p>这个题直接的想法可能是用 <code>HashSet</code> 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。</p>
<p>如果不用额外的空间，只使用两个指针，你如何做呢？</p>
<p>难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：</p>
<p><img src="/images/android_linkedlist_intersection_node02.png" alt="img"></p>
<p>如果用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，并不能<strong>同时</strong>走到公共节点，也就无法得到相交节点 <code>c1</code>。</p>
<p>**解决这个问题的关键是，通过某些方式，让 <code>p1</code> 和 <code>p2</code> 能够同时到达相交节点 <code>c1</code>**。</p>
<p>所以，我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p>
<p>如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code>：</p>
<p><img src="/images/android_linkedlist_intersection_node03.png" alt="img"></p>
<p>那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？</p>
<p>这个逻辑可以覆盖这种情况的，相当于 <code>c1</code> 节点是 null 空指针嘛，可以正确返回 null。</p>
<p>按照这个思路，可以写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断两个链表是否相交</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> headB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//p1指向A链表头结点,p2指向B链表头结点</span></span><br><span class="line">    ListNode p1 = headA, p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1!=p2)&#123;</span><br><span class="line">        <span class="comment">//p1走一步，如果走到A链表末尾，则转到B链表继续走</span></span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            p1 = headB;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//p2走一步，如果走到B链表末尾，则转到B链表继续走</span></span><br><span class="line">        <span class="keyword">if</span>(p2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            p2 = headA;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-判断链表是否包含环</title>
    <url>/2017/08/15/algorithm_linkedlist_hascycle/</url>
    <content><![CDATA[<p>判断链表是否包含环属于经典问题了，解决方案也是用快慢指针。</p>
<span id="more"></span>

<p>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。</p>
<p>如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast</code> 最终和 <code>slow</code> 相遇，那肯定是 <code>fast</code> 超过了 <code>slow</code> 一圈，说明链表中含有环。</p>
<p>只需要把寻找链表中点的代码稍加修改就行了。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否包含环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快慢指针初始化指向head</span></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="comment">//快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">//快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？</p>
<p>这里简单提一下解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果链表包含环，计算这个环的起点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="comment">//fast遇到空指针，说明没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新指向头结点</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="comment">//快慢指针同步前进，相交点就是环起点</span></span><br><span class="line">    <span class="keyword">while</span> (slow!=fast)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</p>
<p>为什么要这样呢？这里简单说一下其中的原理。</p>
<p>我们假设快慢指针相遇时，慢指针 <code>slow</code> 走了 <code>k</code> 步，那么快指针 <code>fast</code> 一定走了 <code>2k</code> 步：</p>
<p><img src="/images/android_linkedlist_hascycle01.png" alt="img"></p>
<p><code>fast</code> 一定比 <code>slow</code> 多走了 <code>k</code> 步，这多走的 <code>k</code> 步其实就是 <code>fast</code> 指针在环里转圈圈，所以 <code>k</code> 的值就是环长度的「整数倍」。</p>
<p>假设相遇点距环的起点的距离为 <code>m</code>，那么结合上图的 <code>slow</code> 指针，环的起点距头结点 <code>head</code> 的距离为 <code>k - m</code>，也就是说如果从 <code>head</code> 前进 <code>k - m</code> 步就能到达环起点。</p>
<p>巧的是，如果从相遇点继续前进 <code>k - m</code> 步，也恰好到达环起点。因为结合上图的 <code>fast</code> 指针，从相遇点开始走k步可以转回到相遇点，那走 <code>k - m</code> 步肯定就走到环起点了：</p>
<p><img src="/images/android_linkedlist_hascycle02.png" alt="img"></p>
<p>所以，只要我们把快慢指针中的任一个重新指向 <code>head</code>，然后两个指针同速前进，<code>k - m</code> 步后一定会相遇，相遇之处就是环的起点了。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-单链表倒数第K个节点</title>
    <url>/2017/08/08/algorithm_linkedlist_lastknode/</url>
    <content><![CDATA[<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<span id="more"></span>

<p><strong>示例：</strong></p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.<br>返回链表 4-&gt;5.</p>
<hr>
<p>从前往后寻找单链表的第 <code>k</code> 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 <code>k</code> 个节点呢？</p>
<p>那你可能说，假设链表有 <code>n</code> 个节点，倒数第 <code>k</code> 个节点就是正数第 <code>n - k + 1</code> 个节点，不也是一个 for 循环的事儿吗？</p>
<p>是的，但是算法题一般只给你一个 <code>ListNode</code> 头结点代表一条单链表，你不能直接得出这条链表的长度 <code>n</code>，而需要先遍历一遍链表算出 <code>n</code> 的值，然后再遍历链表计算第 <code>n - k + 1</code> 个节点。</p>
<p>也就是说，这个解法需要遍历两次链表才能得到出倒数第 <code>k</code> 个节点。</p>
<p>那么，我们能不能<strong>只遍历一次链表</strong>，就算出倒数第 <code>k</code> 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。</p>
<p>这个解法就比较巧妙了，假设 <code>k = 2</code>，思路如下：</p>
<p>首先，我们先让一个指针 <code>p1</code> 指向链表的头节点 <code>head</code>，然后走 <code>k</code> 步：</p>
<p>现在的 <code>p1</code>，只要再走 <code>n - k</code> 步，就能走到链表末尾的空指针了对吧？</p>
<p>趁这个时候，再用一个指针 <code>p2</code> 指向链表头节点 <code>head</code>：</p>
<p>接下来就很显然了，让 <code>p1</code> 和 <code>p2</code> 同时向前走，<code>p1</code> 走到链表末尾的空指针时前进了 <code>n - k</code> 步，<code>p2</code> 也从 <code>head</code> 开始前进了 <code>n - k</code> 步，停留在第 <code>n - k + 1</code> 个节点上，即恰好停链表的倒数第 <code>k</code> 个节点上：</p>
<p>这样，只遍历了一次链表，就获得了倒数第 <code>k</code> 个节点 <code>p2</code>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="keyword">while</span> (p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-链表的中间节点</title>
    <url>/2017/08/10/algorithm_linkedlist_middle_node/</url>
    <content><![CDATA[<p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<span id="more"></span> 

<p>示例 1：</p>
<p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.<br>示例 2：</p>
<p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
<hr>
<p>如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：</p>
<p>我们让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点 <code>head</code>。</p>
<p><strong>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表的中点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快慢指针初始化指向head</span></span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="comment">//快指针走到末尾时停止</span></span><br><span class="line">    <span class="keyword">while</span> (fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//慢指针走一步，快指针走两步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-单链表的分解</title>
    <url>/2017/08/07/algorithm_linkedlist_partition/</url>
    <content><![CDATA[<p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<span id="more"></span>

<p>示例 1：</p>
<p><img src="/images/algorithm_linkedlist_partition.jpg" alt="img"></p>
<p>输入：head = [1,4,3,2,5,2], x = 3<br>输出：[1,2,2,4,3,5]<br>示例 2：</p>
<p>输入：head = [2,1], x = 2<br>输出：[1,2]</p>
<hr>
<p>在合并两个有序链表时让你合二为一，而这里需要分解让你把原链表一分为二。具体来说，我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 <code>x</code>，另一个链表中的元素都大于等于 <code>x</code>，最后再把这两条链表接到一起，就得到了题目想要的结果。</p>
<p>整体逻辑和合并有序链表非常相似，细节直接看代码吧，注意虚拟头结点的运用：</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放小于 x 的链表的虚拟头结点</span></span><br><span class="line">    ListNode lowDummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode low = lowDummy;</span><br><span class="line">    <span class="comment">// 存放大于等于 x 的链表的虚拟头结点</span></span><br><span class="line">    ListNode highDummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode high = highDummy;</span><br><span class="line">    <span class="comment">// p 负责遍历原链表，类似合并两个有序链表的逻辑</span></span><br><span class="line">    <span class="comment">// 这里是将一个链表分解成两个链表</span></span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val &lt; x)&#123;</span><br><span class="line">            low.next = p;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high.next = p;</span><br><span class="line">            high = high.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 断开原链表中的每个节点的 next 指针</span></span><br><span class="line">        ListNode temp = p.next;</span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接两个链表</span></span><br><span class="line">    low.next = highDummy.next;</span><br><span class="line">    <span class="keyword">return</span> lowDummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-合并两个有序链表</title>
    <url>/2017/08/10/algorithm_linkedlist_merge_two_list/</url>
    <content><![CDATA[<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><img src="/images/algorithm_linkedlist_merge_two_list.jpg" alt="img"></p>
<p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]<br>示例 2：</p>
<p>输入：l1 = [], l2 = []<br>输出：[]<br>示例 3：</p>
<p>输入：l1 = [], l2 = [0]<br>输出：[0]</p>
<hr>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode p = dummy;</span><br><span class="line">    ListNode p1 = l1;</span><br><span class="line">    ListNode p2 = l2;</span><br><span class="line">    <span class="keyword">while</span> (p1!=<span class="keyword">null</span> &amp;&amp; p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 比较 p1 和 p2 两个指针</span></span><br><span class="line">        <span class="comment">// 将值较小的的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span>(p1.val &gt; p2.val)&#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next = p1;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的 while 循环每次比较 <code>p1</code> 和 <code>p2</code> 的大小，把较小的节点接到结果链表上。</p>
<p>形象地理解，这个算法的逻辑类似于拉拉链，<code>l1, l2</code> 类似于拉链两侧的锯齿，指针 <code>p</code> 就好像拉链的拉索，将两个有序链表合并；或者说这个过程像蛋白酶合成蛋白质，<code>l1, l2</code> 就好比两条氨基酸，而指针 <code>p</code> 就好像蛋白酶，将氨基酸组合成蛋白质。</p>
<p><strong>代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 <code>dummy</code> 节点</strong>。你可以试试，如果不使用 <code>dummy</code> 虚拟节点，代码会复杂很多，而有了 <code>dummy</code> 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-删除链表倒数第N个节点</title>
    <url>/2017/08/08/algorithm_linkedlist_removenth_fromend/</url>
    <content><![CDATA[<p>给定一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<span id="more"></span>

<p><strong>示例 1：</strong></p>
<p><img src="/images/android_linkedlist_removenth_fromend01.png" alt="img"></p>
<p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<br>示例 2：</p>
<p>输入：head = [1], n = 1<br>输出：[]<br>示例 3：</p>
<p>输入：head = [1,2], n = 1<br>输出：[1]</p>
<hr>
<p>这个逻辑就很简单了，要删除倒数第 <code>n</code> 个节点，就得获得倒数第 <code>n + 1</code> 个节点的引用，可以用我们实现的 <code>findFromEnd</code> 来操作。</p>
<p>不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。</p>
<p>但有了我们虚拟节点 <code>dummy</code> 的存在，就避免了这个问题，能够对这种情况进行正确的删除。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除单链表倒数第N个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="comment">//删除倒数第n个，要先扎到找到倒数第n+1个节点</span></span><br><span class="line">    ListNode x = findFromEnd(dummy.next, n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//删掉倒数第n个节点</span></span><br><span class="line">    x.next = x.next.next;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链表的倒数第 k 个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="comment">// p1 先走 k 步</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时走 n - k 步</span></span><br><span class="line">    <span class="keyword">while</span> (p1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动模式</title>
    <url>/2016/06/10/android_activity_launch_mode/</url>
    <content><![CDATA[<p>Activity的启动模式是android系统管理activity的重要设置项和方式。对应AndroidManifest中activity节点下的launchMode属性。</p>
<span id="more"></span>

<h1 id="四大启动模式"><a href="#四大启动模式" class="headerlink" title="四大启动模式"></a>四大启动模式</h1><ol>
<li><p>standard:标准模式，默认</p>
<p>standard是默认的启动模式，即标准模式，每启动一个Activity，都会创建一个新的实例</p>
</li>
<li><p>singleTop:Task栈顶复用模式</p>
<p>singleTop:当要启动的目标Activity已经位于栈顶时，不会创建新的实例，会复用栈顶的Activity，并且其onNewIntent()方法会被调用，如果目标Activity不在栈顶，则跟standard一样创建新的实例。</p>
</li>
<li><p>singleTask:Task栈内复用模式</p>
<p>这种模式启动的Activity<strong>只会存在相应的Activity的taskAffinit任务栈中</strong>，同一时刻系统中只会存在一个实例，已存在的实例被再次启动时，会重新唤起该实例，并清理当前Task任务栈该实例之上的所有Activity，同时回调onNewIntent()方法。</p>
</li>
<li><p>singleInstance:全局单例模式</p>
<p>这种模式启动的Activity独自占用一个Task任务栈，同一时刻系统中只会存在一个实例，已存在的实例被再次启动时，只会唤起原实例，并回调onNewIntent()方法。</p>
</li>
</ol>
<p>需要说明的是：<u><strong>上面的场景仅仅适用于Activity启动Activity，并且采用的都是默认Intent，没有额外添加任何Flag</strong>，否则表现就可能跟上面的完全不一致，尤其要注意的是FLAG_ACTIVITY_NEW_TASK的使用，后面从源码中看，依靠FLAG_ACTIVITY_NEW_TASK其实可以分为两派。</u></p>
<h1 id="有关启动模式的那些事"><a href="#有关启动模式的那些事" class="headerlink" title="有关启动模式的那些事"></a>有关启动模式的那些事</h1><p>面试的时候，面试官经常同你随便侃侃Activity的启动模式，但Activity启动牵扯的知识点其实很多，并非能单单用四个启动模式就能概括的，默认的启动模式的表现会随着Intent Flag的设置而改变，因此侃Activity启动模式大多走流程装逼，最多结合项目遇到的问题，随便刁难一下面试者，并不太容易把控，也许最后，面试官跟面试者的答案都是错了，比如在Service中必须通过设置FLAG_ACTIVITY_NEW_TASK才能启动Activity，这个时候启动Activit会有什么样的表现呢？就这一个问题，答案就要分好几个场景：</p>
<ul>
<li><p>Activity的taskAffinity属性的Task栈是否存在</p>
</li>
<li><p>如果存在，要看Activity是否存已经存在于该Task</p>
</li>
<li><p>如果已经存在于该taskAffinity的Task，要看其是不是其rootActivity</p>
</li>
<li><p>如果是其rootActivity，还要看启动该Activity的Intent是否跟当前intent相等</p>
</li>
</ul>
<p>不同场景，所表现的行为都会有所不同，再比如singleInstance属性，如果设置了，大家都知道只有一个实例，将来再启动会复用，但是如果使用Intent.FLAG_ACTIVITY_CLEAR_TASK来启动，仍然会重建，并非完全遵守singleInstance的说明，还有不同Flag在叠加使用时候也会有不同的表现，单一而论Activity启动模式其实是很难的。</p>
<h2 id="Intent-FLAG-ACTIVITY-NEW-TASK分析"><a href="#Intent-FLAG-ACTIVITY-NEW-TASK分析" class="headerlink" title="Intent.FLAG_ACTIVITY_NEW_TASK分析"></a>Intent.FLAG_ACTIVITY_NEW_TASK分析</h2><p>从源码来看，Intent.FLAG_ACTIVITY_NEW_TASK是启动模式中最关键的一个Flag，依据该Flag启动模式可以分成两类，设置了该属性的与未设置该属性的，对于非Activity启动的Activity（比如Service或者通知中启动的Activity）需要显示的设置Intent.FLAG_ACTIVITY_NEW_TASK，而singleTask及singleInstance在AMS中被预处理后，隐形的设置了Intent.FLAG_ACTIVITY_NEW_TASK，而启动模式是standard及singletTop的Activity不会被设置Intent.FLAG_ACTIVITY_NEW_TASK，除非通过显示的intent setFlag进行设置。</p>
<p><strong>FLAG_ACTIVITY_NEW_TASK这个属性更多的关注点是在Task，可以认为没有设置FLAG_ACTIVITY_NEW_TASK的情况下，taskAffinity可以不考虑</strong>，大多数情况下，需要将Activity引入到自己taskAffinity的Task中，<strong>Intent.FLAG_ACTIVITY_NEW_TASK的初衷是在Activity目标taskAffinity的Task中启动</strong>，非Activity启动Activity都必须添加Intent.FLAG_ACTIVITY_NEW_TASK才行，以Service启动的Activity为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(BackGroundService.<span class="keyword">this</span>, A.class);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>这种情况很有意思，如果目标Activity实例或者Task不存在，则一定会新建Activity，并将目标Task移动到前台，但是如果Activity存在，却并不一定复用，也不一定可见。这里假定A是standard的Activity，如果已经有一个A实例，并且所在的堆栈的taskAffinity跟A的taskAffinity一致，这个时候要看这个task的根Activity是不是A，如果是A，还要看A的intent是不是跟当前的启动的intent相等，如果都满足，只要将task可见即可。</p>
<p>否则，就需要新建A，并根据A的task栈的存在情况而选择直接入栈还是新建栈。但是，如果Intent想要的启动的Activity的目标堆栈存在，那就将整个堆栈往前迁移，如果位于顶部的Task栈正好是目标Activity的Task栈，那就不做任何处理，连onNewIntent都不会回调，怎么判断目标的Activity的Task栈同找到的栈一致呢？<strong>如果找不到目标Task自然会启动Task，如果目标task栈根Activit的intent同新将要启动的Activit相同，就不启动新Activity，否则启动Activity</strong>。</p>
<p><img src="/images/android_activity_launch_mode01.jpeg" alt="img"></p>
<h2 id="Intent-FLAG-ACTIVITY-CLEAR-TASK：必须配合FLAG-ACTIVITY-NEW-TASK使用"><a href="#Intent-FLAG-ACTIVITY-CLEAR-TASK：必须配合FLAG-ACTIVITY-NEW-TASK使用" class="headerlink" title="Intent.FLAG_ACTIVITY_CLEAR_TASK：必须配合FLAG_ACTIVITY_NEW_TASK使用"></a>Intent.FLAG_ACTIVITY_CLEAR_TASK：必须配合FLAG_ACTIVITY_NEW_TASK使用</h2><p>If set in an Intent passed to Context.startActivity(), this flag will cause any existing task that would be associated with the activity to be cleared before the activity is started. That is, the activity becomes the new root of an otherwise empty task, and any old activities are finished. This can only be used in conjunction with FLAG_ACTIVITY_NEW_TASK.</p>
<p>这个属性必须同FLAG_ACTIVITY_NEW_TASK配合使用，如果设置了FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK，如果目标task已经存在，将清空已存在的目标Task，否则，新建一个Task栈，之后，新建一个Activity作为根Activity。Intent.FLAG_ACTIVITY_CLEAR_TASK的优先级最高，基本可以无视所有的配置，包括启动模式及Intent Flag，哪怕是singleInstance也会被finish，并重建。</p>
<p><img src="/images/android_activity_launch_mode02.jpeg" alt="img"></p>
<h2 id="Intent-FLAG-ACTIVITY-CLEAR-TOP"><a href="#Intent-FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="Intent.FLAG_ACTIVITY_CLEAR_TOP"></a>Intent.FLAG_ACTIVITY_CLEAR_TOP</h2><p>如果没有使用FLAG_ACTIVITY_NEW_TASK，目标是当前Task栈，根据不同的组合会产生不同的效果，如果单独使用Intent.FLAG_ACTIVITY_CLEAR_TOP，并且没有设置特殊的launchmode，那么，Google官方的示例是：如果ABCD Task中的D采用Intent.FLAG_ACTIVITY_CLEAR_TOP唤起B，这个时候首先会将CD出栈，但是至于B是否会重建，要视情况而定，如果没有设置FLAG_ACTIVITY_SINGLE_TOP，则会将B finish掉，之后创建新的入栈。如果同一个栈中原来有</p>
<p><img src="/images/android_activity_launch_mode03.jpeg" alt="img"></p>
<p>如果没有则新建，不会去另一个栈中寻找。</p>
<p><img src="/images/android_activity_launch_mode04.jpeg" alt="img"></p>
<p>如果同时设置了FLAG_ACTIVITY_SINGLE_TOP，在当前栈已有的情况下就不会重建，而是直接回调B的onNewIntent(),</p>
<p><img src="/images/android_activity_launch_mode05.jpeg" alt="img"></p>
<p>官方解释如下：</p>
<p>For example, consider a task consisting of the activities: A, B, C, D. If D calls startActivity() with an Intent that resolves to the component of activity B, then C and D will be finished and B receive the given Intent, resulting in the stack now being: A, B。</p>
<p>The currently running instance of activity B in the above example will either receive the new intent you are starting here in its onNewIntent() method, or be itself finished and restarted with the new intent. </p>
<p>If it has declared its launch mode to be “multiple” (the default) and you have not set FLAG_ACTIVITY_SINGLE_TOP in the same intent, then it will be finished and re-created; for all other launch modes or if FLAG_ACTIVITY_SINGLE_TOP is set then this Intent will be delivered to the current instance’s onNewIntent().</p>
<p>如果同时使用了FLAG_ACTIVITY_NEW_TASK ，这个时候，目标是Activity自己所属的Task栈，如果在自己的Task中能找到一个Activity实例，则将其上面的及自身清理掉，之后重建。</p>
<p><img src="/images/android_activity_launch_mode06.jpeg" alt="img"></p>
<p>如果同时在加上FLAG_ACTIVITY_SINGLE_TOP，会更特殊一些，如果topActivity不是目标Activity，就会去目标Task中去找，并唤起</p>
<p>Intent.FLAG_ACTIVITY_CLEAR_TOP| FLAG_ACTIVITY_NEW_TASK|singleTop.jpg</p>
<p><strong>如果topActivity是目标Activity，就直接回调topActivity的onNewIntent，无论topActivity是不是在目标Task中</strong></p>
<p><img src="/images/android_activity_launch_mode07.jpeg" alt="img"></p>
<h2 id="Intent-FLAG-ACTIVITY-SINGLE-TOP"><a href="#Intent-FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="Intent.FLAG_ACTIVITY_SINGLE_TOP"></a>Intent.FLAG_ACTIVITY_SINGLE_TOP</h2><p>Intent.FLAG_ACTIVITY_SINGLE_TOP多用来做辅助作用，跟launchmode中的singleTop作用一样，在Task栈顶有的话，就不新建，栈顶没有的话，就新建，这里的Task可能是目标栈，也可能是当前Task栈，配合FLAG_ACTIVITY_NEW_TASK及FLAG_ACTIVITY_CLEAR_TOP都会有很有意思的效果。</p>
<h2 id="为什么非Activity启动Activity要强制规定使用参数FLAG-ACTIVITY-NEW-TASK"><a href="#为什么非Activity启动Activity要强制规定使用参数FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="为什么非Activity启动Activity要强制规定使用参数FLAG_ACTIVITY_NEW_TASK"></a>为什么非Activity启动Activity要强制规定使用参数FLAG_ACTIVITY_NEW_TASK</h2><p>从源码上说，ContextImpl在前期做了检查，如果没添加Intent.FLAG_ACTIVITY_NEW_TASK就抛出异常，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">	warnIfCallingFromSystemProcess();</span><br><span class="line">	<span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">            <span class="string">&quot;Calling startActivity() from outside of an Activity &quot;</span></span><br><span class="line">            + <span class="string">&quot; context requires the FLAG_ACTIVITY_NEW_TASK flag.&quot;</span></span><br><span class="line">            + <span class="string">&quot; Is this really what you want?&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要这么呢？其实直观很好理解，如果不是在Activity中启动的，那就可以看做不是用户主动的行为，也就说这个界面可能出现在任何APP之上，如果不用Intent.FLAG_ACTIVITY_NEW_TASK将其限制在自己的Task中，那用户可能会认为该Activity是当前可见APP的页面，这是不合理的。举个例子：我们在听音乐，这个时候如果邮件Service突然要打开一个Activity，如果不用Intent.FLAG_ACTIVITY_NEW_TASK做限制，那用户可能认为这个Activity是属于音乐APP的，因为用户点击返回的时候，可能会回到音乐，而不是邮件（如果邮件之前就有界面）。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title>Android AMS核心分析</title>
    <url>/2019/08/11/android_ams/</url>
    <content><![CDATA[<p>AMS提供的主要功能：</p>
<ul>
<li>统一调度各个应用程序的Activity。</li>
</ul>
<p>应用程序须要启动Activity–&gt;报告给AMS，决定是否能够启动–&gt;若是能够，通知应用程序运行指定Activity。数据结构</p>
<p>AMS必须知道各个应用程序运行的Activity。异步</p>
<ul>
<li>内存管理。</li>
</ul>
<p>Activity退出时不会当即被杀死，只有在内存紧张时才会自动被杀，这些操做由AMS管理。</p>
<ul>
<li>进程管理。</li>
</ul>
<p>AMS向外提供了查询系统正在运行的进程信息的API。</p>
<span id="more"></span>

<h1 id="AMS的启动"><a href="#AMS的启动" class="headerlink" title="AMS的启动"></a>AMS的启动</h1><p>AMS在SystemServer进程initAndLoop()函数中被启动而且初始化。首先看一下SystemServer的启动流程。</p>
<h2 id="SystemServer的启动"><a href="#SystemServer的启动" class="headerlink" title="SystemServer的启动"></a>SystemServer的启动</h2><p><img src="/images/android_ams_system_server_start.png" alt="android_ams_system_server_start"></p>
<h2 id="SystemServer执行流程"><a href="#SystemServer执行流程" class="headerlink" title="SystemServer执行流程"></a>SystemServer执行流程</h2><p><img src="/images/android_ams_system_server_invoke.png" alt="android_ams_system_server_invoke"></p>
<ul>
<li>AMS.main()函数，建立AMS实例，而且建立Android运行环境获得一个ActivityThread和一个Context。</li>
<li>AMS.setSystemProcess()函数，注册AMS服务到ServiceManager中。而且为system_server进程建立ProcessRecord，将该进程归入管理中。</li>
<li>AMS.installSystemProvider()函数，为system_server进程加载SettingsProvider。</li>
<li>AMS.systemReady()函数，作系统启动完毕后的工做，呈现HomeActivity。</li>
</ul>
<h1 id="AMS重要数据结构"><a href="#AMS重要数据结构" class="headerlink" title="AMS重要数据结构"></a>AMS重要数据结构</h1><p>AMS定义了几个数据类用于Process、Activity、Task信息。</p>
<h2 id="进程数据类ProcessRecord"><a href="#进程数据类ProcessRecord" class="headerlink" title="进程数据类ProcessRecord"></a>进程数据类ProcessRecord</h2><p>用于记录一个进程相关信息</p>
<p><img src="/images/android_ams_process_record.jpg" alt="android_ams_process_record"></p>
<h2 id="保存Activity信息数据类ActivityRecord"><a href="#保存Activity信息数据类ActivityRecord" class="headerlink" title="保存Activity信息数据类ActivityRecord"></a>保存Activity信息数据类ActivityRecord</h2><p>用于保存一个Activity的信息。</p>
<p>在ActivityRecord内部提供Token类实现IApplicationToken.Stub能够实现IPC回调其方法。通常是在WMS内部对其IPC调用。</p>
<p><img src="/images/android_ams_activity_record.jpg" alt="android_ams_activity_record"></p>
<h2 id="任务栈信息数据类TaskRecord"><a href="#任务栈信息数据类TaskRecord" class="headerlink" title="任务栈信息数据类TaskRecord"></a>任务栈信息数据类TaskRecord</h2><p>记录Activity所属任务栈信息。</p>
<p><img src="/images/android_ams_task_record.jpg" alt="android_ams_task_record"></p>
<h1 id="Activity的调度机制"><a href="#Activity的调度机制" class="headerlink" title="Activity的调度机制"></a>Activity的调度机制</h1><p>Activity调度过程：</p>
<p>应用进程启动或者中止Activity—&gt;报告给AMS，其内部维护全部应用进程启动或者中止Activity的记录—&gt;AMS更新内部记录，并通知客户端进程操做—&gt;客户端进程接收通知，执行操做</p>
<p>启动Activity的各类方式：</p>
<ul>
<li>应用程序中调用startActivity()</li>
<li>在Home程序中单击应用程序图标启动Activity</li>
<li>按“back”中止当前Activity启动新Activity</li>
<li>长按“home”显示当前任务列表选择一个启动</li>
</ul>
<h2 id="ActivityThread类关系"><a href="#ActivityThread类关系" class="headerlink" title="ActivityThread类关系"></a>ActivityThread类关系</h2><p><img src="/images/android_ams_activity_thread_class_relation.png" alt="android_ams_activity_thread_class_relation"></p>
<p>AMS经过Binder跨进程通知ActivityThread启动、中止指定Activity。</p>
<p>ActivityThread做为Binder服务端实现指定接口由AMS远程调用。</p>
<p>ActivityThread能够看作是进程的Android运行环境。</p>
<h2 id="Activity的launchMode"><a href="#Activity的launchMode" class="headerlink" title="Activity的launchMode"></a>Activity的launchMode</h2><ul>
<li>standard：默认启动模式，无论有没有已存在的实例都生成新的实例。</li>
<li>singleTop：若是栈顶存在对应的实例则重复利用不生产新的实例，不存在则新建实例。</li>
<li>singleTask：若是栈内存在对于的实例则使此Activity实例之上的其余Activity实例都出栈，使此Activity实例成为栈顶对象显示。</li>
<li>singleInstance：启用一个新栈放入新建Activity实例，而且该栈内只容许存在这一个Activity实例。</li>
</ul>
<p>Intent中涉及到的Activity启动方式常量：</p>
<ul>
<li>FLAG_ACTIVITY_NEW_TASK：将目标Activity放置到新的task中。</li>
<li>FLAG_ACTIVITY_CLEAR_TASK：启动一个Activity时先清除和其有关联的task，并新建Activity实例将其放入新的task中。必须和上面变量一块儿使用</li>
<li>FLAG_ACTIVITY_CLEAR_TOP：启动一个不处于栈顶的Activity时，清除排在它前面的Activity使其显示出来。</li>
</ul>
<h1 id="AMS启动Activity流程"><a href="#AMS启动Activity流程" class="headerlink" title="AMS启动Activity流程"></a>AMS启动Activity流程</h1><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p><img src="/images/android_ams_start_activity_01.jpg" alt="android_ams_start_activity_01"></p>
<p>整个调用步骤过程以下：</p>
<p>1.首先IPC调用AMS方法传入参数启动指定Activity</p>
<p>2.在AMS中首先查询PKMS获取该ActivityInfo，新建ActivityRecord和根据lunchMod建立TaskRecord两个重要变量，而且将ActivityRecord添加到task栈顶做为准备启动的Activity。</p>
<p>3.在正式启动Activity以前首先检查其进程是否启动，为启动时通知AMS启动对应进程。</p>
<p>下图就是AMS建立Activity对应进程及启动Activity的过程：</p>
<p><img src="/images/android_ams_start_activity_02.jpg" alt="android_ams_start_activity_02"></p>
<p>整个调用步骤过程以下：</p>
<p>1.首先就是zygote进程fork新进程，指定新进程执行须要启动的ActivityThread类。</p>
<p>2.在ActivityThread的main()方法中：</p>
<ul>
<li>首先新建ActivityThread对象。</li>
<li>接着回调AMS接口通知其应用进程已启动成功。</li>
<li>最后开启主线程消息循环，处理消息。</li>
</ul>
<p>3.其中上步骤第二点在与AMS交互中IPC调用AMS的attachApplication()函数中：</p>
<ul>
<li>首先根据pid查找对应的ProcessRecord</li>
<li>设置该应用退出时的回调接口</li>
<li>修改ProcessRecord一些参数</li>
<li>最后与应用进程交互，开始建立Application对象</li>
</ul>
<p>4.AMS与应用进程交互时会发出一个异步消息，该消息内部：</p>
<ul>
<li>配置运行时信息</li>
<li>安装该Application对应的ContentProvider</li>
<li>生成一个Application对象而且回调onCreate()函数</li>
</ul>
<p>5.AMS与应用进程交互完接着准备启动目标Activity，在ActivityStackSupervisor.attachApplicationLocked()函数中会首先获取须要启动的ActivityRecord并保存到对应的ProcessRecord，接着IPC调用应用进程启动Activity。</p>
<p>6.在应用进程中也是异步消息处理</p>
<ul>
<li>首先反射实例化目标Activity对象，回调相应onStart()以前的生命周期函数</li>
<li>接着回调onResume()函数而且添加一个Idler消息对象到队列中。该对象内部方法会调用到AMS中的相应方法处理所以次启动而被暂停的Activity的相关声明周期函数处理。</li>
</ul>
<p>7.同时在AMS中会将task添加到最近任务列表中，而且发送10s定时等待这个Activity处理结果。</p>
<p>8.此时目标Activity已经被成功启动，接着会处理一些Pending组件，这些组件多是在系统启动未成功时发起的一些启动指令。</p>
<p>最终一个Activity启动成功。</p>
<h2 id="Activity启动时序图"><a href="#Activity启动时序图" class="headerlink" title="Activity启动时序图"></a>Activity启动时序图</h2><p><img src="/images/android_ams_activity_time_schduce.png" alt="android_ams_activity_time_schduce"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ANR原理分析及解决办法</title>
    <url>/2019/11/03/android_anr_analyze/</url>
    <content><![CDATA[<p>ANR是应用开发中典型的问题类型，直译为“应用程序无响应”。</p>
<span id="more"></span>

<h1 id="ANR说明和原因"><a href="#ANR说明和原因" class="headerlink" title="ANR说明和原因"></a>ANR说明和原因</h1><p>ANR全称：<strong>Application Not Responding</strong>，也就是应用程序无响应。</p>
<p>Android系统中，**ActivityManagerService(简称AMS)<strong>和</strong>WindowManagerService(简称WMS)**会检测App的响应时间，如果App在特定时间无法相应屏幕触摸或键盘输入时间，或者特定事件没有处理完毕，就会出现ANR。</p>
<p>以下四个条件都可以造成ANR发生：</p>
<ul>
<li><strong>InputDispatching Timeout</strong>：5秒内无法响应屏幕触摸事件或键盘输入事件</li>
<li><strong>BroadcastQueue Timeout</strong> ：在执行前台广播（BroadcastReceiver）的onReceive()函数时10秒没有处理完成，后台为60秒。</li>
<li><strong>Service Timeout</strong> ：前台服务20秒内，后台服务在200秒内没有执行完毕。</li>
<li><strong>ContentProvider Timeout</strong> ：ContentProvider的publish在10s内没进行完。</li>
</ul>
<p>所以，尽量避免在主线程（UI线程）中作耗时操作。耗时操作就放到子线程中去执行。</p>
<h1 id="ANR的避免与检测"><a href="#ANR的避免与检测" class="headerlink" title="ANR的避免与检测"></a>ANR的避免与检测</h1><p>为了避免在开发中引入可能导致应用发生ANR的问题，除了切记不要在主线程中作耗时操作，我们也可以借助于一些工具来进行检测，从而更有效的避免ANR的引入。</p>
<p>StrictMode</p>
<p>严格模式StrictMode是Android SDK提供的一个用来检测代码中是否存在违规操作的工具类，StrictMode主要检测两大类问题。</p>
<p>线程策略 ThreadPolicy<br>detectCustomSlowCalls：检测自定义耗时操作<br>detectDiskReads：检测是否存在磁盘读取操作 detectDiskWrites：检测是否存在磁盘写入操作<br>detectNetWork：检测是否存在网络操作<br>虚拟机策略VmPolicy<br>detectActivityLeaks：检测是否存在Activity泄露<br>detectLeakedClosableObjects：检测是否存在未关闭的Closeable对象泄露<br>detectLeakedSqlLiteObjects：检测是否存在Sqlite对象泄露<br>setClassInstanceLimit：检测类实例个数是否超过限制</p>
<p>可以看到，ThreadPolicy可以用来检测可能催在的主线程耗时操作，需要注意的是我们只能在Debug版本中使用它，发布到市场上的版本要关闭掉。StrictMode的使用很简单，我们只需要在应用初始化的地方例如Application或者MainActivity类的onCreate方法中执行如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_login);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启线程模式</span></span><br><span class="line">    StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</span><br><span class="line">    .detectAll()</span><br><span class="line">    .penaltyLog()</span><br><span class="line">    .penaltyDialog() 打印logcat，当然也可以定位到dropbox，通过文件保存相应的log</span><br><span class="line">    .build());</span><br><span class="line">    <span class="comment">// 开启虚拟机模式</span></span><br><span class="line">    StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</span><br><span class="line">    .detectAll()</span><br><span class="line">    .penaltyLog()</span><br><span class="line">    .build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的初始化代码调用penaltyLog表示在Logcat中打印日志，调用detectAll方法表示启动所有的检测策略，我们也可以根据应用的具体要求只开启某些策略，语句如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</span><br><span class="line">    .detectDiskReads()</span><br><span class="line">    .detectDiskWrites()</span><br><span class="line">    .detectNetwork()</span><br><span class="line">    .penaltyLog()</span><br><span class="line">    .build());</span><br><span class="line"></span><br><span class="line">StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</span><br><span class="line">    .detectLeakedSqlLiteObjects()</span><br><span class="line">    .detectLeakedClosableObjects()</span><br><span class="line">    .detectActivityLeaks()</span><br><span class="line">    .penaltyLog()</span><br><span class="line">    .build());</span><br></pre></td></tr></table></figure>



<h1 id="ANR分析方法"><a href="#ANR分析方法" class="headerlink" title="ANR分析方法"></a>ANR分析方法</h1><p><strong>ANR示例</strong></p>
<p>生成一个按钮跳转到ANRTestActivity，在后者的onCreate()中主线程休眠20秒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_anr_test);</span><br><span class="line">    <span class="comment">// 这是Android提供线程休眠函数，与Thread.sleep()最大的区别是</span></span><br><span class="line">    <span class="comment">// 该使用该函数不会抛出InterruptedException异常。</span></span><br><span class="line">    SystemClock.sleep(<span class="number">20</span> * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进入ANRTestActivity后黑屏一段时间，大概有七八秒，终于弹出了ANR异常。</p>
<p><img src="/images/android_anr_analyze01.png" alt="img"></p>
<h2 id="ANR分析办法一：看logcat"><a href="#ANR分析办法一：看logcat" class="headerlink" title="ANR分析办法一：看logcat"></a>ANR分析办法一：看logcat</h2><p>产生ANR后，看下Log：</p>
<p><img src="/images/android_anr_analyze02.png" alt="img"></p>
<p>可以看到logcat清晰地记录了ANR发生的时间，以及线程的tid和一句话概括原因：WaitingInMainSignalCatcherLoop，大概意思为主线程等待异常。<br>最后一句The application may be doing too much work on its main thread.告知可能在主线程做了太多的工作。</p>
<h2 id="ANR分析办法二：看trace文件"><a href="#ANR分析办法二：看trace文件" class="headerlink" title="ANR分析办法二：看trace文件"></a>ANR分析办法二：看trace文件</h2><p>刚才的log有第二句Wrote stack traces to ‘/data/anr/traces.txt’，说明ANR异常已经输出到traces.txt文件，使用adb命令把这个文件从手机里导出来：</p>
<ol>
<li>cd到adb.exe所在的目录，也就是<strong>Android SDK</strong>的platform-tools目录，例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd D:\Android\AndroidSdk\platform-tools</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此外，除了Windows的cmd以外，还可以使用AndroidStudio的Terminal来输入adb命令。</p>
</blockquote>
<p>2.到指定目录后执行以下adb命令导出traces.txt文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">adb pull /data/anr/traces.txt</span><br></pre></td></tr></table></figure>

<p>traces.txt默认会被导出到<strong>Android SDK</strong>的<strong>\platform-tools</strong>目录。一般来说traces.txt文件记录的东西会比较多，分析的时候需要有针对性地去找相关记录。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">----- pid 23346 at 2017-11-07 11:33:57 -----  ----&gt; 进程id和ANR产生时间</span><br><span class="line">Cmd line: com.sky.myjavatest</span><br><span class="line">Build fingerprint: &#x27;google/marlin/marlin:8.0.0/OPR3.170623.007/4286350:user/release-keys&#x27;</span><br><span class="line">ABI: &#x27;arm64&#x27;</span><br><span class="line">Build type: optimized</span><br><span class="line">Zygote loaded classes=4681 post zygote classes=106</span><br><span class="line">Intern table: 42675 strong; 137 weak</span><br><span class="line">JNI: CheckJNI is on; globals=526 (plus 22 weak)</span><br><span class="line">Libraries: /system/lib64/libandroid.so /system/lib64/libcompiler<span class="built_in">_</span>rt.so </span><br><span class="line">/system/lib64/libjavacrypto.so</span><br><span class="line">/system/lib64/libjnigraphics.so /system/lib64/libmedia<span class="built_in">_</span>jni.so /system/lib64/libsoundpool.so</span><br><span class="line">/system/lib64/libwebviewchromium<span class="built_in">_</span>loader.so libjavacore.so libopenjdk.so (9)</span><br><span class="line">Heap: 22<span class="comment">% free, 1478KB/1896KB; 21881 objects    ----&gt; 内存使用情况</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&quot;main&quot; prio=5 tid=1 Sleeping    ----&gt; 原因为Sleeping</span><br><span class="line">  | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x733d0670 self=0x74a4abea00</span><br><span class="line">  | sysTid=23346 nice=-10 cgrp=default sched=0/0 handle=0x74a91ab9b0</span><br><span class="line">  | state=S schedstat=( 391462128 82838177 354 ) utm=33 stm=4 core=3 HZ=100</span><br><span class="line">  | stack=0x7fe6fac000-0x7fe6fae000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Thread.sleep(Native method)</span><br><span class="line">  - sleeping on &lt;0x053fd2c2&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:373)</span><br><span class="line">  - locked &lt;0x053fd2c2&gt; (a java.lang.Object)</span><br><span class="line">  at java.lang.Thread.sleep(Thread.java:314)</span><br><span class="line">  at android.os.SystemClock.sleep(SystemClock.java:122)</span><br><span class="line">  at com.sky.myjavatest.ANRTestActivity.onCreate(ANRTestActivity.java:20) ----&gt; 产生ANR的包名以及具体行数</span><br><span class="line">  at android.app.Activity.performCreate(Activity.java:6975)</span><br><span class="line">  at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1213)</span><br><span class="line">  at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2770)</span><br><span class="line">  at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2892)</span><br><span class="line">  at android.app.ActivityThread.-wrap11(ActivityThread.java:-1)</span><br><span class="line">  at android.app.ActivityThread<span class="built_in">$</span>H.handleMessage(ActivityThread.java:1593)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:105)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:164)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:6541)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Native method)</span><br><span class="line">  at com.android.internal.os.Zygote<span class="built_in">$</span>MethodAndArgsCaller.run(Zygote.java:240)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767)</span><br></pre></td></tr></table></figure>

<p>在文件中使用 ctrl + F 查找包名可以快速定位相关代码。<br>通过上方log可以看出相关问题：</p>
<ul>
<li>进程id和包名：pid 23346 com.sky.myjavatest</li>
<li>造成ANR的原因：Sleeping</li>
<li>造成ANR的具体行数：ANRTestActivity.java:20类的第20行</li>
</ul>
<p><strong>特别注意：产生新的ANR，原来的 traces.txt 文件会被覆盖。</strong></p>
<h2 id="ANR分析办法三：java线程调用分析"><a href="#ANR分析办法三：java线程调用分析" class="headerlink" title="ANR分析办法三：java线程调用分析"></a>ANR分析办法三：java线程调用分析</h2><p>通过JDK提供的命令可以帮助分析和调试Java应用，命令为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jstack &#123;pid&#125;</span><br></pre></td></tr></table></figure>

<p>其中pid可以通过jps命令获得，jps命令会列出当前系统中运行的所有Java虚拟机进程，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">7266</span> Test</span><br><span class="line"><span class="number">7267</span> Jps</span><br></pre></td></tr></table></figure>

<h2 id="ANR分析办法四：DDMS分析ANR问题"><a href="#ANR分析办法四：DDMS分析ANR问题" class="headerlink" title="ANR分析办法四：DDMS分析ANR问题"></a>ANR分析办法四：DDMS分析ANR问题</h2><ul>
<li>使用DDMS——Update Threads工具</li>
<li>阅读Update Threads的输出</li>
</ul>
<h1 id="造成ANR的原因及解决办法"><a href="#造成ANR的原因及解决办法" class="headerlink" title="造成ANR的原因及解决办法"></a>造成ANR的原因及解决办法</h1><p>上面例子只是由于简单的主线程耗时操作造成的ANR，造成ANR的原因还有很多：</p>
<ul>
<li>主线程阻塞或主线程数据读取</li>
</ul>
<blockquote>
<p>解决办法：避免死锁的出现，使用子线程来处理耗时操作或阻塞任务。尽量避免在主线程query provider、不要滥用SharePreferenceS</p>
</blockquote>
<ul>
<li>CPU满负荷，I/O阻塞</li>
</ul>
<blockquote>
<p>解决办法：文件读写或数据库操作放在子线程异步操作。</p>
</blockquote>
<ul>
<li>内存不足</li>
</ul>
<blockquote>
<p>解决办法：AndroidManifest.xml文件<applicatiion>中可以设置 android:largeHeap=”true”，以此增大App使用内存。不过<strong>不建议使用此法</strong>，从根本上防止内存泄漏，优化内存使用才是正道。</p>
</blockquote>
<ul>
<li>各大组件ANR</li>
</ul>
<blockquote>
<p>各大组件生命周期中也应避免耗时操作，注意BroadcastReciever的onRecieve()、后台Service和ContentProvider也不要执行太长时间的任务。</p>
</blockquote>
<h1 id="ANR源码分析"><a href="#ANR源码分析" class="headerlink" title="ANR源码分析"></a>ANR源码分析</h1><h2 id="Service造成的Service-Timeout"><a href="#Service造成的Service-Timeout" class="headerlink" title="Service造成的Service Timeout"></a>Service造成的Service Timeout</h2><p><strong>Service Timeout</strong>是位于**”ActivityManager”**线程中的AMS.MainHandler收到SERVICE_TIMEOUT_MSG消息时触发。</p>
<h3 id="发送延时消息"><a href="#发送延时消息" class="headerlink" title="发送延时消息"></a>发送延时消息</h3><p><strong>Service</strong>进程attach到system_server进程的过程中会调用realStartServiceLocked，紧接着mAm.mHandler.sendMessageAtTime()来发送一个延时消息，延时的时常是定义好的，如前台<strong>Service</strong>的20秒。<strong>ActivityManager</strong>线程中的<strong>AMS.MainHandler</strong>收到SERVICE_TIMEOUT_MSG消息时会触发。</p>
<p><strong>AS.realStartServiceLocked</strong></p>
<blockquote>
<p>ActiveServices.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="params"><span class="function">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//发送delay消息(SERVICE_TIMEOUT_MSG)</span></span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;create&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//最终执行服务的onCreate()方法</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AS.bumpServiceExecutingLocked</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bumpServiceExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> fg, String why)</span> </span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleServiceTimeoutLocked</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc.executingServices.size() == <span class="number">0</span> || proc.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当超时后仍没有remove该SERVICE_TIMEOUT_MSG消息，则执行service Timeout流程</span></span><br><span class="line">    mAm.mHandler.sendMessageAtTime(msg,</span><br><span class="line">        proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进入目标进程的主线程创建Service"><a href="#进入目标进程的主线程创建Service" class="headerlink" title="进入目标进程的主线程创建Service"></a>进入目标进程的主线程创建Service</h3><p><strong>经过Binder等层层调用进入目标进程的主线程 handleCreateService(CreateServiceData data)。</strong></p>
<blockquote>
<p>ActivityThread.java</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        Service service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建ContextImpl对象</span></span><br><span class="line">            ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">            context.setOuterContext(service);</span><br><span class="line">            <span class="comment">//创建Application对象</span></span><br><span class="line">            Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">            service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                    ActivityManagerNative.getDefault());</span><br><span class="line">            <span class="comment">//调用服务onCreate()方法 </span></span><br><span class="line">            service.onCreate();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取消AMS.MainHandler的延时消息</span></span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中会创建目标服务对象，以及回调常用的<strong>Service</strong>的onCreate()方法，紧接着通过serviceDoneExecuting()回到system_server执行取消AMS.MainHandler的延时消息。</p>
<h3 id="回到system-server执行取消AMS-MainHandler的延时消息"><a href="#回到system-server执行取消AMS-MainHandler的延时消息" class="headerlink" title="回到system_server执行取消AMS.MainHandler的延时消息"></a>回到system_server执行取消AMS.MainHandler的延时消息</h3><p><strong>AS.serviceDoneExecutingLocked</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> inDestroying,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> finishing)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当前服务所在进程中没有正在执行的service</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法中Service逻辑处理完成则移除之前延时的消息SERVICE_TIMEOUT_MSG。如果没有执行完毕不调用这个方法，则超时后会发出SERVICE_TIMEOUT_MSG来告知ANR发生。</p>
<h2 id="BroadcastReceiver造成的BroadcastQueue-Timeout"><a href="#BroadcastReceiver造成的BroadcastQueue-Timeout" class="headerlink" title="BroadcastReceiver造成的BroadcastQueue Timeout"></a>BroadcastReceiver造成的BroadcastQueue Timeout</h2><blockquote>
<p>BroadcastReceiver Timeout是位于”ActivityManager”线程中的BroadcastQueue.BroadcastHandler收到BROADCAST_TIMEOUT_MSG消息时触发。</p>
</blockquote>
<h3 id="处理广播函数-processNextBroadcast-中-broadcastTimeoutLocked-false-发送延时消息"><a href="#处理广播函数-processNextBroadcast-中-broadcastTimeoutLocked-false-发送延时消息" class="headerlink" title="处理广播函数 processNextBroadcast() 中 broadcastTimeoutLocked(false) 发送延时消息"></a>处理广播函数 processNextBroadcast() 中 broadcastTimeoutLocked(false) 发送延时消息</h3><p>广播处理顺序为先处理并行广播，再处理当前有序广播。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processNextBroadcast</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 处理当前有序广播</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//获取所有该广播所有的接收者</span></span><br><span class="line">            <span class="keyword">int</span> numReceivers = (r.receivers != <span class="keyword">null</span>) ? r.receivers.size() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        (now &gt; r.dispatchTime + (<span class="number">2</span>*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">                    <span class="comment">//step 1\. 发送延时消息，这个函数处理了很多事情，比如广播处理超时结束广播</span></span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">false</span>);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r.receivers == <span class="keyword">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//2\. 处理广播消息消息</span></span><br><span class="line">                    performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                        <span class="keyword">new</span> Intent(r.intent), r.resultCode,</span><br><span class="line">                        r.resultData, r.resultExtras, <span class="keyword">false</span>, <span class="keyword">false</span>, r.userId);</span><br><span class="line">                    r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//3\. 取消广播超时ANR消息</span></span><br><span class="line">                cancelBroadcastTimeoutLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="keyword">null</span>);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下条有序广播</span></span><br><span class="line">        r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">            <span class="comment">//设置广播超时</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上文的step 1. broadcastTimeoutLocked(false)函数：记录时间信息并调用函数设置发送延时消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">broadcastTimeoutLocked</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mService.mDidDexOpt) &#123;</span><br><span class="line">                <span class="comment">// Delay timeouts until dexopt finishes.</span></span><br><span class="line">                mService.mDidDexOpt = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">long</span> timeoutTime = SystemClock.uptimeMillis() + mTimeoutPeriod;</span><br><span class="line">                setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mService.mProcessesReady) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">            <span class="keyword">if</span> (timeoutTime &gt; now) &#123;</span><br><span class="line">                <span class="comment">// step 2</span></span><br><span class="line">                setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>上文的step 2.setBroadcastTimeoutLocked函数： 设置广播超时具体操作，同样是发送延时消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setBroadcastTimeoutLocked</span><span class="params">(<span class="keyword">long</span> timeoutTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, <span class="keyword">this</span>);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timeoutTime);</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setBroadcastTimeoutLocked-long-timeoutTime-函数的参数timeoutTime是当前时间加上设定好的超时时间。"><a href="#setBroadcastTimeoutLocked-long-timeoutTime-函数的参数timeoutTime是当前时间加上设定好的超时时间。" class="headerlink" title="setBroadcastTimeoutLocked(long timeoutTime)函数的参数timeoutTime是当前时间加上设定好的超时时间。"></a>setBroadcastTimeoutLocked(long timeoutTime)函数的参数timeoutTime是当前时间加上设定好的超时时间。</h3><p>也就是上文的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> timeoutTime = SystemClock.uptimeMillis() + mTimeoutPeriod;</span><br></pre></td></tr></table></figure>

<p>mTimeoutPeriod 也就是前台队列的10s和后台队列的60s。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerService</span><span class="params">(Context systemContext)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BROADCAST_FG_TIMEOUT = <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BROADCAST_BG_TIMEOUT = <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    ...</span><br><span class="line">    mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">            <span class="string">&quot;foreground&quot;</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">    mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">            <span class="string">&quot;background&quot;</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在processNextBroadcast-过程，执行完performReceiveLocked后调用cancelBroadcastTimeoutLocked"><a href="#在processNextBroadcast-过程，执行完performReceiveLocked后调用cancelBroadcastTimeoutLocked" class="headerlink" title="在processNextBroadcast()过程，执行完performReceiveLocked后调用cancelBroadcastTimeoutLocked"></a>在processNextBroadcast()过程，执行完performReceiveLocked后调用cancelBroadcastTimeoutLocked</h3><p><strong>cancelBroadcastTimeoutLocked ：处理广播消息函数 processNextBroadcast() 中 performReceiveLocked() 处理广播消息完毕则调用 cancelBroadcastTimeoutLocked() 取消超时消息。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cancelBroadcastTimeoutLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        mHandler.removeMessages(BROADCAST_TIMEOUT_MSG, <span class="keyword">this</span>);</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ContentProvider的ContentProvider-Timeout"><a href="#ContentProvider的ContentProvider-Timeout" class="headerlink" title="ContentProvider的ContentProvider Timeout"></a>ContentProvider的ContentProvider Timeout</h2><blockquote>
<p>ContentProvider Timeout是位于”ActivityManager”线程中的AMS.MainHandler收到CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG消息时触发。</p>
</blockquote>
<h1 id="Android-ANR的信息收集"><a href="#Android-ANR的信息收集" class="headerlink" title="Android ANR的信息收集"></a>Android ANR的信息收集</h1><p>无论是四大组件或者进程等只要发生ANR，最终都会调用AMS.appNotResponding()方法。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>ANR</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP-CarLauncher介绍</title>
    <url>/2021/03/17/android_aosp_car_launcher_introduction/</url>
    <content><![CDATA[<p>Car Launcher作为车载Android的桌面启动器，是车载Android的入口应用。</p>
<span id="more"></span>

<p><img src="/images/android_aosp_car_launcher_introduction01.png" alt="image"></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><p>Car Launcher是安卓系统中的桌面启动器，安卓系统的桌面UI统称为Launcher;</p>
</li>
<li><p>Launcher是安卓系统中的主要程序组件之一，安卓系统中如果没有Launcher就无法启动安卓桌面</p>
</li>
<li><p>Car Launcher是android系统的桌面，是用户接触到的第一个带有界面的APP。</p>
</li>
<li><p>它本质上就是一个系统级APP，和普通的APP一样，它界面也是在Activity上绘制出来的。</p>
</li>
<li><p>虽然Car Launcher也是一个APP，但是它涉及到的技术点却比一般的APP要多。</p>
</li>
<li><p>CarLauncher作为IVI系统的桌面，需要显示系统中所有用户可用app的入口，显示最近用户使用的APP，同时还需要支持在桌面上动态显示如地图、音乐在内各个APP内部的信息，在桌面显示地图并与之进行简单的交互。</p>
</li>
</ul>
<h1 id="Car-Launcher元素介绍"><a href="#Car-Launcher元素介绍" class="headerlink" title="Car Launcher元素介绍"></a>Car Launcher元素介绍</h1><p>Car Launcher 代码，可以划分两个领域<br>1.Car Launcher主要功能区域<br>2.Car Launcher 协作式 控制 SystemUI 功能区域</p>
<p>如下图，为快捷功能区域和SystemUI</p>
<p><img src="/images/android_aosp_car_launcher_introduction03.png" alt="image"></p>
<p>如下图，为CarLauncher区域和SystemUI</p>
<p><img src="/images/android_aosp_car_launcher_introduction02.png" alt="image"></p>
<p>【SystemUI区域】：在下方的NaviBar有9个按钮，只有点击[首页]或[App桌面]才会进入Car Launcher<br>【Car launcher区域】：在上方的大范围区域，基本上就是 Car Launcher区域</p>
<h1 id="Car-Launcher代码介绍"><a href="#Car-Launcher代码介绍" class="headerlink" title="Car Launcher代码介绍"></a>Car Launcher代码介绍</h1><p><img src="/images/android_aosp_car_launcher_introduction04.png" alt="image"></p>
<h2 id="android-bp分析"><a href="#android-bp分析" class="headerlink" title="android.bp分析"></a>android.bp分析</h2><p>描述Android.bp: 车载CarLauncher的Android.bp比Android.mk更加优秀，他定义CarLauncher的源码结构，和依赖的类库。</p>
<p><img src="/images/android_aosp_car_launcher_introduction05.png" alt="image"></p>
<ul>
<li><p>注意1：一个属性overrides，它表示覆盖的意思。<br>在系统编译时Launcher2、Launcher3、Launcher3QuickStep都会被CarLauncher取代，前面三个Launcher并不是车机系统的桌面，车载系统中会用CarLauncher这个定制新的桌面取代掉其它系统的桌面。\</p>
</li>
<li><p>注意2：若不想使用系统中自带的CarLauncher，那么也需要在overrides中覆盖掉CarLauncher。</p>
</li>
<li><p>注意3：在自主开发的车载Android系统中这个属性我们会经常用到，用我们自己定制的各种APP来取代系统中默认的APP，比如系统设置等等。</p>
</li>
</ul>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">android<span class="built_in">_</span>app &#123;</span><br><span class="line">    name: &quot;CarLauncher&quot;,</span><br><span class="line">    srcs: [&quot;src/**/*.java&quot;],</span><br><span class="line">    resource<span class="built_in">_</span>dirs: [&quot;res&quot;],</span><br><span class="line">    // 允许使用系统的hide api</span><br><span class="line">    platform<span class="built_in">_</span>apis: true,</span><br><span class="line">    required: [&quot;privapp<span class="built_in">_</span>whitelist<span class="built_in">_</span>com.android.car.carlauncher&quot;],</span><br><span class="line">    // 签名类型 ： platform</span><br><span class="line">    certificate: &quot;platform&quot;,</span><br><span class="line">    // 设定apk安装路径为priv-app</span><br><span class="line">    privileged: true,</span><br><span class="line">    // 覆盖其它类型的Launcher</span><br><span class="line">    overrides: [</span><br><span class="line">        &quot;Launcher2&quot;,</span><br><span class="line">        &quot;Launcher3&quot;,</span><br><span class="line">        &quot;Launcher3QuickStep&quot;,</span><br><span class="line">    ],</span><br><span class="line">    optimize: &#123;</span><br><span class="line">    	enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    dex<span class="built_in">_</span>preopt: &#123;</span><br><span class="line">    	enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    // 引入静态库</span><br><span class="line">    static<span class="built_in">_</span>libs: [</span><br><span class="line">        &quot;androidx-constraintlayout<span class="built_in">_</span>constraintlayout-solver&quot;,</span><br><span class="line">        &quot;androidx-constraintlayout<span class="built_in">_</span>constraintlayout&quot;,</span><br><span class="line">        &quot;androidx.lifecycle<span class="built_in">_</span>lifecycle-extensions&quot;,</span><br><span class="line">        &quot;car-media-common&quot;,</span><br><span class="line">        &quot;car-ui-lib&quot;,</span><br><span class="line">    ],</span><br><span class="line">    libs: [&quot;android.car&quot;],</span><br><span class="line">    product<span class="built_in">_</span>variables: &#123;</span><br><span class="line">        pdk: &#123;</span><br><span class="line">        	enabled: false,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AndroidManifest-xml分析"><a href="#AndroidManifest-xml分析" class="headerlink" title="AndroidManifest.xml分析"></a>AndroidManifest.xml分析</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/ic_launcher_home&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/app_title&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Launcher&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 首页快捷操作功能区域，车载系统开机后，默认的第一个画面（首页CarLauncher） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.CarLauncher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:configChanges</span>=<span class="string">&quot;uiMode|mcc|mnc&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:clearTaskOnLaunch</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:stateNotNeeded</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resumeWhilePausing</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;adjustPan&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;distractionOptimized&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.HOME&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 车载所有应用展示 的 桌面中心（AppCridActivity 展示所有应用） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;.AppGridActivity&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:launchMode</span>=<span class="string">&quot;singleInstance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Launcher.AppGridActivity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;distractionOptimized&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.android.car.carlauncher.ACTION_APP_GRID&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 提供管理电话呼叫功能的应用程序实现的服务（还记得 蓝牙拨号功能么？）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.homescreen.audio.telecom.InCallServiceImpl&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:permission</span>=<span class="string">&quot;android.permission.BIND_INCALL_SERVICE&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- The home app does not display the in-call UI. This is handled by the</span></span><br><span class="line"><span class="comment">        Dialer application.--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.telecom.IN_CALL_SERVICE_UI&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.telecom.IN_CALL_SERVICE_CAR_MODE_UI&quot;</span> <span class="attr">android:value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.telecom.InCallService&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="AppGridActivity"><a href="#AppGridActivity" class="headerlink" title="AppGridActivity"></a>AppGridActivity</h2><p>车载APPGridActivity，目的是展示所有车载系统应用，为车载驾驶的用户提供车载系统操作中心</p>
<p><img src="/images/android_aosp_car_launcher_introduction06.png" alt="image"></p>
<h3 id="展示所有的车载应用"><a href="#展示所有的车载应用" class="headerlink" title="展示所有的车载应用"></a>展示所有的车载应用</h3><p>车载Launcher中 获取所有APP的方法都集中在<code>AppLauncherUtils</code>工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取我们希望在启动器中以未排序的顺序看到的所有组件，包括启动器活动和媒体服务。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> blackList 要隐藏的应用程序（包名称）列表（可能为空）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> customMediaComponents 不应在Launcher中显示的媒体组件（组件名称）列表</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> appTypes 要显示的应用程序类型（例如：全部或仅媒体源）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> openMediaCenter 当用户选择媒体源时，启动器是否应导航到media center</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> launcherApps &#123;<span class="doctag">@link</span> LauncherApps&#125;系统服务</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> carPackageManager &#123;<span class="doctag">@link</span> CarPackageManager&#125;系统服务</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> packageManager &#123;<span class="doctag">@link</span> PackageManager&#125;系统服务</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 一个新的 &#123;<span class="doctag">@link</span> LauncherAppsInfo&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> LauncherAppsInfo <span class="title">getLauncherApps</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Set&lt;String&gt; appsToHide,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@NonNull</span> Set&lt;String&gt; customMediaComponents,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@AppTypes</span> <span class="keyword">int</span> appTypes,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> openMediaCenter,</span></span></span><br><span class="line"><span class="params"><span class="function">        LauncherApps launcherApps,</span></span></span><br><span class="line"><span class="params"><span class="function">        CarPackageManager carPackageManager,</span></span></span><br><span class="line"><span class="params"><span class="function">        PackageManager packageManager,</span></span></span><br><span class="line"><span class="params"><span class="function">        CarMediaManager carMediaManager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (launcherApps == <span class="keyword">null</span> || carPackageManager == <span class="keyword">null</span> || packageManager == <span class="keyword">null</span></span><br><span class="line">            || carMediaManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_APPS_INFO;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;ResolveInfo&gt; mediaServices = packageManager.queryIntentServices(</span><br><span class="line">            <span class="keyword">new</span> Intent(MediaBrowserService.SERVICE_INTERFACE),</span><br><span class="line">            PackageManager.GET_RESOLVED_FILTER);</span><br><span class="line">    List&lt;LauncherActivityInfo&gt; availableActivities =</span><br><span class="line">            launcherApps.getActivityList(<span class="keyword">null</span>, Process.myUserHandle());</span><br><span class="line">    Map&lt;ComponentName, AppMetaData&gt; launchablesMap = <span class="keyword">new</span> HashMap&lt;&gt;(</span><br><span class="line">            mediaServices.size() + availableActivities.size());</span><br><span class="line">    Map&lt;ComponentName, ResolveInfo&gt; mediaServicesMap = <span class="keyword">new</span> HashMap&lt;&gt;(mediaServices.size());</span><br><span class="line">    <span class="comment">// Process media services</span></span><br><span class="line">    <span class="keyword">if</span> ((appTypes &amp; APP_TYPE_MEDIA_SERVICES) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ResolveInfo info : mediaServices) &#123;</span><br><span class="line">            String packageName = info.serviceInfo.packageName;</span><br><span class="line">            String className = info.serviceInfo.name;</span><br><span class="line">            ComponentName componentName = <span class="keyword">new</span> ComponentName(packageName, className);</span><br><span class="line">            mediaServicesMap.put(componentName, info);</span><br><span class="line">            <span class="keyword">if</span> (shouldAddToLaunchables(componentName, appsToHide, customMediaComponents,</span><br><span class="line">                    appTypes, APP_TYPE_MEDIA_SERVICES)) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> isDistractionOptimized = <span class="keyword">true</span>;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Car.CAR_INTENT_ACTION_MEDIA_TEMPLATE);</span><br><span class="line">                intent.putExtra(Car.CAR_EXTRA_MEDIA_COMPONENT, componentName.flattenToString());</span><br><span class="line">                AppMetaData appMetaData = <span class="keyword">new</span> AppMetaData(</span><br><span class="line">                    info.serviceInfo.loadLabel(packageManager),</span><br><span class="line">                    componentName,</span><br><span class="line">                    info.serviceInfo.loadIcon(packageManager),</span><br><span class="line">                    isDistractionOptimized,</span><br><span class="line">                    context -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (openMediaCenter) &#123;</span><br><span class="line">                            AppLauncherUtils.launchApp(context, intent);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            selectMediaSourceAndFinish(context, componentName, carMediaManager);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    context -&gt; &#123;</span><br><span class="line">                        <span class="comment">// getLaunchIntentForPackage looks for a main activity in the category</span></span><br><span class="line">                        <span class="comment">// Intent.CATEGORY_INFO, then Intent.CATEGORY_LAUNCHER, and returns null</span></span><br><span class="line">                        <span class="comment">// if neither are found</span></span><br><span class="line">                        Intent packageLaunchIntent =</span><br><span class="line">                                packageManager.getLaunchIntentForPackage(packageName);</span><br><span class="line">                        AppLauncherUtils.launchApp(context,</span><br><span class="line">                                packageLaunchIntent != <span class="keyword">null</span> ? packageLaunchIntent : intent);</span><br><span class="line">                    &#125;);</span><br><span class="line">                launchablesMap.put(componentName, appMetaData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process activities</span></span><br><span class="line">    <span class="keyword">if</span> ((appTypes &amp; APP_TYPE_LAUNCHABLES) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LauncherActivityInfo info : availableActivities) &#123;</span><br><span class="line">            ComponentName componentName = info.getComponentName();</span><br><span class="line">            String packageName = componentName.getPackageName();</span><br><span class="line">            <span class="keyword">if</span> (shouldAddToLaunchables(componentName, appsToHide, customMediaComponents,</span><br><span class="line">                    appTypes, APP_TYPE_LAUNCHABLES)) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isDistractionOptimized =</span><br><span class="line">                    isActivityDistractionOptimized(carPackageManager, packageName,</span><br><span class="line">                        info.getName());</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN)</span><br><span class="line">                    .setComponent(componentName)</span><br><span class="line">                    .addCategory(Intent.CATEGORY_LAUNCHER)</span><br><span class="line">                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                AppMetaData appMetaData = <span class="keyword">new</span> AppMetaData(</span><br><span class="line">                    info.getLabel(),</span><br><span class="line">                    componentName,</span><br><span class="line">                    info.getBadgedIcon(<span class="number">0</span>),</span><br><span class="line">                    isDistractionOptimized,</span><br><span class="line">                    context -&gt; AppLauncherUtils.launchApp(context, intent),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">                launchablesMap.put(componentName, appMetaData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LauncherAppsInfo(launchablesMap, mediaServicesMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AppLauncherUtils中的其他方法"><a href="#AppLauncherUtils中的其他方法" class="headerlink" title="AppLauncherUtils中的其他方法"></a>AppLauncherUtils中的其他方法</h3><ul>
<li><p>1.LauncherApps.getActivityList() 可以获取List包含了车载所有配置<br>Intent#ACTION_MAIN 和Intent#CATEGORY_LAUNCHER的Activity信息。</p>
</li>
<li><p>2.API操作介绍<br>String LauncherActivityInfogetLabel() : 获取app的name<br>String LauncherActivityInfo.getComponentName() : 获取app的Mainactivity信息<br>Drawable LauncherActivityInfo.getBadgedIcon(0) : 获取App的图标</p>
</li>
<li><p>3.涉及到车载多屏<br>当用户点击图标时，虽然也是通过startActivity启动App，但是ActivityOptions可以让我们决定目标APP在哪个屏幕上启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">launchApp</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">ActivityOptions options = ActivityOptions.makeBasic();</span><br><span class="line"><span class="comment">// 在当前的车载系统屏幕上启动目标App的Activity</span></span><br><span class="line">options.setLaunchDisplayId(context.getDisplayId());</span><br><span class="line">context.startActivity(intent, options.toBundle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="展示最近使用的车载应用"><a href="#展示最近使用的车载应用" class="headerlink" title="展示最近使用的车载应用"></a>展示最近使用的车载应用</h3><p>车载系统中有UsageStatusManager来对设备使用情况历史记录和统计信息的访问，UsageStatusManager使用<br>android.provider.Settings#ACTION_USAGE_ACCESS_SETTINGS，<br>注意：<br>getAppStandbyBucket()，queryEventsForSelf(long,long)，方法时不需要添加额外的权限<br>但是除此以外的方法都需要android.permission.PACKAGE_USAGE_STATS权限才行哦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 注意，为了从上一次boot中获得使用情况统计数据，设备必须经过干净的关闭过程。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;AppMetaData&gt; <span class="title">getMostRecentApps</span><span class="params">(LauncherAppsInfo appsInfo)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;AppMetaData&gt; apps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (appsInfo.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> apps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取从1年前开始的使用情况统计数据，返回如下条目：</span></span><br><span class="line">    <span class="comment">// returning entries like:</span></span><br><span class="line">    <span class="comment">// &quot;During 2017 App A is last used at 2017/12/15 18:03&quot;</span></span><br><span class="line">    <span class="comment">// &quot;During 2017 App B is last used at 2017/6/15 10:00&quot;</span></span><br><span class="line">    <span class="comment">// &quot;During 2018 App A is last used at 2018/1/1 15:12&quot;</span></span><br><span class="line">    List&lt;UsageStats&gt; stats =</span><br><span class="line">            mUsageStatsManager.queryUsageStats(</span><br><span class="line">                    UsageStatsManager.INTERVAL_YEARLY,</span><br><span class="line">                    System.currentTimeMillis() - DateUtils.YEAR_IN_MILLIS,</span><br><span class="line">                    System.currentTimeMillis());</span><br><span class="line">    <span class="keyword">if</span> (stats == <span class="keyword">null</span> || stats.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> apps; <span class="comment">// empty list</span></span><br><span class="line">    &#125;</span><br><span class="line">    stats.sort(<span class="keyword">new</span> LastTimeUsedComparator());</span><br><span class="line">    <span class="keyword">int</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> itemsAdded = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> statsSize = stats.size();</span><br><span class="line">    <span class="keyword">int</span> itemCount = Math.min(mColumnNumber, statsSize);</span><br><span class="line">    <span class="keyword">while</span> (itemsAdded &lt; itemCount &amp;&amp; currentIndex &lt; statsSize) &#123;</span><br><span class="line">        UsageStats usageStats = stats.get(currentIndex);</span><br><span class="line">        String packageName = usageStats.mPackageName;</span><br><span class="line">        currentIndex++;</span><br><span class="line">        <span class="comment">// 不包括自己</span></span><br><span class="line">        <span class="keyword">if</span> (packageName.equals(getPackageName())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO(b/136222320): 每个包都可以获得UsageStats，但一个包可能包含多个媒体服务</span></span><br><span class="line">		<span class="comment">// 我们需要找到一种方法来获取每个服务的使用率统计数据。</span></span><br><span class="line">        ComponentName componentName = AppLauncherUtils.getMediaSource(mPackageManager,</span><br><span class="line">                packageName);</span><br><span class="line">        <span class="comment">// 免除媒体服务的后台和启动器检查</span></span><br><span class="line">        <span class="keyword">if</span> (!appsInfo.isMediaService(componentName)) &#123;</span><br><span class="line">            <span class="comment">// 不要包括仅在后台运行的应用程序</span></span><br><span class="line">            <span class="keyword">if</span> (usageStats.getTotalTimeInForeground() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不要包含不支持从启动器启动的应用程序</span></span><br><span class="line">            Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);</span><br><span class="line">            <span class="keyword">if</span> (intent == <span class="keyword">null</span> || !intent.hasCategory(Intent.CATEGORY_LAUNCHER)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        AppMetaData app = appsInfo.getAppMetaData(componentName);</span><br><span class="line">        <span class="comment">// 防止重复条目</span></span><br><span class="line">        <span class="comment">// e.g. app is used at 2017/12/31 23:59, and 2018/01/01 00:00</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; !apps.contains(app)) &#123;</span><br><span class="line">            apps.add(app);</span><br><span class="line">            itemsAdded++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> apps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快捷功能区域代码"><a href="#快捷功能区域代码" class="headerlink" title="快捷功能区域代码"></a>快捷功能区域代码</h2><p><img src="/images/android_aosp_car_launcher_introduction08.png" alt="image"></p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>车载系统开机默认启动CarLauncher的onCreate方法&amp;布局文件</p>
<p><img src="/images/android_aosp_car_launcher_introduction07.png" alt="image"></p>
<p>接下来看一下横屏的布局文件，源码中其实还包含了竖屏和多窗口的布局</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layoutDirection</span>=<span class="string">&quot;ltr&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.CarLauncher&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 上面正方形区域 显示天气 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.android.car.ui.FocusArea</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/top_card&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/main_screen_widget_margin&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layoutDirection</span>=<span class="string">&quot;locale&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toLeftOf</span>=<span class="string">&quot;@+id/vertical_barrier&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@+id/bottom_card&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 下面正方形区域 显示 音乐活动交互等信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.android.car.ui.FocusArea</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bottom_card&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layoutDirection</span>=<span class="string">&quot;locale&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toLeftOf</span>=<span class="string">&quot;@+id/vertical_barrier&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/top_card&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.Guideline</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/vertical_barrier&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintGuide_begin</span>=<span class="string">&quot;@dimen/card_width&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用来显示地图的 大区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.cardview.widget.CardView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/maps_card&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;@style/CardViewStyle&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;@dimen/main_screen_widget_margin&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layoutDirection</span>=<span class="string">&quot;locale&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toRightOf</span>=<span class="string">&quot;@+id/vertical_barrier&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>车载系统 快捷功能主页的初始化工作，都是在 CarLauncher的onCreate方法中完成的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    mCarLauncherTaskId = getTaskId();</span><br><span class="line">    ActivityTaskManager.getInstance().registerTaskStackListener(mTaskStackListener);</span><br><span class="line">    <span class="comment">// Setting as trusted overlay to let touches pass through.</span></span><br><span class="line">    getWindow().addPrivateFlags(PRIVATE_FLAG_TRUSTED_OVERLAY);</span><br><span class="line">    <span class="comment">// To pass touches to the underneath task.</span></span><br><span class="line">    getWindow().addFlags(WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL);</span><br><span class="line">    <span class="comment">// 在多窗口模式下『car_launcher_multiwindow』不显示“地图”面板。</span></span><br><span class="line">	<span class="comment">// 注意：拆分屏幕的CTS测试与启动器默认活动的活动视图不兼容</span></span><br><span class="line">    <span class="comment">// activity of the launcher</span></span><br><span class="line">    <span class="keyword">if</span> (isInMultiWindowMode() || isInPictureInPictureMode()) &#123;</span><br><span class="line">        setContentView(R.layout.car_launcher_multiwindow);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setContentView(R.layout.car_launcher);</span><br><span class="line">        <span class="comment">// We don&#x27;t want to show Map card unnecessarily for the headless user 0.</span></span><br><span class="line">        <span class="keyword">if</span> (!UserHelperLite.isHeadlessSystemUser(getUserId())) &#123;</span><br><span class="line">            ViewGroup mapsCard = findViewById(R.id.maps_card);</span><br><span class="line">            <span class="keyword">if</span> (mapsCard != <span class="keyword">null</span>) &#123;</span><br><span class="line">                setUpTaskView(mapsCard);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此方法用于 初始化『天气』和『音乐』fragment 区域信息</span></span><br><span class="line">    initializeCards();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Android系统开发</category>
        <category>车联网</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP-Android安全机制SEAndroid/SELinux</title>
    <url>/2021/04/06/android_aosp_android_safe/</url>
    <content><![CDATA[<p>Android 平台利用基于用户的 Linux 保护机制识别和隔离应用资源，作为 Android 安全模型的一部分，Android 使用安全增强型 Linux (SELinux) 对所有进程强制执行强制访问控制 (MAC)，甚至包括以 Root/超级用户权限运行的进程（Linux 功能）。</p>
<span id="more"></span>

<h1 id="Android权限控制流程"><a href="#Android权限控制流程" class="headerlink" title="Android权限控制流程"></a>Android权限控制流程</h1><p>Android中自主访问控制是通过Linux UID/GID实现，而强制访问控制则是使用的SEAndroid！<br>在Android中SEAndroid安全机制（MAC）与传统的Linux UID/GID安全机制（DAC）是并存关系的，也就是说，它们同时用来约束进程的权限。当一个进程访问一个文件的时候，首先要通过基于UID/GID的DAC安全检查，接着才有资格进入到基于SEAndroid的MAC安全检查。只要其中的一个检查不通过，那么进程访问文件的请求就会被拒绝。</p>
<p><img src="/images/android_aosp_android_safe01.png" alt="image"></p>
<h1 id="DAC自主访问控制"><a href="#DAC自主访问控制" class="headerlink" title="DAC自主访问控制"></a>DAC自主访问控制</h1><p>自主访问控制，正式的英文名称为Discretionary Access Control，简称为DAC。<br>比如通过 ls -l /system ，可以查看到该目录下存在一个manifest.xml文件，其输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rwxr-x--- 1 root root 2544 2022-09-29 17:02 manifest.xml</span><br></pre></td></tr></table></figure>

<p>表示 manifest.xml是root用户组的root用户拥有，对于root用户来说，是rwx（可读可写可执行）；而对于root用户<br>组其他用户来说，是可读可执行；对于其他用户则没有任何权限；也就是750权限。</p>
<p>那我们的程序能够对该文件进行写操作呢？在设备中运行程序执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/system/manifest.xml&quot;</span>);</span><br><span class="line">Log.i(<span class="string">&quot;Lance&quot;</span>, file.canRead()+<span class="string">&quot; &quot;</span>+file.canWrite()+<span class="string">&quot; &quot;</span>+file.canExecute());</span><br></pre></td></tr></table></figure>

<p>会输出：false false false，因为当前程序UID不可能是root（可以通过 data/system/packages.list 文件查看）。<br>我们知道，Android是一个基于Linux内核的系统，但是它不像传统的Linux系统，需要用户登录之后才能使用。然<br>而，Android系统又像传统的Linux系统一样有用户的概念。只不过这些用户不需要登录，也可以使用Android系统。<br>这是因为Android系统将每一个安装在系统的APK都映射为一个不同的Linux用户。也就是说，每一个APK都有一个对应的UID和GID。这些UID和GID是在APK安装的时候由系统安装服务PMS分配的：</p>
<p>在系统源码<code>/base./services/core/java/com/android/server/pm/PackageManagerService.java:</code>中如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageDirtyLI</span><span class="params">(PackageParser.Package pkg,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> policyFlags, <span class="keyword">final</span> <span class="keyword">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">scanFlags, <span class="keyword">long</span> currentTime, <span class="meta">@Nullable</span> UserHandle user)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (pkgSetting == <span class="keyword">null</span>) &#123;</span><br><span class="line">        .......................</span><br><span class="line">        mSettings.addUserToSettingLPw(pkgSetting);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> pkg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在系统源码<code>/base./services/core/java/com/android/server/pm/Settings.java:</code>中如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addUserToSettingLPw</span><span class="params">(PackageSetting p)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.appId == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配uid</span></span><br><span class="line">        p.appId = newUserIdLPw(p);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newUserIdLPw</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mUserIds.size();</span><br><span class="line">    <span class="comment">//从0开始，找到第一个未使用的ID，此处对应之前有应用被移除的情况，复用之前的ID</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mFirstAvailableUid; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mUserIds.get(i) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mUserIds.set(i, obj);</span><br><span class="line">            <span class="keyword">return</span> Process.FIRST_APPLICATION_UID + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最多只能安装 9999 个应用</span></span><br><span class="line">    <span class="keyword">if</span> (N &gt; (Process.LAST_APPLICATION_UID-Process.FIRST_APPLICATION_UID)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mUserIds.add(obj);</span><br><span class="line">    <span class="keyword">return</span> Process.FIRST_APPLICATION_UID + N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在完成安装并运行程序后，可以通过 ps -A | grep PACKAGENAME 查看程序uid：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">angler:/system <span class="params">#</span> ps -A | grep com.enjoy</span><br><span class="line">u0<span class="built_in">_</span>a72 7124 562 2402748 170132 SyS<span class="built_in">_</span>epoll<span class="built_in">_</span>wait 78511081d4 S xxxxx</span><br></pre></td></tr></table></figure>

<p>得到当前程序进程ID为7124，然后通过 cat /proc/7124/status 查看：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">cat /proc/7124/status</span><br><span class="line"><span class="params">#</span>输出</span><br><span class="line">Name: xxxxx</span><br><span class="line">State: S (sleeping)</span><br><span class="line">Tgid: 7124</span><br><span class="line">Pid: 7124</span><br><span class="line">PPid: 562</span><br><span class="line">TracerPid: 0</span><br><span class="line">Uid: 10072 10072 10072 10072</span><br><span class="line">Gid: 10072 10072 10072 10072</span><br><span class="line">FDSize: 64</span><br><span class="line">Groups: 9997 20072 50072</span><br></pre></td></tr></table></figure>

<p>可以看到当前程序UID为10072，通过这种方式，就可以保证每一个APK进程都以不同的身份来运行，从而保证了相<br>互之间不会受到干扰。这就是所谓的沙箱了，这完全是建立在Linux的UID和GID基础上的。<br>root的UID/GID可以通过下面方式查看：</p>
<p>在系统源码<code>/system/core/include/private/android_filesystem_config.h</code>下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AID_ROOT 0 <span class="comment">/* traditional unix root user */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AID_SYSTEM 1000 <span class="comment">/* system server */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AID_APP 10000 <span class="comment">/* <span class="doctag">TODO:</span> switch users over to AID_APP_START */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AID_APP_START 10000 <span class="comment">/* first app user */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AID_APP_END 19999 <span class="comment">/* last app user */</span></span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>可以看到，普通APP的UID从10000开始分配，最大到19999，而root用户的id为0。很显然程序并不具备对<br>manifest.xml文件的读写权限。<br>这种基于Linux UID/GID的安全机制，我们称之为自主访问控制，正式的英文名称为Discretionary Access Control，简称为DAC。</p>
<h1 id="应用权限与DAC的关系"><a href="#应用权限与DAC的关系" class="headerlink" title="应用权限与DAC的关系"></a>应用权限与DAC的关系</h1><p>如何才能让我们的进程能通过Linux UID/GID的拦截呢？如果是一个Android APP若让其具备网络权限，我们只需要在AndroidManifest.xml中配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>APP的UID和GID是在安装时候就由PMS分配好了的。为什么这样一个配置就能够让程序通过Linux UID/GID的拦截？<br>这是因为PMS在安装APK时，从Manifest文件中把App信息和权限存到 /data/system/packages.xml和 /data/system/packages.list 文件中。以《百度作业帮》为例，打开packages.list会存在下面的记录：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">com.baidu.homework 10051 0 /data/user/0/com.baidu.homework default:targetSdkVersion=26 3002,3003,3001</span><br></pre></td></tr></table></figure>

<p>其中3002,3003,3001代表的就是用户组，通过 /system/core/include/private/android_filesystem_config.h 查看可知</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AID_NET_BT_ADMIN 3001 <span class="comment">/* bluetooth: create any socket */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AID_NET_BT 3002 <span class="comment">/* bluetooth: create sco, rfcomm or l2cap sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AID_INET 3003 <span class="comment">/* can create AF_INET and AF_INET6 sockets */</span></span></span><br></pre></td></tr></table></figure>

<p>3001与3002代表了具备蓝牙相关权限的用户组，而3003则表示具备网络权限的用户组。PMS会将APK加入到相应的某个Linux用户组去，这样APK才能够具备对应的权限。<br>运行作业帮后执行：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span>执行</span><br><span class="line">ps -A | grep com.baidu.homework</span><br><span class="line"><span class="params">#</span>输出</span><br><span class="line">u0<span class="built_in">_</span>a51 2516 563 1759664 113932 SyS<span class="built_in">_</span>epoll<span class="built_in">_</span>wait f62ef264 S com.baidu.homework</span><br><span class="line"><span class="params">#</span>执行</span><br><span class="line">cat /proc/2516/status</span><br><span class="line"><span class="params">#</span>输出</span><br><span class="line">Name: .baidu.homework</span><br><span class="line">State: S (sleeping)</span><br><span class="line">Tgid: 2516</span><br><span class="line">Pid: 2516</span><br><span class="line">PPid: 563</span><br><span class="line">TracerPid: 0</span><br><span class="line">Uid: 10051 10051 10051 10051</span><br><span class="line">Gid: 10051 10051 10051 10051</span><br><span class="line">FDSize: 64</span><br><span class="line">Groups: 3001 3002 3003 9997 20051 50051</span><br></pre></td></tr></table></figure>

<p>可以看到在Groups中存在3003，因此作业帮才具备网络访问的权限！Android应用权限与Linux UID/GID权限就是因此而关联起来的。</p>
<h1 id="DAC的问题"><a href="#DAC的问题" class="headerlink" title="DAC的问题"></a>DAC的问题</h1><p>在理想情况下，DAC机制是没有问题的。然而，现实很骨感。比如我们将某个系统文件的权限改为777（可读可写可执行），那是不是意味着我们的程序就能随意修改系统的配置了呢？我们还是以/system/manifest.xml为例：<br>我们通过以下命令将/system挂载为可读可写，并修改manifest文件读写权限：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb disable-verity</span><br><span class="line">adb reboot</span><br><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line">adb shell</span><br><span class="line">mount |grep system</span><br><span class="line"><span class="params">#</span>假设输出：</span><br><span class="line"><span class="params">#</span>/dev/block/dm-0 on /system type ext4 (ro,seclabel,relatime,inode<span class="built_in">_</span>readahead<span class="built_in">_</span>blks=8)</span><br><span class="line"><span class="params">#</span>挂载点 /system 设备为：/dev/block/dm-0</span><br><span class="line">mount -o remount,rw /dev/block/dm-0 /system</span><br><span class="line">chmod 777 manifest.xml</span><br></pre></td></tr></table></figure>

<p>修改完成后，如果只有DAC机制那么任何用户都能具备对该文件的读写以及执行权限，造成严重的安全问题。然而Android中我们会发现哪怕修改了777权限，app仍然无法对该文件进行写操作，这是因为Android中还是使用了一种更为强有力的安全机制来保证系统的安全，这种机制就是MAC！</p>
<h1 id="Android-MAC强制访问控制"><a href="#Android-MAC强制访问控制" class="headerlink" title="Android MAC强制访问控制"></a>Android MAC强制访问控制</h1><p>完成上文的对manifest文件权限的修改后，再执行我们的程序运行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;/system/manifest.xml&quot;</span>);</span><br><span class="line">Log.i(<span class="string">&quot;Lance&quot;</span>, file.canRead()+<span class="string">&quot; &quot;</span>+file.canWrite()+<span class="string">&quot; &quot;</span>+file.canExecute());</span><br></pre></td></tr></table></figure>

<p>此时输出：true false true。可以看到我们以及可以在程序中对该文件进行读取，然而还是无法写这个文件。<br>这就是MAC强制访问控制的作用，在MAC机制中，用户、进程或者文件的权限是由管理策略决定的，而不是由它们自主决定的。例如，我们可以设定这样的一个管理策略，不允许用户A将它创建的文件F授予用户B访问。这样无论用户A如何修改文件F的权限位，用户B都是无法访问文件F的。这种安全访问模型可以强有力地保护系统的安全。</p>
<h2 id="SELinux-SEAndroid"><a href="#SELinux-SEAndroid" class="headerlink" title="SELinux/SEAndroid"></a>SELinux/SEAndroid</h2><p>Android中使用的MAC机制就是SEAndroid。SELinux(Security-Enhanced Linux) 是美国国家安全局（NSA）在Linux<br>社区的帮助下设计的一个Linux历史上最杰出的安全系统，是一种MAC机制（Mandatory Access Control，强制访问控制）。在这种访问控制体系的限制下，进程只能访问那些在他的任务中所需要文件。<br>由于Android系统有着独特的用户空间运行时，因此SELinux不能完全适用于Android系统。为此，NSA针对Android系统，在SELinux基础上开发了SEAndroid。</p>
<p>可参考官方文档：</p>
<p><a href="https://source.android.google.cn/docs/security/features/selinux?hl=zh_cn">https://source.android.google.cn/docs/security/features/selinux?hl=zh_cn</a></p>
<h1 id="SEAndroid权限配置实战"><a href="#SEAndroid权限配置实战" class="headerlink" title="SEAndroid权限配置实战"></a>SEAndroid权限配置实战</h1><p>SEAndroid安全机制又称为是基于TE（Type Enforcement）策略的安全机制。在/system/sepolicy目录中，所有<br>以.te为后缀的文件均为策略配置文件。我们以fdbus的name-server配置为例进行示例操作。</p>
<h2 id="安全上下文"><a href="#安全上下文" class="headerlink" title="安全上下文"></a>安全上下文</h2><p>SEAndroid安全机制中的安全策略是在安全上下文的基础上进行描述的，也就是说，它通过主体和客体的安全上下<br>文，定义主体是否有权限访问客体。主体通常就是进程，而客体就是指进程所要访问的资源，例如文件、系统属性<br>等。<br>由于我们的服务程序可执行文件为<code>/system/bin/name-server</code>，首先我们需要在<code>/system/sepolicy/private/file_contexts</code>中声明该执行文件的SEAndroid系统文件的安全上下文：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">/system/bin/name-server u:object<span class="built_in">_</span>r:name-server<span class="built_in">_</span>exec:s0</span><br></pre></td></tr></table></figure>

<p>安全上下文实际上就是一个附加在对象上的标签（Tag）。这个标签实际上就是一个字符串，它由四部分内容组成，分别是：</p>
<blockquote>
<p>SELinux用户:SELinux角色:类型:安全级别</p>
</blockquote>
<p>每一个部分都通过一个冒号来分隔，格式为”user:role:type:sensitivity”。<br><strong>在安全上下文中，只有类型（Type）才是最重要的，SELinux用户、SELinux角色和安全级别都几乎可以忽略不计的</strong>。正因为如此，SEAndroid安全机制又称为是基于TE（Type Enforcement）策略的安全机制。</p>
<h3 id="用户与角色"><a href="#用户与角色" class="headerlink" title="用户与角色"></a>用户与角色</h3><p>在<code>/system/sepolicy/private/users</code>中声明了SELinux用户u，它可用的SELinux角色为r，它的默认安全级别为s0，可<br>用的安全级别范围为s0 - mls_systemhigh：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">user u roles &#123; r &#125; level s0 range s0 - mls<span class="built_in">_</span>systemhigh;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mls_systemhigh为系统定义的最高安全级别。</p>
</blockquote>
<p>在<code>/system/sepolicy/public/roles</code>中声明了SELinux角色r与类型domain关联：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">role r types domain;</span><br></pre></td></tr></table></figure>

<p>在SEAndroid中，只定义了唯一一个用户u，两个角色r（适用于主题，如进程）与object_r(适用于对象，如文件)，<br>这意味着只有u、r/object_r和domain可以组合在一起形成一个合法的安全上下文，那么ps -Z查看进程应为<br><code>u:r:domain:s0</code> ，ls -Z查看文件则为： <code>u:object_r:domain:s0</code>，而其它形式的安全上下文定义均是非法的。<br>但是以init进程为例，执行 <code>adb shell ps -Z | grep zygote</code> （Windows为： <code>adb shell ps -Z | findStr zygote</code> ），可以看到输出为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">u:r:zygote:s0 root 646 1 1577904 69500 poll<span class="built_in">_</span>schedule<span class="built_in">_</span>timeout eb7e743c S zygote</span><br></pre></td></tr></table></figure>

<p>安全上下文 u:r:zygote:s0 ，按照上面的分析，这不是应该是一个不合法的上下文吗？原因是在 <code>/system/sepolicy/public/zygote.te</code> 中通过type声明了类型zygote并且将domain设置为类型zygote的属<br>性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">type zygote, domain;</span><br><span class="line">type zygote_tmpfs, file_type;</span><br><span class="line">type zygote_exec, system_file_type, exec_type, file_type;</span><br></pre></td></tr></table></figure>

<p>因此它就可以像domain一样，可以和SELinux用户u和SELinux角色组合在一起形成合法的安全上下文。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>在SEAndroid中，每一个用来描述文件安全上下文的类型都将file_type设置为其属性，每一个用于进程安全上下文的类型都将domain设置为其属性。</p>
<h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><p>前面提到，SEAndroid安全机制主要是使用对象安全上下文中的类型来定义安全策略，这种安全策略就称Type<br>Enforcement，简称TE，.te文件即为安全策略配置文件。</p>
<p>修改 <code>system/sepolicy/prebuilts/api/31.0/private</code> 与 <code>system/sepolicy/private/file_contexts</code> 目录下同<br>样的：file_contexts、netd.te与untrusted_app_all.te文件，并在两个目录下都创建name-server.te文件。</p>
<blockquote>
<p>按照google官方的介绍：</p>
<ul>
<li><p>system/sepolicy/public：公共策略配置，将此目录视为相应平台的已导出政策 API，包括供应商特定<br>策略。</p>
</li>
<li><p>system/sepolicy/private：系统正常运行所必需（但供应商映像政策应该不知道）的策略。</p>
</li>
</ul>
<p>对于权限的配置不建议直接修改以上目录，应该在 /device/manufacturer/device-name/sepolicy 目录进<br>行自己设备的专用策略配置。<br>如Pixel5手机搭载AAOS，则应该在： /device/google_car/redfin_car/sepolicy 目录下配置。同时修改或<br>添加政策文件和上下文的描述文件后，需要修改 /device/manufacturer/device-name/BoardConfig.mk 以<br>引用 sepolicy 子目录和每个新的政策文件。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">BOARD<span class="built_in">_</span>SEPOLICY<span class="built_in">_</span>DIRS += <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>	&lt;root&gt;/device/manufacturer/device-name/sepolicy</span><br><span class="line">BOARD<span class="built_in">_</span>SEPOLICY<span class="built_in">_</span>UNION += <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>	genfs<span class="built_in">_</span>contexts <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>	file<span class="built_in">_</span>contexts <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>	sepolicy.te</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由于我们的进程名为name-server，因此在 /system/sepolicy/private 目录下创建一个name-server.te作为该进<br>程的策略文件。文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 声明name-server类型，并将domain属性关联到该类型 （进程）</span></span><br><span class="line">type name-server, domain;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 声明name-server_exec类型（可执行文件，类型要与file_contexts中的相同）</span></span><br><span class="line">type name-server_exec, exec_type, file_type;</span><br><span class="line"><span class="meta">#</span><span class="bash">allow语句表示允许的权限。</span></span><br><span class="line">allow name-server self:tcp_socket &#123; read write getattr getopt setopt shutdown create bind</span><br><span class="line">connect name_connect &#125;;</span><br><span class="line">allow name-server self:netlink_route_socket &#123;create write read nlmsg_readpriv nlmsg_read&#125;;</span><br><span class="line">allow name-server fwmarkd_socket:sock_file &#123;write&#125;;</span><br><span class="line">allow name-server port:tcp_socket &#123;name_connect&#125;;</span><br><span class="line">allow name-server netd:unix_stream_socket &#123;connectto&#125;;</span><br><span class="line">allow name-server self:capability &#123;net_raw&#125;;</span><br><span class="line">allow name-server node:tcp_socket &#123;node_bind&#125;;</span><br><span class="line"><span class="meta">#</span><span class="bash">init_daemon_domain：system/sepolicy/public/te_macros中定义的宏（函数） 进行默认的一些配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash">domain_auto_trans（init,name-server_exec,name-server）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> domain_trans(init,name-server_exec,name-server)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allow init name-server_exec:file &#123; getattr open <span class="built_in">read</span> execute &#125;;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allow init name-server:process transition;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> allow name-server name-server_exec:file &#123; entrypoint open <span class="built_in">read</span> execute getattr &#125;;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> type_transition init name-server_exec:process name-server;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ......</span></span><br><span class="line"><span class="meta">#</span><span class="bash">声明 name-server 是从 init 衍生而来的，并且可以与其通信</span></span><br><span class="line">init_daemon_domain(name-server)</span><br></pre></td></tr></table></figure>

<h3 id="Allow规则"><a href="#Allow规则" class="headerlink" title="Allow规则"></a>Allow规则</h3><p>allow表示开放权限，当某个进程执行，如果该进程不具备对应的权限，则可以在logcat 或者在执行 adb root 后执<br>行 adb shell dmesg 查看，可以以执行 adb shell dmesg &gt; xx.txt 将内核日志都输出到xx.txt中查看。</p>
<blockquote>
<p>官方资料：<a href="https://source.android.google.cn/docs/security/selinux/concepts?hl=zh_cn">https://source.android.google.cn/docs/security/selinux/concepts?hl=zh_cn</a></p>
</blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">avc: denied &#123; bind &#125; for pid=417 comm=&quot;name-server&quot; scontext=u:r:name-server:s0</span><br><span class="line">tcontext=u:r:name-server:s0 tclass=tcp<span class="built_in">_</span>socket permissive=0</span><br><span class="line">avc: denied &#123; connectto &#125; for pid=417 comm=&quot;name-server&quot; scontext=u:r:name-server:s0</span><br><span class="line">tcontext=u:r:netd:s0 tclass=unix<span class="built_in">_</span>stream<span class="built_in">_</span>socket permissive=0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>缺少什么权限</td>
<td>{ bind }</td>
</tr>
<tr>
<td>谁缺少权限</td>
<td>scontext=u:r:name-server:s0</td>
</tr>
<tr>
<td>对谁缺少权限</td>
<td>tcontext=u:r:name-server:s0</td>
</tr>
<tr>
<td>什么类型的权限</td>
<td>tclass=tcp_socket</td>
</tr>
</tbody></table>
<p>此时就需要在TE文件中声明：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">allow [谁缺少权限] [对谁缺少权限]:[什么类型的权限] [缺少什么权限]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当sconext与tcontext都是自己时候，可以将 [对谁缺少权限]写为：self</span></span><br><span class="line">allow name-server self:tcp_socket &#123;bind&#125;</span><br><span class="line">allow name-server netd:unix_stream_socket &#123;connectto&#125;;</span><br></pre></td></tr></table></figure>

<p>所以通过日志，就能完成对SEAndroid权限的赋予！</p>
<blockquote>
<p>若验证是否为SEAndroid权限导致的程序无法正常运行可以通过关闭临时SEAndroid验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭seandroid</span></span><br><span class="line">adb shell setenforce 0</span><br><span class="line"><span class="meta">#</span><span class="bash">开启seandroid</span></span><br><span class="line">adb shell setenforce 0</span><br><span class="line"><span class="meta">#</span><span class="bash">查看seandroid</span></span><br><span class="line">adb shell getenforce</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="audit2allow"><a href="#audit2allow" class="headerlink" title="audit2allow"></a>audit2allow</h3><p><a href="https://source.android.google.cn/docs/security/selinux/validate?hl=zh_cn#using_audit2allow">https://source.android.google.cn/docs/security/selinux/validate?hl=zh_cn#using_audit2allow</a><br>audit2allow 工具可以获取 dmesg 拒绝事件并将其转换成相应的 SELinux 政策声明。因此，该工具有助于大幅加快 SELinux 开发速度。<br>如需使用该工具，请运行以下命令：(需要切换到Python2)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">保证当前终端先执行了<span class="built_in">source</span>与lunch指令</span></span><br><span class="line">adb pull /sys/fs/selinux/policy</span><br><span class="line">adb logcat -b events -d | audit2allow -p policy</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_aosp_android_safe02.png" alt="image"></p>
<p>如上图，表示需要在name-server.te中增加：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">allow name-server self:netlink<span class="built_in">_</span>route<span class="built_in">_</span>socket read;</span><br></pre></td></tr></table></figure>

<h3 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h3><p>在system/sepolicy/public/te_macros中定义了很多宏函数，其中init_daemon_domain表示声明 name-server<br>是从 init 衍生而来的，并且可以与其通信。<br>另外还有其他宏如：net_domain，其定义为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> net_domain(domain)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Allow a base <span class="built_in">set</span> of permissions required <span class="keyword">for</span> network access.</span></span><br><span class="line">define(`net_domain&#x27;, `</span><br><span class="line">typeattribute $1 netdomain;</span><br><span class="line">&#x27;)</span><br></pre></td></tr></table></figure>

<p>如果调用该宏：net_domain(name-server)表示将name-server赋予netdomain类型。而netdomain类型可以在<br>system/sepolicy/public/net.te 中看到，存在如下规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">......</span></span><br><span class="line">allow netdomain self:tcp_socket create_stream_socket_perms;</span><br><span class="line"><span class="meta">#</span><span class="bash">......</span></span><br></pre></td></tr></table></figure>

<p>那么使用该宏则表示，将name-server赋予tcp_socket对应的create_stream_socket_perms权限。整体而言<br>net_domain函数表示允许 使用 net 域中的常用网络功能，如读取和写入 TCP 数据包、通过套接字进行通信，以及<br>执行 DNS 请求等。也就是说，可以通过对应的宏函数调用完成对某些类型权限的统一allow。</p>
]]></content>
      <categories>
        <category>Android系统开发</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
        <tag>Android安全机制</tag>
        <tag>SELinux</tag>
        <tag>SEAndroid</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP-预置APP历险记</title>
    <url>/2021/03/02/android_aosp_built_in_app/</url>
    <content><![CDATA[<p>Android 系统预置 APP 是做 Framework 应用开发经常经常会遇到的工作，预置 APP 分为两种，一种是直接预置 APK，一种是预置带有源码的 APP。</p>
<span id="more"></span>

<h1 id="源码形式内置"><a href="#源码形式内置" class="headerlink" title="源码形式内置"></a>源码形式内置</h1><p>我这边编译时，lunch选择的版本是sdk_car的版本，所以下面以内置android_car app的形式进行讲解。</p>
<p><img src="/images/android_aosp_built_in_app01.png" alt="image"></p>
<p>car目录内就是android_car源码内置app的目录。其余目录为手机版内置app的源码包。</p>
<h2 id="第一步：创建APP源码根目录"><a href="#第一步：创建APP源码根目录" class="headerlink" title="第一步：创建APP源码根目录"></a>第一步：创建APP源码根目录</h2><p>进入<code>/aosp/packages/app/car</code>下创建<code>DemoApp</code>目录</p>
<p><img src="/images/android_aosp_built_in_app02.png" alt="image"></p>
<h2 id="第二步：APP根目录下创建Android-bp配置文件"><a href="#第二步：APP根目录下创建Android-bp配置文件" class="headerlink" title="第二步：APP根目录下创建Android.bp配置文件"></a>第二步：APP根目录下创建Android.bp配置文件</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">android_app &#123;</span><br><span class="line">    //应用名</span><br><span class="line">    name: <span class="string">&quot;DemoApp&quot;</span>,</span><br><span class="line">    manifest: <span class="string">&quot;AndroidManifest.xml&quot;</span>,</span><br><span class="line">    //源码目录</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">&quot;src/**/*.java&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    //res目录</span><br><span class="line">    resource_dirs: [</span><br><span class="line">        <span class="string">&quot;res&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line">    //静态库</span><br><span class="line">    static_libs: [</span><br><span class="line">        <span class="string">&quot;androidx.appcompat_appcompat&quot;</span>,</span><br><span class="line">        <span class="string">&quot;com.google.android.material_material&quot;</span>,</span><br><span class="line">        <span class="string">&quot;androidx-constraintlayout_constraintlayout&quot;</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    //签名类型</span><br><span class="line">    // certificate 用于指定APK的签名方式。如果不指定，默认使用testkey签名</span><br><span class="line">    // testkey：普通APK，默认使用该签名。</span><br><span class="line">    // platform：该APK完成一些系统的核心功能。经过对系统中存在的文件夹的访问测试</span><br><span class="line">    // shared：该APK需要和home/contacts进程共享数据。</span><br><span class="line">    // media：该APK是media/download系统中的一环。</span><br><span class="line">    certificate: <span class="string">&quot;platform&quot;</span>,</span><br><span class="line"></span><br><span class="line">    // 设定apk安装路径为priv-app</span><br><span class="line">    privileged: true,</span><br><span class="line"></span><br><span class="line">    sdk_version: <span class="string">&quot;system_current&quot;</span>,</span><br><span class="line">    min_sdk_version: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">    target_sdk_version: <span class="string">&quot;28&quot;</span>,</span><br><span class="line"></span><br><span class="line">    optimize: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dex_preopt: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三部：根据上面的配置拷贝并放置对应目录及文件"><a href="#第三部：根据上面的配置拷贝并放置对应目录及文件" class="headerlink" title="第三部：根据上面的配置拷贝并放置对应目录及文件"></a>第三部：根据上面的配置拷贝并放置对应目录及文件</h2><p><img src="/images/android_aosp_built_in_app03.png" alt="image"></p>
<p><strong>注意</strong></p>
<p><code>AndroidManifest.xml</code>根节点要加上package属性标明包名称，要不然编译会报错。</p>
<h2 id="第四部：配置Product"><a href="#第四部：配置Product" class="headerlink" title="第四部：配置Product"></a>第四部：配置Product</h2><p>这个配置决定了应用是否能够正常显示到launcher里。</p>
<p>aosp下找到该路径下<code>/aosp/build/target/product/handheld_product.mk</code>文件</p>
<p>在<code>PRODUCT_PACKAGES</code>下增加 <code>DemoApp\</code>，如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This makefile contains the product partition contents for</span></span><br><span class="line"><span class="comment"># a generic phone or tablet device. Only add something here if</span></span><br><span class="line"><span class="comment"># it definitely doesn&#x27;t belong on other types of devices (if it</span></span><br><span class="line"><span class="comment"># does, use base_product.mk).</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> inherit-product, <span class="variable">$(SRC_TARGET_DIR)</span>/product/media_product.mk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /product packages</span></span><br><span class="line">PRODUCT_PACKAGES += \</span><br><span class="line">    Browser2 \</span><br><span class="line">    Calendar \</span><br><span class="line">    Camera2 \</span><br><span class="line">    Contacts \</span><br><span class="line">    DeskClock \</span><br><span class="line">    Gallery2 \</span><br><span class="line">    LatinIME \</span><br><span class="line">    Music \</span><br><span class="line">    OneTimeInitializer \</span><br><span class="line">    preinstalled-packages-platform-handheld-product.xml \</span><br><span class="line">    QuickSearchBox \</span><br><span class="line">    SettingsIntelligence \</span><br><span class="line">    DemoApp\</span><br><span class="line">    frameworks-base-overlays</span><br><span class="line"></span><br><span class="line">PRODUCT_PACKAGES_DEBUG += \</span><br><span class="line">    frameworks-base-overlays-debug</span><br></pre></td></tr></table></figure>

<h2 id="第五步：编译"><a href="#第五步：编译" class="headerlink" title="第五步：编译"></a>第五步：编译</h2><p>在aosp主目录下初始化环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br></pre></td></tr></table></figure>

<p>然后进入自定义的app目录下<code>/packages/app/Car/DemoApp</code>执行模块编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mm</span><br></pre></td></tr></table></figure>

<p>编译完成后，回到aosp主目录，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lunch sdk_car_x86_64-userdebug</span><br></pre></td></tr></table></figure>

<p>然后整体编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p>编译完成后，启动模拟器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">emulator</span><br></pre></td></tr></table></figure>

<p>即可看到新增的app</p>
<p><img src="/images/android_aosp_built_in_app04.png" alt="image"></p>
<h1 id="APK预置"><a href="#APK预置" class="headerlink" title="APK预置"></a>APK预置</h1><h2 id="第一步：创建APK放置的目录"><a href="#第一步：创建APK放置的目录" class="headerlink" title="第一步：创建APK放置的目录"></a>第一步：创建APK放置的目录</h2><p>进入<code>/aosp/packages/app/car</code>下，创建TestApk.apk放置的目录TestApp，将apk放置于该目录下，并创建Android.bp配置文件。</p>
<p><img src="/images/android_aosp_built_in_app05.png" alt="image"></p>
<h2 id="第二步：配置Android-bp如下"><a href="#第二步：配置Android-bp如下" class="headerlink" title="第二步：配置Android.bp如下"></a>第二步：配置Android.bp如下</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android_app_import &#123;</span><br><span class="line">    name: &quot;TestApk&quot;,</span><br><span class="line">    //使用原签名</span><br><span class="line">    presigned: true,</span><br><span class="line">    //安装到system/pri-app下</span><br><span class="line">    privileged: true,</span><br><span class="line">    //指定apk文件</span><br><span class="line">    apk:&quot;TestApk.apk&quot;,</span><br><span class="line">    </span><br><span class="line">    dex_preopt: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三步：配置product"><a href="#第三步：配置product" class="headerlink" title="第三步：配置product"></a>第三步：配置product</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This makefile contains the product partition contents <span class="keyword">for</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a generic phone or tablet device. Only add something here <span class="keyword">if</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> it definitely doesn<span class="string">&#x27;t belong on other types of devices (if it</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> does, use base_product.mk).</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="string">(call inherit-product, $(SRC_TARGET_DIR)/product/media_product.mk)</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> /product packages</span></span></span><br><span class="line">PRODUCT_PACKAGES += \</span><br><span class="line">    Browser2 \</span><br><span class="line">    Calendar \</span><br><span class="line">    Camera2 \</span><br><span class="line">    Contacts \</span><br><span class="line">    DeskClock \</span><br><span class="line">    Gallery2 \</span><br><span class="line">    LatinIME \</span><br><span class="line">    Music \</span><br><span class="line">    OneTimeInitializer \</span><br><span class="line">    preinstalled-packages-platform-handheld-product.xml \</span><br><span class="line">    QuickSearchBox \</span><br><span class="line">    SettingsIntelligence \</span><br><span class="line">    DemoApp\</span><br><span class="line">    TestApk\</span><br><span class="line">    frameworks-base-overlays</span><br><span class="line"></span><br><span class="line">PRODUCT_PACKAGES_DEBUG += \</span><br><span class="line">    frameworks-base-overlays-debug</span><br></pre></td></tr></table></figure>

<h2 id="第四步：编译"><a href="#第四步：编译" class="headerlink" title="第四步：编译"></a>第四步：编译</h2><p>在aosp主目录下初始化环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br></pre></td></tr></table></figure>

<p>然后进入自定义的app目录下<code>/packages/app/Car/TestApk</code>执行模块编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mm</span><br></pre></td></tr></table></figure>

<p>编译完成后，回到aosp主目录，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lunch sdk_car_x86_64-userdebug</span><br></pre></td></tr></table></figure>

<p>然后整体编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p>编译完成后，启动模拟器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">emulator</span><br></pre></td></tr></table></figure>

<p>即可看到新增的app</p>
<h2 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h2><p>在Android 12 S上预制apk时候发现有编译不过情况，报<code>artifact_path_requirements</code>相关错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">build/make/core/artifact_path_requirements.mk:26: warning:  build/make/target/product/sdk_car_x86_64.mk produces files inside build/make/target/product/generic_system.mks artifact path requirement. </span><br><span class="line">Offending entries:</span><br><span class="line">system/pri-app/TestApk/TestApk.apk</span><br><span class="line">In file included from build/make/core/main.mk:1383:</span><br><span class="line">build/make/core/artifact_path_requirements.mk:26: error: Build failed.</span><br><span class="line">00:42:13 ckati failed with: exit status 1</span><br></pre></td></tr></table></figure>

<p>因为新版本<code>artifact_path_requirements</code>有对预装相关东西进行了规则检测，发现<code>system/pri-app/TestApk/TestApk.apk</code>这种预制到<code>system/pri-app</code>的情况属于违规了。<br>那么具体怎么解决呢？</p>
<p>通过在github寻找到了一些第三方rom维护者也有遇到类似问题，参考他们解决方案，修改如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ......</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> and <span class="keyword">in</span> with the new</span></span><br><span class="line">    local prebuiltdir=$(getprebuilt)</span><br><span class="line">    local gccprebuiltdir=$(get_abs_build_var ANDROID_GCC_PREBUILTS)</span><br><span class="line"></span><br><span class="line">    # defined in core/config.mk</span><br><span class="line">    local targetgccversion=$(get_build_var TARGET_GCC_VERSION)</span><br><span class="line">    local targetgccversion2=$(get_build_var 2ND_TARGET_GCC_VERSION)</span><br><span class="line">    export TARGET_GCC_VERSION=$targetgccversion</span><br><span class="line">    </span><br><span class="line">    # 此处增加配置</span><br><span class="line">    export DISABLE_ARTIFACT_PATH_REQUIREMENTS=&quot;true&quot;</span><br><span class="line"></span><br><span class="line">    # The gcc toolchain does not exists for windows/cygwin. In this case, do not reference it.</span><br><span class="line">    export ANDROID_TOOLCHAIN=</span><br><span class="line">    export ANDROID_TOOLCHAIN_2ND_ARCH=</span><br><span class="line">    local ARCH=$(get_build_var TARGET_ARCH)</span><br><span class="line">    local toolchaindir toolchaindir2=</span><br><span class="line"><span class="meta">#</span><span class="bash"> ......</span></span><br></pre></td></tr></table></figure>

<p>即<code>build/envsetup.sh</code> 加上<code>export DISABLE_ARTIFACT_PATH_REQUIREMENTS=&quot;true&quot;</code>就可以顺利编译通过不再报<code>artifact_path_requirements</code>错误，这里其实就相当于把新版本编译系统中<code>artifact_path_requirements</code>检测关闭就可以</p>
<h1 id="关于预置配置"><a href="#关于预置配置" class="headerlink" title="关于预置配置"></a>关于预置配置</h1><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><h3 id="自签名"><a href="#自签名" class="headerlink" title="自签名"></a>自签名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android_app_import &#123;</span><br><span class="line">    name: &quot;SogouInput&quot;,</span><br><span class="line">    system_ext_specific: true,</span><br><span class="line">    presigned: true,</span><br><span class="line">    dex_preopt: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    apk: &quot;SogouInput_android_oem_baoneng.apk&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统签名"><a href="#系统签名" class="headerlink" title="系统签名"></a>系统签名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> system signal</span></span><br><span class="line">android_app_import &#123;</span><br><span class="line">    name: &quot;SogouInput&quot;,</span><br><span class="line">    system_ext_specific: true,</span><br><span class="line">    certificate: &quot;platform&quot;,</span><br><span class="line">    apk: &quot;SogouInput_android_oem_baoneng.apk&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集成位置"><a href="#集成位置" class="headerlink" title="集成位置"></a>集成位置</h2><h3 id="system-app"><a href="#system-app" class="headerlink" title="system/app"></a>system/app</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android_app_import &#123;</span><br><span class="line">    name: &quot;SogouInput&quot;,</span><br><span class="line">    presigned: true,</span><br><span class="line">    dex_preopt: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    apk: &quot;SogouInput_android_oem_baoneng.apk&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="system-ext-app"><a href="#system-ext-app" class="headerlink" title="system_ext/app"></a>system_ext/app</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android_app_import &#123;</span><br><span class="line">    name: &quot;SogouInput&quot;,</span><br><span class="line">    system_ext_specific: true,</span><br><span class="line">    presigned: true,</span><br><span class="line">    dex_preopt: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    apk: &quot;SogouInput_android_oem_baoneng.apk&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="system-pri-app"><a href="#system-pri-app" class="headerlink" title="system/pri-app"></a>system/pri-app</h3><blockquote>
<p>必须声明在permission白名单内。<br>aosp路径：frameworks/base/data/etc/privapp-permissions-platform.xml<br>手机路径：system/etc/permission/privapp-permission-platform.xml</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android_app_import &#123;</span><br><span class="line">    name: &quot;SogouInput&quot;,</span><br><span class="line">    privileged: true,</span><br><span class="line">    presigned: true,</span><br><span class="line">    dex_preopt: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    apk: &quot;SogouInput_android_oem_baoneng.apk&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="product-app"><a href="#product-app" class="headerlink" title="product/app"></a>product/app</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android_app_import &#123;</span><br><span class="line">    name: &quot;SogouInput&quot;,</span><br><span class="line">    product_specific: true,</span><br><span class="line">    presigned: true,</span><br><span class="line">    dex_preopt: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    apk: &quot;SogouInput_android_oem_baoneng.apk&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="vendor-app"><a href="#vendor-app" class="headerlink" title="vendor/app"></a>vendor/app</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">android_app_import &#123;</span><br><span class="line">    name: &quot;SogouInput&quot;,</span><br><span class="line">    proprietary: true,</span><br><span class="line">    presigned: true,</span><br><span class="line">    dex_preopt: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    apk: &quot;SogouInput_android_oem_baoneng.apk&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android系统开发</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP-Android.bp</title>
    <url>/2021/03/13/android_aosp_android_bp/</url>
    <content><![CDATA[<p>在 Android 7.0 发布之前，Android 仅使用 GNU Make 描述和执行其构建规则。Make 构建系统得到了广泛的支持和使用，但在 Android 层面变得缓慢、容易出错、无法扩展且难以测试。Soong 构建系统正好提供了 Android build 所需的灵活性。</p>
<span id="more"></span>

<p>Soong 构建系统是在 Android 7.0 (Nougat) 中引入的，旨在取代 Make。它利用 Kati GNU Make 克隆工具和 Ninja 构建系统组件来加速 Android 的构建。</p>
<h1 id="了解ninjia"><a href="#了解ninjia" class="headerlink" title="了解ninjia"></a>了解ninjia</h1><p>Ninja 的配置文件就是Android.bp，Android 系统使用 Soong 工具来解析 Android.bp 转换生成 ninja文件。<br>为了兼容老的 mk 配置文件，Android 当初也开发了 Kati 工具来转换 mk 文件生成ninja，目前 Android Q 里边，还是支持 Android.mk 方式的。</p>
<p>kati是Android开发的一个基于Golang和C++的工具，主要功能是把Android中的Android.mk文件转换成Ninja文件。</p>
<p>相信在将来的版本中，会彻底让 mk 文件废弃，同时 Kati 也就淘汰了，只保留 bp 配置方式。</p>
<p>其实ninja是一个编译框架，会根据相应的ninja格式的配置文件进行编译，ninja文件一般不会手动修改，而是通过将Android.bp文件转换成ninja格文件来编译。</p>
<h1 id="了解Soong"><a href="#了解Soong" class="headerlink" title="了解Soong"></a>了解Soong</h1><p>Soong类似于之前的Makefile编译系统的核心，负责提供Android.bp语义解析，并将之转换成Ninja文件。</p>
<p>Soong还会编译生成一个androidmk命令，用于将Android.mk文件转换为Android.bp文件，不过这个转换功能仅限于没有分支、循环等流程控制的Android.mk才有效。</p>
<h1 id="Make和Soong比较"><a href="#Make和Soong比较" class="headerlink" title="Make和Soong比较"></a>Make和Soong比较</h1><p>以下是 Make 配置与 Soong 在 Soong 配置（Blueprint 或 <code>.bp</code>）文件中完成相同操作的比较。</p>
<h2 id="Make示例"><a href="#Make示例" class="headerlink" title="Make示例"></a>Make示例</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE := libxmlrpc++</span><br><span class="line">LOCAL_MODULE_HOST_OS := linux</span><br><span class="line"></span><br><span class="line">LOCAL_RTTI_FLAG := -frtti</span><br><span class="line">LOCAL_CPPFLAGS := -Wall -Werror -fexceptions</span><br><span class="line">LOCAL_EXPORT_C_INCLUDES := <span class="variable">$(LOCAL_PATH)</span>/src</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := <span class="variable">$(<span class="built_in">call</span> \</span></span><br><span class="line"><span class="variable">     all-cpp-files-under,src)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<h2 id="Soong示例"><a href="#Soong示例" class="headerlink" title="Soong示例"></a>Soong示例</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>shared &#123;</span><br><span class="line">     name: “libxmlrpc++”,</span><br><span class="line"></span><br><span class="line">     rtti: true,</span><br><span class="line">     cppflags: [</span><br><span class="line">           “-Wall”,</span><br><span class="line">           “-Werror”,</span><br><span class="line">           “-fexceptions”,</span><br><span class="line">     ],</span><br><span class="line">     export<span class="built_in">_</span>include<span class="built_in">_</span>dirs: [“src”],</span><br><span class="line">     srcs: [“src/**/*.cpp”],</span><br><span class="line"></span><br><span class="line">     target: &#123;</span><br><span class="line">           darwin: &#123;</span><br><span class="line">                enabled: false,</span><br><span class="line">           &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Android-bp文件格式"><a href="#Android-bp文件格式" class="headerlink" title="Android.bp文件格式"></a>Android.bp文件格式</h1><p>根据设计，<code>Android.bp</code> 文件很简单。它们不包含任何条件语句，也不包含控制流语句；所有复杂问题都由用 Go 编写的构建逻辑处理。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><code>Android.bp</code> 文件中的模块以<a href="https://ci.android.com/builds/latest/branches/aosp-build-tools/targets/linux/view/soong_build.html?hl=zh-cn">模块类型</a>开头，后跟一组 <code>name: &quot;value&quot;,</code> 格式的属性：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">cc<span class="built_in">_</span>binary &#123;</span><br><span class="line">    name: &quot;gzip&quot;,</span><br><span class="line">    srcs: [&quot;src/test/minigzip.c&quot;],</span><br><span class="line">    shared<span class="built_in">_</span>libs: [&quot;libz&quot;],</span><br><span class="line">    stl: &quot;none&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个模块都必须具有 <code>name</code> 属性，并且相应值在所有 <code>name</code> 文件中必须是唯一的，仅有两个例外情况是命名空间和预构建模块中的 <code>Android.bp</code> 属性值，这两个值可能会重复。</p>
<p><code>srcs</code> 属性以字符串列表的形式指定用于构建模块的源文件。您可以使用模块引用语法 <code>&quot;:&lt;module-name&gt;&quot;</code> 来引用生成源文件的其他模块的输出，如 <code>genrule</code> 或 <code>filegroup</code>。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>变量和属性是强类型，变量根据第一项赋值动态变化，属性由模块类型静态设置。支持的类型为：</p>
<ul>
<li>布尔值（<code>true</code> 或 <code>false</code>）</li>
<li>整数 (<code>int</code>)</li>
<li>字符串 (<code>&quot;string&quot;</code>)</li>
<li>字符串列表 (<code>[&quot;string1&quot;, &quot;string2&quot;]</code>)</li>
<li>映射 (<code>&#123;key1: &quot;value1&quot;, key2: [&quot;value2&quot;]&#125;</code>)</li>
</ul>
<p>映射可以包含任何类型的值，包括嵌套映射。列表和映射可能在最后一个值后面有终止逗号。</p>
<h2 id="Glob"><a href="#Glob" class="headerlink" title="Glob"></a>Glob</h2><p>接受文件列表的属性（例如 <code>srcs</code>）也可以采用 glob 模式。glob 模式可以包含普通的 UNIX 通配符 <code>*</code>，例如 <code>*.java</code>。glob 模式还可以包含单个 <code>**</code> 通配符作为路径元素，与零个或多个路径元素匹配。例如，<code>java/**/*.java</code> 同时匹配 <code>java/Main.java</code> 和 <code>java/com/android/Main.java</code> 模式。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>Android.bp</code> 文件可能包含顶级变量赋值：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">gzip<span class="built_in">_</span>srcs = [&quot;src/test/minigzip.c&quot;],</span><br><span class="line">cc<span class="built_in">_</span>binary &#123;</span><br><span class="line">    name: &quot;gzip&quot;,</span><br><span class="line">    srcs: gzip<span class="built_in">_</span>srcs,</span><br><span class="line">    shared<span class="built_in">_</span>libs: [&quot;libz&quot;],</span><br><span class="line">    stl: &quot;none&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量的作用域限定在声明它们的文件的其余部分，以及所有子 Blueprint 文件。变量是不可变的，但有一个例外情况：可以使用 <code>+=</code> 赋值将变量附加到别处，但只能在引用它们之前附加。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><code>Android.bp</code> 文件可以包含 C 样式的多行 <code>/* */</code> 注释以及 C++ 样式的单行 <code>//</code> 注释。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>可以使用 + 运算符附加字符串、字符串列表和映射。可以使用 <code>+</code> 运算符对整数求和。附加映射会生成两个映射中键的并集，并附加在两个映射中都存在的所有键的值。</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>Soong 不支持 <code>Android.bp</code> 文件中的条件语句。但是，编译规则中需要条件语句的复杂问题将在 Go（在这种语言中，您可以使用高级语言功能，并且可以跟踪条件语句引入的隐式依赖项）中处理。大多数条件语句都会转换为映射属性，其中选择了映射中的某个值并将其附加到顶级属性。</p>
<p>例如，要支持特定于架构的文件，请使用以下命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">cc<span class="built_in">_</span>library &#123;</span><br><span class="line">    ...</span><br><span class="line">    srcs: [&quot;generic.cpp&quot;],</span><br><span class="line">    arch: &#123;</span><br><span class="line">        arm: &#123;</span><br><span class="line">            srcs: [&quot;arm.cpp&quot;],</span><br><span class="line">        &#125;,</span><br><span class="line">        x86: &#123;</span><br><span class="line">            srcs: [&quot;x86.cpp&quot;],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="格式设置工具"><a href="#格式设置工具" class="headerlink" title="格式设置工具"></a>格式设置工具</h2><p>Soong 包含一个针对 Blueprint 文件的规范格式设置工具，类似于 <a href="https://golang.org/cmd/gofmt/">gofmt</a>。如需以递归方式重新设置当前目录中所有 <code>Android.bp</code> 文件的格式，请运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bpfmt -w .</span><br></pre></td></tr></table></figure>

<p>规范格式包括缩进四个空格、多元素列表的每个元素后面有换行符，以及列表和映射末尾有英文逗号。</p>
<h1 id="Android-bp常用模块类型"><a href="#Android-bp常用模块类型" class="headerlink" title="Android.bp常用模块类型"></a>Android.bp常用模块类型</h1><p>在Android.bp中我们会基于模块类型来构建我们所需要的东西，常用的有以下几种类型</p>
<h2 id="android-app"><a href="#android-app" class="headerlink" title="android_app"></a>android_app</h2><p>用于构建Android 应用程序安装包，是Android系统应用开发中常用的模块类型，与Android.mk中的<code>BUILD_PACKAGE</code>作用相同。</p>
<h2 id="java-library"><a href="#java-library" class="headerlink" title="java_library"></a>java_library</h2><p><code>java_library</code>用于将源代码构建并链接到设备的<code>.jar</code>文件中。默认情况下，<code>java_library</code>只有一个变量，它生成一个包含根据设备引导类路径编译的<code>.class</code>文件的<code>.jar</code>包。生成的jar不适合直接安装在设备上，通过会用作另一个模块的<code>static_libs</code>依赖项。</p>
<p>如果指定“installable:true”将生成一个包含“classes.dex”文件的“.jar”文件，适合在设备上安装。指定’host_supported:true’将产生两个变量，一个根据device的bootclasspath编译，另一个根据host的bootclasspath编译。</p>
<h2 id="java-library-static"><a href="#java-library-static" class="headerlink" title="java_library_static"></a>java_library_static</h2><p><code>java_library_static</code>作用等同于<code>java_library</code>，但是<code>java_library_static</code>已经过时，不推荐使用</p>
<h2 id="android-library"><a href="#android-library" class="headerlink" title="android_library"></a>android_library</h2><p><code>android_library</code>将源代码与android资源文件一起构建并链接到设备的“.jar”文件中。android_library有一个单独的变体，它生成一个包含根据device的bootclasspath编译的<code>.class</code>文件的<code>.jar</code>文件，以及一个包含使用aapt2编译的android资源的<code>.package-res.apk</code>文件。生成的apk文件不能直接安装在设备上，但可以用作<code>android_app</code>模块的<code>static_libs</code>依赖项。</p>
<h2 id="cc-library"><a href="#cc-library" class="headerlink" title="cc_library"></a>cc_library</h2><p><code>cc_library</code>为device或host创建静态库或共享库。默认情况下，<code>cc_library</code>具有针对设备的单一变体。指定’host_supported:true’还会创建一个以主机为目标的库。与cc_library相关的模块类型还有<code>cc_library_shared</code>、<code>cc_library_headers</code>、<code>cc_library_static</code>等。</p>
<h1 id="Android-bp常见用法"><a href="#Android-bp常见用法" class="headerlink" title="Android.bp常见用法"></a>Android.bp常见用法</h1><h2 id="bp下的常见属性"><a href="#bp下的常见属性" class="headerlink" title=".bp下的常见属性"></a>.bp下的常见属性</h2><p>介绍一些使用频率比较高的属性。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">// 构建可执行程序</span><br><span class="line">android<span class="built_in">_</span>app &#123;</span><br><span class="line">    // 设定可执行的程序的名称，编译后会生成一个 CarNotification.apk</span><br><span class="line">    name: &quot;CarNotification&quot;,</span><br><span class="line">    // 指定java源码的位置</span><br><span class="line">    srcs: [&quot;src/**/*.java&quot;],</span><br><span class="line">    // 指定资源文件的位置</span><br><span class="line">    resource<span class="built_in">_</span>dirs: [&quot;res&quot;],</span><br><span class="line">    // 允许使用系统hide api</span><br><span class="line">    platform<span class="built_in">_</span>apis: true,</span><br><span class="line">    // 设定apk签名为 platform</span><br><span class="line">    certificate: &quot;platform&quot;,</span><br><span class="line">    // 如果集成的是apk且使用原签名，则使用该属性</span><br><span class="line">    presigned: true,</span><br><span class="line">    // 设定apk安装路径为priv-app</span><br><span class="line">    privileged: true,</span><br><span class="line">    // 是否启用代码优化，android<span class="built_in">_</span>app中默认为true，java<span class="built_in">_</span>library中默认为false</span><br><span class="line">    optimize: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    // 是否预先生成dex文件，默认为true。该属性会影响应用的首次启动速度以及Android系统的启动速度</span><br><span class="line">    dex<span class="built_in">_</span>preopt: &#123;</span><br><span class="line">        enabled: false,</span><br><span class="line">    &#125;,</span><br><span class="line">    // 引入java静态库</span><br><span class="line">    static<span class="built_in">_</span>libs: [</span><br><span class="line">        &quot;androidx.cardview<span class="built_in">_</span>cardview&quot;,</span><br><span class="line">        &quot;androidx.recyclerview<span class="built_in">_</span>recyclerview&quot;,</span><br><span class="line">        &quot;androidx.palette<span class="built_in">_</span>palette&quot;,</span><br><span class="line">        &quot;car-assist-client-lib&quot;,</span><br><span class="line">        &quot;android.car.userlib&quot;,</span><br><span class="line">        &quot;androidx-constraintlayout<span class="built_in">_</span>constraintlayout&quot;</span><br><span class="line">    ],</span><br><span class="line">    // 引入java库</span><br><span class="line">    libs: [&quot;android.car&quot;],</span><br><span class="line">    product<span class="built_in">_</span>variables: &#123;</span><br><span class="line">        pdk: &#123;</span><br><span class="line">            enabled: false,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    // 设定依赖模块。如果安装了此模块，则要还需要安装的其他模块的名称</span><br><span class="line">    required: [&quot;privapp<span class="built_in">_</span>whitelist<span class="built_in">_</span>com.android.car.notification&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引入第三方jar包"><a href="#引入第三方jar包" class="headerlink" title="引入第三方jar包"></a>引入第三方jar包</h2><p>在项目的根目录新建 libs文件夹，放入要导入的jar包，比如 CarServicelib.jar，然后在Android.bp中引入该jar</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">java<span class="built_in">_</span>import &#123;</span><br><span class="line">  name: &quot;CarServicelib.jar&quot;,</span><br><span class="line">  jars: [&quot;libs/CarServicelib.jar&quot;],</span><br><span class="line">&#125;</span><br><span class="line">android<span class="built_in">_</span>app &#123;</span><br><span class="line">    // 省去其它属性</span><br><span class="line">    // 引入AndroidX库下的lib</span><br><span class="line">    static<span class="built_in">_</span>libs: [</span><br><span class="line">        &quot;CarServicelib.jar&quot;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Android-bp与Android-mk对比"><a href="#Android-bp与Android-mk对比" class="headerlink" title="Android.bp与Android.mk对比"></a>Android.bp与Android.mk对比</h1><h2 id="编译成Java库"><a href="#编译成Java库" class="headerlink" title="编译成Java库"></a>编译成Java库</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_JAVA_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">java<span class="built_in">_</span>library &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译成Java静态库"><a href="#编译成Java静态库" class="headerlink" title="编译成Java静态库"></a>编译成Java静态库</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_STATIC_JAVA_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">java<span class="built_in">_</span>library<span class="built_in">_</span>static &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译成APP应用"><a href="#编译成APP应用" class="headerlink" title="编译成APP应用"></a>编译成APP应用</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_PACKAGE)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">android<span class="built_in">_</span>app &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译成Native动态库"><a href="#编译成Native动态库" class="headerlink" title="编译成Native动态库"></a>编译成Native动态库</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>shared &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译成Native静态库"><a href="#编译成Native静态库" class="headerlink" title="编译成Native静态库"></a>编译成Native静态库</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_STATIC_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>static &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译成Native执行程序"><a href="#编译成Native执行程序" class="headerlink" title="编译成Native执行程序"></a>编译成Native执行程序</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">cc<span class="built_in">_</span>binary &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译成头文件库"><a href="#编译成头文件库" class="headerlink" title="编译成头文件库"></a>编译成头文件库</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_HEADER_LIBRARY)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>headers &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="本地头文件路径"><a href="#本地头文件路径" class="headerlink" title="本地头文件路径"></a>本地头文件路径</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line">LOCAL_C_INCLUDES :=</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">local<span class="built_in">_</span>include<span class="built_in">_</span>dirs: [&quot;xxx&quot;, ...]</span><br></pre></td></tr></table></figure>

<h2 id="依赖的静态库"><a href="#依赖的静态库" class="headerlink" title="依赖的静态库"></a>依赖的静态库</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line">LOCAL_STATIC_LIBRARIES :=</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">static<span class="built_in">_</span>libs: [&quot;xxx&quot;, &quot;xxx&quot;, ...]</span><br></pre></td></tr></table></figure>

<h2 id="依赖的动态库"><a href="#依赖的动态库" class="headerlink" title="依赖的动态库"></a>依赖的动态库</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line">LOCAL_SHARED_LIBRARIES :=</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">shared<span class="built_in">_</span>libs: [&quot;xxx&quot;, &quot;xxx&quot;, ...]</span><br></pre></td></tr></table></figure>

<h2 id="依赖的Java库"><a href="#依赖的Java库" class="headerlink" title="依赖的Java库"></a>依赖的Java库</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">Android.mk</span><br><span class="line">LOCAL_STATIC_JAVA_LIBRARIES :=</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Android.bp</span><br><span class="line">static<span class="built_in">_</span>libs: [&quot;xxx&quot;, &quot;xxx&quot;, ...]</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Android系统开发</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android车载核心服务-CarService</title>
    <url>/2022/02/23/android_aosp_car_service/</url>
    <content><![CDATA[<p><code>CarService</code>是车载Android系统的核心服务之一，所有应用都需要通过<code>CarService</code>来查询、控制整车的状态。不仅仅是车辆控制，实际上<code>CarService</code>几乎就是整个车载Framework最核心的组件。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>CarService源码位置：<code>/packages/service/Car/service</code></p>
<p>Android系统主要应用于中控和副驾屏幕，原生的车载Android本质上可以看作是Android OS + Automotive Services + Automotive APPs组成的系统。用户会通过显示在中控屏幕上App，将对车辆的操作信息通过Car API 传递给<code>Framework Service</code>，Service再通过HIDL将信息处理后传递给<code>HAL Service</code>，<code>HAL Service</code>再将数据处理后传递给<code>MCU</code>，<code>MCU</code>通过<code>CAN bus</code>将信息传递给汽车上的各个ECU（中间忽略了一些不需要理解的步骤），然后由ECU控制汽车的机械零部件进行活动，这样就完成了一次从Android APP到车辆机械零部件间的通信。</p>
<blockquote>
<p>HIDL是一种类似于AIDL的跨进程通信手段，主要应用于HAL层程序的跨进程通信。Google在Android 8中引入并在Android 10中废弃，Android 10 以后被AIDL取代。</p>
</blockquote>
<p><img src="/images/android_aosp_car_service01.png" alt="img"></p>
<p>以上通信过程起到承上启下作用的Framework Service就是我们的主角 — <code>CarService</code>。</p>
<blockquote>
<p>原生Android Automotive 系统里<code>CarService</code>实现的功能非常多，架构图里描述的只是其中的冰山一角，架构图描述的意义只是为了引出<code>CarService</code>。</p>
</blockquote>
<h1 id="CarService-的组成"><a href="#CarService-的组成" class="headerlink" title="CarService 的组成"></a>CarService 的组成</h1><p>作为 Android Automotive 的核心进程，原生的<code>CarService</code>业务量非常庞大，包含了许多与汽车相关的服务，主要有以下几个：</p>
<ul>
<li><strong>CarPropertyService</strong></li>
</ul>
<p>此类实现<code>ICarProperty</code>的binder接口。有助于更容易地创建处理车辆属性的多个Manager。</p>
<ul>
<li><strong>CarInputService</strong></li>
</ul>
<p><code>CarInputService</code>通过车辆HAL监控和处理输入事件。</p>
<ul>
<li><strong>CarLocationService</strong></li>
</ul>
<p>此服务在车辆停放时存储<code>LocationManager</code>中最后一个已知位置，并在车辆通电时恢复该位置。</p>
<ul>
<li><strong>CarMediaService</strong></li>
</ul>
<p><code>CarMediaService</code>管理汽车应用程序的当前活动媒体源。这与<code>MediaSessionManager</code>的活动会话不同，因为同一时间内车内只能有一个活动源。</p>
<p>在车内，活动的媒体源不一定有活动的<code>MediaSession</code>，例如，如果只是在浏览它。但是，该源仍然被视为活动源，并且应该是任何媒体相关UI（媒体中心、主屏幕等）中显示的源。</p>
<ul>
<li><strong>CarPowerManagementService</strong></li>
</ul>
<p>汽车电源管理服务。控制电源状态并与系统的其他部分交互以确保其自身状态。</p>
<ul>
<li><strong>CarProjectionService</strong></li>
</ul>
<p>汽车投屏服务。</p>
<ul>
<li><strong>CarAudioService</strong></li>
</ul>
<p>负责与汽车音响系统交互的服务。</p>
<ul>
<li><strong>AppFocusService</strong></li>
</ul>
<p>应用程序焦点服务确保一次只有一个应用程序类型的实例处于活动状态。</p>
<ul>
<li><strong>GarageModeService</strong></li>
</ul>
<p>车库模式。车库模式启用车内空闲时间。</p>
<ul>
<li><strong>InstrumentClusterService</strong></li>
</ul>
<p>负责与汽车仪表盘交互的服务。</p>
<ul>
<li><strong>CarPackageManagerService</strong></li>
</ul>
<p>汽车包管理服务。</p>
<ul>
<li><strong>CarUserService</strong></li>
</ul>
<p>汽车多用户服务。在启动时管理用户。包括：</p>
<ol>
<li>创建用作驱动程序的用户。</li>
<li>创建用作乘客的用户。</li>
<li>首次运行时创建辅助管理员用户。</li>
<li>切换驾驶员。</li>
</ol>
<ul>
<li>CarStorageMonitoringService</li>
</ul>
<p>提供存储监视数据（如I/O统计数据）的服务。为了接收此类数据，用户需要实现<code>IIoStatsListener</code>并根据此服务注册自己。</p>
<ul>
<li>CarBluetoothService</li>
</ul>
<p>车载蓝牙服务-维护当前用户的蓝牙设备和配置文件连接。</p>
<ul>
<li>FixedActivityService</li>
</ul>
<p>监控显示器顶部的Activity，并确保在固定模式下的Activity在崩溃或因任何原因进入后台时重新启动。此组件还监视目标包的更新，并在更新完成后重新启动它。</p>
<ul>
<li>CarBugreportManagerService</li>
</ul>
<p>Bug report服务</p>
<ul>
<li>CarConfigurationService</li>
</ul>
<p>该服务将查看系统上的默认JSON配置文件并解析其结果。该服务将查找映射到<code>R.raw.car_config</code>的JSON文件。如果此值不存在或格式不正确，则此服务不会失败；相反，它返回各种配置的默认值。</p>
<ul>
<li>CarDiagnosticService</li>
</ul>
<p>汽车诊断服务。工程模式会用到此服务。</p>
<ul>
<li>CarDrivingStateService</li>
</ul>
<p>推断车辆当前驾驶状态的服务。它通过侦听<code>CarPropertyService</code>的相关属性来计算驾驶状态。</p>
<ul>
<li>CarExperimentalFeatureServiceController</li>
</ul>
<p>控制与<code>ExperimentalCarService</code>的绑定以及实验功能的接口。</p>
<ul>
<li>CarFeatureController</li>
</ul>
<p>控制汽车特性的部件。</p>
<ul>
<li>CarNightService</li>
</ul>
<p>用于处理用于将车辆设置为夜间模式的事件。</p>
<ul>
<li>CarOccupantZoneService</li>
</ul>
<p>用于实现<code>CarOccupantZoneManager</code>API的服务。</p>
<ul>
<li>CarTestService</li>
</ul>
<p>允许测试/模拟车辆HAL的服务。该服务直接使用车辆HAL API，因为车辆HAL模拟无论如何都需要直接访问该级别。</p>
<ul>
<li>CarUxRestrictionsManagerService</li>
</ul>
<p>用户体验限制的服务。根据监听到的车辆当前驾驶状态，限制HMI显示。</p>
<ul>
<li>OccupantAwarenessService</li>
</ul>
<p>一种服务，通过HAL边界监听占用者感知检测系统，并通过<code>OccupantAwarenessManager</code>将数据暴露给Android中的系统客户端。</p>
<ul>
<li>SystemActivityMonitoringService</li>
</ul>
<p>监控AMS新Activity或Service启动的服务。</p>
<ul>
<li>SystemStateControllerService</li>
</ul>
<p>系统状态控制服务。原生系统中是一个空服务，并没有实现。</p>
<ul>
<li>CarMonitoringService</li>
</ul>
<p>监视应用程序资源使用情况的服务。</p>
<ul>
<li>CarTrustedDeviceService</li>
</ul>
<p>汽车服务中启用受信任设备功能的部分。可信设备是一项功能，其中远程设备注册为可信设备，可以授权Android用户而不是用户输入密码或PIN。</p>
<ul>
<li>CarUserNoticeService</li>
</ul>
<p>向用户显示初始通知UI的服务。它仅在启用设置时启动它，并根据用户的请求通知UI自行关闭。</p>
<ul>
<li>VmsBrokerService</li>
</ul>
<p>VMS客户端实现，使用HAL特定消息编码将VmsPublisher/VmsSubscriber API调用代理到车辆HAL。</p>
<ul>
<li>CarWatchdogService</li>
</ul>
<p>实现<code>CarWatchdogManager</code>API的服务。<code>CarWatchdogService</code>作为汽车监控中介运行，它检查客户端的健康状况，并将结果报告给汽车监控服务器。</p>
<blockquote>
<p>加粗的各个<code>Service</code>属于<code>CarService</code>中比较重要的功能，以后都会单独开坑讲。</p>
<p>往简单地说，车载Framework的功能性开发基本就是围绕着<code>CarService</code>中的这些服务做增改，如果能把所有这些服务和背后原理都理解透彻，车载Framework基本就算完事了。当然可能也有些过于理想化了，因为还有android自身的Framework需要修改，比如网络系统、蓝牙协议栈等等。</p>
</blockquote>
<hr>
<p>以上就是Android Automotive中<code>CarService</code>支持的所有功能，虽然冠名了xxxService但这些服务其实并不是四大组件意义上的<code>Service</code>，它们没有继承自<code>android.app.Service</code>，相反它们都继承自<code>ICarxxxx.Stub</code>，本质上属于AIDL接口的实现类。到这一步也可以看出<code>CarService</code>本质上只是作为这些服务的容器而存在的，本身并没有实现业务逻辑上的功能。</p>
<p>既然这些Service都是AIDL接口的实现类，本质上就是AIDL的Server端，那应用就还需要通过相应的API SDK才能调用Server的方法，这个API SDK就是Car API。</p>
<h1 id="Car-API-使用方式"><a href="#Car-API-使用方式" class="headerlink" title="Car API 使用方式"></a>Car API 使用方式</h1><p>不同的公司或车机系统项目对于Car API的定位、实现并不相同，本文主要从原生Android Automotive的角度介绍。</p>
<p>Car API 源码位置<code>/packages/service/Car/car-lib</code></p>
<h2 id="Car-API-简介"><a href="#Car-API-简介" class="headerlink" title="Car API 简介"></a>Car API 简介</h2><p>在上面的介绍中，我们提到<code>CarService</code>中各个服务本质上是AIDL接口的实现类，属于Server端，而对应的Client端就需要一个<code>IBinder</code>对象来访问Server端的方法，这些<code>IBinder</code>对象在Car API中被封装在一个个<code>XXXManager</code>类中。</p>
<p>Car API与<code>CarService</code>中的服务，名称上存在对应关系，所以很好理解。例如：<code>CarWatchdogManager</code>对应<code>CarWatchdogService</code>，<code>CarMediaManager</code>对应<code>CarMediaService</code>。</p>
<p>不过也有例外：<code>CarInfoManager</code>、<code>CarSensorManager</code>、<code>CarHvacManager</code>、<code>CarCabinManager</code>、<code>CarVendorExtensionManager</code>都对应<code>CarPropertyService</code>。但是在Android 11中这些Manager都已经过时，Google建议统一使用<code>CarPropertyManager</code>。</p>
<blockquote>
<p>实际项目中我们不一定要按照Google建议的那样编写Car API，可以按实际情况实施。我个人也经历过某个把Car API源码整个移除，从头重写CarService的项目。</p>
</blockquote>
<h2 id="编译-Car-API"><a href="#编译-Car-API" class="headerlink" title="编译 Car API"></a>编译 Car API</h2><p>在使用Car API之前，我们需要先将Car API编译成jar也就是CarLib，这样才能让其它的系统应用使用。</p>
<p>编译CarLib有三种不同指令：</p>
<p><strong>1）make android.car</strong></p>
<p>编译成功后的jar存放在<code>/out/soong/.intermediates/packages/services/Car/car-lib/android.car/android_common/javac/</code>目录下。</p>
<p>编译出的CarLib库<strong>包含Car API中定义的所有方法以及实现细节</strong>。导入到android studio中打开后，如下所示：</p>
<p><img src="/images/android_aosp_car_service02.png" alt="img"></p>
<p><strong>2）make android.car-system-stubs</strong></p>
<p>编译成功后的jar存放在<code>/out/soong/.intermediates/packages/services/Car/car-lib/android.car-system-stubs/android_common/javac/</code>目录下。</p>
<p>编译出的CarLib库<code>包含CarAPI中定义的所有方法，但是不包含实现细节，一些与实现细节有关的变量也会被隐藏</code>。实际项目中这种模式较为常用。导入到android studio中打开后，如下所示：</p>
<p><img src="/images/android_aosp_car_service03.png" alt="img"></p>
<p><strong>3）make android.car-stubs</strong></p>
<p>编译成功后的jar存放在<code>/out/soong/.intermediates/packages/services/Car/car-lib/android.car-stubs/android_common/javac/</code>目录下。</p>
<p>编译出的CarLib库<strong>仅包含没有被@SystemApi修饰方法，而且方法同样不包含实现细节，是最严格的编译模式</strong>。此模式下编译出的CarLib甚至已经没有<code>CarDiagnosticManager</code>这个系统API了。</p>
<p>上述的编译步骤对应的是使用Android Studio开发的系统应用。原生android automotive中的系统应用则是直接在android.bp中将CarLib引入，可以参考<code>Settings/Android.bp</code>的引入方式。</p>
<p><img src="/images/android_aosp_car_service04.png" alt="image"></p>
<h2 id="使用-Car-API"><a href="#使用-Car-API" class="headerlink" title="使用 Car API"></a>使用 Car API</h2><p>Car API 的使用并不复杂，大致有以下几个步骤。</p>
<p>通过<code>Car.createCar()</code>方法可以创建出Car的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) &#123;</span><br><span class="line">    Car carApiClient = Car.createCar(context, mCarServiceConnection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过getPackageManager().hasSystemFeature(String string)判断系统是否支持特定的模块功能</p>
</blockquote>
<p><code>Car.createCar()</code>需要传入<code>ServiceConnection</code>，并在service连接成功后，获取想要的Manager实例，实现方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServiceConnection mCarServiceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                CarHvacManager manager = (CarHvacManager) mCarApiClient.getCarManager(Car.HVAC_SERVICE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CarNotConnectedException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Car not connected in onServiceConnected&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构建出Car对象后还需要调用<code>connect()</code>才会连接到<code>CarService</code>上。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">carApiClient<span class="selector-class">.connect</span>();</span><br></pre></td></tr></table></figure>

<p><code>connect()</code>只能调用一次，如果当前已经处于连接状态，再次调用<code>connect()</code>会抛出异常，client如果没有捕获该异常，则会引起client端程序崩溃（血的教训！）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mConnectionState != STATE_DISCONNECTED) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;already connected or connecting&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mConnectionState = STATE_CONNECTING;</span><br><span class="line">        startCarService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>connect()</code>对应的还有<code>disconnect()</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">carApiClient<span class="selector-class">.disconnect</span>();</span><br></pre></td></tr></table></figure>

<p>不知道你有没有注意到，<code>connect()</code>被标记为Deprecated过时的方法了。</p>
<p>这是因为在android 10 以后，Google改写了Car API的使用方式，Android 10以后构建Car对象不再建议传入<code>ServiceConnection</code>而是使用下面的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) &#123;</span><br><span class="line">    Car carApiClient = Car.createCar(context);</span><br><span class="line">    CarHvacManager manager = (CarHvacManager) mCarApiClient.getCarManager(Car.HVAC_SERVICE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Android 10以后Car Api的调用方式由异步方法改为了同步方法，保留了<code>disconnect()</code>，但是不再需要调用<code>connect()</code>，这样使用起来更简单。</p>
<p>这种调用方式是乐观的认为<code>CarService</code>不会发生异常，与<code>CarService</code>的连接也不会断开。但是如果<code>CarService</code>发生异常，连接被断开的话，client端调用方就会直接被杀死，使用下面这种调用方式可以避免这种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = Car.createCar(<span class="keyword">this</span>, workThreadHandler, <span class="number">2000</span>, <span class="keyword">new</span> Car.CarServiceLifecycleListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLifecycleChanged</span><span class="params">(<span class="meta">@NonNull</span> Car car, <span class="keyword">boolean</span> ready)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ready 在Service断开连接时会变为false</span></span><br><span class="line"><span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// CarService 发生异常或连接被断开了，需要client端处理。</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>为什么上面的那种调用方式会导致client端的进程被杀死呢？这就需要我们继续深入的探究一下Car Api是如何实现的。</p>
<h1 id="Car-API-实现原理"><a href="#Car-API-实现原理" class="headerlink" title="Car API 实现原理"></a>Car API 实现原理</h1><p>探讨Car API的实现原理我们可以它的入口类Car开始。源码位置：</p>
<p><code>/packages/services/Car/car-lib/src/android/car/Car.java</code></p>
<p><code>createCar</code>有三个不同的重载方法，分别如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Car createCar(Context context)</span><br><span class="line">public static Car createCar(Context context, @Nullable Handler handler)</span><br><span class="line"></span><br><span class="line">public static Car createCar(@NonNull Context context,</span><br><span class="line">                            @Nullable Handler handler, long waitTimeoutMs,</span><br><span class="line">                            @NonNull CarServiceLifecycleListener statusChangeListener) </span><br></pre></td></tr></table></figure>

<p><code>createCar(context)</code>在实现上是直接调用了<code>createCar(context, handler)</code>，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span>(<span class="params">Context context</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createCar(context, (Handler) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createCar(context, handler)</code>与<code>createCar(context, handler, waitTimeoutMs, statusChangeListener)</code>之间则没有调用关系，各自有各自的实现方式，但是逻辑上大致相同，并且第三种的<code>createCar(context, handler, waitTimeoutMs, statusChangeListener)</code>逻实现上要更复杂一些。所以我们直接看<code>createCar(context, handler, waitTimeoutMs, statusChangeListener)</code>是实现的就可以了。</p>
<ul>
<li><strong>createCar(context, handler, waitTimeoutMs, statusChangeListener)</strong></li>
</ul>
<p><strong>Handler handler</strong>：将所有CarXXXManager事件发送到此handler。但是<code>statusChangeListener</code>将始终调度到主线程。传递null会导致将所有CarXXXManager回调发送到主线程。</p>
<p><strong>long waitTimeoutMs</strong>：将其设置为<code>CAR_WAIT_TIMEOUT_DO_NOT_WAIT</code>则不等待<code>CarService</code>连接就绪。将此设置为<code>CAR_WAIT_TIMEOUT_WAIT_FOREVER</code>将阻塞调用，直到<code>CarService</code>连接成功为止。</p>
<p>设置的值大于0则为超时时间，当存在有限的超时时间时，返回的Car对象不能保证是可用的。</p>
<p><strong>CarServiceLifecycleListener statusChangeListener：</strong> 监听<code>CarService</code>是否连接就绪。</p>
<hr>
<p><code>createCar</code>在实现流程上可以分为三个部分：</p>
<p>第一步，计算出绑定<code>CarService</code>的最大重试次数。这个次数决定了后面，多久会显示连接异常的日志。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(@NonNull Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">                            @Nullable Handler handler, <span class="keyword">long</span> waitTimeoutMs,</span></span></span><br><span class="line"><span class="params"><span class="function">                            @NonNull CarServiceLifecycleListener statusChangeListener)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">long</span> maxRetryCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (waitTimeoutMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        maxRetryCount = waitTimeoutMs / CAR_SERVICE_BINDER_POLLING_INTERVAL_MS; <span class="comment">// 50 ms</span></span><br><span class="line"> <span class="comment">// 如果是正值，则至少等待一次。</span></span><br><span class="line"><span class="keyword">if</span> (maxRetryCount == <span class="number">0</span>) &#123;</span><br><span class="line">            maxRetryCount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步也是最关键的一步，构造出Car对象并返回给调用方，同时将状态通过<code>statusChangeListener</code>回调给调用方。正常流程下到createCar()方法执行到这里就已经结束了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(<span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="meta">@Nullable</span> Handler handler, <span class="keyword">long</span> waitTimeoutMs,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="meta">@NonNull</span> CarServiceLifecycleListener statusChangeListener)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Car car = <span class="keyword">null</span>;</span><br><span class="line">    IBinder service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> retryCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> isMainThread = Looper.myLooper() == Looper.getMainLooper();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个 CAR_SERVICE_BINDER_SERVICE_NAME 是在CarService启动时添加的。</span></span><br><span class="line">        service = ServiceManager.getService(CAR_SERVICE_BINDER_SERVICE_NAME);</span><br><span class="line">        <span class="keyword">if</span> (car == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// service可以为空，构造方法对于空service是安全的。</span></span><br><span class="line">car = <span class="keyword">new</span> Car(context, ICar.Stub.asInterface(service), <span class="keyword">null</span>, statusChangeListener,</span><br><span class="line">                    handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                car.dispatchCarReadyToMainThread(isMainThread);</span><br><span class="line">                car.startCarService();</span><br><span class="line">                <span class="comment">// 正常流程下，while (true)循环执行到这里就结束了，后面的方法只有CarService启动出现异常时才会出现。 </span></span><br><span class="line">                <span class="keyword">return</span> car;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">            car.startCarService();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果连接失败，每隔50毫秒重试一次，尝试达到一定的阈值后,日志上会显示异常</span></span><br><span class="line">retryCount++;</span><br><span class="line">        <span class="keyword">if</span> (waitTimeoutMs &lt; <span class="number">0</span> &amp;&amp; retryCount &gt;= CAR_SERVICE_BINDER_POLLING_MAX_RETRY</span><br><span class="line">&amp;&amp; retryCount % CAR_SERVICE_BINDER_POLLING_MAX_RETRY == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 日志警告</span></span><br><span class="line">Log.w(TAG_CAR, <span class="string">&quot;car_service not ready, waited for car service (ms):&quot;</span></span><br><span class="line">                            + retryCount * CAR_SERVICE_BINDER_POLLING_INTERVAL_MS,</span><br><span class="line">                    <span class="keyword">new</span> RuntimeException());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitTimeoutMs &gt;= <span class="number">0</span> &amp;&amp; retryCount &gt; maxRetryCount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (waitTimeoutMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG_CAR, <span class="string">&quot;car_service not ready, waited for car service (ms):&quot;</span></span><br><span class="line">                                + waitTimeoutMs,</span><br><span class="line">                        <span class="keyword">new</span> RuntimeException());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> car;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 休眠 50 ms</span></span><br><span class="line">Thread.sleep(CAR_SERVICE_BINDER_POLLING_INTERVAL_MS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            Log.w(TAG_CAR, <span class="string">&quot;interrupted&quot;</span>, <span class="keyword">new</span> RuntimeException());</span><br><span class="line">            <span class="keyword">return</span> car;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后一步，主要是应对一些异常情况，正常情况不会触发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(<span class="meta">@NonNull</span> Context context,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="meta">@Nullable</span> Handler handler, <span class="keyword">long</span> waitTimeoutMs,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="meta">@NonNull</span> CarServiceLifecycleListener statusChangeListener)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁是为了让 mServiceConnectionListener 能在主线程中正常访问 car 实例</span></span><br><span class="line"><span class="keyword">synchronized</span> (car.mLock) &#123;</span><br><span class="line">        Log.w(TAG_CAR,</span><br><span class="line">                <span class="string">&quot;waited for car_service (ms):&quot;</span></span><br><span class="line">                        + retryCount * CAR_SERVICE_BINDER_POLLING_INTERVAL_MS,</span><br><span class="line">                <span class="keyword">new</span> RuntimeException());</span><br><span class="line">        <span class="comment">// ServiceConnection 已经处理了一切，直接返回 car 实例</span></span><br><span class="line"><span class="keyword">if</span> (car.mService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> car;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mService check in ServiceConnection prevents calling onLifecycleChanged.</span></span><br><span class="line"> <span class="comment">// So onLifecycleChanged should be called explicitly but do it outside lock.</span></span><br><span class="line">car.mService = ICar.Stub.asInterface(service);</span><br><span class="line">        car.mConnectionState = STATE_CONNECTED;</span><br><span class="line">    &#125;</span><br><span class="line">    car.dispatchCarReadyToMainThread(isMainThread);</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>createCar()</code>方法中分发Car实例状态时，会调用<code>startCarService()</code>绑定<code>CarService</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCarService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setPackage(CAR_SERVICE_PACKAGE);</span><br><span class="line">    intent.setAction(Car.CAR_SERVICE_INTERFACE_NAME);</span><br><span class="line">    <span class="keyword">boolean</span> bound = mContext.bindServiceAsUser(intent, mServiceConnectionListener,</span><br><span class="line">            Context.BIND_AUTO_CREATE, UserHandle.CURRENT_OR_SELF);</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bound) &#123;</span><br><span class="line">            <span class="comment">// 绑定失败时的重试机制</span></span><br><span class="line">            mConnectionRetryCount++;</span><br><span class="line">            <span class="keyword">if</span> (mConnectionRetryCount &gt; CAR_SERVICE_BIND_MAX_RETRY) &#123;</span><br><span class="line">                Log.w(TAG_CAR, <span class="string">&quot;cannot bind to car service after max retry&quot;</span>);</span><br><span class="line">                mMainThreadEventHandler.post(mConnectionRetryFailedRunnable);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mEventHandler.postDelayed(mConnectionRetryRunnable,</span><br><span class="line">                        CAR_SERVICE_BIND_RETRY_INTERVAL_MS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 绑定成功时要取消重试机制</span></span><br><span class="line">            mEventHandler.removeCallbacks(mConnectionRetryRunnable);</span><br><span class="line">            mMainThreadEventHandler.removeCallbacks(mConnectionRetryFailedRunnable);</span><br><span class="line">            mConnectionRetryCount = <span class="number">0</span>;</span><br><span class="line">            mServiceBound = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mConnectionRetryRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        startCarService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable mConnectionRetryFailedRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mServiceConnectionListener.onServiceDisconnected(<span class="keyword">new</span> ComponentName(CAR_SERVICE_PACKAGE,</span><br><span class="line">                CAR_SERVICE_CLASS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在绑定<code>CarService</code>时，需要使用<code>ServiceConnection</code>监听与<code>CarService</code>的连接状态，并处理service连接成功与连接断开的情况。</p>
<p>1）连接成功：由于在createCar中已经创建好了mService，所以正常流程下，执行到return就结束了，后面流程基本都是出现异常触发了重连。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServiceConnection mServiceConnectionListener = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    ICar newService = ICar.Stub.asInterface(service);</span><br><span class="line">                    <span class="keyword">if</span> (newService == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Log.wtf(TAG_CAR, <span class="string">&quot;null binder service&quot;</span>, <span class="keyword">new</span> RuntimeException());</span><br><span class="line">                        <span class="keyword">return</span>;  <span class="comment">// 这不应该发生</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mService != <span class="keyword">null</span> &amp;&amp; mService.asBinder().equals(newService.asBinder())) &#123;</span><br><span class="line">                        <span class="comment">// 由于在createCar中已经创建好了mService，所以正常流程下，执行到这一步就结束了</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mConnectionState = STATE_CONNECTED;</span><br><span class="line">                    mService = newService;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 分发连接状态</span></span><br><span class="line"><span class="keyword">if</span> (mStatusChangeCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mStatusChangeCallback.onLifecycleChanged(Car.<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mServiceConnectionListenerClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mServiceConnectionListenerClient.onServiceConnected(name, service);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ...</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>2）连接断开：分发Car对象的状态，此时Client不应该再使用Car的实例。所以如果Client端调用createCar()时没有监听连接状态，Car Api会触发<code>finishClient()</code>，直接杀死client端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ServiceConnection mServiceConnectionListener = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    ...</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 重新启动后，CarService可以接收功能更改。</span></span><br><span class="line">mFeatures.resetCache();</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mConnectionState  == STATE_DISCONNECTED) &#123;</span><br><span class="line">                        <span class="comment">// 当客户端调用在 onServiceDisconnected 调用之前断开连接时，可能会发生这种情况。</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    handleCarDisconnectLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mStatusChangeCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mStatusChangeCallback.onLifecycleChanged(Car.<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mServiceConnectionListenerClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mServiceConnectionListenerClient.onServiceDisconnected(name);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// client端没有正确处理CarService会重新启动的情况，因此直接杀死client端</span></span><br><span class="line">finishClient();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>finishClient()</code>中会根据传入client传入的context类型，执行不同的操作。</p>
<p>情景一：context = null，在Client端抛出异常。</p>
<p>情景二：context 是 Activity，结束该Activity，不会终止Client端的进程。</p>
<p>情景三：context 是 Service，终止Client端的进程。</p>
<p>情景四：context 不是以上的情况，终止Client端的进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void finishClient() &#123;</span><br><span class="line">    if (mContext == null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Car service has crashed, null Context&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mContext instanceof Activity) &#123;</span><br><span class="line">        Activity activity = (Activity) mContext;</span><br><span class="line">        if (!activity.isFinishing()) &#123;</span><br><span class="line">            Log.w ( TAG_CAR,</span><br><span class="line">                    &quot;Car service crashed, client not handling it, finish Activity, created &quot;</span><br><span class="line">                            + &quot;from &quot; + mConstructionStack);</span><br><span class="line">            activity.finish();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else if (mContext instanceof Service) &#123;</span><br><span class="line">        Service service = (Service) mContext;</span><br><span class="line">        killClient(service.getPackageName() + &quot;,&quot; + service.getClass().getSimpleName());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        killClient(/ * clientInfo= */  null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void killClient(@Nullable String clientInfo) &#123;</span><br><span class="line">    Log.w ( TAG_CAR, &quot;**Car service has crashed. Client(&quot; + clientInfo + &quot;) is not handling it.&quot;</span><br><span class="line">                    + &quot; Client should use Car.createCar(..., CarServiceLifecycleListener, ..&quot;</span><br><span class="line">                    + &quot;.) to handle it properly. Check pritned callstack to check where other &quot;</span><br><span class="line">                    + &quot;version of Car.createCar() was called. Killing the client process**&quot;,</span><br><span class="line">            mConstructionStack);</span><br><span class="line">    Process.killProcess( Process.myPid( ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正是由于<code>finishClient()</code>这种机制的存在，所以调用方应该要监听CarService的连接状态。</p>
<p>最后我们再看一下<code>getCarManager()</code>这个方法是如何实现的。</p>
<p><code>getCarManager()</code>实现机制上利用了BinderPool的思路，使用<code>ICar.aidl</code>的<code>getService()</code>来获取Server端的Binder对象，然后将Binder对象封装在Manager里面，同时将Manager对象缓存在一个Map集合中，后续就可以从Map取出需要的Manager，减少IPC通信开销。如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object getCarManager(String serviceName) &#123;</span><br><span class="line">    CarManagerBase manager;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mService == <span class="literal">null</span>) &#123;</span><br><span class="line">            Log.w(TAG_CAR, <span class="string">&quot;getCarManager not working while car service not ready&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        manager = mServiceMap.<span class="keyword">get</span>(serviceName);</span><br><span class="line">        <span class="keyword">if</span> (manager == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                IBinder binder = mService.getCarService(serviceName);</span><br><span class="line">                <span class="keyword">if</span> (binder == <span class="literal">null</span>) &#123;</span><br><span class="line">                    Log.w(TAG_CAR, <span class="string">&quot;getCarManager could not get binder for service:&quot;</span></span><br><span class="line">                            + serviceName);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                manager = createCarManagerLocked(serviceName, binder);</span><br><span class="line">                <span class="keyword">if</span> (manager == <span class="literal">null</span>) &#123;</span><br><span class="line">                    Log.w(TAG_CAR, <span class="string">&quot;getCarManager could not create manager for service:&quot;</span></span><br><span class="line">                            + serviceName);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mServiceMap.put(serviceName, manager);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                handleRemoteExceptionFromCarService(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> CarManagerBase createCarManagerLocked(String serviceName, IBinder binder) &#123;</span><br><span class="line">    CarManagerBase manager = <span class="literal">null</span>;</span><br><span class="line">    switch (serviceName) &#123;</span><br><span class="line">        case AUDIO_SERVICE:</span><br><span class="line">            manager = new CarAudioManager(<span class="keyword">this</span>, binder);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case SENSOR_SERVICE:</span><br><span class="line">            manager = new CarSensorManager(<span class="keyword">this</span>, binder);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        case INFO_SERVICE:</span><br><span class="line">            manager = new CarInfoManager(<span class="keyword">this</span>, binder);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        default:</span><br><span class="line">            <span class="comment">// Experimental or non-existing</span></span><br><span class="line">String className = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                className = mService.getCarManagerClassForFeature(serviceName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                handleRemoteExceptionFromCarService(e);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (className == <span class="literal">null</span>) &#123;</span><br><span class="line">                Log.e(TAG_CAR, <span class="string">&quot;Cannot construct CarManager for service:&quot;</span> + serviceName</span><br><span class="line">                        + <span class="string">&quot; : no class defined&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            manager = constructCarManager(className, binder);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就Car API的实现过和原理了。注意在<code>createCar()</code>中有这样一段代码。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">IBinder service = <span class="literal">null</span>;</span><br><span class="line">service = ServiceManager.getService(CAR_SERVICE_BINDER_SERVICE_NAME);</span><br></pre></td></tr></table></figure>

<p>在Client端与<code>CarService</code>建立连接之前，通过<code>ServiceManager.getService()</code>就可以直接取出IBinder对象，而不用等到与service建立连接后再从<code>onServiceConnected(ComponentName name, IBinder service)</code>中取。</p>
<p>但是这样操作的前提是使用<code>ServiceManager.addService()</code>添加了这个IBinder，那么是哪里添加的呢，IBinder是Server端实现的，那么答案就需要去<code>CarService</code>中寻找了。</p>
<h1 id="CarService-的实现原理"><a href="#CarService-的实现原理" class="headerlink" title="CarService 的实现原理"></a>CarService 的实现原理</h1><p>想要说清楚<code>CarService</code>实现方式，我们需要搞明白<code>CarService</code>是怎么启动的。</p>
<h2 id="CarService-启动流程"><a href="#CarService-启动流程" class="headerlink" title="CarService 启动流程"></a>CarService 启动流程</h2><p><code>CarService</code>作为Android Automotive的核心服务，它是在<code>SystemServer</code>中启动的，<code>SystemServer</code>会在<code>startOtherServices()</code>方法中让<code>SystemServiceManager</code>先通过反射的形式创建出<code>StartCarServiceHelperService</code>这个对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">(@NonNull TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 仅在automotive中启动</span></span><br><span class="line">    <span class="keyword">if</span> (mPackageManager.<span class="built_in">hasSystemFeature</span>(PackageManager.FEATURE_AUTOMOTIVE)) &#123;</span><br><span class="line">        t.<span class="built_in">traceBegin</span>(<span class="string">&quot;StartCarServiceHelperService&quot;</span>);</span><br><span class="line">        mSystemServiceManager.<span class="built_in">startService</span>(CAR_SERVICE_HELPER_SERVICE_CLASS);</span><br><span class="line">        t.<span class="built_in">traceEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>SystemServiceManager</code>中调用<code>StartCarServiceHelperService</code>的<code>onStart()</code>方法。</p>
<p><code>CarServiceHelperService</code>是<code>CarService</code>的SystemService端的配套服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SystemService <span class="title">startService</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;SystemService&gt; serviceClass = loadClassFromLoader(className,</span><br><span class="line">            <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">    <span class="keyword">return</span> startService(serviceClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Register it.</span></span><br><span class="line">mServices.add(service);</span><br><span class="line">    <span class="keyword">long</span> time = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        service.onStart();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failed to start service &quot;</span> + service.getClass().getName()</span><br><span class="line">                + <span class="string">&quot;: onStart threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    warnIfTooLong(SystemClock.elapsedRealtime() - time, service, <span class="string">&quot;onStart&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终在<code>onStart()</code>方法中启动<code>CarService</code>，并加载jni库为<code>CarService</code>提供必要的API。</p>
<blockquote>
<p>CarServiceHelperService 源码位置：</p>
<p><code>/frameworks/opt/car/services/src/com/android/internal/car/CarServiceHelperService.java</code></p>
<p>注意：CarServiceHelperService并不是android.app.Service</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setPackage(<span class="string">&quot;com.android.car&quot;</span>);</span><br><span class="line">    intent.setAction(ICarConstants.CAR_SERVICE_INTERFACE);</span><br><span class="line">    <span class="keyword">if</span> (!mContext.bindServiceAsUser(intent, mCarServiceConnection, Context.BIND_AUTO_CREATE,</span><br><span class="line">            UserHandle.SYSTEM)) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">&quot;cannot start car service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    loadNativeLibrary();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadNativeLibrary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;car-framework-service-jni&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的步骤<code>CarService</code>就完成了启动，<code>CarService</code>的启动时序如下所示：</p>
<p><img src="/images/android_aosp_car_service05.png" alt="img"></p>
<h2 id="CarService-初始化"><a href="#CarService-初始化" class="headerlink" title="CarService 初始化"></a>CarService 初始化</h2><p><code>CarService</code>进入启动时序后，会<code>onCreate()</code>方法中进行一系列的自身的初始化操作，步骤如下：</p>
<p>1）通过HIDL接口获取到HAL层的IHwBinder对象-<code>IVehicle</code>，与AIDL的用法类似，必须持有IHwBinder对象我们才可以与Vehicle HAL层进行通信。有关HIDL、VechicleHAL以后都会单独介绍。</p>
<p>2）创建ICarImpl对象，并调用<code>init</code>方法，它就是<code>ICar.aidl</code>接口的实现类，我们需要通过它才能拿到其他的Service的IBinder对象。</p>
<p>3）将<code>ICar.aidl</code>的实现类添加到ServiceManager中。这就解答了我们在Car API中疑问。</p>
<p>4）设定SystemProperty，将<code>CarService</code>设定为创建完成状态，只有包含<code>CarService</code>在内的所有的核心Service都完成初始化，才能结束开机动画并发送开机广播。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.i(CarLog.TAG_SERVICE, <span class="string">&quot;Service onCreate&quot;</span>);</span><br><span class="line">    mCanBusErrorNotifier = <span class="keyword">new</span> CanBusErrorNotifier(<span class="keyword">this</span> <span class="comment">/* context */</span> );</span><br><span class="line">    mVehicle = getVehicle();</span><br><span class="line">    EventLog.writeEvent(EventLogTags.CAR_SERVICE_CREATE, mVehicle == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVehicle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Vehicle HAL service is not available.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mVehicleInterfaceName = mVehicle.interfaceDescriptor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unable to get Vehicle HAL interface descriptor&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(CarLog.TAG_SERVICE, <span class="string">&quot;Connected to &quot;</span> + mVehicleInterfaceName);</span><br><span class="line">    EventLog.writeEvent(EventLogTags.CAR_SERVICE_CONNECTED, mVehicleInterfaceName);</span><br><span class="line"></span><br><span class="line">    mICarImpl = <span class="keyword">new</span> ICarImpl(<span class="keyword">this</span>,</span><br><span class="line">            mVehicle,</span><br><span class="line">            SystemInterface.Builder.defaultSystemInterface(<span class="keyword">this</span>).build(),</span><br><span class="line">            mCanBusErrorNotifier,</span><br><span class="line">            mVehicleInterfaceName);</span><br><span class="line">    mICarImpl.init();</span><br><span class="line">    <span class="comment">// 处理 HIDL 连接</span></span><br><span class="line">linkToDeath(mVehicle, mVehicleDeathRecipient);</span><br><span class="line"></span><br><span class="line">    ServiceManager.addService(<span class="string">&quot;car_service&quot;</span>, mICarImpl);</span><br><span class="line">    SystemProperties.set(<span class="string">&quot;boot.car_service_created&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IVehicle <span class="title">getVehicle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String instanceName = SystemProperties.get(<span class="string">&quot;ro.vehicle.hal&quot;</span>, <span class="string">&quot;default&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> android.hardware.automotive.vehicle.V2_0.IVehicle.getService(instanceName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(CarLog.TAG_SERVICE, <span class="string">&quot;Failed to get IVehicle/&quot;</span> + instanceName + <span class="string">&quot; service&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">        Log.e(CarLog.TAG_SERVICE, <span class="string">&quot;IVehicle/&quot;</span> + instanceName + <span class="string">&quot; service not registered yet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们再来看<code>ICarImpl</code>的实现，如下所示：</p>
<p>1）创建各个核心服务对象。</p>
<p>2）把服务对象缓存到CarLocalServices中，这里主要是为了方便Service之间的相互访问。</p>
<blockquote>
<p>ICarImpl的源码位置：<code>/packages/services/Car/service/src/com/android/car/ICar</code></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ICarImpl(Context serviceContext, IVehicle vehicle, SystemInterface systemInterface,</span><br><span class="line">         CanBusErrorNotifier errorNotifier, String vehicleInterfaceName,</span><br><span class="line">         <span class="meta">@Nullable</span> CarUserService carUserService,</span><br><span class="line">         <span class="meta">@Nullable</span> CarWatchdogService carWatchdogService) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建 核心服务对象</span></span><br><span class="line">mCarPowerManagementService = new CarPowerManagementService(mContext, mHal.getPowerHal(),</span><br><span class="line">            systemInterface, mCarUserService);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将重要的服务缓存到 CarLocalServices</span></span><br><span class="line">CarLocalServices.addService(CarPowerManagementService.<span class="keyword">class</span>, mCarPowerManagementService);</span><br><span class="line">    CarLocalServices.addService(CarPropertyService.<span class="keyword">class</span>, mCarPropertyService);</span><br><span class="line">    CarLocalServices.addService(CarUserService.<span class="keyword">class</span>, mCarUserService);</span><br><span class="line">    CarLocalServices.addService(CarTrustedDeviceService.<span class="keyword">class</span>, mCarTrustedDeviceService);</span><br><span class="line">    CarLocalServices.addService(CarUserNoticeService.<span class="keyword">class</span>, mCarUserNoticeService);</span><br><span class="line">    CarLocalServices.addService(SystemInterface.<span class="keyword">class</span>, mSystemInterface);</span><br><span class="line">    CarLocalServices.addService(CarDrivingStateService.<span class="keyword">class</span>, mCarDrivingStateService);</span><br><span class="line">    CarLocalServices.addService(PerUserCarServiceHelper.<span class="keyword">class</span>, mPerUserCarServiceHelper);</span><br><span class="line">    CarLocalServices.addService(FixedActivityService.<span class="keyword">class</span>, mFixedActivityService);</span><br><span class="line">    CarLocalServices.addService(VmsBrokerService.<span class="keyword">class</span>, mVmsBrokerService);</span><br><span class="line">    CarLocalServices.addService(CarOccupantZoneService.<span class="keyword">class</span>, mCarOccupantZoneService);</span><br><span class="line">    CarLocalServices.addService(AppFocusService.<span class="keyword">class</span>, mAppFocusService);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将创建的服务对象依次添加到一个list中保存起来</span></span><br><span class="line">List&lt;CarServiceBase&gt; allServices = new ArrayList&lt;&gt;();</span><br><span class="line">    allServices.add(mFeatureController);</span><br><span class="line">    allServices.add(mCarUserService);</span><br><span class="line">    ...</span><br><span class="line">    allServices.add(mCarWatchdogService);</span><br><span class="line">    <span class="comment">// Always put mCarExperimentalFeatureServiceController in last.</span></span><br><span class="line">addServiceIfNonNull(allServices, mCarExperimentalFeatureServiceController);</span><br><span class="line">    mAllServices = allServices.toArray(new CarServiceBase[allServices.size()]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）将服务对象放置一个list中。这样init方法中就可以以循环的形式直接调用服务对象的init，而不需要一个个调用。VechicleHAL的程序也会在这里完成初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mBootTiming = <span class="keyword">new</span> TimingsTraceLog(VHAL_TIMING_TAG, Trace.TRACE_TAG_HAL);</span><br><span class="line">    traceBegin(<span class="string">&quot;VehicleHal.init&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化 Vechicle HAL</span></span><br><span class="line">    mHal.init();</span><br><span class="line">    </span><br><span class="line">    traceEnd();</span><br><span class="line">    traceBegin(<span class="string">&quot;CarService.initAllServices&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化所有服务</span></span><br><span class="line">    <span class="keyword">for</span> (CarServiceBase service : mAllServices) &#123;</span><br><span class="line">        service.init();</span><br><span class="line">    &#125;</span><br><span class="line">    traceEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）最后实现<code>ICar.aidl</code>中定义的各个接口就可以了，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">getCarService</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFeatureController.isFeatureEnabled(serviceName)) &#123;</span><br><span class="line">        Log.w(CarLog.TAG_SERVICE, <span class="string">&quot;getCarService for disabled service:&quot;</span> + serviceName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (serviceName) &#123;</span><br><span class="line">        <span class="keyword">case</span> Car.AUDIO_SERVICE:</span><br><span class="line">            <span class="keyword">return</span> mCarAudioService;</span><br><span class="line">        <span class="keyword">case</span> Car.APP_FOCUS_SERVICE:</span><br><span class="line">            <span class="keyword">return</span> mAppFocusService;</span><br><span class="line">        <span class="keyword">case</span> Car.PACKAGE_SERVICE:</span><br><span class="line">            <span class="keyword">return</span> mCarPackageManagerService;</span><br><span class="line">       ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            IBinder service = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (mCarExperimentalFeatureServiceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">                service = mCarExperimentalFeatureServiceController.getCarService(serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Log.w(CarLog.TAG_SERVICE, <span class="string">&quot;getCarService for unknown service:&quot;</span></span><br><span class="line">                        + serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下<code>CarService</code>的启动时序如下所示：</p>
<p><img src="/images/android_aosp_car_service06.png" alt="img"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇讲解了<code>CarService</code>的总体结构，以及Car API 的实现原理，<code>CarService</code>中实现的功能非常庞大，就像文章中反复在强调的那样，在<code>CarService</code>实现的功能几乎就是覆盖整个车载Framework的核心。</p>
<p>然而现实中为了保证各个核心服务的稳定性，同时降低<code>CarService</code>协同开发的难度，一般会选择将一些重要的服务拆分单独作为一个独立的Service运行在独立的进程中，导致有的车机系统中<code>CarService</code>只实现了<code>CarPropertyService</code>的功能。</p>
]]></content>
      <categories>
        <category>Android系统开发</category>
        <category>车联网</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++各种排序实现-你懂得</title>
    <url>/2018/01/18/algorithm_sort/</url>
    <content><![CDATA[<p>排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。我们常说的排序就是内部排序。</p>
<span id="more"></span>

<p>较为常见的八大排序分别为：</p>
<p><em><strong>直接插入排序</strong></em>、<em><strong>希尔排序</strong></em>、<em><strong>简单选择排序</strong></em>、<em><strong>堆排序</strong></em>、<em><strong>冒泡排序</strong></em>、<em><strong>快速排序</strong></em>、<em><strong>归并排序</strong></em>、<em><strong>基数排序</strong></em></p>
<p>本篇讲一下八大排序算法的思想、实现、稳定性、时间复杂度。</p>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p><strong>基本思想:</strong></p>
<p>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p>
<p>要点：设立哨兵，作为临时存储和判断数组边界之用。</p>
<p>直接插入排序示例：</p>
<p><img src="/images/algorithm_sort_direct_insert.jpg" alt="sort_direct_insert_sort"></p>
<p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<p>实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n ,<span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line">  cout&lt;&lt;i &lt;&lt;<span class="string">&quot;:&quot;</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123; </span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  cout&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;n; i++)&#123; </span><br><span class="line">    <span class="keyword">if</span>(a[i] &lt; a[i<span class="number">-1</span>])&#123;        <span class="comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 </span></span><br><span class="line">      <span class="keyword">int</span> j= i<span class="number">-1</span>;  </span><br><span class="line">      <span class="keyword">int</span> x = a[i];    <span class="comment">//复制为哨兵，即存储待排序元素 </span></span><br><span class="line">      a[i] = a[i<span class="number">-1</span>];      <span class="comment">//先后移一个元素 </span></span><br><span class="line">      <span class="keyword">while</span>(x &lt; a[j])&#123; <span class="comment">//查找在有序表的插入位置 </span></span><br><span class="line">        a[j+<span class="number">1</span>] = a[j]; </span><br><span class="line">        j--;     <span class="comment">//元素后移 </span></span><br><span class="line">      &#125; </span><br><span class="line">      a[j+<span class="number">1</span>] = x;   <span class="comment">//插入到正确位置 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">print</span>(a,n,i);      <span class="comment">//打印每趟排序的结果 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>&#125;; </span><br><span class="line">  <span class="built_in">InsertSort</span>(a,<span class="number">8</span>); </span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">8</span>,<span class="number">8</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效率：</p>
<p>时间复杂度：O（n^2）.</p>
<p>其他的插入排序有二分插入排序，2-路插入排序。</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序是1959 年由D.L.Shell 提出来的，相对直接排序有较大的改进。希尔排序又叫缩小增量排序</p>
<p><strong>基本思想：</strong></p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p><strong>操作方法：</strong></p>
<p>1.选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>2.按增量序列个数k，对序列进行k 趟排序；<br>3.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<p>希尔排序的示例：</p>
<p><img src="/images/algorithm_sort_xier.jpg" alt="sort_xier"></p>
<p>算法实现：</p>
<p>我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 …..1} n为要排序数的个数</p>
<p>即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n ,<span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line">  cout&lt;&lt;i &lt;&lt;<span class="string">&quot;:&quot;</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123; </span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  cout&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 直接插入排序的一般形式 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param int dk 缩小增量，如果是直接插入排序，dk=1 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> dk)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i= dk; i&lt;n; ++i)&#123; </span><br><span class="line">    <span class="keyword">if</span>(a[i] &lt; a[i-dk])&#123;     <span class="comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 </span></span><br><span class="line">      <span class="keyword">int</span> j = i-dk;   </span><br><span class="line">      <span class="keyword">int</span> x = a[i];      <span class="comment">//复制为哨兵，即存储待排序元素 </span></span><br><span class="line">      a[i] = a[i-dk];     <span class="comment">//首先后移一个元素 </span></span><br><span class="line">      <span class="keyword">while</span>(x &lt; a[j])&#123;   <span class="comment">//查找在有序表的插入位置 </span></span><br><span class="line">        a[j+dk] = a[j]; </span><br><span class="line">        j -= dk;       <span class="comment">//元素后移 </span></span><br><span class="line">      &#125; </span><br><span class="line">      a[j+dk] = x;      <span class="comment">//插入到正确位置 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">print</span>(a, n,i ); </span><br><span class="line">  &#125; </span><br><span class="line">    </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 先按增量d（n/2,n为要排序数的个数进行希尔排序 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> dk = n/<span class="number">2</span>; </span><br><span class="line">  <span class="keyword">while</span>( dk &gt;= <span class="number">1</span> )&#123; </span><br><span class="line">    <span class="built_in">ShellInsertSort</span>(a, n, dk); </span><br><span class="line">    dk = dk/<span class="number">2</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>&#125;; </span><br><span class="line">  <span class="comment">//ShellInsertSort(a,8,1); //直接插入排序 </span></span><br><span class="line">  <span class="built_in">shellSort</span>(a,<span class="number">8</span>);      <span class="comment">//希尔插入排序 </span></span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">8</span>,<span class="number">8</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。</p>
<h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><p>基本思想：</p>
<p>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>
<p>简单选择排序的示例：</p>
<p><img src="/images/algorithm_sort_simple_select.jpg" alt="sort_simple_select"></p>
<p><strong>操作方法：</strong></p>
<p>第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；</p>
<p>第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；</p>
<p>以此类推…..</p>
<p>第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，</p>
<p>直到整个序列按关键码有序。</p>
<p>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n ,<span class="keyword">int</span> i)</span></span>&#123; </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;i+<span class="number">1</span> &lt;&lt;<span class="string">&quot;趟 : &quot;</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123; </span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  cout&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 数组的最小值 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return int 数组的键值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectMinKey</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> k = i; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span> ;j&lt; n; ++j) &#123; </span><br><span class="line">    <span class="keyword">if</span>(a[k] &gt; a[j]) k = j; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> k; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 选择排序 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> key, tmp; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; ++i) &#123; </span><br><span class="line">    key = <span class="built_in">SelectMinKey</span>(a, n,i);      <span class="comment">//选择最小的元素 </span></span><br><span class="line">    <span class="keyword">if</span>(key != i)&#123; </span><br><span class="line">      tmp = a[i]; a[i] = a[key]; a[key] = tmp; <span class="comment">//最小元素与第i位置元素互换 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">print</span>(a, n , i); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>&#125;; </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;初始值：&quot;</span>; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123; </span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  cout&lt;&lt;endl&lt;&lt;endl; </span><br><span class="line">  <span class="built_in">selectSort</span>(a, <span class="number">8</span>); </span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">8</span>,<span class="number">8</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单选择排序的改进–二元选择排序"><a href="#简单选择排序的改进–二元选择排序" class="headerlink" title="简单选择排序的改进–二元选择排序"></a>简单选择排序的改进–二元选择排序</h2><p>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> r[],<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i ,j , min ,max, tmp; </span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span> ;i &lt;= n/<span class="number">2</span>;i++) &#123;  </span><br><span class="line">    <span class="comment">// 做不超过n/2趟选择排序  </span></span><br><span class="line">    min = i; max = i ; <span class="comment">//分别记录最大和最小关键字记录位置 </span></span><br><span class="line">    <span class="keyword">for</span> (j= i+<span class="number">1</span>; j&lt;= n-i; j++) &#123; </span><br><span class="line">      <span class="keyword">if</span> (r[j] &gt; r[max]) &#123;  </span><br><span class="line">        max = j ; <span class="keyword">continue</span> ;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">if</span> (r[j]&lt; r[min]) &#123;  </span><br><span class="line">        min = j ;  </span><br><span class="line">      &#125;   </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//该交换操作还可分情况讨论以提高效率 </span></span><br><span class="line">   tmp = r[i<span class="number">-1</span>]; r[i<span class="number">-1</span>] = r[min]; r[min] = tmp; </span><br><span class="line">   tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp;  </span><br><span class="line">  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p>
<p><strong>基本思想：</strong></p>
<p>堆的定义如下：具有n个元素的序列（k1,k2,…,kn),当且仅当满足</p>
<p><img src="/images/algorithm_sort_heap.jpg" alt="sort_heap"></p>
<p>时称之为堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。<br> 若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：</p>
<p>（a）大顶堆序列：（96, 83,27,38,11,09)</p>
<p> (b) 小顶堆序列：（12，36，24，85，47，30，53，91）</p>
<p><img src="/images/algorithm_sort_heap_desc01.jpg" alt="sort_heap_desc01"></p>
<p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p>
<p>因此，实现堆排序需解决两个问题：</p>
<p>\1. 如何将n 个待排序的数建成堆；</p>
<p>\2. 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。</p>
<p>首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。</p>
<p> 调整小顶堆的方法：</p>
<p>1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</p>
<p>2）将根结点与左、右子树中较小元素的进行交换。</p>
<p>3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.</p>
<p>4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.</p>
<p>5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</p>
<p>称这个自根结点到叶子结点的调整过程为筛选。如图：</p>
<p><img src="/images/algorithm_sort_heap_desc02.jpg" alt="sort_heap_desc02"></p>
<p>再讨论对n 个元素初始建堆的过程。</p>
<p>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</p>
<p>1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。</p>
<p>2）筛选从第个结点为根的子树开始，该子树成为堆。</p>
<p>3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</p>
<p>如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）</p>
<p><img src="/images/algorithm_sort_heap_desc03.jpg" alt="sort_heap_desc03"></p>
<p>(a)无序序列; (b)97被筛选之后的状态; (c)65被筛选之后的状态; (d)38被筛选之后的状态; (e)49被筛选之后建成的堆</p>
<p>算法的实现：</p>
<p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123; </span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  cout&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 已知H[s…m]除了H[s] 外均满足堆的定义 </span></span><br><span class="line"><span class="comment"> * 调整H[s],使其成为大顶堆即将对第s个结点为根的子树筛选, </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param H是待调整的堆数组 </span></span><br><span class="line"><span class="comment"> * @param s是待调整的数组元素的位置 </span></span><br><span class="line"><span class="comment"> * @param length是数组的长度 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> H[],<span class="keyword">int</span> s, <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> tmp = H[s]; </span><br><span class="line">  <span class="keyword">int</span> child = <span class="number">2</span>*s+<span class="number">1</span>; <span class="comment">//左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置) </span></span><br><span class="line">  <span class="keyword">while</span> (child &lt; length) &#123; </span><br><span class="line">    <span class="keyword">if</span>(child+<span class="number">1</span> &lt;length &amp;&amp; H[child]&lt;H[child+<span class="number">1</span>]) &#123; <span class="comment">// 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点) </span></span><br><span class="line">      ++child ; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(H[s]&lt;H[child]) &#123; <span class="comment">// 如果较大的子结点大于父结点 </span></span><br><span class="line">      H[s] = H[child]; <span class="comment">// 那么把较大的子结点往上移动，替换它的父结点 </span></span><br><span class="line">      s = child;    <span class="comment">// 重新设置s ,即待调整的下一个结点的位置 </span></span><br><span class="line">      child = <span class="number">2</span>*s+<span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;      <span class="comment">// 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出 </span></span><br><span class="line">       <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    H[s] = tmp;     <span class="comment">// 当前待调整的结点放到比其大的孩子结点位置上 </span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">print</span>(H,length); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 初始堆进行调整 </span></span><br><span class="line"><span class="comment"> * 将H[length-1]建成堆 </span></span><br><span class="line"><span class="comment"> * 调整完之后第一个元素是序列的最小的元素 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildingHeap</span><span class="params">(<span class="keyword">int</span> H[], <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="comment">//最后一个有孩子的节点的位置 i= (length -1) / 2 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = (length <span class="number">-1</span>) / <span class="number">2</span> ; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line">    <span class="built_in">HeapAdjust</span>(H,i,length); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 堆排序算法 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> H[],<span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="comment">//初始堆 </span></span><br><span class="line">  <span class="built_in">BuildingHeap</span>(H, length); </span><br><span class="line">  <span class="comment">//从最后一个元素开始对序列进行调整 </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="comment">//交换堆顶元素H[0]和堆中最后一个元素 </span></span><br><span class="line">    <span class="keyword">int</span> temp = H[i]; H[i] = H[<span class="number">0</span>]; H[<span class="number">0</span>] = temp; </span><br><span class="line">    <span class="comment">//每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整 </span></span><br><span class="line">    <span class="built_in">HeapAdjust</span>(H,<span class="number">0</span>,i); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> H[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;; </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;初始值：&quot;</span>; </span><br><span class="line">  <span class="built_in">print</span>(H,<span class="number">10</span>); </span><br><span class="line">  <span class="built_in">HeapSort</span>(H,<span class="number">10</span>); </span><br><span class="line">  <span class="comment">//selectSort(a, 8); </span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;结果：&quot;</span>; </span><br><span class="line">  <span class="built_in">print</span>(H,<span class="number">10</span>); </span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>分析:</p>
<p>设树深度为k，。从根到叶的筛选，元素比较次数至多2(k-1)次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式：</p>
<p><img src="/images/algorithm_sort_heap_result.jpg" alt="sort_heap_result"></p>
<p>而建堆时的比较次数不超过4n 次，因此堆排序最坏情况下，时间复杂度也为：O(nlogn )。</p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>基本思想：</p>
<p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>
<p>冒泡排序的示例：</p>
<p><img src="/images/algorithm_sort_bubble.jpg" alt="sort_bubble"></p>
<p>算法的实现： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt; n<span class="number">-1</span>; ++i) &#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; ++j) &#123; </span><br><span class="line">      <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) </span><br><span class="line">      &#123; </span><br><span class="line">        <span class="keyword">int</span> tmp = a[j] ; a[j] = a[j+<span class="number">1</span>] ; a[j+<span class="number">1</span>] = tmp; </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>冒泡排序算法的改进</strong></p>
<p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：</p>
<p>1．设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。</p>
<p>改进后算法如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_1</span> <span class="params">( <span class="keyword">int</span> r[], <span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i= n <span class="number">-1</span>; <span class="comment">//初始时,最后位置保持不变 </span></span><br><span class="line">  <span class="keyword">while</span> ( i&gt; <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">int</span> pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; i; j++) </span><br><span class="line">      <span class="keyword">if</span> (r[j]&gt; r[j+<span class="number">1</span>]) &#123; </span><br><span class="line">        pos= j; <span class="comment">//记录交换的位置  </span></span><br><span class="line">        <span class="keyword">int</span> tmp = r[j]; r[j]=r[j+<span class="number">1</span>];r[j+<span class="number">1</span>]=tmp; </span><br><span class="line">      &#125;  </span><br><span class="line">    i= pos; <span class="comment">//为下一趟排序作准备 </span></span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>2．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p>
<p>改进后的算法实现为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_2</span> <span class="params">( <span class="keyword">int</span> r[], <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;  </span><br><span class="line">  <span class="keyword">int</span> high= n <span class="number">-1</span>; <span class="comment">//设置变量的初始值 </span></span><br><span class="line">  <span class="keyword">int</span> tmp,j; </span><br><span class="line">  <span class="keyword">while</span> (low &lt; high) &#123; </span><br><span class="line">    <span class="keyword">for</span> (j= low; j&lt; high; ++j) <span class="comment">//正向冒泡,找到最大者 </span></span><br><span class="line">      <span class="keyword">if</span> (r[j]&gt; r[j+<span class="number">1</span>]) &#123; </span><br><span class="line">        tmp = r[j]; r[j]=r[j+<span class="number">1</span>];r[j+<span class="number">1</span>]=tmp; </span><br><span class="line">      &#125;  </span><br><span class="line">    --high;         <span class="comment">//修改high值, 前移一位 </span></span><br><span class="line">    <span class="keyword">for</span> ( j=high; j&gt;low; --j) <span class="comment">//反向冒泡,找到最小者 </span></span><br><span class="line">      <span class="keyword">if</span> (r[j]&lt;r[j<span class="number">-1</span>]) &#123; </span><br><span class="line">        tmp = r[j]; r[j]=r[j<span class="number">-1</span>];r[j<span class="number">-1</span>]=tmp; </span><br><span class="line">      &#125; </span><br><span class="line">    ++low;         <span class="comment">//修改low值,后移一位 </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>基本思想：</p>
<p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p>
<p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p>
<p>3）此时基准元素在其排好序后的正确位置</p>
<p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p>
<p>快速排序的示例：</p>
<p>（a）一趟排序的过程：</p>
<p><img src="/images/algorithm_sort_quick_01.jpg" alt="sort_quick_01"></p>
<p>（b）排序的全过程</p>
<p><img src="/images/algorithm_sort_quick_02.jpg" alt="sort_quick_02"></p>
<p>算法的实现：</p>
<p> 递归实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123; </span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  cout&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> tmp = *a; </span><br><span class="line">  *a = *b; </span><br><span class="line">  *b = tmp; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> privotKey = a[low];               <span class="comment">//基准元素 </span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high)&#123;                  <span class="comment">//从表的两端交替地向中间扫描 </span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt;= privotKey) --high; <span class="comment">//从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端 </span></span><br><span class="line">    <span class="built_in">swap</span>(&amp;a[low], &amp;a[high]); </span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= privotKey ) ++low; </span><br><span class="line">    <span class="built_in">swap</span>(&amp;a[low], &amp;a[high]); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">10</span>); </span><br><span class="line">  <span class="keyword">return</span> low; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(low &lt; high)&#123; </span><br><span class="line">    <span class="keyword">int</span> privotLoc = <span class="built_in">partition</span>(a, low, high); <span class="comment">//将表一分为二 </span></span><br><span class="line">    <span class="built_in">quickSort</span>(a, low, privotLoc <span class="number">-1</span>);     <span class="comment">//递归对低子表递归排序 </span></span><br><span class="line">    <span class="built_in">quickSort</span>(a,  privotLoc + <span class="number">1</span>, high);    <span class="comment">//递归对高子表递归排序 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;; </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;初始值：&quot;</span>; </span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">10</span>); </span><br><span class="line">  <span class="built_in">quickSort</span>(a,<span class="number">0</span>,<span class="number">9</span>); </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;结果：&quot;</span>; </span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">10</span>); </span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<p> <strong>快速排序的改进</strong></p>
<p>在本改进算法中,只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当k取值为 8 左右时,改进算法的性能最佳。算法思想如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123; </span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  cout&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> tmp = *a; </span><br><span class="line">  *a = *b; </span><br><span class="line">  *b = tmp; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> privotKey = a[low];         <span class="comment">//基准元素 </span></span><br><span class="line">  <span class="keyword">while</span>(low &lt; high)&#123;          <span class="comment">//从表的两端交替地向中间扫描 </span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt;= privotKey) --high; <span class="comment">//从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端 </span></span><br><span class="line">    <span class="built_in">swap</span>(&amp;a[low], &amp;a[high]); </span><br><span class="line">    <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= privotKey ) ++low; </span><br><span class="line">    <span class="built_in">swap</span>(&amp;a[low], &amp;a[high]); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">10</span>); </span><br><span class="line">  <span class="keyword">return</span> low; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort_improve</span><span class="params">(<span class="keyword">int</span> r[ ],<span class="keyword">int</span> low,<span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span>&#123; </span><br><span class="line">  <span class="keyword">if</span>( high -low &gt; k ) &#123; <span class="comment">//长度大于k时递归, k为指定的数 </span></span><br><span class="line">    <span class="keyword">int</span> pivot = <span class="built_in">partition</span>(r, low, high); <span class="comment">// 调用的Partition算法保持不变 </span></span><br><span class="line">    <span class="built_in">qsort_improve</span>(r, low, pivot - <span class="number">1</span>,k); </span><br><span class="line">    <span class="built_in">qsort_improve</span>(r, pivot + <span class="number">1</span>, high,k); </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> r[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123; </span><br><span class="line">  <span class="built_in">qsort_improve</span>(r,<span class="number">0</span>,n,k);<span class="comment">//先调用改进算法Qsort使之基本有序 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//再用插入排序对基本有序序列排序 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n;i ++)&#123; </span><br><span class="line">    <span class="keyword">int</span> tmp = r[i];  </span><br><span class="line">    <span class="keyword">int</span> j=i<span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">while</span>(tmp &lt; r[j])&#123; </span><br><span class="line">      r[j+<span class="number">1</span>]=r[j]; j=j<span class="number">-1</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    r[j+<span class="number">1</span>] = tmp; </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;; </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;初始值：&quot;</span>; </span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">10</span>); </span><br><span class="line">  <span class="built_in">quickSort</span>(a,<span class="number">9</span>,<span class="number">4</span>); </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;结果：&quot;</span>; </span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">10</span>); </span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>基本思想：</p>
<p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p>归并排序示例：</p>
<p><img src="/images/algorithm_sort_merge.jpg" alt="sort_merge"></p>
<p><strong>合并方法：</strong></p>
<p>设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为n-i +1、n-m。</p>
<p>1.j=m+1；k=i；i=i; //置两个子表的起始下标及辅助数组的起始下标</p>
<p>2.若i&gt;m 或j&gt;n，转⑷ //其中一个子表已合并完，比较选取结束</p>
<p>3.//选取r[i]和r[j]较小的存入辅助数组rf</p>
<p>如果r[i]&lt;r[j]，rf[k]=r[i]； i++； k++； 转⑵</p>
<p>否则，rf[k]=r[j]； j++； k++； 转⑵</p>
<p>4.//将尚未处理完的子表中元素存入rf</p>
<p>如果i&lt;=m，将r[i…m]存入rf[k…n] //前一子表非空</p>
<p>如果j&lt;=n , 将r[j…n] 存入rf[k…n] //后一子表非空</p>
<p>5.合并结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n] </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType *r,ElemType *rf, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> j,k; </span><br><span class="line">  <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k)&#123; </span><br><span class="line">    <span class="keyword">if</span>(r[j] &lt; r[i]) rf[k] = r[j++]; </span><br><span class="line">    <span class="keyword">else</span> rf[k] = r[i++]; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">while</span>(i &lt;= m) rf[k++] = r[i++]; </span><br><span class="line">  <span class="keyword">while</span>(j &lt;= n) rf[k++] = r[j++]; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>归并的迭代算法</strong></p>
<p>1 个元素的表总是有序的。所以对n 个元素的待排序列，每个元素可看成1 个有序子表。对子表两两合并生成n/2个子表，所得子表除最后一个子表长度可能为1 外，其余子表长度均为2。再进行两两合并，直到生成n 个元素按关键码有序的表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123; </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123; </span><br><span class="line">    cout&lt;&lt;a[j] &lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  cout&lt;&lt;endl; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="comment">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n] </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType *r,ElemType *rf, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> j,k; </span><br><span class="line">  <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k)&#123; </span><br><span class="line">    <span class="keyword">if</span>(r[j] &lt; r[i]) rf[k] = r[j++]; </span><br><span class="line">    <span class="keyword">else</span> rf[k] = r[i++]; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">while</span>(i &lt;= m) rf[k++] = r[i++]; </span><br><span class="line">  <span class="keyword">while</span>(j &lt;= n) rf[k++] = r[j++]; </span><br><span class="line">  <span class="built_in">print</span>(rf,n+<span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType *r, ElemType *rf, <span class="keyword">int</span> lenght)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">1</span>; </span><br><span class="line">  ElemType *q = r ; </span><br><span class="line">  ElemType *tmp ; </span><br><span class="line">  <span class="keyword">while</span>(len &lt; lenght) &#123; </span><br><span class="line">    <span class="keyword">int</span> s = len; </span><br><span class="line">    len = <span class="number">2</span> * s ; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(i+ len &lt;lenght)&#123; </span><br><span class="line">      <span class="built_in">Merge</span>(q, rf, i, i+ s<span class="number">-1</span>, i+ len<span class="number">-1</span> ); <span class="comment">//对等长的两个子表合并 </span></span><br><span class="line">      i = i+ len; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(i + s &lt; lenght)&#123; </span><br><span class="line">      <span class="built_in">Merge</span>(q, rf, i, i+ s <span class="number">-1</span>, lenght <span class="number">-1</span>); <span class="comment">//对不等长的两个子表合并 </span></span><br><span class="line">    &#125; </span><br><span class="line">    tmp = q; q = rf; rf = tmp; <span class="comment">//交换q,rf，以保证下一趟归并时，仍从q 归并到rf </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;; </span><br><span class="line">  <span class="keyword">int</span> b[<span class="number">10</span>]; </span><br><span class="line">  <span class="built_in">MergeSort</span>(a, b, <span class="number">10</span>); </span><br><span class="line">  <span class="built_in">print</span>(b,<span class="number">10</span>); </span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;结果：&quot;</span>; </span><br><span class="line">  <span class="built_in">print</span>(a,<span class="number">10</span>); </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两路归并的递归算法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(ElemType *r, ElemType *rf,<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  ElemType *rf2; </span><br><span class="line">  <span class="keyword">if</span>(s==t) r[s] = rf[s]; </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;  </span><br><span class="line">    <span class="keyword">int</span> m=(s+t)/<span class="number">2</span>;     <span class="comment">/*平分*p 表*/</span></span><br><span class="line">    <span class="built_in">MSort</span>(r, rf2, s, m);    <span class="comment">/*递归地将p[s…m]归并为有序的p2[s…m]*/</span></span><br><span class="line">    <span class="built_in">MSort</span>(r, rf2, m+<span class="number">1</span>, t);   <span class="comment">/*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/</span></span><br><span class="line">    <span class="built_in">Merge</span>(rf2, rf, s, m+<span class="number">1</span>,t);  <span class="comment">/*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort_recursive</span><span class="params">(ElemType *r, ElemType *rf, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">/*对顺序表*p 作归并排序*/</span></span><br><span class="line">  <span class="built_in">MSort</span>(r, rf,<span class="number">0</span>, n<span class="number">-1</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>说基数排序之前，我们先说桶排序：</p>
<p>基本思想：是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p>
<p>简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。 </p>
<p> 例如要对大小为[1..1000]范围内的n个整数A[1..n]排序 </p>
<p> 首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储  (10..20]的整数，……集合B[i]存储(  (i-1)<em>10,  i</em>10]的整数，i  =  1,2,..100。总共有 100个桶。 </p>
<p> 然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。 再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任 何排序法都可以。</p>
<p> 最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这 样就得到所有数字排好序的一个序列了。 </p>
<p> 假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果 </p>
<p> 对每个桶中的数字采用快速排序，那么整个算法的复杂度是 </p>
<p> O(n  +  m  *  n/m*log(n/m))  =  O(n  +  nlogn  -  nlogm) </p>
<p> 从上式看出，当m接近n的时候，桶排序复杂度接近O(n) </p>
<p> 当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的 ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。 </p>
<p> 前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：</p>
<p> 1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</p>
<p>2）其次待排序的元素都要在一定的范围内等等。</p>
<p>桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。</p>
<p> <strong>分配排序的基本思想：说白了就是进行多次的桶式排序</strong>。</p>
<p>基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)。</p>
<p>实例:</p>
<p>扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：</p>
<p>花色： 梅花&lt; 方块&lt; 红心&lt; 黑心 </p>
<p>面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A</p>
<p>若对扑克牌按花色、面值进行升序排序，得到如下序列：</p>
<p><img src="/images/algorithm_sort_radix_01.jpg" alt="sort_radix_01"></p>
<p><img src="/images/algorithm_sort_radix_02.jpg" alt="sort_radix_02"></p>
<p>即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。</p>
<p>为得到排序结果，我们讨论两种排序方法。</p>
<p>方法1：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。</p>
<p>方法2：先按13 个面值给出13 个编号组(2 号，3 号，…，A 号)，将牌按面值依次放入对应的编号组，分成13 堆。再按花色给出4 个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样，4 个花色组中均按面值有序，然后，将4 个花色组依次连接起来即可。</p>
<p>设n 个元素的待排序列包含d 个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：对于序列中任两个记录r[i]和r<a href="1%E2%89%A4i%E2%89%A4j%E2%89%A4n">j</a>都满足下列有序关系：<br><img src="http://my.csdn.net/uploads/201207/21/1342829730_4247.jpg" alt="img"></p>
<p>其中k1 称为最主位关键码，kd 称为最次位关键码 。</p>
<p> 两种多关键码排序方法：</p>
<p>多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法：</p>
<p><strong>最高位优先(Most Significant Digit first)法，简称MSD 法：</strong></p>
<p>1）先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。</p>
<p>2）再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。</p>
<p>3）再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。</p>
<p><strong>最低位优先(Least Significant Digit first)法，简称LSD 法：</strong></p>
<p>\1) 先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。</p>
<p>\2) 最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。</p>
<p> <strong>基于LSD方法的链式基数排序的基本思想</strong></p>
<p>“多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。 </p>
<p><strong>基数排序:</strong></p>
<p>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<p>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Void <span class="title">RadixSort</span><span class="params">(Node L[],length,maxradix)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> m,n,k,lsp; </span><br><span class="line">  k=<span class="number">1</span>;m=<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">int</span> temp[<span class="number">10</span>][length<span class="number">-1</span>]; </span><br><span class="line">  <span class="built_in">Empty</span>(temp); <span class="comment">//清空临时空间 </span></span><br><span class="line">  <span class="keyword">while</span>(k&lt;maxradix) <span class="comment">//遍历所有关键字 </span></span><br><span class="line">  &#123; </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="comment">//分配过程 </span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">if</span>(L[i]&lt;m) </span><br><span class="line">     Temp[<span class="number">0</span>][n]=L[i]; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">     Lsp=(L[i]/m)%<span class="number">10</span>; <span class="comment">//确定关键字 </span></span><br><span class="line">    Temp[lsp][n]=L[i]; </span><br><span class="line">    n++; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">CollectElement</span>(L,Temp); <span class="comment">//收集 </span></span><br><span class="line">  n=<span class="number">0</span>; </span><br><span class="line">  m=m*<span class="number">10</span>; </span><br><span class="line"> k++; </span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各种排序的稳定性，时间复杂度和空间复杂度总结：</p>
<p><img src="/images/algorithm_sort_summary_01.jpg" alt="sort_summary_01"></p>
<p>我们比较时间复杂度函数的情况</p>
<p><img src="/images/algorithm_sort_summary_02.jpg" alt="sort_summary_02"></p>
<p>我们比较时间复杂度函数的情况</p>
<p><img src="/images/algorithm_sort_summary_03.jpg" alt="sort_summary_03"></p>
<p>所以对n较大的排序记录。一般的选择都是时间复杂度为O(nlog2n)的排序方法。</p>
<p> <strong>时间复杂度来说：</strong></p>
<p>(1)平方阶(O(n2))排序</p>
<p>各类简单排序:直接插入、直接选择和冒泡排序；</p>
<p>(2)线性对数阶(O(nlog2n))排序</p>
<p>快速排序、堆排序和归并排序；</p>
<p> (3)O(n1+§))排序,§是介于0和1之间的常数。</p>
<p>希尔排序</p>
<p>(4)线性阶(O(n))排序</p>
<p>基数排序，此外还有桶、箱排序。</p>
<p>说明：</p>
<p> 当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</p>
<p>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</p>
<p>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</p>
<p><strong>稳定性：</strong></p>
<p>排序算法的稳定性:若待排序的序列中，存在多个具有相同关键字的记录，经过排序， 这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对 次序发生了改变，则称该算法是不稳定的。 </p>
<p>稳定性的好处：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；</p>
<p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</p>
<p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</p>
<p> <strong>选择排序算法准则：</strong></p>
<p>每种排序算法都各有优缺点。因此，在实用时需根据不同情况适当选用，甚至可以将多种方法结合起来使用。</p>
<p>选择排序算法的依据</p>
<p>影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：</p>
<p>1．待排序的记录数目n的大小；</p>
<p>2．记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</p>
<p>3．关键字的结构及其分布情况；</p>
<p>4．对排序稳定性的要求。</p>
<p><strong>设待排序元素的个数为n.</strong></p>
<p>1）当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。</p>
<p>  快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；<br>    堆排序 ： 如果内存空间允许且要求稳定性的，</p>
<p>​    归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</p>
<p>2） 当n较大，内存空间允许，且要求稳定性 =》归并排序</p>
<p>3）当n较小，可采用直接插入或直接选择排序。</p>
<p>  直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。</p>
<p>  直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序</p>
<p>5）一般不使用或不直接使用传统的冒泡排序。</p>
<p>6）基数排序</p>
<p>它是一种稳定的排序算法，但有一定的局限性：</p>
<p>1、关键字可分解。</p>
<p>2、记录的关键字位数较少，如果密集更好</p>
<p>3、如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Android系统开机过程解析</title>
    <url>/2021/03/28/android_aosp_power_up/</url>
    <content><![CDATA[<p>对于任何系统的学习来讲，开机过程的了解都是个比较重要的知识点。开机时间的优化都是一个很关键的工作。如果用户每次启动设备都需要等待很长的时间，那么其用户体验是很差的。所以，对于任何开机过程的修改以及优化的前提都是要对开机过程有个较为详细的了解。</p>
<span id="more"></span>

<h1 id="Android开机过程"><a href="#Android开机过程" class="headerlink" title="Android开机过程"></a>Android开机过程</h1><p>开机过程从CPU上电开始，到锁屏界面显示出来结束。下图为比较简洁的开机流程图。</p>
<p><img src="/images/android_aosp_power_up01.png" alt="img"></p>
<p>再来看一张比较详细的开机流程图</p>
<p><img src="/images/android_aosp_power_up02.png" alt="img"></p>
<p>总的来说，开机过程分为以下六主要子过程</p>
<h2 id="Boot-ROM"><a href="#Boot-ROM" class="headerlink" title="Boot ROM"></a>Boot ROM</h2><p>Boot ROM是硬编码在CPU内部固定地址的一段ROM(在一些较老的系统上也可能使用外挂Boot ROM（相对CPU来说）)，这块代码是由CPU制造商提供。当用户按下电源键或者系统重启之后，触发CPU上电动作，此时其它硬件还未初始化，然而这块ROM就已经可读了。CPU首先执行PBL(Primary Boot Loader，主引导加载程序，固化在ROM上)代码。在必要的硬件初始化之后，Boot ROM开始加载Bootloader到RAM中，然后PC指针跳过去执行bootloader。在加载 Bootloader之前，PBL也可以进行验证。如果验证无法通过，则不会加载运行Bootloader，从而开机失败。</p>
<p><img src="/images/android_aosp_power_up03.png" alt="img"></p>
<blockquote>
<ul>
<li><p><strong>A.</strong> CPU刚上电时，CPU 处于未初始化状态，还没有设定内部时钟，此时只有内部 RAM 可用。当电源稳定后会开始执行 Boot ROM 代码。Boot ROM通过系统寄存器映射到 ASIC (Application Specific Integrated Circuit, 即专用集成电路，是指应特定用户要求和特定电子系统的需要而设计、制造的集成电路)中的物理区域来找到boot media，进而可以找到Bootloader</p>
</li>
<li><p><strong>B.</strong> boot  media序列确定之后，Boot ROM 加载 Bootloader到内部 RAM 中，之后Boot ROM代码会跳到Bootloader</p>
</li>
</ul>
</blockquote>
<h2 id="Bootloader"><a href="#Bootloader" class="headerlink" title="Bootloader"></a>Bootloader</h2><p>Bootloader是一个特殊的独立于内核的程序，是CPU复位后进入操作系统之前执行的一段代码。Bootloader完成由硬件启动到操作系统启动的过渡，从而为操作系统提供基本的运行环境，如初始化CPU、时钟、堆栈、存储器系统等。Bootloader功能类似于PC机的BIOS程序,其代码与CPU芯片的内核结构、具体型号、应用系统的配置及使用的操作系统等因素有关，因此不可能有通用的bootloader,开发时需要用户根据具体情况进行移植。嵌入式Linux系统中常用的Bootloader有armboot、redboot、blob、U-Boot、Bios-lt、Bootldr等，其中U-Boot是当前比较流行，功能比较强大的Bootloader，可以支持多种体系结构，但相对也比较复杂。硬件初始化完成之后，Bootloader将boot.img(kernel + ramdisk(ramdisk.img中主要是存放android启动后第一个用户进程init可执行文件和init.*.rc等相关启动脚本以及sbin目录下的adbd工具))从flash上copy到RAM里面，然后CPU执行转向kernel。</p>
<p><img src="/images/android_aosp_power_up04.png" alt="img"></p>
<blockquote>
<ul>
<li><p><strong>A.</strong> Bootloader第一阶段首先会检测和设置外部RAM</p>
</li>
<li><p><strong>B.</strong> 外部 RAM可用之后，将Bootloader代码加载到外部RAM中</p>
</li>
<li><p><strong>C.</strong> Bootloader第二阶段包含了设置文件系统，内存，网络等等。</p>
</li>
<li><p><strong>D.</strong> Bootloader查找Linux内核并将其从boot media (或者其他地方，这取决于系统配置) 加载到 RAM 中，并且会配置一些内核启动时需要的启动参数</p>
</li>
<li><p><strong>E.</strong> Bootloader执行完之后会跳转到 Linux 内核执行</p>
</li>
</ul>
</blockquote>
<p>一般也可将Bootloader程序的执行分为两个阶段，如下图所示</p>
<p><img src="/images/android_aosp_power_up05.png" alt="img"></p>
<p>执行Bootloader程序过程中，如果镜像验证失败、BootLinux (&amp;Info) 函数启动失败或者接收到启动至 fastboot 的命令（比如使用 adb reboot bootloader进行重启、在启动时按下了电源键+下音量键组合）时，会进入到Fastboot模式(Fastboot 是一种电脑通过USB数据线对手机固件进行刷写、擦除/格式化、调试、传输各种指令的固件通信协议, 俗称线刷模式或快速引导模式)。</p>
<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>Android kernel基于上游 Linux LTS (Linux Long Term Supported，长期支持) 内核。在 Google，LTS 内核会与 Android 专用补丁结合，形成所谓的“Android 通用内核 (ACK，Android Common Kernel)”。较新的 ACK（版本 5.4 及更高版本）也称为 GKI (Generic Kernel Image，通用内核镜像 )内核。GKI项目通过统一核心内核并将 SoC 和板级支持从核心内核移至可加载模块中，解决了内核碎片化问题。GKI 内核为内核模块提供了稳定的内核模块接口 (KMI)，因此模块和内核可以独立进行更新。GKI 具有以下特点：</p>
<blockquote>
<ul>
<li>基于 ACK 来源构建而成。</li>
<li>是每个架构和每个 LTS 版本的单内核二进制文件以及关联的可加载模块（目前只有适用于 android11-5.4 和 android12-5.4 的 arm64）。</li>
<li>已经过关联 ACK 支持的所有 Android 平台版本的测试。在 GKI 内核版本的生命周期内不会发生功能弃用。</li>
<li>为给定 LTS 中的驱动程序提供了稳定版 KMI。</li>
<li>不包含 SoC 专用代码或板卡专用代码。下图显示了 GKI 内核和供应商模块架构：</li>
</ul>
</blockquote>
<p><img src="/images/android_aosp_power_up06.png" alt="img"></p>
<p>由于Android的kernel实际上就是Linux kernel，只是针对移动设备做了一些优化，所以与其它Linux kernel的启动方式大同小异，都是对start_kernel函数的调用和执行。Kernel主要工作内容为设置缓存、被保护存储器、计划列表，加载驱动，启动kernel守护，挂载根目录，初始化输入输出，开启中断，初始化进程表等。当内核完成这些系统设置后，接下来在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p>
<p>Kernel启动过程分为两个阶段：<br>1）内核引导阶段。通常使用汇编语言编写，主要检查内核与当前硬件是否匹配。这部分也与硬件体系结构相关。<br>2）内核启动阶段。引导阶段结束前，将调用start_kernel()进入内核启动阶段。内核启动阶段相关的代码主要位于kernel/init/main.c。</p>
<p><img src="/images/android_aosp_power_up07.png" alt="img"></p>
<blockquote>
<ul>
<li><p><strong>A.</strong> 内存管理单元和高速缓存初始化完成之后，系统便可以使用虚拟内存和启动用户空间进程</p>
</li>
<li><p><strong>B.</strong> 内核在根目录寻找初始化程序（/system/core/init），执行该程序以启动init进程<br>Kernel启动的核心函数是start_kernel函数，它完成了内核的大部分初始化工作。这个函数在最后调用了reset_init函数进行后续的初始化。reset_init函数最主要的任务就是启动内核线程kernel_init。kernel_init函数将完成设备驱动程序的初始化，并调用init_post函数启动用户空间的init进程。到init_post函数为止，内核的初始化已经基本完成。</p>
</li>
</ul>
</blockquote>
<p><img src="/images/android_aosp_power_up08.png" alt="img"></p>
<h2 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h2><p>用户空间的第一个进程便是init进程，进程号为1。</p>
<p><img src="/images/android_aosp_power_up09.png" alt="img"></p>
<p>当系统启动完成之后，init进程会作为守护进程监视其它进程。在Linux中所有的进程都是由init进程直接或间接fork出来的。在init进程启动的过程中，会相继启动servicemanager(binder服务管理者)、Zygote进程。而Zygote又会创建system_server进程以及app进程。</p>
<p><img src="/images/android_aosp_power_up10.png" alt="img"></p>
<p>对于init进程的功能分为4部分：</p>
<blockquote>
<ul>
<li>解析并运行所有的init.rc相关文件</li>
<li>根据rc文件，生成相应的设备驱动节点</li>
<li>处理子进程的终止(signal方式)</li>
<li>提供属性服务的功能<br>init进程涉及的主要代码文件有</li>
</ul>
</blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">system/core/init/</span><br><span class="line">  -main.cpp</span><br><span class="line">  -init.cpp</span><br><span class="line">  -parser.cpp</span><br><span class="line">/system/core/rootdir/</span><br><span class="line">  -init.rc</span><br></pre></td></tr></table></figure>

<p>init进程的入口为main.cpp类的main方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system/core/init/main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(address_sanitizer)</span></span><br><span class="line">     __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 创建设备节点、权限设定等</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="built_in">basename</span>(argv[<span class="number">0</span>]), <span class="string">&quot;ueventd&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ueventd_main</span>(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 初始化日志系统</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;subcontext&quot;</span>))&#123;</span><br><span class="line">            android::base::<span class="built_in">InitLogging</span>(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            <span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">SubcontextMain</span>(argc, argv, &amp;function_map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.创建安全增强型Linux（SELinux）</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;selinux_setup&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">SetupSelinux</span>(argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.解析init.rc文件、提供服务、创建epoll与处理子进程的终止等</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;second_stage&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">SecondStageMain</span>(argc, argv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.挂载相关文件系统</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">FirstStageMain</span>(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要执行了三步</p>
<blockquote>
<ul>
<li>FirstStageMain</li>
<li>SetupSelinux</li>
<li>SecondStageMain</li>
</ul>
</blockquote>
<h3 id="FirstStageMain"><a href="#FirstStageMain" class="headerlink" title="FirstStageMain"></a>FirstStageMain</h3><p>init进程启动的第一步，主要是挂载相关的文件系统</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system/core/init/first_stage_init.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(REBOOT_BOOTLOADER_ON_PANIC)&#123;</span><br><span class="line">        <span class="built_in">InstallRebootSignalHandlers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    boot_clock::time_point start_time = boot_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::vector&lt;std::pair&lt;std::string, <span class="keyword">int</span>&gt;&gt; errors;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECKCALL(x) \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (x != 0) errors.emplace_back(#x <span class="meta-string">&quot; failed&quot;</span>, errno);</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建于挂载相关文件系统</span></span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">clearenv</span>());</span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">setenv</span>(<span class="string">&quot;PATH&quot;</span>, _PATH_DEFPATH, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line">    <span class="comment">// on / and then we&#x27;ll let the rc file figure out the rest.</span></span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">mount</span>(<span class="string">&quot;tmpfs&quot;</span>, <span class="string">&quot;/dev&quot;</span>, <span class="string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="string">&quot;mode=0755&quot;</span>));</span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">mkdir</span>(<span class="string">&quot;/dev/pts&quot;</span>, <span class="number">0755</span>));</span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">mkdir</span>(<span class="string">&quot;/dev/socket&quot;</span>, <span class="number">0755</span>));</span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">mount</span>(<span class="string">&quot;devpts&quot;</span>, <span class="string">&quot;/dev/pts&quot;</span>, <span class="string">&quot;devpts&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">mount</span>(<span class="string">&quot;proc&quot;</span>, <span class="string">&quot;/proc&quot;</span>, <span class="string">&quot;proc&quot;</span>, <span class="number">0</span>, <span class="string">&quot;hidepid=2,gid=&quot;</span> <span class="built_in">MAKE_STR</span>(AID_READPROC)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> MAKE_STR</span></span><br><span class="line">    <span class="comment">// 原始命令不可暴露给没有特权的进程</span></span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">chmod</span>(<span class="string">&quot;/proc/cmdline&quot;</span>, <span class="number">0440</span>));</span><br><span class="line">    <span class="keyword">gid_t</span> groups[] = &#123;AID_READPROC&#125;;</span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">setgroups</span>(<span class="built_in">arraysize</span>(groups), groups));</span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">mount</span>(<span class="string">&quot;sysfs&quot;</span>, <span class="string">&quot;/sys&quot;</span>, <span class="string">&quot;sysfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">CHECKCALL</span>(<span class="built_in">mount</span>(<span class="string">&quot;selinuxfs&quot;</span>, <span class="string">&quot;/sys/fs/selinux&quot;</span>, <span class="string">&quot;selinuxfs&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// tmpfs已经挂载在/dev下，并且已生成/dev/kmsg，故可以与外界通信</span></span><br><span class="line">    <span class="comment">// 初始化日志系统</span></span><br><span class="line">    <span class="built_in">InitKernelLogging</span>(argv);</span><br><span class="line">    <span class="comment">// 进入下一步</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;/system/bin/init&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">&quot;selinux_setup&quot;</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">execv</span>(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 只有在错误发生的情况下execv()函数才会返回</span></span><br><span class="line">    <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;) failed&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要通过mount挂载对应的文件系统，mkdir创建对应的文件目录，并配置相应的访问权限。<br>需要注意的是，这些文件只是在应用运行的时候存在，一旦应用运行结束就会随着应用一起消失。<br>挂载的<strong>文件系统</strong>主要有四类：</p>
<ul>
<li>tmpfs: 一种虚拟内存文件系统，它会将所有的文件存储在虚拟内存中。由于tmpfs是驻留在RAM的，因此它的内容是不持久的。断电后，tmpfs 的内容就消失了，这也是被称作tmpfs的根本原因。</li>
<li>devpts: 为伪终端提供了一个标准接口，它的标准挂接点是/dev/pts。只要pty(pseudo-tty, 虚拟终端)的主复合设备/dev/ptmx被打开，就会在/dev/pts下动态的创建一个新的pty设备文件。</li>
<li>proc: 也是一个虚拟文件系统，它可以看作是内核内部数据结构的接口，通过它我们可以获得系统的信息，同时也能够在运行时修改特定的内核参数。</li>
<li>sysfs: 与proc文件系统类似，也是一个不占有任何磁盘空间的虚拟文件系统。它通常被挂接在/sys目录下。</li>
</ul>
<p>在FirstStageMain还会通过InitKernelLogging(argv)来初始化log日志系统。此时Android还没有自己的系统日志，采用kernel的log系统，打开的设备节点/dev/kmsg， 那么可通过cat /dev/kmsg来获取内核log。</p>
<p>最后会通过execv方法传递对应的path与下一阶段的参数selinux_setup。</p>
<h3 id="SetupSelinux"><a href="#SetupSelinux" class="headerlink" title="SetupSelinux"></a>SetupSelinux</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system/core/init/selinux.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SetupSelinux</span><span class="params">(<span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//初始化本阶段内核日志</span></span><br><span class="line">    <span class="built_in">InitKernelLogging</span>(argv);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;</span><br><span class="line">        <span class="built_in">InstallRebootSignalHandlers</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">//  初始化 SELinux，加载 SELinux 策略</span></span><br><span class="line">    <span class="built_in">SelinuxSetupKernelLogging</span>();</span><br><span class="line">    <span class="built_in">SelinuxInitialize</span>();</span><br><span class="line">    <span class="comment">//  再次调用 main 函数，并传入 second_stage 进入第二阶段</span></span><br><span class="line">    <span class="comment">//  而且此次启动就已经在 SELinux 上下文中运行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">selinux_android_restorecon</span>(<span class="string">&quot;/system/bin/init&quot;</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;restorecon failed of /system/bin/init failed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入下一步</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* path = <span class="string">&quot;/system/bin/init&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* args[] = &#123;path, <span class="string">&quot;second_stage&quot;</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">execv</span>(path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>**&gt;(args));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// execv() only returns if an error happened, in which case we</span></span><br><span class="line">    <span class="comment">// panic and never return from this function.</span></span><br><span class="line">    <span class="built_in">PLOG</span>(FATAL) &lt;&lt; <span class="string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\&quot;) failed&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这阶段主要是初始化 SELinux。SELinux 是安全加强型 Linux，能够很好的对全部进程强制执行访问控制，从而让 Android 更好的保护和限制系统服务、控制对应用数据和系统日志的访问，提高系统安全性。<br>接下来调用execv进入到最后阶段SecondStageMain。</p>
<h3 id="SecondStageMain"><a href="#SecondStageMain" class="headerlink" title="SecondStageMain"></a>SecondStageMain</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  system/core/init/init.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondStageMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SetStdioToDevNull</span>(argv);</span><br><span class="line">    <span class="comment">// 初始化本阶段内核日志</span></span><br><span class="line">    <span class="built_in">InitKernelLogging</span>(argv);</span><br><span class="line">    <span class="comment">//  系统属性初始化</span></span><br><span class="line">    <span class="built_in">property_init</span>();</span><br><span class="line">    <span class="comment">//  建立 Epoll</span></span><br><span class="line">    Epoll epoll;</span><br><span class="line">    <span class="comment">//  注册信号处理</span></span><br><span class="line">    <span class="built_in">InstallSignalFdHandler</span>(&amp;epoll);</span><br><span class="line">    <span class="comment">//  加载默认的系统属性</span></span><br><span class="line">    <span class="built_in">property_load_boot_defaults</span>(load_debug_prop);</span><br><span class="line">    <span class="comment">//  启动属性服务</span></span><br><span class="line">    <span class="built_in">StartPropertyService</span>(&amp;epoll);</span><br><span class="line">       subcontexts = <span class="built_in">InitializeSubcontexts</span>();</span><br><span class="line">    <span class="comment">//加载系统启动脚本&quot;/init.rc&quot;</span></span><br><span class="line">       ActionManager&amp; am = ActionManager::<span class="built_in">GetInstance</span>();</span><br><span class="line">    ServiceList&amp; sm = ServiceList::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="built_in">LoadBootScripts</span>(am, sm);</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 触发early-init，，init，late-init流程</span></span><br><span class="line">    am.<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;early-init&quot;</span>);</span><br><span class="line">    am.<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    am.<span class="built_in">QueueBuiltinAction</span>(InitBinder, <span class="string">&quot;InitBinder&quot;</span>);</span><br><span class="line">    am.<span class="built_in">QueueEventTrigger</span>(<span class="string">&quot;late-init&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解析启动脚本</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//  执行 Action</span></span><br><span class="line">        am.<span class="built_in">ExecuteOneCommand</span>();</span><br><span class="line">        <span class="comment">//  还有就是重启死掉的子进程</span></span><br><span class="line">        <span class="keyword">auto</span> next_process_action_time = <span class="built_in">HandleProcessActions</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SecondStageMain的主要工作总结</p>
<ul>
<li>使用epoll对init子进程的信号进行监听</li>
<li>初始化系统属性，使用mmap共享内存</li>
<li>开启属性服务，并注册到epoll中</li>
<li>加载系统启动脚本”init.rc”</li>
<li>解析启动脚本，启动相关服务</li>
</ul>
<p>重点介绍下init.rc文件的解析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//system/core/init/init.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadBootScripts</span><span class="params">(ActionManager&amp; action_manager, ServiceList&amp; service_list)</span> </span>&#123;</span><br><span class="line">    Parser parser = <span class="built_in">CreateParser</span>(action_manager, service_list);</span><br><span class="line">    std::string bootscript = <span class="built_in">GetProperty</span>(<span class="string">&quot;ro.boot.init_rc&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bootscript.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/init.rc&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/system/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.<span class="built_in">emplace_back</span>(<span class="string">&quot;/system/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/product/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.<span class="built_in">emplace_back</span>(<span class="string">&quot;/product/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/product_services/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.<span class="built_in">emplace_back</span>(<span class="string">&quot;/product_services/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/odm/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.<span class="built_in">emplace_back</span>(<span class="string">&quot;/odm/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.<span class="built_in">ParseConfig</span>(<span class="string">&quot;/vendor/etc/init&quot;</span>)) &#123;</span><br><span class="line">            late_import_paths.<span class="built_in">emplace_back</span>(<span class="string">&quot;/vendor/etc/init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parser.<span class="built_in">ParseConfig</span>(bootscript);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ParseConfig来解析init.rc配置文件。.rc文件以行为单位，以空格为间隔，以#开始代表注释行。.rc文件主要包含Action、Service、Command、Options、Import，其中对于Action和Service的名称都是唯一的，对于重复的命名视为无效。init.rc中的Action、Service语句都有相应的类来解析，即ActionParser、ServiceParser。以下为init.rc配置文件的部分内容。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">// system/core/rootdir/init.rc</span><br><span class="line">import /init.environ.rc</span><br><span class="line">import /init.usb.rc</span><br><span class="line">import /init.<span class="built_in">$</span>&#123;ro.hardware&#125;.rc</span><br><span class="line">import /init.<span class="built_in">$</span>&#123;ro.zygote&#125;.rc</span><br><span class="line">import /init.trace.rc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">on early-init</span><br><span class="line">    start ueventd</span><br><span class="line">    mkdir /mnt 0775 root system</span><br><span class="line">on init</span><br><span class="line">    mount tmpfs none /sys/fs/cgroup mode=0750,uid=0,gid=1000</span><br><span class="line">    mkdir /sys/fs/cgroup/memory 0750 root system</span><br><span class="line">    mount cgroup none /sys/fs/cgroup/memory memory</span><br><span class="line">on property:sys.boot<span class="built_in">_</span>from<span class="built_in">_</span>charger<span class="built_in">_</span>mode=1</span><br><span class="line">    class<span class="built_in">_</span>stop charger</span><br><span class="line">    trigger late-init</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">service ueventd /sbin/ueventd</span><br><span class="line">    class core</span><br><span class="line">    critical</span><br><span class="line">    seclabel u:r:ueventd:s0</span><br><span class="line">    </span><br><span class="line">service logd /system/bin/logd</span><br><span class="line">    class core</span><br><span class="line">    socket logd stream 0666 logd logd</span><br><span class="line">    socket logdr seqpacket 0666 logd logd</span><br><span class="line">    socket logdw dgram 0222 logd logd</span><br><span class="line">    seclabel u:r:logd:s0</span><br><span class="line">    </span><br><span class="line">service console /system/bin/sh</span><br><span class="line">    class core</span><br><span class="line">    console</span><br><span class="line">    disabled</span><br><span class="line">    user shell</span><br><span class="line">    seclabel u:r:shell:s0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">service adbd /sbin/adbd --root<span class="built_in">_</span>seclabel=u:r:su:s0</span><br><span class="line">    class core</span><br><span class="line">    socket adbd stream 660 system system</span><br><span class="line">    disabled</span><br><span class="line">    seclabel u:r:adbd:s0</span><br><span class="line">    </span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    class core</span><br><span class="line">    user system</span><br><span class="line">    group system</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    </span><br><span class="line">on late-init</span><br><span class="line">     trigger early-fs</span><br><span class="line">    trigger fs</span><br><span class="line">    trigger post-fs</span><br><span class="line">    trigger late-fs</span><br><span class="line">    trigger post-fs-data</span><br><span class="line">    trigger load<span class="built_in">_</span>persist<span class="built_in">_</span>props<span class="built_in">_</span>action</span><br><span class="line">    // 这里启动zygote-start</span><br><span class="line">    trigger zygote-start</span><br><span class="line">    trigger firmware<span class="built_in">_</span>mounts<span class="built_in">_</span>complete</span><br><span class="line">    trigger early-boot</span><br><span class="line">    trigger boot</span><br></pre></td></tr></table></figure>

<p>可以看到，在解析init.rc的配置中，在late-init阶段启动了Zygote进程。</p>
<h2 id="Zygote"><a href="#Zygote" class="headerlink" title="Zygote"></a>Zygote</h2><p><img src="/images/android_aosp_power_up11.png" alt="img"></p>
<p>Zygote进程是Android中所有Java进程的父进程。Zygote进程在Init进程启动过程中被以service服务的形式启动。Zygote进程相关的.rc配置文件为init.zygote64.rc或者init.zygote32.rc。以init.zygote64.rc为例，其内容如下</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">// system/core/rootdir/init.zygote64.rc</span><br><span class="line">service zygote /system/bin/app<span class="built_in">_</span>process64 -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line"> class main</span><br><span class="line">   priority -20</span><br><span class="line">   user root</span><br><span class="line">   group root readproc reserved<span class="built_in">_</span>disk</span><br><span class="line">   socket zygote stream 660 root system</span><br><span class="line">   socket usap<span class="built_in">_</span>pool<span class="built_in">_</span>primary stream 660 root system</span><br><span class="line">   onrestart exec<span class="built_in">_</span>background - system system -- /ssystem/bin/vdc volume abort<span class="built_in">_</span>fuse</span><br><span class="line">   onrestart write /sys/power/state on</span><br><span class="line">   onrestart restart audioserver</span><br><span class="line">   onrestart restart cmeraserver</span><br><span class="line">   onrestart restart media</span><br><span class="line">   onrestart restart netd</span><br><span class="line">   onrestart setprop sys.android.reboot 1</span><br><span class="line">   writepid /dev/cpuset/foreground/tasks</span><br><span class="line">   critical window=<span class="built_in">$</span>&#123;zygote.critical<span class="built_in">_</span>window.minute:-off&#125; target=zygote-fatal</span><br></pre></td></tr></table></figure>

<p>init进程解析init.zygote64.rc配置文件之后，会调用app_process</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/cmds/app_process/app_main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(zygote)&#123;</span><br><span class="line">     runtime.<span class="built_in">start</span>(<span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>, args, zygote);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到frameworks/base/core/jni/AndroidRuntime.cpp的start()方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/AndroidRuntime.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n&quot;</span>,class Name！= <span class="literal">NULL</span>？class Name：<span class="string">&quot;(unknown)&quot;</span>, <span class="built_in">getuid</span>() );</span><br><span class="line">    <span class="comment">// 打印LOG_BOOT_PROGRESS_START日志</span></span><br><span class="line">    <span class="built_in">LOG_EVENT_LONG</span>(LOG_BOOT_PROGRESS_START, <span class="built_in">ns2ms</span>(<span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">startVm</span>(&amp;mJavaVM, &amp;env, zygote, primaryZygote) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">onVmCreated</span>(env);</span><br><span class="line">    <span class="comment">// 调用ZygoteInit类的main()方法</span></span><br><span class="line">    env.<span class="built_in">CallStaticVoidMethod</span>(startClass, startMeth, strArray)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AndroidRuntime.cpp的start方法主要做了以下工作：</p>
<ul>
<li>加载libart.so</li>
<li>启动虚拟机</li>
<li>加载注册JNI方法</li>
<li>启动Zygote</li>
</ul>
<p>执行ZygoteInit.java的main()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//zygote进程会fork出system_server进程</span></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">        <span class="comment">// zygote进程中，r == null；zygote子进程（如system_server进程）中， r != null</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">          r.run();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;Accepting command socket connections&quot;</span>);</span><br><span class="line">    <span class="comment">// zygote进程会在select loop死循环；而非zygote进程中之前已return。</span></span><br><span class="line">    <span class="comment">// loops forever in the zygote.</span></span><br><span class="line">    caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zygote进程主要做了以下工作</p>
<ul>
<li>加载虚拟机，并为JVM注册JNI方法</li>
<li>提前加载类PreloadClasses</li>
<li>提前加载资源PreLoadResouces</li>
<li>fork system_server</li>
<li>提前加载类PreloadClasses, 调用runSelectLoop方法，等待进程孵化请求</li>
</ul>
<p>zygote进程在fork子进程的时候可以共享虚拟机和资源，从而加快进程的启动速度，节省内存。</p>
<h2 id="SystemServer"><a href="#SystemServer" class="headerlink" title="SystemServer"></a>SystemServer</h2><p><img src="/images/android_aosp_power_up12.png" alt="img"></p>
<p>SystemServer进程由Zygote进程fork而来，是Zygote孵化出的第一个进程。SystemServer和Zygote进程是Android Framework层的两大重要进程。SystemServer负责启动和管理整个Java frameWork。SystemServer进程在开启的时候，会初始化AMS、WMS、PMS等关键服务。同时会加载本地系统的服务库，调用createSystemContext()创建系统上下文，创建ActivityThread及开启各种服务等等。</p>
<p>SystemServer的启动相关代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        <span class="comment">// 初始化本地服务</span></span><br><span class="line">        System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line">         <span class="comment">// 初始化系统上下文</span></span><br><span class="line">        createSystemContext();</span><br><span class="line">        <span class="comment">// 创建SystemServiceManager</span></span><br><span class="line">        mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">        mSystemServiceManager.setStartInfo(mRuntimeRestart,</span><br><span class="line">                mRuntimeStartElapsedTime, mRuntimeStartUptime);</span><br><span class="line">        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">        <span class="comment">// 构建线程池，以便并行执行一些初始化任务</span></span><br><span class="line">        SystemServerInitThreadPool.get();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 开启服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        traceBeginAndSlog(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">        startBootstrapServices();<span class="comment">// 启动引导服务</span></span><br><span class="line">        startCoreServices();<span class="comment">// 启动核心服务</span></span><br><span class="line">        startOtherServices();<span class="comment">// 启动其他服务</span></span><br><span class="line">        SystemServerInitThreadPool.shutdown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">        Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        traceEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，SystemServer最重要的工作就是通过执行三个方法来启动所有服务</p>
<ul>
<li>startBootstrapServices();</li>
<li>startCoreServices();</li>
<li>startOtherServices();</li>
</ul>
<p>分别对应引导服务、核心服务和其他服务：</p>
<ul>
<li>引导服务(Bootstrap services)：这类服务包括 Installer，ActivityManagerService<br>PowerManagerService, DisplayManagerService, PackageManagerService, UserManagerService等</li>
<li>核心服务(Core services )：这类服务包括 LightsService, BatteryService, UsageStatsServtce,<br>WebViewUpdateService等</li>
<li>其他服务：所有其它服务</li>
</ul>
<p>在startOtherServices()方法中会启动SystemUI，之后SystemServer通知AMS系统已准备好，此时AMS启动桌面并且发送BOOT_COMPLETED广播。至此，系统层面启动流程结束。</p>
<p>通过下图再回顾下整个开机流程</p>
<p><img src="/images/android_aosp_power_up13.png" alt="img"></p>
<h1 id="分析开机时间"><a href="#分析开机时间" class="headerlink" title="分析开机时间"></a>分析开机时间</h1><p>要想进行开机速度的优化，我们需要分析开机时间的分布，从而找出异常耗时的地方，从而进行实际的优化工作。下面介绍如何分析开机时间。</p>
<h2 id="分析开机日志"><a href="#分析开机日志" class="headerlink" title="分析开机日志"></a>分析开机日志</h2><p>Android的log系统是独立于Linux内核log系统的. Android系统把Log分为了四类，不同的类别记录不同的Log信息，默认通过logcat抓取的是main信息：</p>
<ul>
<li>main - 主要的Log信息，大部分应用级别的Log信息都在这里</li>
<li>events - 系统事件相关的Log信息</li>
<li>radio - 无线/电话相关的Log信息</li>
<li>system - 低级别的系统调试Log信息<br>通过查看events.txt中搜索”<strong>boot_progress</strong>“关键字或者通过以下命令过滤日志输出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb logcat -d -v time -b &quot;events&quot; | grep &quot;boot_progress&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_aosp_power_up14.png" alt="image"></p>
<p>行末数字即为此刻距开机时刻的时间间隔。每行代表开机的各个关键阶段。</p>
<table>
<thead>
<tr>
<th align="left">阶段</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boot_progress_start</td>
<td align="left">系统进入用户空间，标志着kernel启动完成</td>
</tr>
<tr>
<td align="left">boot_progress_preload_start</td>
<td align="left">Zygote启动</td>
</tr>
<tr>
<td align="left">boot_progress_preload_end</td>
<td align="left">Zygote结束</td>
</tr>
<tr>
<td align="left">boot_progress_system_run</td>
<td align="left">SystemServer ready,开始启动Android系统服务</td>
</tr>
<tr>
<td align="left">boot_progress_pms_start</td>
<td align="left">PMS开始扫描安装的应用</td>
</tr>
<tr>
<td align="left">boot_progress_pms_system_scan_start</td>
<td align="left">PMS先行扫描/system目录下的安装包</td>
</tr>
<tr>
<td align="left">boot_progress_pms_data_scan_start</td>
<td align="left">PMS扫描/data目录下的安装包</td>
</tr>
<tr>
<td align="left">boot_progress_pms_scan_end</td>
<td align="left">PMS扫描结束</td>
</tr>
<tr>
<td align="left">boot_progress_pms_ready</td>
<td align="left">PMS就绪</td>
</tr>
<tr>
<td align="left">boot_progress_ams_ready</td>
<td align="left">AMS就绪</td>
</tr>
<tr>
<td align="left">boot_progress_enable_screen</td>
<td align="left">AMS启动完成后开始激活屏幕，从此以后屏幕才能响应用户的触摸，它在WindowManagerService发出退出开机动画的时间节点之前</td>
</tr>
<tr>
<td align="left">sf_stop_bootanim</td>
<td align="left">SF设置service.bootanim.exit属性值为1，标志系统要结束开机动画了</td>
</tr>
<tr>
<td align="left">wm_boot_animation_done</td>
<td align="left">开机动画结束，这一步用户能直观感受到开机结束</td>
</tr>
</tbody></table>
<p>各行log对应的打印代码为</p>
<h2 id="boot-progress-start"><a href="#boot-progress-start" class="headerlink" title="boot_progress_start"></a>boot_progress_start</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/jni/AndroidRuntime.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">            primary_zygote = <span class="literal">true</span>;</span><br><span class="line">           <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">           <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">           <span class="built_in">LOG_EVENT_LONG</span>(LOG_BOOT_PROGRESS_START,  <span class="built_in">ns2ms</span>(<span class="built_in">systemTime</span>(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boot-progress-preload-start"><a href="#boot-progress-preload-start" class="headerlink" title="boot_progress_preload_start"></a>boot_progress_preload_start</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!enableLazyPreload)&#123;</span><br><span class="line">        bootTimingsTraceLog.traceBegin(<span class="string">&quot;ZygotePreload&quot;</span>);</span><br><span class="line">        EventLog.writeEvent(BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis());</span><br><span class="line">        preload(bootTimingsTraceLog);</span><br><span class="line">        EventLog.writeEvent(BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis());</span><br><span class="line">        bootTimingsTraceLog.traceEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boot-progress-system-run"><a href="#boot-progress-system-run" class="headerlink" title="boot_progress_system_run"></a>boot_progress_system_run</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/java/com/android/server/SystemServer.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Slog.i(TAG, <span class="string">&quot;Entered the Android system server!&quot;</span>);</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">long</span> uptimeMillis = SystemClock.elapsedRealtime();</span><br><span class="line">   EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, uptimeMillis);</span><br><span class="line">   <span class="keyword">if</span> (!mRuntimeRestart)&#123;</span><br><span class="line">            FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME_REPORTED,</span><br><span class="line">FrameworkStatsLog.BOOT_TIME_EVENT_ELAPSED_TIME__EVENT__SYSTEM_SERVER_INIT_START,uptimeMillis);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boot-progress-pms-start"><a href="#boot-progress-pms-start" class="headerlink" title="boot_progress_pms_start"></a>boot_progress_pms_start</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Injector injector, <span class="keyword">boolean</span> onlyCore, <span class="keyword">boolean</span> factoryTest)</span> </span>&#123;</span><br><span class="line">    LockGuard.installLock(mLock, LockGuard.INDEX_PACKAGES);</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,SystemClock.uptimeMillis()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boot-progress-pms-system-scan-start"><a href="#boot-progress-pms-system-scan-start" class="headerlink" title="boot_progress_pms_system_scan_start"></a>boot_progress_pms_system_scan_start</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Injector injector, <span class="keyword">boolean</span> onlyCore, <span class="keyword">boolean</span> factoryTest)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">   EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START, startTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boot-progress-pms-data-scan-start"><a href="#boot-progress-pms-data-scan-start" class="headerlink" title="boot_progress_pms_data_scan_start"></a>boot_progress_pms_data_scan_start</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Injector injector, <span class="keyword">boolean</span> onlyCore, <span class="keyword">boolean</span> factoryTest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> systemScanTime = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> systemPackagesCount = mPackages.size();</span><br><span class="line">    Slog.i(TAG, <span class="string">&quot;Finished scanning system apps. Time: &quot;</span> + systemScanTime</span><br><span class="line">                + <span class="string">&quot; ms, packageCount: &quot;</span> + systemPackagesCount</span><br><span class="line">                + <span class="string">&quot; , timePerPackage: &quot;</span></span><br><span class="line">                + (systemPackagesCount == <span class="number">0</span> ? <span class="number">0</span> : systemScanTime / systemPackagesCount)</span><br><span class="line">                + <span class="string">&quot; , cached: &quot;</span> + cachedSystemApps);</span><br><span class="line">    <span class="keyword">if</span> (mIsUpgrade &amp;&amp; systemPackagesCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        FrameworkStatsLog.write(FrameworkStatsLog.BOOT_TIME_EVENT_DURATION_REPORTED,                </span><br><span class="line">BOOT_TIME_EVENT_DURATION__EVENT__OTA_PACKAGE_MANAGER_SYSTEM_APP_AVG_SCAN_TIME,</span><br><span class="line"> systemScanTime / systemPackagesCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</span><br><span class="line">        SystemClock.uptimeMillis());</span><br><span class="line">        scanDirTracedLI(sAppInstallDir, <span class="number">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class="number">0</span>,</span><br><span class="line">                    packageParser, executorService);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boot-progress-pms-scan-end"><a href="#boot-progress-pms-scan-end" class="headerlink" title="boot_progress_pms_scan_end"></a>boot_progress_pms_scan_end</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Injector injector, <span class="keyword">boolean</span> onlyCore, <span class="keyword">boolean</span> factoryTest)</span> </span>&#123;</span><br><span class="line">    mPackageUsage.read(mSettings.mPackages);</span><br><span class="line">    mCompilerStats.read();</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Time to scan packages: &quot;</span></span><br><span class="line">                + ((SystemClock.uptimeMillis()-startTime)/<span class="number">1000f</span>)</span><br><span class="line">                + <span class="string">&quot; seconds&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boot-progress-pms-ready"><a href="#boot-progress-pms-ready" class="headerlink" title="boot_progress_pms_ready"></a>boot_progress_pms_ready</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Injector injector, <span class="keyword">boolean</span> onlyCore, <span class="keyword">boolean</span> factoryTest)</span> </span>&#123;</span><br><span class="line">    t.traceBegin(<span class="string">&quot;write settings&quot;</span>);</span><br><span class="line">    mSettings.writeLPr();</span><br><span class="line">    t.traceEnd();</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY, SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boot-progress-ams-ready"><a href="#boot-progress-ams-ready" class="headerlink" title="boot_progress_ams_ready"></a>boot_progress_ams_ready</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback, <span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    t.traceEnd();</span><br><span class="line">    EventLog.writeBootProgressAmsReady(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boot-progress-enable-screen"><a href="#boot-progress-enable-screen" class="headerlink" title="boot_progress_enable_screen"></a>boot_progress_enable_screen</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enableScreenAfterBoot</span><span class="params">(<span class="keyword">boolean</span> booted)</span> </span>&#123;</span><br><span class="line">    writeBootProgressEnableScreen(SystemClock.uptimeMillis());</span><br><span class="line">    mWindowManager.enableScreenAfterBoot();</span><br><span class="line">    <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">        updateEventDispatchingLocked(booted);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="sf-stop-bootanim"><a href="#sf-stop-bootanim" class="headerlink" title="sf_stop_bootanim"></a>sf_stop_bootanim</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::bootFinished()</span><br><span class="line">&#123;</span><br><span class="line">         property_set(<span class="string">&quot;service.bootanim.exit&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">         LOG_EVENT_LONG(LOGTAG_SF_STOP_BOOTANIM, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wm-boot-animation-done"><a href="#wm-boot-animation-done" class="headerlink" title="wm_boot_animation_done"></a>wm_boot_animation_done</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performEnableScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLogTags.writeWmBootAnimationDone(SystemClock.uptimeMillis());</span><br><span class="line">        Trace.asyncTraceEnd(TRACE_TAG_WINDOW_MANAGER,   <span class="string">&quot;Stop bootanim&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将测试机与对比机抓取的此log数据制作成表格，制作成折线图，可以更加直观的观察到耗时异常的流程。</p>
<p><img src="/images/android_aosp_power_up15.png" alt="img"></p>
<p>通过”boot_progress_”关键字分析日志，粒度较大，只能定位出大概的耗时流程，之后还需分析流程内部具体的耗时情况。开机各流程内部也有相应的日志，可以进行更加细致的分析。例如在SystemServiceManager.java类中启动服务时，会打印启动某项服务的日志。通过查看某个服务A与下一个服务的日志时间，可以计算出启动服务A的耗时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// frameworks/base/services/core/java/com/android/server/SystemServiceManager.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> String name = serviceClass.getName();</span><br><span class="line">        Slog.i(TAG, <span class="string">&quot;Starting &quot;</span> + name);</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="string">&quot;StartService &quot;</span> + name);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;T&gt; constructor = serviceClass . getConstructor (Context.class);</span><br><span class="line">            service = constructor.newInstance(mContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> ...</span><br><span class="line">            startService(service);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用bootchart工具"><a href="#使用bootchart工具" class="headerlink" title="使用bootchart工具"></a>使用bootchart工具</h2><p>bootchart是一个能对GNU/Linux boot过程进行性能分析并把结果直观化的开源工具，在系统启动过程中自动收集 CPU 占用率、磁盘吞吐率、进程等信息，并以图形方式显示分析结果，可用作指导优化系统启动过程。BootChart包含数据收集工具和图像产生工具，数据收集工具在原始的BootChart中是独立的shell程序，但在Android中，数据收集工具被集成到了init程序中。<br>以下涉及到的命令，请自行应该参数的path。</p>
<h3 id="抓取bootchart数据"><a href="#抓取bootchart数据" class="headerlink" title="抓取bootchart数据"></a>抓取bootchart数据</h3><p>bootchart开始生成数据的源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system/core/init/bootchart.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_bootchart_start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 只要存在/data/bootchart/enabled文件，即抓取bootchart数据</span></span><br><span class="line">   std::string start;</span><br><span class="line">   <span class="keyword">if</span> (!android::base::<span class="built_in">ReadFileToString</span>(<span class="string">&quot;/data/bootchart/enabled&quot;</span>, &amp;start)) &#123;</span><br><span class="line">       <span class="built_in">LOG</span>(VERBOSE) &lt;&lt; <span class="string">&quot;Not bootcharting&quot;</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">   g_bootcharting_thread = <span class="keyword">new</span> std::<span class="built_in">thread</span>(bootchart_thread_main);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以只要生成/data/bootchart/enabled文件即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell touch /data/bootchart/enabled</span><br><span class="line">adb reboot</span><br></pre></td></tr></table></figure>

<p>在设备启动后，提取启动图表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb  pull /data/bootchart</span><br></pre></td></tr></table></figure>

<p>获取到bootchart数据之后进行打包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -czf bootchart.tgz *</span><br></pre></td></tr></table></figure>

<h3 id="分析数据"><a href="#分析数据" class="headerlink" title="分析数据"></a>分析数据</h3><p>下载Boot Chart包并解压，使用bootchart.jar解析生成的文件输出图片</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar bootchart.jar bootchart.tgz</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_aosp_power_up16.png" alt="img"></p>
<p>从生成的图片可以更加直观详细的看到开机耗时以及硬件使用情况。个人认为，bootchart的分析应该是以PIXEL或者开机速度正常机子的bootchart为参考来对照分析。使用完之后，记得删除enabled文件以防每次开机都收集启动数据。</p>
<h2 id="抓取boottrace"><a href="#抓取boottrace" class="headerlink" title="抓取boottrace"></a>抓取boottrace</h2><p>抓取开机阶段的trace，也就是boottrace，是一种重要的分析开机的手段。抓取方式如下：</p>
<ol>
<li><p>将手机中的atrace.rc拉取下来，并备份；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb pull /system/etc/init/atrace.rc</span><br></pre></td></tr></table></figure></li>
<li><p>在文件atrace.rc末尾添加</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">on property:persist.debug.atrace.boottrace=1</span><br><span class="line">   start boottrace</span><br><span class="line">   service boottrace /system/bin/atrace --async<span class="built_in">_</span>start -b 30720 gfx input view webview wm am sm audio video binder<span class="built_in">_</span>lock binder<span class="built_in">_</span>driver camera hal res dalvik rs bionic power pm ss database network adb vibrator aidl sched  </span><br><span class="line">   disabled</span><br><span class="line">   oneshot</span><br></pre></td></tr></table></figure></li>
<li><p>将修改后的atrace.rc文件push到手机里面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push atrace.rc /system/etc/init/</span><br></pre></td></tr></table></figure></li>
<li><p>打开抓取boottrace的属性开关</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb  shell setprop persist.debug.atrace.boottrace 1</span><br></pre></td></tr></table></figure></li>
<li><p>重启手机，手机启动完成之后等待几秒，关闭boottrace属性开关</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb  shell setprop persist.debug.atrace.boottrace 0</span><br></pre></td></tr></table></figure></li>
<li><p>生成boottrace文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell atrace --async_stop -z -c -o /data/local/tmp/boot_trace</span><br></pre></td></tr></table></figure></li>
<li><p>拉取boottrace日志文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb  pull /data/local/tmp/boot_trace</span><br></pre></td></tr></table></figure></li>
</ol>
<p>之后就可以通过分析boot_trace文件来分析了。</p>
]]></content>
      <categories>
        <category>Android系统开发</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android车载-小组件Widget</title>
    <url>/2021/12/17/android_aosp_car_widget/</url>
    <content><![CDATA[<p>Widget，小部件是放置在主屏幕（Launcher）上的Android应用程序的小工具或控件。通过小部件可以将自己喜欢的应用程序放在主屏幕上，以便快速访问它们或是显示一些重点信息。</p>
<span id="more"></span>

<p>小部件可以是多种类型，例如信息小部件、集合小部件、控件小部件和混合小部件。Android为我们提供了一个完整的框架来开发我们自己的小部件。在手机上我们已经看过一些常见的小部件，例如音乐小部件，天气小部件，时钟小部件等。</p>
<p>官方对widget的描述：<a href="https://developer.android.google.cn/guide/topics/appwidgets/overview?hl=zh-cn">https://developer.android.google.cn/guide/topics/appwidgets/overview?hl=zh-cn</a></p>
<p><img src="/images/android_aosp_car_widget01.png" alt="image"></p>
<p>由于车载系统需要我们额外开发天气、音乐、时钟等应用，所以Widget在车载应用开发中，也算是必修课了。不仅如此，开发车载Launcher时还需要做额外开发，使Launcher具有摆放Widget的能力。</p>
<h1 id="创建一个Widget"><a href="#创建一个Widget" class="headerlink" title="创建一个Widget"></a>创建一个Widget</h1><h2 id="创建Widget的布局"><a href="#创建Widget的布局" class="headerlink" title="创建Widget的布局"></a>创建Widget的布局</h2><p><code>simple_widget.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;@style/Widget.CarWidget.AppWidget.Container&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.CarWidget.AppWidgetContainer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/appwidget_text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;@style/Widget.CarWidget.AppWidget.InnerView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerHorizontal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerVertical</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/appwidget_text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/appwidget_text&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textStyle</span>=<span class="string">&quot;bold|italic&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="定义Widget的属性"><a href="#定义Widget的属性" class="headerlink" title="定义Widget的属性"></a>定义Widget的属性</h2><p>在<code>res/xml</code>下创建一个新的XML，XML文件的资源类型应设置为<code>appwidget-provider</code>用于定义Widget的基本属性。在XML文件中，定义一些属性，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">appwidget-provider</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:initialLayout</span>=<span class="string">&quot;@layout/simple_widget&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minWidth</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minHeight</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:updatePeriodMillis</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="实现AppWidgetProvider"><a href="#实现AppWidgetProvider" class="headerlink" title="实现AppWidgetProvider"></a>实现AppWidgetProvider</h2><p>重写<code>AppWidgetProvider</code>的<code>Updae</code>方法，并在其中调用<code>AppWidgetManager.updateAppWidget()</code>将数据更新到布局<code>RemoteViews</code>中，完整的代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleWidget</span> : <span class="type">AppWidgetProvider</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onUpdate</span><span class="params">(context: <span class="type">Context</span>, appWidgetManager: <span class="type">AppWidgetManager</span>, appWidgetIds: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (appWidgetId <span class="keyword">in</span> appWidgetIds) &#123;</span><br><span class="line">            updateAppWidget(context, appWidgetManager, appWidgetId)</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;onUpdate: <span class="variable">$appWidgetIds</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateAppWidget</span><span class="params">(context: <span class="type">Context</span>,appWidgetManager: <span class="type">AppWidgetManager</span>, appWidgetId: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> widgetText = <span class="string">&quot;TEST&quot;</span></span><br><span class="line">    <span class="keyword">val</span> views = RemoteViews(context.packageName, R.layout.simple_widget)</span><br><span class="line">    views.setTextViewText(R.id.appwidget_text, widgetText)</span><br><span class="line">    <span class="comment">// 更新整个widget</span></span><br><span class="line">    appWidgetManager.updateAppWidget(appWidgetId, views)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="声明AppWidgetProvider"><a href="#声明AppWidgetProvider" class="headerlink" title="声明AppWidgetProvider"></a>声明AppWidgetProvider</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.SimpleWidget&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;android.appwidget.provider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">&quot;@xml/simple_widget_info&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行这个程序，并在Launcher上添加这个Widget，就可以看到一个最简单的Widget了。</p>
<p>到这一步，我们就完成了Widget的helloworld。总体来说Widget的架构组成如下所示，接下来我们逐个介绍每个组件的作用。</p>
<p><img src="/images/android_aosp_car_widget02.png" alt="img"></p>
<h1 id="AppWidgetProviderInfo"><a href="#AppWidgetProviderInfo" class="headerlink" title="AppWidgetProviderInfo"></a>AppWidgetProviderInfo</h1><p><code>AppWidgetProviderInfo</code>用于描述这个Widget的各种基本信息，包括layout布局，刷新频率以及<code>AppWidgetProvider</code>。这些信息都会定义在xml中，tag标记是<code>&lt;appwidget-provider&gt;</code></p>
<h2 id="常用属性与说明"><a href="#常用属性与说明" class="headerlink" title="常用属性与说明"></a>常用属性与说明</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>updatePeriodMillis</td>
<td>定义小部件通过调用onUpdate()回调方法从AppWidgetProvider请求更新的频率。实际更新不能保证使用此值准时进行，尽可能不频繁地更新。<strong>updatePeriodMillis不支持小于30分钟的值。如果要禁用定期更新，可以指定为0</strong>小部件的其他更新方式，请参考后面的 《小部件进阶用法 - 优化更新频率》</td>
</tr>
<tr>
<td>initialLayout</td>
<td>指向定义小部件布局的布局资源。</td>
</tr>
<tr>
<td>initialKeyguardLayout</td>
<td>指向定义小部件布局的布局资源。</td>
</tr>
<tr>
<td>configure</td>
<td>定义用户添加小部件时启动的Activity，允许他们配置小部件属性。</td>
</tr>
<tr>
<td>description</td>
<td>指定要为小部件显示的小部件选择器的描述。 Android 12中引入。</td>
</tr>
<tr>
<td>previewLayout (Android 12)previewImage (Android 11 and lower)</td>
<td>从Android 12开始，previewLayout属性指定了一个可扩展的预览，您将提供一个设置为小部件默认大小的XML布局。理想情况下，指定为该属性的布局XML应该与具有实际默认值的实际小部件相同。 在Android 11或更低版本中，previewImage属性指定了小部件配置后的预览，用户在选择应用程序小部件时会看到该预览。如果未提供，则用户会看到应用程序的启动器图标。该字段对应于AndroidManifest中<receiver>元素中的android:previewImage属性。 注意：建议同时指定previewImage和previewLayout属性，以便在用户的设备不支持previewLayout的情况下，应用程序可以使用previewImage。</td>
</tr>
<tr>
<td>autoAdvanceViewId</td>
<td>指定小部件主机应自动推进的小部件子视图的视图ID。 Android 3.0中引入。</td>
</tr>
<tr>
<td>widgetCategory</td>
<td>声明小部件是否可以显示在主屏幕（home_screen）、锁屏（keyguard）或两者上。只有低于5.0的Android版本支持锁屏小部件。对于Android 5.0及更高版本，只有home_screen有效。</td>
</tr>
<tr>
<td>widgetFeatures</td>
<td>声明小部件支持的功能。例如，如果您希望小部件在用户添加时使用其默认配置，请指定configuration_optional和reconfigurable 。这绕过了在用户添加小部件后启动配置活动。（之后用户仍然可以重新配置小部件。）</td>
</tr>
<tr>
<td>targetCellWidth、targetCellHeight (Android 12)minWidth、minHeight</td>
<td>从Android 12开始，targetCellWidth和targetCellHeight属性指定小部件的默认大小（以网格单元为单位）。 在Android 11及更低版本中，这些属性将被忽略，如果主屏幕不支持基于网格的布局，则这些属性可能会被忽略。minWidth和minHeight属性指定dp中小部件的默认大小。如果小部件的最小宽度或高度的值与单元格的尺寸不匹配，则将这些值四舍五入到最接近的单元格大小。 注意：建议同时指定targetCellWidth/targetCellHeight和minWidth/minHeight属性集，以便在用户的设备不支持targetCellWidth和targetCellHeight的情况下，应用程序可以使用minWidth和minHeight。如果支持，targetCellWidth和targetCellHeight属性优先于minWidth和minHeight属性。</td>
</tr>
<tr>
<td>minResizeWidthminResizeHeight</td>
<td>指定小部件的绝对最小大小。这些值应指定小部件无法辨认或无法使用的大小。使用这些属性，用户可以将小部件的大小调整为可能小于默认小部件大小的大小。如果minResizeWidth属性大于minWidth或未启用水平调整大小，则忽略该属性（请参见resizeMode）。 同样，如果minResizeHeight属性大于minHeight或未启用垂直调整大小，则忽略该属性。 Android 4.0中引入。</td>
</tr>
<tr>
<td>maxResizeWidthmaxResizeHeight</td>
<td>指定小部件的建议最大大小。如果值不是网格单元尺寸的倍数，则会将其四舍五入到最近的单元尺寸。如果maxResizeWidth属性小于minWidth或未启用水平调整大小，则忽略该属性（请参见resizeMode）。 同样，如果maxResizeHeight属性大于minHeight或未启用垂直调整大小，则忽略该属性。 Android 12中引入。</td>
</tr>
<tr>
<td>resizeMode</td>
<td>指定可以调整小部件大小的规则。可以使用此属性使主屏幕小部件可以水平、垂直或在两个轴上调整大小。用户长按小部件以显示其大小调整手柄，然后拖动水平和/或垂直手柄以更改其在布局网格上的大小。resizeMode属性的值包括horizontal、vertical和none。 要将小部件声明为可水平和垂直调整大小，请使用horizontal  vertical。 在Android 3.1中引入。</td>
</tr>
</tbody></table>
<p>关于小部件尺寸的计算问题请参考 ： <a href="https://developer.android.google.cn/develop/ui/views/appwidgets/layouts">Provide flexible widget layouts</a></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><code>AppWidgetProviderInfo</code>需要在res/xml中使用<code>&lt;appwidget-provider/&gt;</code>标记将需要的属性定义出来即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">appwidget-provider</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configure</span>=<span class="string">&quot;com.android.car.carwidget.SimpleWidgetConfigureActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:description</span>=<span class="string">&quot;@string/app_widget_description&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:initialKeyguardLayout</span>=<span class="string">&quot;@layout/simple_widget&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:initialLayout</span>=<span class="string">&quot;@layout/simple_widget&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minWidth</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minHeight</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:previewImage</span>=<span class="string">&quot;@drawable/example_appwidget_preview&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:previewLayout</span>=<span class="string">&quot;@layout/simple_widget&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:resizeMode</span>=<span class="string">&quot;horizontal|vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:targetCellWidth</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:targetCellHeight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:updatePeriodMillis</span>=<span class="string">&quot;86400000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:widgetCategory</span>=<span class="string">&quot;home_screen|keyguard&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="AppWidgetProvider"><a href="#AppWidgetProvider" class="headerlink" title="AppWidgetProvider"></a>AppWidgetProvider</h1><p>AppWidgetProvider是Widget的功能提供者，继承自BroadcastReceiver，本质上就是一个广播接收器，AppWidgetProvider也只是在onReceive中解析接收到的intent，并使用接收到的数据调用其他扩展方法。</p>
<p><img src="/images/android_aosp_car_widget03.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//防止恶意更新广播（不是真正的安全问题，只是过滤出坏的Broacast，这样子类就不太可能崩溃）。</span></span><br><span class="line">String action = intent.getAction();</span><br><span class="line">    <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] appWidgetIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);</span><br><span class="line">            <span class="keyword">if</span> (appWidgetIds != <span class="keyword">null</span> &amp;&amp; appWidgetIds.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.onUpdate(context, AppWidgetManager.getInstance(context), appWidgetIds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_DELETED.equals(action)) &#123;</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        <span class="keyword">if</span> (extras != <span class="keyword">null</span> &amp;&amp; extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);</span><br><span class="line">            <span class="keyword">this</span>.onDeleted(context, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; appWidgetId &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED.equals(action)) &#123;</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        <span class="keyword">if</span> (extras != <span class="keyword">null</span> &amp;&amp; extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID)</span><br><span class="line">                &amp;&amp; extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS)) &#123;</span><br><span class="line">            <span class="keyword">int</span> appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);</span><br><span class="line">            Bundle widgetExtras = extras.getBundle(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS);</span><br><span class="line">            <span class="keyword">this</span>.onAppWidgetOptionsChanged(context, AppWidgetManager.getInstance(context),</span><br><span class="line">                    appWidgetId, widgetExtras);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_ENABLED.equals(action)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onEnabled(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_DISABLED.equals(action)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onDisabled(context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_RESTORED.equals(action)) &#123;</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] oldIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS);</span><br><span class="line">            <span class="keyword">int</span>[] newIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);</span><br><span class="line">            <span class="keyword">if</span> (oldIds != <span class="keyword">null</span> &amp;&amp; oldIds.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.onRestored(context, oldIds, newIds);</span><br><span class="line">                <span class="keyword">this</span>.onUpdate(context, AppWidgetManager.getInstance(context), newIds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码不复杂主要就是完成以下事件的分发逻辑</p>
<blockquote>
<p><strong>ACTION_APPWIDGET_UPDATE -&gt; onUpdate</strong></p>
<p><strong>ACTION_APPWIDGET_DELETED -&gt; onDeleted</strong></p>
<p><strong>ACTION_APPWIDGET_OPTIONS_CHANGED -&gt; onAppWidgetOptionsChanged</strong></p>
<p><strong>ACTION_APPWIDGET_ENABLED -&gt; onEnabled</strong></p>
<p><strong>ACTION_APPWIDGET_DISABLED -&gt; onDisabled</strong></p>
<p><strong>ACTION_APPWIDGET_RESTORED -&gt; onRestored</strong></p>
</blockquote>
<h2 id="基本属性与说明"><a href="#基本属性与说明" class="headerlink" title="基本属性与说明"></a>基本属性与说明</h2><p>该类将BroadcastReceiver扩展为一个方便的类来处理小部件广播。它只接收与小部件相关的事件广播，例如当小部件被更新、删除、启用和禁用时。当这些广播事件发生时，将调用以下方法：</p>
<ul>
<li>onUpdate</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpdate</span><span class="params">(Context context, AppWidgetManager appWidgetManager, <span class="keyword">int</span>[] appWidgetIds)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在前面的<code>AppWidgetProviderInfo</code>中定义了<code>updatePeriodMillis</code>，系统会根据这个时间周期性的产生<em>ACTION_APPWIDGET_UPDATE</em>事件。当用户添加widget时也会产生这一事件。</p>
<p>此方法在用户添加小部件时也会调用，因此它应执行基本设置，例如为 <code>View</code> 对象定义事件处理程序或启动作业以加载要在小部件中显示的数据。但是，如果您声明了一个没有标志的配置活动，则在用户添加小部件时<strong>不会调用此方法</strong>，而是为后续更新调用此方法。配置活动负责在配置完成后执行第一次更新。</p>
<ul>
<li>onAppWidgetOptionsChanged</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAppWidgetOptionsChanged</span><span class="params">(Context context, AppWidgetManager appWidgetManager,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> appWidgetId, Bundle newOptions)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一次放置小部件或调整小部件的大小时产生这一事件。使用此回调可以根据小部件的大小范围显示或隐藏内容或者获取大小范围。</p>
<p>通过<code>AppWidgetManager.getAppWidgetOptions(appWidgetId)</code>可以获取对应WidgetId的Bundle，其中包括以下内容：</p>
<blockquote>
<p><strong>OPTION_APPWIDGET_MIN_WIDTH</strong>：包含小部件实例的宽度下限（单位dp）。</p>
<p><strong>OPTION_APPWIDGET_MIN_HEIGHT</strong>：包含小部件实例高度的下限（单位:dp）。</p>
<p><strong>OPTION_APPWIDGET_MAX_WIDTH</strong>：包含小部件实例的宽度上限（单位:dp）。</p>
<p><strong>OPTION_APPWIDGET_MAX_HEIGHT</strong>：包含小部件实例高度的上限（单位:dp）。</p>
</blockquote>
<ul>
<li>onDeleted</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDeleted</span><span class="params">(Context context, <span class="keyword">int</span>[] appWidgetIds)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次从窗口小部件主机中删除窗口小部件时，都会调用该函数。</p>
<ul>
<li>onEnabled</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEnabled</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在第一次创建小部件的实例时调用。</p>
<p>例如，如果用户添加了两个小部件实例，则这只是第一次调用。如果您需要打开一个新的数据库或执行另一个只需要对所有小部件实例执行一次的设置，那么这是一个很好的地方。</p>
<ul>
<li>onDisabled</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisabled</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建的小部件的最后一个实例从AppWidgetHost中删除时，将调用此函数。</p>
<ul>
<li>onRestored</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRestored</span><span class="params">(Context context, <span class="keyword">int</span>[] oldWidgetIds, <span class="keyword">int</span>[] newWidgetIds)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当AppWidget提供的实例从备份中恢复使调用。此方法调用后，会立即调用onUpdate。</p>
<p>当需要从持久化数据中恢复Widget时，需要重写此方法将旧的AppWidgetID重新映射到新值，并更新任何其他可能相关的状态。</p>
<ul>
<li>onReceive</li>
</ul>
<p>这是为每个广播调用的，通常不需要实现此方法。</p>
<h1 id="RemoteViews"><a href="#RemoteViews" class="headerlink" title="RemoteViews"></a>RemoteViews</h1><p><strong><code>RemoteViews</code>是一个用于描述可在另一个进程中显示的视图层次结构的类。主要用于通知栏和Widget上。</strong></p>
<p>在定义AppWidgetProviderInfo时需要把Widget的布局文件引入，Widget的布局与传统的Android布局文件一样，保存在项目的<code>res/layout/</code>下。</p>
<p>但是需要注意的是，Widget的布局基于RemoteViews，与传统的布局方式不同，并不是每种布局或视图Widget都支持。RemoteViews 仅支持以下布局类型：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">FrameLayout</span><br><span class="line">LinearLayout</span><br><span class="line">RelativeLayout</span><br><span class="line">GridLayout</span><br></pre></td></tr></table></figure>

<p>以及以下控件类：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">AnalogClock</span><br><span class="line">Button</span><br><span class="line">Chronometer</span><br><span class="line">ImageButton</span><br><span class="line">ImageView</span><br><span class="line">ProgressBar</span><br><span class="line">TextView</span><br><span class="line">ViewFlipper</span><br><span class="line">ListView</span><br><span class="line">GridView</span><br><span class="line">StackView</span><br><span class="line">AdapterViewFlipper</span><br></pre></td></tr></table></figure>

<p>Android 12 之后，支持的控件类增加了三个</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">CheckBox</span><br><span class="line">Switch</span><br><span class="line">RadioButton</span><br><span class="line">RadioGroup</span><br></pre></td></tr></table></figure>

<p>RemoteViews 也支持 <code>ViewStub</code>，它是一个大小为零的不可见视图，我们在使用传统布局，进行性能优化时也会经常使用。</p>
<h2 id="常用方法与说明"><a href="#常用方法与说明" class="headerlink" title="常用方法与说明"></a>常用方法与说明</h2><ul>
<li>创建 <code>RemoteViews</code></li>
</ul>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>RemoteViews(String packageName, int layoutId)创建一个新的 RemoteViews 对象，该对象将显示指定布局文件中包含的视图。</td>
</tr>
<tr>
<td>RemoteViews(String packageName, int layoutId, int viewId)创建一个新的 RemoteViews 对象，该对象将显示指定布局文件中包含的视图，并将根视图的 ID 更改为指定的 id。</td>
</tr>
<tr>
<td>RemoteViews(RemoteViews landscape, RemoteViews portrait)创建一个新的 RemoteViews 对象，该对象将填充为指定的横向或纵向 RemoteViews，具体取决于当前配置。</td>
</tr>
<tr>
<td>RemoteViews(Map&lt;SizeF, RemoteViews&gt; remoteViews)创建一个新的 RemoteViews 对象，该对象将使用最接近的大小规范来膨胀布局。</td>
</tr>
<tr>
<td>RemoteViews(RemoteViews src)基于RemoteViews创建一个副本。</td>
</tr>
</tbody></table>
<ul>
<li>设定文字</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTextViewText</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, CharSequence text)</span></span></span><br></pre></td></tr></table></figure>

<p>相当于<code>TextVIew.setText()</code>,<code>setTextViewText</code>内部使用了<code>setCharSequence</code>，所以其实也可以调用<code>setCharSequence</code>来完成设定文字的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextViewText</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, CharSequence text)</span> </span>&#123;</span><br><span class="line">    setCharSequence(viewId, <span class="string">&quot;setText&quot;</span>, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设定字体颜色</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTextColor</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, <span class="meta">@ColorInt</span> <span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(viewId, <span class="string">&quot;setTextColor&quot;</span>, color)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>设定字体大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTextViewTextSize</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, <span class="keyword">int</span> units, <span class="keyword">float</span> size)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>设定图片</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setImageViewResource</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, <span class="meta">@DrawableRes</span> <span class="keyword">int</span> srcId)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(viewId, <span class="string">&quot;setImageResource&quot;</span>, srcId)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setImageViewUri</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, Uri uri)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUri</span><span class="params">(viewId, <span class="string">&quot;setImageURI&quot;</span>, uri)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setImageViewBitmap</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, Bitmap bitmap)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBitmap</span><span class="params">(viewId, <span class="string">&quot;setImageBitmap&quot;</span>, bitmap)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setImageViewIcon</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, Icon icon)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setIcon</span><span class="params">(viewId, <span class="string">&quot;setImageIcon&quot;</span>, icon)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>设定单个控件的点击事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOnClickPendingIntent</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, PendingIntent pendingIntent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOnClickResponse</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, <span class="meta">@NonNull</span> RemoteResponse response)</span> </span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> url = <span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_VIEW)</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)</span><br><span class="line">intent.<span class="keyword">data</span> = Uri.parse(url)</span><br><span class="line"><span class="keyword">val</span> pending = PendingIntent.getActivity(context, <span class="number">0</span>, intent, PendingIntent.FLAG_MUTABLE)</span><br><span class="line">views.setOnClickPendingIntent(R.id.appwidget_text, pending)</span><br><span class="line"></span><br><span class="line">appWidgetManager.updateAppWidget(appWidgetId, views)</span><br></pre></td></tr></table></figure>

<ul>
<li>设定ProgressBar</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setProgressBar</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, <span class="keyword">int</span> max, <span class="keyword">int</span> progress,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">boolean</span> indeterminate)</span></span></span><br></pre></td></tr></table></figure>

<p>或者使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setBoolean(viewId, <span class="string">&quot;setIndeterminate&quot;</span>, indeterminate);</span><br><span class="line"><span class="keyword">if</span> (!indeterminate) &#123;</span><br><span class="line">    setInt(viewId, <span class="string">&quot;setMax&quot;</span>, max);</span><br><span class="line">    setInt(viewId, <span class="string">&quot;setProgress&quot;</span>, progress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调整RemoteViews的布局属性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setViewLayoutMargin</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, <span class="meta">@MarginType</span> <span class="keyword">int</span> type, <span class="keyword">float</span> value, <span class="meta">@ComplexDimensionUnit</span> <span class="keyword">int</span> units)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setViewLayoutHeight</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, <span class="keyword">float</span> height, <span class="meta">@ComplexDimensionUnit</span> <span class="keyword">int</span> units)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setViewLayoutWidth</span><span class="params">(<span class="meta">@IdRes</span> <span class="keyword">int</span> viewId, <span class="keyword">float</span> width, <span class="meta">@ComplexDimensionUnit</span> <span class="keyword">int</span> units)</span></span></span><br></pre></td></tr></table></figure>

<p>以上就是常用的一些方法，更多API，请参考官方文档：<a href="https://developer.android.google.cn/reference/android/widget/RemoteViews">RemoteViews  |  Android Developers</a></p>
<h1 id="Widget进阶用法"><a href="#Widget进阶用法" class="headerlink" title="Widget进阶用法"></a>Widget进阶用法</h1><h2 id="优化更新方法"><a href="#优化更新方法" class="headerlink" title="优化更新方法"></a>优化更新方法</h2><p>在<code>AppWidgetProvider</code>中更新RemoteViews有以下三种不同方式可供选择：</p>
<h3 id="完整更新"><a href="#完整更新" class="headerlink" title="完整更新"></a>完整更新</h3><p>调用<code>AppWidgetManager.updateAppWidget</code>可以完整更新整个 widget。性能成本最大。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> appWidgetManager = AppWidgetManager.getInstance(context)</span><br><span class="line"><span class="keyword">val</span> views = RemoteViews(context.packageName, R.layout.simple_widget)</span><br><span class="line">views.setTextViewText(R.id.appwidget_text, widgetText)</span><br><span class="line"></span><br><span class="line">appWidgetManager.updateAppWidget(appWidgetId, views)</span><br></pre></td></tr></table></figure>

<h3 id="部分更新"><a href="#部分更新" class="headerlink" title="部分更新"></a>部分更新</h3><p>调用<code>AppWidgetManager.partialupdateAppWidget</code>可以只更新小部件指定的部分。此更新与<code>updateAppWidget</code>的不同之处在于，传递的RemoteViews对象被理解为小部件的不完整表示，因此AppWidgetService不会缓存它。</p>
<blockquote>
<p>注意，由于这些更新没有缓存，因此在使用AppWidgetService中的缓存版本还原Widget的情况下，它们修改的任何未由restoreInstanceState还原的状态都不会持久。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> appWidgetManager = AppWidgetManager.getInstance(context)</span><br><span class="line"><span class="keyword">val</span> views = RemoteViews(context.packageName, R.layout.simple_widget)</span><br><span class="line">views.setTextViewText(R.id.appwidget_text, widgetText)</span><br><span class="line"></span><br><span class="line">appWidgetManager.partiallyUpdateAppWidget(appWidgetId, views)</span><br></pre></td></tr></table></figure>

<h3 id="集合数据的更新"><a href="#集合数据的更新" class="headerlink" title="集合数据的更新"></a>集合数据的更新</h3><p>在RemoteViews中使用StackView、ListView、GridView时，需要使用<br> <code>AppWidgetManager.notifyAppWidgetViewDataChanged</code>来更新视图的集合数据，这将触发<code>RemoteViewsFactory.onDataSetChanged</code>。在此期间，旧数据将显示在Widget中。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> appWidgetManager = AppWidgetManager.getInstance(context)</span><br><span class="line">appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetId, R.id.widget_listview)</span><br></pre></td></tr></table></figure>

<p>集合Widget专门用于显示许多相同类型的元素，例如来自图库应用程序的图片集合、来自新闻应用程序的文章集合或来自通信应用程序的消息集合。</p>
<h2 id="优化更新频率"><a href="#优化更新频率" class="headerlink" title="优化更新频率"></a>优化更新频率</h2><h3 id="定期更新"><a href="#定期更新" class="headerlink" title="定期更新"></a>定期更新</h3><p>定期更新Widget很常见，但是<code>updatePeriodMillis</code>不能设定小于30分钟的数值，如果需要小于30分钟定时更新事件，建议搭配<code>WorkManger</code>使用，同时要把<code>updatePeriodMillis</code>设为0，禁用Widget的定期更新。</p>
<h3 id="依据广播的更新"><a href="#依据广播的更新" class="headerlink" title="依据广播的更新"></a>依据广播的更新</h3><p>在车载HMI的开发中，有时候需要依据广播更新Widget，比较常见的是地图Widget，可选的做法是根据Location广播更新Widget。</p>
<p>根据广播更新Widget有以下注意事项：</p>
<p><strong>更新持续时间</strong></p>
<p>通常，系统允许广播接收器（通常在应用程序的主线程中运行）运行10 秒，然后再将其视为无响应并触发ANR错误。如果更新小组件需要更多时间，需要考虑以下替代方法：</p>
<ul>
<li>使用 WorkManager</li>
<li>使用<code>BroadcastReceiver.``goAsync</code>方法为接收方提供更多时间。这允许接收器执行 30 秒。但是，在此处执行的任何工作都会阻止进一步的广播，直到它完成为止，因此过度利用这一点可能会适得其反，并导致以后的事件接收速度更慢</li>
</ul>
<p><strong>更新优先级</strong></p>
<p>默认情况下，广播作为后台进程运行，这意味着当系统资源紧张时可能会导致广播接收器调用延迟。可以通过将广播设定为前台广播<code>Intent.FLAG_RECEIVER_FOREGROUND</code>，提高广播的优先级。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/images/android_aosp_car_widget04.png" alt="img"></p>
<p>最后我们再总结一下Widget的使用方法，<code>&lt;appwidget-provider&gt;</code>用于定义widget的基本属性和初始布局。<code>AppWidgetProvider</code>本质上就是一个广播接收器，我们在<code>AppWidgetProvider</code>中使用<code>RemoteViews</code>显示UI并填充数据，最后使用<code>AppWidgetManger</code>刷新UI。</p>
<p>在车载Android系统中，虽然Widget的宿主也是Launcher，但是由于Launcher一般是我们自己重新开发的，所以，如何容纳Widget也是需要Launcher的开发者额外开发的，这块的内容比较复杂，建议阅读<a href="https://developer.android.google.cn/guide/topics/appwidgets/host?hl=zh-cn#java">构建应用Widget宿主</a>，并参考AOSP-Launcher3的源码实现。</p>
]]></content>
      <categories>
        <category>Android系统开发</category>
        <category>车联网</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
        <tag>车载多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>Android车载多媒体应用LocalMedia</title>
    <url>/2021/10/10/android_aosp_local_media/</url>
    <content><![CDATA[<p>LocalMedia 是 AndroidCar 中自带的本地音乐播放器，它可以识别出系统中的音乐，并进行播放。本质上属于一个功能比较完善的Demo，官方的目的可能是为了演示如何使用 MediaSession 框架写一个音乐播放器。关于MediaSession框架之前已经介绍过了，本篇就简单解析一下这个Demo。</p>
<span id="more"></span>

<h1 id="LocalMedia源码组成"><a href="#LocalMedia源码组成" class="headerlink" title="LocalMedia源码组成"></a>LocalMedia源码组成</h1><p>源码包主要由三部分构成：</p>
<ul>
<li><p><strong>com.android.car.media.localmediaplayer</strong><br> 该app是一个Service，主要作用是检索出本地的音乐多媒体，并封装成元数据。</p>
</li>
<li><p><strong>com.android.car.media</strong><br> 主要用于展示HMI和用户交互，源码量非常庞大。</p>
</li>
<li><p><strong>com.android.car.media.common</strong></p>
<p>lib下的基类库，抽成基类主要是为了方便其他应用引用，比如launcher，因为桌面有播放小组件。</p>
</li>
</ul>
<p><img src="/images/android_aosp_local_media01.png" alt="image"></p>
<p>其实还有还有一个进程<strong>android.car.media</strong>，官方给出的注释是这么介绍它的：<br> <strong>CarMediaService</strong> 管理汽车应用程序当前活动的媒体源。 这与 MediaSessionManager 的活动会话不同，因为汽车中只能有一个活动源，通过浏览和播放。在汽车中，活动媒体源不一定有活动的 MediaSession，例如 如果它只是被浏览。 但是，该来源仍被视为活动来源，并且应该是任何与媒体相关的 UI（媒体中心、主屏幕等）中显示的来源。</p>
<p>这里就不介绍<strong>CarMediaService</strong>，在源码中被分类在com.android.car目录下，已经不属于应用的范畴，本质上属于Framework。</p>
<p>我们先来看看<strong>com.android.car.media.localmediaplayer</strong> 是如何实现。</p>
<h1 id="LocalMediaPlayer源码分析"><a href="#LocalMediaPlayer源码分析" class="headerlink" title="LocalMediaPlayer源码分析"></a>LocalMediaPlayer源码分析</h1><p>源码位于：<code>/packages/apps/Car/LocalMediaPlayer</code></p>
<p>应用的源码分析讨论都是一样的，先从AndroidManifest开始。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.android.car.media.localmediaplayer&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:sharedUserId</span>=<span class="string">&quot;com.android.car.media&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 省略不重要的代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/LocalMediaPlayerAppTheme&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.LocalMediaBrowserService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.media.browse.MediaBrowserService&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.PermissionsActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@android:style/Theme.Translucent.NoTitleBar.Fullscreen&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">&quot;distractionOptimized&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看出Service的结构很简单，<code>LocalMediaBrowserService</code>是MediaSession的容器，<code>PermissionsActivity</code>则是负责权限检查和申请。</p>
<h2 id="LocalMediaBrowserService"><a href="#LocalMediaBrowserService" class="headerlink" title="LocalMediaBrowserService"></a>LocalMediaBrowserService</h2><p><code>LocalMediaBrowserService</code>继承自<code>MediaBrowserService</code>，作为一个容器，主要就是用来初始化其它组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="comment">// 创建 DataModel。</span></span><br><span class="line">    mDataModel = <span class="keyword">new</span> DataModel(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 初始化 RootItem</span></span><br><span class="line">    addRootItems();</span><br><span class="line">    <span class="comment">// 创建 MediaSession</span></span><br><span class="line">    mSession = <span class="keyword">new</span> MediaSession(<span class="keyword">this</span>, MEDIA_SESSION_TAG);</span><br><span class="line">    setSessionToken(mSession.getSessionToken());</span><br><span class="line">    <span class="comment">// 媒体播放器，同时也是 MediaSession.Callback</span></span><br><span class="line">    mPlayer = <span class="keyword">new</span> Player(<span class="keyword">this</span>, mSession, mDataModel);</span><br><span class="line">    mSession.setCallback(mPlayer);</span><br><span class="line">    mSession.setFlags(MediaSession.FLAG_HANDLES_MEDIA_BUTTONS</span><br><span class="line">            | MediaSession.FLAG_HANDLES_TRANSPORT_CONTROLS);</span><br><span class="line">    mPlayer.maybeRestoreState();</span><br><span class="line">    <span class="comment">// 广播，用于监听Notification的控制动作</span></span><br><span class="line">    IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    filter.addAction(ACTION_PLAY);</span><br><span class="line">    filter.addAction(ACTION_PAUSE);</span><br><span class="line">    filter.addAction(ACTION_NEXT);</span><br><span class="line">    filter.addAction(ACTION_PREV);</span><br><span class="line">    registerReceiver(mNotificationReceiver, filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 DataModel<br>用来检索设备本地的多媒体数据。其内部主要封装的都是如何在设备上查询各种多媒体数据。</li>
<li>初始化 RootItem</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;MediaBrowser.MediaItem&gt; mRootItems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addRootItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MediaDescription folders = <span class="keyword">new</span> MediaDescription.Builder()</span><br><span class="line">            .setMediaId(FOLDERS_ID)</span><br><span class="line">            .setTitle(getString(R.string.folders_title))</span><br><span class="line">            .setIconUri(Utils.getUriForResource(<span class="keyword">this</span>, R.drawable.ic_folder))</span><br><span class="line">            .build();</span><br><span class="line">    mRootItems.add(<span class="keyword">new</span> MediaBrowser.MediaItem(folders, MediaBrowser.MediaItem.FLAG_BROWSABLE));</span><br><span class="line"></span><br><span class="line">    MediaDescription albums = <span class="keyword">new</span> MediaDescription.Builder()</span><br><span class="line">            .setMediaId(ALBUMS_ID)</span><br><span class="line">            .setTitle(getString(R.string.albums_title))</span><br><span class="line">            .setIconUri(Utils.getUriForResource(<span class="keyword">this</span>, R.drawable.ic_album))</span><br><span class="line">            .build();</span><br><span class="line">    mRootItems.add(<span class="keyword">new</span> MediaBrowser.MediaItem(albums, MediaBrowser.MediaItem.FLAG_BROWSABLE));</span><br><span class="line"></span><br><span class="line">    MediaDescription artists = <span class="keyword">new</span> MediaDescription.Builder()</span><br><span class="line">            .setMediaId(ARTISTS_ID)</span><br><span class="line">            .setTitle(getString(R.string.artists_title))</span><br><span class="line">            .setIconUri(Utils.getUriForResource(<span class="keyword">this</span>, R.drawable.ic_artist))</span><br><span class="line">            .build();</span><br><span class="line">    mRootItems.add(<span class="keyword">new</span> MediaBrowser.MediaItem(artists, MediaBrowser.MediaItem.FLAG_BROWSABLE));</span><br><span class="line"></span><br><span class="line">    MediaDescription genres = <span class="keyword">new</span> MediaDescription.Builder()</span><br><span class="line">            .setMediaId(GENRES_ID)</span><br><span class="line">            .setTitle(getString(R.string.genres_title))</span><br><span class="line">            .setIconUri(Utils.getUriForResource(<span class="keyword">this</span>, R.drawable.ic_genre))</span><br><span class="line">            .build();</span><br><span class="line">    mRootItems.add(<span class="keyword">new</span> MediaBrowser.MediaItem(genres, MediaBrowser.MediaItem.FLAG_BROWSABLE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RootItems是在HMI查询ROOT_ID时返回的一个列表，列表中包含四个默认的<code>MediaItem</code>，而且Flag都是***FLAG_BROWSABLE***表示<code>MediaItem</code>是可浏览的（文件夹）。四个<code>MediaItem</code>对应HMI上显示的四个大类。</p>
<p><img src="/images/android_aosp_local_media02.png" alt="image"></p>
<p><strong>mRootItems</strong>会在onLoadChildren()方法中传给HMI端。HMI端需要调用<strong>MediaBrowser</strong>.subscribe才能触发onLoadChildren()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadChildren</span><span class="params">(String parentId, Result&lt;List&lt;MediaBrowser.MediaItem&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onLoadChildren parentId=&quot;</span> + parentId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (parentId) &#123;</span><br><span class="line">        <span class="keyword">case</span> ROOT_ID:</span><br><span class="line">            result.sendResult(mRootItems);</span><br><span class="line">            mLastCategory = parentId;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建 Player<br>创建本地播放器。内部主要基于MediaPlayer实现。</li>
<li>添加广播监听<br>用来响应Notification中的动作。支持4个动作。</li>
</ul>
<h2 id="检索-封装Audio-DataModel"><a href="#检索-封装Audio-DataModel" class="headerlink" title="检索/封装Audio - DataModel"></a>检索/封装Audio - DataModel</h2><p><code>DataModel</code>主要用于检索设备本地的多媒体数据，提供了以下四种从ContentProvider检索方式。</p>
<h3 id="文件夹-Folder-检索"><a href="#文件夹-Folder-检索" class="headerlink" title="文件夹(Folder)检索"></a>文件夹(Folder)检索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri[] ALL_AUDIO_URI = <span class="keyword">new</span> Uri[] &#123;</span><br><span class="line">        MediaStore.Audio.Media.INTERNAL_CONTENT_URI,</span><br><span class="line">        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueryByFolder</span><span class="params">(String parentId, Result&lt;List&lt;MediaItem&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    FilesystemListTask query = <span class="keyword">new</span> FilesystemListTask(result, ALL_AUDIO_URI, mResolver);</span><br><span class="line">    queryInBackground(result, query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="专辑-Album-检索"><a href="#专辑-Album-检索" class="headerlink" title="专辑(Album)检索"></a>专辑(Album)检索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri[] ALBUMS_URI = <span class="keyword">new</span> Uri[] &#123;</span><br><span class="line">        MediaStore.Audio.Albums.INTERNAL_CONTENT_URI,</span><br><span class="line">        MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueryByAlbum</span><span class="params">(String parentId, Result&lt;List&lt;MediaItem&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    QueryTask query = <span class="keyword">new</span> QueryTask.Builder()</span><br><span class="line">            .setResolver(mResolver)</span><br><span class="line">            .setResult(result)</span><br><span class="line">            .setUri(ALBUMS_URI)</span><br><span class="line">            .setKeyColumn(AudioColumns.ALBUM_KEY)</span><br><span class="line">            .setTitleColumn(AudioColumns.ALBUM)</span><br><span class="line">            .setFlags(MediaItem.FLAG_BROWSABLE)</span><br><span class="line">            .build();</span><br><span class="line">    queryInBackground(result, query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="艺术家-Artist-检索"><a href="#艺术家-Artist-检索" class="headerlink" title="艺术家(Artist)检索"></a>艺术家(Artist)检索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri[] ARTISTS_URI = <span class="keyword">new</span> Uri[] &#123;</span><br><span class="line">        MediaStore.Audio.Artists.INTERNAL_CONTENT_URI,</span><br><span class="line">        MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueryByArtist</span><span class="params">(String parentId, Result&lt;List&lt;MediaItem&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    QueryTask query = <span class="keyword">new</span> QueryTask.Builder()</span><br><span class="line">            .setResolver(mResolver)</span><br><span class="line">            .setResult(result)</span><br><span class="line">            .setUri(ARTISTS_URI)</span><br><span class="line">            .setKeyColumn(AudioColumns.ARTIST_KEY)</span><br><span class="line">            .setTitleColumn(AudioColumns.ARTIST)</span><br><span class="line">            .setFlags(MediaItem.FLAG_BROWSABLE)</span><br><span class="line">            .build();</span><br><span class="line">    queryInBackground(result, query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流派-Genre-检索"><a href="#流派-Genre-检索" class="headerlink" title="流派(Genre)检索"></a>流派(Genre)检索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri[] GENRES_URI = <span class="keyword">new</span> Uri[] &#123;</span><br><span class="line">        MediaStore.Audio.Genres.INTERNAL_CONTENT_URI,</span><br><span class="line">        MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueryByGenre</span><span class="params">(String parentId, Result&lt;List&lt;MediaItem&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    QueryTask query = <span class="keyword">new</span> QueryTask.Builder()</span><br><span class="line">            .setResolver(mResolver)</span><br><span class="line">            .setResult(result)</span><br><span class="line">            .setUri(GENRES_URI)</span><br><span class="line">            .setKeyColumn(MediaStore.Audio.Genres._ID)</span><br><span class="line">            .setTitleColumn(MediaStore.Audio.Genres.NAME)</span><br><span class="line">            .setFlags(MediaItem.FLAG_BROWSABLE)</span><br><span class="line">            .build();</span><br><span class="line">    queryInBackground(result, query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模糊检索"><a href="#模糊检索" class="headerlink" title="模糊检索"></a>模糊检索</h3><p>该方法主要就是检索出设备中所有的Audio数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUERY_BY_KEY_WHERE_CLAUSE =</span><br><span class="line">        AudioColumns.ALBUM_KEY + <span class="string">&quot;= ? or &quot;</span></span><br><span class="line">                + AudioColumns.ARTIST_KEY + <span class="string">&quot; = ? or &quot;</span></span><br><span class="line">                + AudioColumns.TITLE_KEY + <span class="string">&quot; = ? or &quot;</span></span><br><span class="line">                + AudioColumns.DATA + <span class="string">&quot; like ?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：这会清除队列。 在调用此方法之前，应该拥有队列的本地备份。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueryByKey</span><span class="params">(String lastCategory, String parentId, Result&lt;List&lt;MediaItem&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">    mQueue.clear();</span><br><span class="line">    QueryTask.Builder query = <span class="keyword">new</span> QueryTask.Builder()</span><br><span class="line">            .setResolver(mResolver)</span><br><span class="line">            .setResult(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LocalMediaBrowserService.GENRES_ID.equals(lastCategory)) &#123;</span><br><span class="line">        <span class="comment">// Genre来自不同的表，并且不使用通常媒体表中的 where 子句，因此我们需要有这个条件。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> id = Long.parseLong(parentId);</span><br><span class="line">            query.setUri(<span class="keyword">new</span> Uri[] &#123;</span><br><span class="line">                MediaStore.Audio.Genres.Members.getContentUri(EXTERNAL, id),</span><br><span class="line">                MediaStore.Audio.Genres.Members.getContentUri(INTERNAL, id) &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生。</span></span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Incorrect key type: &quot;</span> + parentId + <span class="string">&quot;, sending empty result&quot;</span>);</span><br><span class="line">            result.sendResult(<span class="keyword">new</span> ArrayList&lt;MediaItem&gt;());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        query.setUri(ALL_AUDIO_URI)</span><br><span class="line">                .setWhereClause(QUERY_BY_KEY_WHERE_CLAUSE)</span><br><span class="line">                .setWhereArgs(<span class="keyword">new</span> String[] &#123; parentId, parentId, parentId, parentId &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    query.setKeyColumn(AudioColumns.TITLE_KEY)</span><br><span class="line">            .setTitleColumn(AudioColumns.TITLE)</span><br><span class="line">            .setSubtitleColumn(AudioColumns.ALBUM)</span><br><span class="line">            .setFlags(MediaItem.FLAG_PLAYABLE)</span><br><span class="line">            .setQueue(mQueue);</span><br><span class="line">    queryInBackground(result, query.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QueryTask"><a href="#QueryTask" class="headerlink" title="QueryTask"></a>QueryTask</h3><p>由于ContentProvider#query是一个耗时方法，所以需要放在子线程中执行，于是就有了<strong>QueryTask</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</span><br><span class="line">    List&lt;MediaItem&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">long</span> idx = <span class="number">0</span>;</span><br><span class="line">    Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Uri uri : mUris) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cursor = mResolver.query(uri, mColumns, mWhereClause, mWhereArgs, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> keyColumn = cursor.getColumnIndex(mKeyColumn);</span><br><span class="line">                <span class="keyword">int</span> titleColumn = cursor.getColumnIndex(mTitleColumn);</span><br><span class="line">                <span class="keyword">int</span> pathColumn = cursor.getColumnIndex(AudioColumns.DATA);</span><br><span class="line">                <span class="keyword">int</span> subtitleColumn = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (mSubtitleColumn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    subtitleColumn = cursor.getColumnIndex(mSubtitleColumn);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">                    Bundle path = <span class="keyword">new</span> Bundle();</span><br><span class="line">                    <span class="keyword">if</span> (pathColumn != -<span class="number">1</span>) &#123;</span><br><span class="line">                        path.putString(PATH_KEY, cursor.getString(pathColumn));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    MediaDescription.Builder builder = <span class="keyword">new</span> MediaDescription.Builder()</span><br><span class="line">                            .setMediaId(cursor.getString(keyColumn))</span><br><span class="line">                            .setTitle(cursor.getString(titleColumn))</span><br><span class="line">                            .setExtras(path);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (subtitleColumn != -<span class="number">1</span>) &#123;</span><br><span class="line">                        builder.setSubtitle(cursor.getString(subtitleColumn));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    MediaDescription description = builder.build();</span><br><span class="line">                    results.add(<span class="keyword">new</span> MediaItem(description, mFlags));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 我们在这里重建队列，所以如果用户选择项目，那么我们可以立即使用这个队列。</span></span><br><span class="line">                    <span class="keyword">if</span> (mQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mQueue.add(<span class="keyword">new</span> QueueItem(description, idx));</span><br><span class="line">                    &#125;</span><br><span class="line">                    idx++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLiteException e) &#123;</span><br><span class="line">            <span class="comment">// 有时，如果媒体扫描尚未看到该类型的数据，则表不存在。</span></span><br><span class="line">            <span class="comment">// 例如，在第一次遇到具有流派的歌曲之前，流派表似乎根本不存在。</span></span><br><span class="line">            <span class="comment">// 如果我们遇到异常，则永远不会发送结果导致另一端挂断，这是一件坏事。</span></span><br><span class="line">            <span class="comment">// 相反，我们可以保持弹性并返回一个空列表。</span></span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Failed to execute query &quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mResult.sendResult(results);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// 忽略.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>QueryTask</strong>从名字上就能猜出来，是一个AsyncTask，而且实际只用到了<code>doInBackground()</code>，在后台执行完查询结果后，执行<code>mResult.sendResult(results)</code>，结果就会从Service传递给HMI。QueryTask封装了多个可配置参数，还用到一个简单建造者模式，不过我们自己改写的话，用比<strong>AsyncTask</strong>更轻量的一些的<strong>线程池</strong>或<strong>协程</strong>即可。</p>
<h3 id="FilesystemListTask"><a href="#FilesystemListTask" class="headerlink" title="FilesystemListTask"></a>FilesystemListTask</h3><p>FilesystemListTask 与 QueryTask 一样都是 AsyncTask，FilesystemListTask 主要用于<strong>文件夹检索</strong>，为了便于理解代码，没有和QueryTask封装在一起。如果强行写在一起，看起来非常奇怪并且过度参数化，有可能变得更加冗长。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; paths = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">    Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Uri uri : mUris) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cursor = mResolver.query(uri, COLUMNS, <span class="keyword">null</span> , <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> pathColumn = cursor.getColumnIndex(AudioColumns.DATA);</span><br><span class="line">                <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">                    <span class="comment">// 我们想要对每首歌曲的路径进行重复数据删除，因此我们只得到一个包含目录的列表。</span></span><br><span class="line">                    String fullPath = cursor.getString(pathColumn);</span><br><span class="line">                    <span class="keyword">int</span> fileNameStart = fullPath.lastIndexOf(File.separator);</span><br><span class="line">                    <span class="keyword">if</span> (fileNameStart &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String dirPath = fullPath.substring(<span class="number">0</span>, fileNameStart);</span><br><span class="line">                    paths.add(dirPath);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLiteException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Failed to execute query &quot;</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cursor.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出去重目录列表，并将它们放入结果列表中，以完整目录路径为键，以便我们稍后进行匹配。</span></span><br><span class="line">    List&lt;MediaItem&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">        <span class="keyword">int</span> dirNameStart = path.lastIndexOf(File.separator) + <span class="number">1</span>;</span><br><span class="line">        String dirName = path.substring(dirNameStart, path.length());</span><br><span class="line">        <span class="comment">//在封装为 MediaItem</span></span><br><span class="line">        MediaDescription description = <span class="keyword">new</span> MediaDescription.Builder()</span><br><span class="line">                .setMediaId(path + <span class="string">&quot;%&quot;</span>)  <span class="comment">// 在类似查询中使用。</span></span><br><span class="line">                .setTitle(dirName)</span><br><span class="line">                .setSubtitle(path)</span><br><span class="line">                .build();</span><br><span class="line">        results.add(<span class="keyword">new</span> MediaItem(description, MediaItem.FLAG_BROWSABLE));</span><br><span class="line">    &#125;</span><br><span class="line">    mResult.sendResult(results);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="媒体播放器-Player"><a href="#媒体播放器-Player" class="headerlink" title="媒体播放器-Player"></a>媒体播放器-Player</h2><p>Player继承<code>MediaSession.Callback</code>，所以需要处理HMI端调用<code>MediaController.transportControls.xxx</code>的对应方法。在内部逻辑主要就是记录播放状态和处理音频焦点。</p>
<h3 id="初始化媒体播放器"><a href="#初始化媒体播放器" class="headerlink" title="初始化媒体播放器"></a>初始化媒体播放器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(Context context, MediaSession session, DataModel dataModel)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mDataModel = dataModel;</span><br><span class="line">    <span class="comment">// 创建AudioManager</span></span><br><span class="line">    mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line"></span><br><span class="line">    mSession = session;</span><br><span class="line">    <span class="comment">// 创建SharedPreferences用于记录播放状态</span></span><br><span class="line">    mSharedPrefs = context.getSharedPreferences(SHARED_PREFS_NAME, Context.MODE_PRIVATE);</span><br><span class="line"></span><br><span class="line">    mShuffle = <span class="keyword">new</span> CustomAction.Builder(SHUFFLE, context.getString(R.string.shuffle),</span><br><span class="line">            R.drawable.shuffle).build();</span><br><span class="line"></span><br><span class="line">    mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">    mMediaPlayer.reset();</span><br><span class="line">    mMediaPlayer.setOnCompletionListener(mOnCompletionListener);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化播放器状态，这里设定为error状态</span></span><br><span class="line">    mErrorState = <span class="keyword">new</span> PlaybackState.Builder()</span><br><span class="line">            .setState(PlaybackState.STATE_ERROR, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            .setErrorMessage(context.getString(R.string.playback_error))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Notification</span></span><br><span class="line">    mNotificationManager =</span><br><span class="line">            (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">    <span class="comment">// 媒体通知有两种形式，播放时需要显示暂停和跳过的控件，暂停时需要显示播放和跳过的控件。</span></span><br><span class="line">    <span class="comment">// 预先为这两个设置预先填充的构建器。</span></span><br><span class="line">    Notification.Action prevAction = makeNotificationAction(</span><br><span class="line">            LocalMediaBrowserService.ACTION_PREV, R.drawable.ic_prev, R.string.prev);</span><br><span class="line">    Notification.Action nextAction = makeNotificationAction(</span><br><span class="line">            LocalMediaBrowserService.ACTION_NEXT, R.drawable.ic_next, R.string.next);</span><br><span class="line">    Notification.Action playAction = makeNotificationAction(</span><br><span class="line">            LocalMediaBrowserService.ACTION_PLAY, R.drawable.ic_play, R.string.play);</span><br><span class="line">    Notification.Action pauseAction = makeNotificationAction(</span><br><span class="line">            LocalMediaBrowserService.ACTION_PAUSE, R.drawable.ic_pause, R.string.pause);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 播放时，需要上一个，暂停，下一个。</span></span><br><span class="line">    mPlayingNotificationBuilder = <span class="keyword">new</span> Notification.Builder(context)</span><br><span class="line">            .setVisibility(Notification.VISIBILITY_PUBLIC)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_sd_storage_black)</span><br><span class="line">            .addAction(prevAction)</span><br><span class="line">            .addAction(pauseAction)</span><br><span class="line">            .addAction(nextAction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停时，需要上一个，播放，下一个。</span></span><br><span class="line">    mPausedNotificationBuilder = <span class="keyword">new</span> Notification.Builder(context)</span><br><span class="line">            .setVisibility(Notification.VISIBILITY_PUBLIC)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_sd_storage_black)</span><br><span class="line">            .addAction(prevAction)</span><br><span class="line">            .addAction(playAction)</span><br><span class="line">            .addAction(nextAction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Notification.Action </span></span><br><span class="line"><span class="keyword">private</span> Notification.<span class="function">Action <span class="title">makeNotificationAction</span><span class="params">(String action, <span class="keyword">int</span> iconId, <span class="keyword">int</span> stringId)</span> </span>&#123;</span><br><span class="line">    PendingIntent intent = PendingIntent.getBroadcast(mContext, REQUEST_CODE,</span><br><span class="line">            <span class="keyword">new</span> Intent(action), PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">    Notification.Action notificationAction = <span class="keyword">new</span> Notification.Action.Builder(iconId,</span><br><span class="line">            mContext.getString(stringId), intent)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">return</span> notificationAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> OnCompletionListener mOnCompletionListener = <span class="keyword">new</span> OnCompletionListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(MediaPlayer mediaPlayer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onCompletion()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        safeAdvance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="处理音频焦点"><a href="#处理音频焦点" class="headerlink" title="处理音频焦点"></a>处理音频焦点</h3><p>关于如何管理音频焦点可参考官方文档</p>
<p><a href="https://developer.android.google.cn/guide/topics/media-apps/audio-focus?hl=zh-cn">Android Developer</a></p>
<p>这里我们看下LocalMedia中的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请音频焦点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">requestAudioFocus</span><span class="params">(Runnable onSuccess)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = mAudioManager.requestAudioFocus(mAudioFocusListener, AudioManager.STREAM_MUSIC,</span><br><span class="line">            AudioManager.AUDIOFOCUS_GAIN);</span><br><span class="line">    <span class="keyword">if</span> (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) &#123;</span><br><span class="line">        onSuccess.run();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;Failed to acquire audio focus&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听音频焦点变化</span></span><br><span class="line"><span class="keyword">private</span> OnAudioFocusChangeListener mAudioFocusListener = <span class="keyword">new</span> OnAudioFocusChangeListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (focus) &#123;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_GAIN:</span><br><span class="line">                resumePlayback();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS:</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:</span><br><span class="line">            <span class="keyword">case</span> AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:</span><br><span class="line">                pausePlayback();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Unhandled audio focus type: &quot;</span> + focus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="播放指定的媒体"><a href="#播放指定的媒体" class="headerlink" title="播放指定的媒体"></a>播放指定的媒体</h3><p>在HMI端调用 <code>MediaController.transportControls.playFromMediaId()</code>时触发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPlayFromMediaId</span><span class="params">(String mediaId, Bundle extras)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPlayFromMediaId(mediaId, extras);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPlayFromMediaId mediaId&quot;</span> + mediaId + <span class="string">&quot; extras=&quot;</span> + extras);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试申请音频焦点，申请成功则执行 startPlayback</span></span><br><span class="line">    requestAudioFocus(() -&gt; startPlayback(mediaId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPlayback</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;startPlayback()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;QueueItem&gt; queue = mDataModel.getQueue();</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> foundIdx = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (QueueItem item : queue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.getDescription().getMediaId().equals(key)) &#123;</span><br><span class="line">            foundIdx = idx;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (foundIdx == -<span class="number">1</span>) &#123;</span><br><span class="line">        mSession.setPlaybackState(mErrorState);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = <span class="keyword">new</span> ArrayList&lt;&gt;(queue);</span><br><span class="line">    mCurrentQueueIdx = foundIdx;</span><br><span class="line">    QueueItem current = mQueue.get(mCurrentQueueIdx);</span><br><span class="line">    String path = current.getDescription().getExtras().getString(DataModel.PATH_KEY);</span><br><span class="line">    MediaMetadata metadata = mDataModel.getMetadata(current.getDescription().getMediaId());</span><br><span class="line">    updateSessionQueueState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        play(path, metadata);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Playback failed.&quot;</span>, e);</span><br><span class="line">        mSession.setPlaybackState(mErrorState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String path, MediaMetadata metadata)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;play path=&quot;</span> + path + <span class="string">&quot; metadata=&quot;</span> + metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    mMediaPlayer.reset();</span><br><span class="line">    mMediaPlayer.setDataSource(path);</span><br><span class="line">    mMediaPlayer.prepare();</span><br><span class="line">    <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSession.setMetadata(metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断此时是否获取到音频焦点</span></span><br><span class="line">    <span class="keyword">boolean</span> wasGrantedAudio = requestAudioFocus(() -&gt; &#123;</span><br><span class="line">        mMediaPlayer.start();</span><br><span class="line">        updatePlaybackStatePlaying();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 没有获取到音频焦点，则暂停播放</span></span><br><span class="line">    <span class="keyword">if</span> (!wasGrantedAudio) &#123;</span><br><span class="line">        pausePlayback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getMetadata()</code>是<strong>DataModel</strong>中的方法，主要就是将从ContentProvider中查询到的原始数据，封装成元数据。下面的代码，演示了如何封装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MediaMetadata <span class="title">getMetadata</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">    MediaMetadata.Builder metadata = <span class="keyword">new</span> MediaMetadata.Builder();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Uri uri : ALL_AUDIO_URI) &#123;</span><br><span class="line">            cursor = mResolver.query(uri, <span class="keyword">null</span>, AudioColumns.TITLE_KEY + <span class="string">&quot; = ?&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123; key &#125;, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> title = cursor.getColumnIndex(AudioColumns.TITLE);</span><br><span class="line">                <span class="keyword">int</span> artist = cursor.getColumnIndex(AudioColumns.ARTIST);</span><br><span class="line">                <span class="keyword">int</span> album = cursor.getColumnIndex(AudioColumns.ALBUM);</span><br><span class="line">                <span class="keyword">int</span> albumId = cursor.getColumnIndex(AudioColumns.ALBUM_ID);</span><br><span class="line">                <span class="keyword">int</span> duration = cursor.getColumnIndex(AudioColumns.DURATION);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (cursor.moveToNext()) &#123;</span><br><span class="line">                    metadata.putString(MediaMetadata.METADATA_KEY_TITLE,</span><br><span class="line">                            cursor.getString(title));</span><br><span class="line">                    metadata.putString(MediaMetadata.METADATA_KEY_ARTIST,</span><br><span class="line">                            cursor.getString(artist));</span><br><span class="line">                    metadata.putString(MediaMetadata.METADATA_KEY_ALBUM,</span><br><span class="line">                            cursor.getString(album));</span><br><span class="line">                    metadata.putLong(MediaMetadata.METADATA_KEY_DURATION,</span><br><span class="line">                            cursor.getLong(duration));</span><br><span class="line"></span><br><span class="line">                    String albumArt = <span class="keyword">null</span>;</span><br><span class="line">                    Uri albumArtUri = ContentUris.withAppendedId(ART_BASE_URI,</span><br><span class="line">                            cursor.getLong(albumId));</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        InputStream dummy = mResolver.openInputStream(albumArtUri);</span><br><span class="line">                        albumArt = albumArtUri.toString();</span><br><span class="line">                        dummy.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// Ignored because the albumArt is intialized correctly anyway.</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    metadata.putString(MediaMetadata.METADATA_KEY_ALBUM_ART_URI, albumArt);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> metadata.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="恢复播放"><a href="#恢复播放" class="headerlink" title="恢复播放"></a>恢复播放</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPlay();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPlay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次尝试播放媒体时都要检查权限</span></span><br><span class="line">    <span class="keyword">if</span> (!Utils.hasRequiredPermissions(mContext)) &#123;</span><br><span class="line">        setMissingPermissionError();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestAudioFocus(() -&gt; resumePlayback());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限检查错误</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMissingPermissionError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动权限申请用的Activity</span></span><br><span class="line">    Intent prefsIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">    prefsIntent.setClass(mContext, PermissionsActivity.class);</span><br><span class="line">    prefsIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    PendingIntent pendingIntent = PendingIntent.getActivity(mContext, <span class="number">0</span>, prefsIntent, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将播放状态设定未ERROR</span></span><br><span class="line">    Bundle extras = <span class="keyword">new</span> Bundle();</span><br><span class="line">    extras.putString(Utils.ERROR_RESOLUTION_ACTION_LABEL,</span><br><span class="line">            mContext.getString(R.string.permission_error_resolve));</span><br><span class="line">    extras.putParcelable(Utils.ERROR_RESOLUTION_ACTION_INTENT, pendingIntent);</span><br><span class="line">    PlaybackState state = <span class="keyword">new</span> PlaybackState.Builder()</span><br><span class="line">            .setState(PlaybackState.STATE_ERROR, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            .setErrorMessage(mContext.getString(R.string.permission_error))</span><br><span class="line">            .setExtras(extras)</span><br><span class="line">            .build();</span><br><span class="line">    mSession.setPlaybackState(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resumePlayback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;resumePlayback()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新播放状态</span></span><br><span class="line">    updatePlaybackStatePlaying();</span><br><span class="line">    <span class="keyword">if</span> (!mMediaPlayer.isPlaying()) &#123;</span><br><span class="line">        mMediaPlayer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>播放时还要同步更新播放状态，并通过MediaSession将状态告知HMI端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新播放状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePlaybackStatePlaying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSession.isActive()) &#123;</span><br><span class="line">        mSession.setActive(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新媒体会话中的状态。</span></span><br><span class="line">    CustomAction action = <span class="keyword">new</span> CustomAction</span><br><span class="line">            .Builder(<span class="string">&quot;android.car.media.localmediaplayer.shuffle&quot;</span>,</span><br><span class="line">            mContext.getString(R.string.shuffle),</span><br><span class="line">            R.drawable.shuffle)</span><br><span class="line">            .build();</span><br><span class="line">    PlaybackState state = <span class="keyword">new</span> PlaybackState.Builder()</span><br><span class="line">            .setState(PlaybackState.STATE_PLAYING,</span><br><span class="line">                    mMediaPlayer.getCurrentPosition(), PLAYBACK_SPEED)</span><br><span class="line">            .setActions(PLAYING_ACTIONS)</span><br><span class="line">            .addCustomAction(action)</span><br><span class="line">            .setActiveQueueItemId(mQueue.get(mCurrentQueueIdx).getQueueId())</span><br><span class="line">            .build();</span><br><span class="line">    mSession.setPlaybackState(state);</span><br><span class="line">    <span class="comment">// 更新媒体样式的通知。</span></span><br><span class="line">    postMediaNotification(mPlayingNotificationBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onPause&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pausePlayback();</span><br><span class="line">    <span class="comment">// 放弃音频焦点</span></span><br><span class="line">    mAudioManager.abandonAudioFocus(mAudioFocusListener);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pausePlayback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;pausePlayback()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> currentPosition = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mMediaPlayer.isPlaying()) &#123;</span><br><span class="line">        currentPosition = mMediaPlayer.getCurrentPosition();</span><br><span class="line">        mMediaPlayer.pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新播放状态</span></span><br><span class="line">    PlaybackState state = <span class="keyword">new</span> PlaybackState.Builder()</span><br><span class="line">            .setState(PlaybackState.STATE_PAUSED, currentPosition, PLAYBACK_SPEED_STOPPED)</span><br><span class="line">            .setActions(PAUSED_ACTIONS)</span><br><span class="line">            .addCustomAction(mShuffle)</span><br><span class="line">            .setActiveQueueItemId(mQueue.get(mCurrentQueueIdx).getQueueId())</span><br><span class="line">            .build();</span><br><span class="line">    mSession.setPlaybackState(state);</span><br><span class="line">    <span class="comment">// 更新媒体的Notification状态。</span></span><br><span class="line">    postMediaNotification(mPausedNotificationBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="终止播放"><a href="#终止播放" class="headerlink" title="终止播放"></a>终止播放</h3><p>在Service被销毁时需要终止播放，并销毁播放器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Service的onDestroy方法中调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stopPlayback();</span><br><span class="line">    mNotificationManager.cancelAll();</span><br><span class="line">    mAudioManager.abandonAudioFocus(mAudioFocusListener);</span><br><span class="line">    mMediaPlayer.release();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopPlayback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;stopPlayback()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMediaPlayer.isPlaying()) &#123;</span><br><span class="line">        mMediaPlayer.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新播放状态</span></span><br><span class="line">    PlaybackState state = <span class="keyword">new</span> PlaybackState.Builder()</span><br><span class="line">            .setState(PlaybackState.STATE_STOPPED, PLAYBACK_POSITION_STOPPED,</span><br><span class="line">                    PLAYBACK_SPEED_STOPPED)</span><br><span class="line">            .setActions(STOPPED_ACTIONS)</span><br><span class="line">            .build();</span><br><span class="line">    mSession.setPlaybackState(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切换下一曲"><a href="#切换下一曲" class="headerlink" title="切换下一曲"></a>切换下一曲</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSkipToNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onSkipToNext()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    safeAdvance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeAdvance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        advance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Failed to advance.&quot;</span>, e);</span><br><span class="line">        mSession.setPlaybackState(mErrorState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;advance()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在，请转到下一首歌曲。</span></span><br><span class="line">    <span class="comment">// 请注意，如果您要支持无缝播放，则必须更改此代码，</span></span><br><span class="line">    <span class="comment">// 以便拥有当前正在播放和正在加载的MediaPlayer，并在它们之间进行切换，同时还调用setNextMediaPlayer。</span></span><br><span class="line">    <span class="keyword">if</span> (mQueue != <span class="keyword">null</span> &amp;&amp; !mQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 当我们跑出当前队列的末尾时，继续循环。</span></span><br><span class="line">        mCurrentQueueIdx = (mCurrentQueueIdx + <span class="number">1</span>) % mQueue.size();</span><br><span class="line">        playCurrentQueueIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 终止播放</span></span><br><span class="line">        stopPlayback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切换上一曲"><a href="#切换上一曲" class="headerlink" title="切换上一曲"></a>切换上一曲</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSkipToPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;onSkipToPrevious()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    safeRetreat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeRetreat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        retreat();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Failed to advance.&quot;</span>, e);</span><br><span class="line">        mSession.setPlaybackState(mErrorState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">retreat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;retreat()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有下一首歌，请转到下一首。请注意，如果要支持无间隙播放，则必须更改此代码，</span></span><br><span class="line">    <span class="comment">// 以便在调用setNextMediaPlayer的同时，拥有当前正在播放和正在加载的MediaPlayer，并在两者之间进行切换。</span></span><br><span class="line">    <span class="keyword">if</span> (mQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当我们跑完当前队列的末尾时，继续循环。</span></span><br><span class="line">        mCurrentQueueIdx--;</span><br><span class="line">        <span class="keyword">if</span> (mCurrentQueueIdx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mCurrentQueueIdx = mQueue.size() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        playCurrentQueueIndex();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 终止播放</span></span><br><span class="line">        stopPlayback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="播放指定的媒体-1"><a href="#播放指定的媒体-1" class="headerlink" title="播放指定的媒体"></a>播放指定的媒体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSkipToQueueItem</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mCurrentQueueIdx = (<span class="keyword">int</span>) id;</span><br><span class="line">        playCurrentQueueIndex();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Failed to play.&quot;</span>, e);</span><br><span class="line">        mSession.setPlaybackState(mErrorState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">playCurrentQueueIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    MediaDescription next = mQueue.get(mCurrentQueueIdx).getDescription();</span><br><span class="line">    String path = next.getExtras().getString(DataModel.PATH_KEY);</span><br><span class="line">    MediaMetadata metadata = mDataModel.getMetadata(next.getMediaId());</span><br><span class="line">    play(path, metadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="随机播放"><a href="#随机播放" class="headerlink" title="随机播放"></a>随机播放</h3><p><strong>随机播放</strong>在<code>MediaSession.Callback</code>中并没有定义，所以需要使用<code>MediaSession.Callback</code>中提供的<strong>onCustomAction</strong>进行拓展。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCustomAction</span><span class="params">(String action, Bundle extras)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> SHUFFLE:</span><br><span class="line">            shuffle();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Unhandled custom action: &quot;</span> + action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是shuffle 的一个简单实现，之前播放的歌曲可能会在shuffle操作后重复。只能从主线程调用此函数。</span></span><br><span class="line"><span class="comment"> * shuffle 可以理解为乱序播放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Shuffling&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以随机的形式重建队列。</span></span><br><span class="line">    <span class="keyword">if</span> (mQueue != <span class="keyword">null</span> &amp;&amp; mQueue.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        QueueItem current = mQueue.remove(mCurrentQueueIdx);</span><br><span class="line">        <span class="comment">// 打乱队列顺序</span></span><br><span class="line">        Collections.shuffle(mQueue);</span><br><span class="line">        mQueue.add(<span class="number">0</span>, current);</span><br><span class="line">        <span class="comment">// QueueItem 包含一个队列 id，当用户选择当前播放列表时，该 id 用作键。</span></span><br><span class="line">        <span class="comment">// 这意味着必须重建 QueueItems 以设置其新 ID。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mQueue.size(); i++) &#123;</span><br><span class="line">            mQueue.set(i, <span class="keyword">new</span> QueueItem(mQueue.get(i).getDescription(), i));</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentQueueIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 更新MediaSession队列状态</span></span><br><span class="line">        updateSessionQueueState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateSessionQueueState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSession.setQueueTitle(mContext.getString(R.string.playlist));</span><br><span class="line">    mSession.setQueue(mQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Media源码分析"><a href="#Media源码分析" class="headerlink" title="Media源码分析"></a>Media源码分析</h1><p>该部分为HMI部分，LocalMedia的源码中HMI部分的量尤其的大，而且包含了很多动画、公共控件，所以HMI的源码分析只介绍播放界面，其它部分暂时不做介绍。</p>
<p><img src="/images/android_aosp_local_media03.png" alt="image"></p>
<p>源码位置：<code>/packages/apps/Car/Media</code></p>
<h2 id="播放界面源码结构"><a href="#播放界面源码结构" class="headerlink" title="播放界面源码结构"></a>播放界面源码结构</h2><p>播放界面就是一个Fragment，而且也是应用开发中很常见的<strong>Fragment+ViewModel+Repository</strong>架构，但是它并没有完全遵守MVVM架构的设计规范，倒不是因为它没有使用DataBinding，而是因为Fragment的实现中直接调用了Repository的方法，这不符合MVVM架构的设计思想。</p>
<p><img src="/images/android_aosp_local_media04.png" alt="img"></p>
<h2 id="MediaSourceViewModel"><a href="#MediaSourceViewModel" class="headerlink" title="MediaSourceViewModel"></a>MediaSourceViewModel</h2><p><code>MediaSourceViewModel</code>通过<code>CarMediaManager</code>来监听当前系统中媒体源，并使用<code>MediaBrowserConnector</code>来连接到<code>MediaBrowserService</code>。</p>
<blockquote>
<p><code>CarMediaManager</code>是Framework层封装的API，主要的通信对象是<code>CarMediaService</code>，关于CarAndroid中Framework层各个Service的实现，我们等车载应用都说完后再来一一解析。这里我们暂时不需要理解，因为在实际的车载应用开发中，<code>CarMediaService</code>往往都会被裁剪掉。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateModelState</span><span class="params">(MediaSource newMediaSource)</span> </span>&#123;</span><br><span class="line">    MediaSource oldMediaSource = mPrimaryMediaSource.getValue();</span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(oldMediaSource, newMediaSource)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 广播新的源</span></span><br><span class="line">    mPrimaryMediaSource.setValue(newMediaSource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从CarMediaManager处拿到媒体源，</span></span><br><span class="line">    <span class="keyword">if</span> (newMediaSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBrowserConnector.connectTo(newMediaSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MediaBrowserConnector mBrowserConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MediaBrowserConnector.Callback mBrowserCallback = <span class="keyword">new</span> MediaBrowserConnector.Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBrowserConnectionChanged</span><span class="params">(<span class="meta">@NonNull</span> BrowsingState state)</span> </span>&#123;</span><br><span class="line">        mBrowsingState.setValue(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>MediaBrowserConnector</code>的连接状态会通过callback返回给<code>MediaSourceViewModel</code>。<code>MediaSourceViewModel</code>则将其封装在LiveData<BrowsingState>中，供其它有需要的模块监听<strong>MediaBrowserService</strong>的连接状态。</p>
<h2 id="MediaBrowserConnector"><a href="#MediaBrowserConnector" class="headerlink" title="MediaBrowserConnector"></a>MediaBrowserConnector</h2><p><code>MediaBrowserConnector</code>的逻辑从名字上就能看出来。主要就是创建<code>MediaBrowserCompat</code>并连接到<strong>MediaBrowserService</strong>，并把连接过程、连接状态以及MediaBrowser的实例封装在BrowsingState中暴露给<code>MediaSourceViewModel</code>完成闭环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果给定的 &#123;<span class="doctag">@link</span> MediaSource&#125; 不为空，则创建并连接一个新的 &#123;<span class="doctag">@link</span> MediaBrowserCompat&#125;。</span></span><br><span class="line"><span class="comment"> * 如果需要，之前的浏览器会断开连接。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mediaSource 要连接的媒体源。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> MediaBrowserCompat#MediaBrowserCompat(Context, ComponentName,</span></span><br><span class="line"><span class="comment"> * MediaBrowserCompat.ConnectionCallback, Bundle)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectTo</span><span class="params">(<span class="meta">@Nullable</span> MediaSource mediaSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBrowser != <span class="keyword">null</span> &amp;&amp; mBrowser.isConnected()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;Disconnecting: &quot;</span> + getSourcePackage()</span><br><span class="line">                    + <span class="string">&quot; mBrowser: &quot;</span> + idHash(mBrowser));</span><br><span class="line">        &#125;</span><br><span class="line">        sendNewState(ConnectionStatus.DISCONNECTING);</span><br><span class="line">        mBrowser.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMediaSource = mediaSource;</span><br><span class="line">    <span class="keyword">if</span> (mMediaSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBrowser = createMediaBrowser(mMediaSource, <span class="keyword">new</span> BrowserConnectionCallback());</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;Connecting to: &quot;</span> + getSourcePackage()</span><br><span class="line">                    + <span class="string">&quot; mBrowser: &quot;</span> + idHash(mBrowser));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendNewState(ConnectionStatus.CONNECTING);</span><br><span class="line">            mBrowser.connect();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="comment">// 这个comment还有效吗？</span></span><br><span class="line">            <span class="comment">// 忽略：MediaBrowse 可能处于中间状态（未连接，但也未断开连接。）</span></span><br><span class="line">            <span class="comment">// 在这种情况下，再次尝试连接可以抛出这个异常，但是不尝试是无法知道的。</span></span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Connection exception: &quot;</span> + ex);</span><br><span class="line">            sendNewState(ConnectionStatus.SUSPENDED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mBrowser = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Override for testing.</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MediaBrowserCompat <span class="title">createMediaBrowser</span><span class="params">(<span class="meta">@NonNull</span> MediaSource mediaSource,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="meta">@NonNull</span> MediaBrowserCompat.ConnectionCallback callback)</span> </span>&#123;</span><br><span class="line">    Bundle rootHints = <span class="keyword">new</span> Bundle();</span><br><span class="line">    rootHints.putInt(MediaConstants.EXTRA_MEDIA_ART_SIZE_HINT_PIXELS, mMaxBitmapSizePx);</span><br><span class="line">    ComponentName browseService = mediaSource.getBrowseServiceComponentName();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MediaBrowserCompat(mContext, browseService, callback, rootHints);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MediaItemRepository"><a href="#MediaItemRepository" class="headerlink" title="MediaItemRepository"></a>MediaItemRepository</h2><p><code>MediaItemRepository</code>对外提供媒体项目搜索和子查询功能。</p>
<p><code>MediaItemRepository</code>使用了单例模式，在创建过程中会从同样基于单例模式的<code>MediaSourceViewModel</code>中获取到<code>LiveData&lt;BrowsingState&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** One instance per MEDIA_SOURCE_MODE. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> MediaItemsRepository[] sInstances = <span class="keyword">new</span> MediaItemsRepository[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回与给定模式的应用程序关联的 MediaItemsRepository“单例”。 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MediaItemsRepository <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> Application application, <span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstances[mode] == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sInstances[mode] = <span class="keyword">new</span> MediaItemsRepository(</span><br><span class="line">                MediaSourceViewModel.get(application, mode).getBrowsingState()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sInstances[mode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MediaItemsRepository</span><span class="params">(LiveData&lt;BrowsingState&gt; browsingState)</span> </span>&#123;</span><br><span class="line">    browsingState.observeForever(<span class="keyword">this</span>::onMediaBrowsingStateChanged);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察LiveData<BrowsingState>，根据不同的连接状态，处理不同的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onMediaBrowsingStateChanged</span><span class="params">(BrowsingState newBrowsingState)</span> </span>&#123;</span><br><span class="line">    mBrowsingState = newBrowsingState;</span><br><span class="line">    <span class="keyword">if</span> (mBrowsingState == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Null browsing state (no media source!)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mBrowsingStateLiveData.setValue(mBrowsingState);</span><br><span class="line">    <span class="keyword">switch</span> (mBrowsingState.mConnectionStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> CONNECTING:</span><br><span class="line">            mRootMediaItems.setLoading();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CONNECTED:</span><br><span class="line">            String rootId = mBrowsingState.mBrowser.getRoot();</span><br><span class="line">            getCache().mRootId = rootId;</span><br><span class="line">            getMediaChildren(rootId);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DISCONNECTING:</span><br><span class="line">            <span class="comment">// 清理数据</span></span><br><span class="line">            unsubscribeNodes();</span><br><span class="line">            clearSearchResults();</span><br><span class="line">            clearNodes();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">        <span class="keyword">case</span> SUSPENDED:</span><br><span class="line">            <span class="comment">// 连接失败</span></span><br><span class="line">            onBrowseData(getCache().mRootId, <span class="keyword">null</span>);</span><br><span class="line">            clearSearchResults();</span><br><span class="line">            clearNodes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果连接成功，默认检索根节点，并更新本地数据。</p>
<h3 id="基于节点检索"><a href="#基于节点检索" class="headerlink" title="基于节点检索"></a>基于节点检索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 返回给定节点的子数据。 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MediaItemsLiveData <span class="title">getMediaChildren</span><span class="params">(String nodeId)</span> </span>&#123;</span><br><span class="line">    PerMediaSourceCache cache = getCache();</span><br><span class="line">    MediaChildren items = cache.mChildrenByNodeId.get(nodeId);</span><br><span class="line">    <span class="keyword">if</span> (items == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将节点缓存起来</span></span><br><span class="line">        items = <span class="keyword">new</span> MediaChildren(nodeId);</span><br><span class="line">        cache.mChildrenByNodeId.put(nodeId, items);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 始终刷新订阅（以解决媒体应用程序中的错误）。</span></span><br><span class="line">    mBrowsingState.mBrowser.unsubscribe(nodeId);</span><br><span class="line">    mBrowsingState.mBrowser.subscribe(nodeId, mBrowseCallback);</span><br><span class="line">    <span class="keyword">return</span> items.mLiveData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在SubscriptionCallback中更新本地缓存数据，同时也更新对外暴露的<code>MediaItemsLiveData</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SubscriptionCallback mBrowseCallback = <span class="keyword">new</span> SubscriptionCallback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChildrenLoaded</span><span class="params">(<span class="meta">@NonNull</span> String parentId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@NonNull</span> List&lt;MediaBrowserCompat.MediaItem&gt; children)</span> </span>&#123;</span><br><span class="line">        onBrowseData(parentId, children.stream()</span><br><span class="line">                .filter(Objects::nonNull)</span><br><span class="line">                .map(MediaItemMetadata::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChildrenLoaded</span><span class="params">(<span class="meta">@NonNull</span> String parentId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@NonNull</span> List&lt;MediaBrowserCompat.MediaItem&gt; children,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="meta">@NonNull</span> Bundle options)</span> </span>&#123;</span><br><span class="line">        onChildrenLoaded(parentId, children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> String parentId)</span> </span>&#123;</span><br><span class="line">        onBrowseData(parentId, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> String parentId, <span class="meta">@NonNull</span> Bundle options)</span> </span>&#123;</span><br><span class="line">        onError(parentId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点的数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBrowseData</span><span class="params">(<span class="meta">@NonNull</span> String parentId, <span class="meta">@Nullable</span> List&lt;MediaItemMetadata&gt; list)</span> </span>&#123;</span><br><span class="line">    PerMediaSourceCache cache = getCache();</span><br><span class="line">    MediaChildren children = cache.mChildrenByNodeId.get(parentId);</span><br><span class="line">    <span class="keyword">if</span> (children == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Log.isLoggable(TAG, Log.WARN)) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;Browse parent not in the cache: &quot;</span> + parentId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新缓存中的数据</span></span><br><span class="line">    List&lt;MediaItemMetadata&gt; old = children.mPreviousValue;</span><br><span class="line">    children.mPreviousValue = list;</span><br><span class="line">    <span class="comment">// MediaItemsLiveData#onDataLoaded 可以视为带状态的setValue</span></span><br><span class="line">    children.mLiveData.onDataLoaded(old, list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Objects.equals(parentId, cache.mRootId)) &#123;</span><br><span class="line">        mRootMediaItems.onDataLoaded(old, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于关键字检索"><a href="#基于关键字检索" class="headerlink" title="基于关键字检索"></a>基于关键字检索</h3><p>关键字检索通过search()方法实现。使用时先调用<code>getSearchMediaItems()</code>拿到一个LiveData并持续观察，再调用<code>setSearchQuery()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 设置搜索查询。 结果将通过 &#123;<span class="doctag">@link</span> #getSearchMediaItems&#125; 给出。 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSearchQuery</span><span class="params">(String query)</span> </span>&#123;</span><br><span class="line">    mSearchQuery = query;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(mSearchQuery)) &#123;</span><br><span class="line">        clearSearchResults();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mSearchMediaItems.setLoading();</span><br><span class="line">        mBrowsingState.mBrowser.search(mSearchQuery, <span class="keyword">null</span>, mSearchCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SearchCallback mSearchCallback = <span class="keyword">new</span> SearchCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSearchResult</span><span class="params">(<span class="meta">@NonNull</span> String query, Bundle extras,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="meta">@NonNull</span> List&lt;MediaBrowserCompat.MediaItem&gt; items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSearchResult(query, extras, items);</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(mSearchQuery, query)) &#123;</span><br><span class="line">            onSearchData(items.stream()</span><br><span class="line">                    .filter(Objects::nonNull)</span><br><span class="line">                    .map(MediaItemMetadata::<span class="keyword">new</span>)</span><br><span class="line">                    .collect(toList()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="meta">@NonNull</span> String query, Bundle extras)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onError(query, extras);</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(mSearchQuery, query)) &#123;</span><br><span class="line">            onSearchData(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onSearchData</span><span class="params">(<span class="meta">@Nullable</span> List&lt;MediaItemMetadata&gt; list)</span> </span>&#123;</span><br><span class="line">    mSearchMediaItems.onDataLoaded(<span class="keyword">null</span>, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PlaybackViewModel"><a href="#PlaybackViewModel" class="headerlink" title="PlaybackViewModel"></a>PlaybackViewModel</h2><p><code>MediaBrowserConnector</code>和<code>MediaItemRepository</code>分别完成了连接和检索功能，接下来就是<strong>PlaybackViewModel</strong>中实现的播放控制功能。</p>
<h3 id="封装-MediaControllerCompat-Callback"><a href="#封装-MediaControllerCompat-Callback" class="headerlink" title="封装 MediaControllerCompat.Callback"></a>封装 MediaControllerCompat.Callback</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaControllerCallback</span> <span class="keyword">extends</span> <span class="title">MediaControllerCompat</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MediaBrowserConnector.BrowsingState mBrowsingState;</span><br><span class="line">    <span class="keyword">private</span> MediaControllerCompat mMediaController;</span><br><span class="line">    <span class="keyword">private</span> MediaMetadataCompat mMediaMetadata;</span><br><span class="line">    <span class="keyword">private</span> PlaybackStateCompat mPlaybackState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onMediaBrowsingStateChanged</span><span class="params">(MediaBrowserConnector.BrowsingState newBrowsingState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(mBrowsingState, newBrowsingState)) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;onMediaBrowsingStateChanged noop &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重置旧控制器（如果有），在浏览未暂停（崩溃）时取消注册回调。</span></span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (newBrowsingState.mConnectionStatus) &#123;</span><br><span class="line">                <span class="keyword">case</span> DISCONNECTING:</span><br><span class="line">                <span class="keyword">case</span> REJECTED:</span><br><span class="line">                <span class="keyword">case</span> CONNECTING:</span><br><span class="line">                <span class="keyword">case</span> CONNECTED:</span><br><span class="line">                    mMediaController.unregisterCallback(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="comment">// Fall through</span></span><br><span class="line">                <span class="keyword">case</span> SUSPENDED:</span><br><span class="line">                    setMediaController(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mBrowsingState = newBrowsingState;</span><br><span class="line">        <span class="keyword">if</span> (mBrowsingState.mConnectionStatus == ConnectionStatus.CONNECTED) &#123;</span><br><span class="line">            setMediaController(mInputFactory.getControllerForBrowser(mBrowsingState.mBrowser));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMediaController</span><span class="params">(MediaControllerCompat mediaController)</span> </span>&#123;</span><br><span class="line">        mMediaMetadata = <span class="keyword">null</span>;</span><br><span class="line">        mPlaybackState = <span class="keyword">null</span>;</span><br><span class="line">        mMediaController = mediaController;</span><br><span class="line">        mPlaybackControls.setValue(<span class="keyword">new</span> PlaybackController(mediaController));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMediaController.registerCallback(<span class="keyword">this</span>);</span><br><span class="line">            mColors.setValue(mColorsFactory.extractColors(mediaController.getPackageName()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 应用程序并不总是发送更新，因此请确保我们获取最新的值。</span></span><br><span class="line">            onMetadataChanged(mMediaController.getMetadata());</span><br><span class="line">            onPlaybackStateChanged(mMediaController.getPlaybackState());</span><br><span class="line">            onQueueChanged(mMediaController.getQueue());</span><br><span class="line">            onQueueTitleChanged(mMediaController.getQueueTitle());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mColors.setValue(<span class="keyword">null</span>);</span><br><span class="line">            onMetadataChanged(<span class="keyword">null</span>);</span><br><span class="line">            onPlaybackStateChanged(<span class="keyword">null</span>);</span><br><span class="line">            onQueueChanged(<span class="keyword">null</span>);</span><br><span class="line">            onQueueTitleChanged(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        updatePlaybackStatus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSessionDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;onSessionDestroyed&quot;</span>);</span><br><span class="line">        <span class="comment">// 在MediaSession销毁时unregisterCallback。</span></span><br><span class="line">        <span class="comment">//TODO：考虑跟踪孤立的回调，以防它们复活......</span></span><br><span class="line">        setMediaController(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMetadataChanged</span><span class="params">(<span class="meta">@Nullable</span> MediaMetadataCompat mmdCompat)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// MediaSession#setMetadata 在其参数为 null 时构建一个空的 MediaMetadata，但 MediaMetadataCompat 不实现 equals...</span></span><br><span class="line">        <span class="comment">// 因此，如果给定的 mmdCompat 的 MediaMetadata 等于 EMPTY_MEDIA_METADATA，请将 mMediaMetadata 设置为 null 以使代码在其他任何地方都更简单。</span></span><br><span class="line">        <span class="keyword">if</span> ((mmdCompat != <span class="keyword">null</span>) &amp;&amp; EMPTY_MEDIA_METADATA.equals(mmdCompat.getMediaMetadata())) &#123;</span><br><span class="line">            mMediaMetadata = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMediaMetadata = mmdCompat;</span><br><span class="line">        &#125;</span><br><span class="line">        MediaItemMetadata item =</span><br><span class="line">                (mMediaMetadata != <span class="keyword">null</span>) ? <span class="keyword">new</span> MediaItemMetadata(mMediaMetadata) : <span class="keyword">null</span>;</span><br><span class="line">        mMetadata.setValue(item);</span><br><span class="line">        updatePlaybackStatus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueueTitleChanged</span><span class="params">(CharSequence title)</span> </span>&#123;</span><br><span class="line">        mQueueTitle.setValue(title);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueueChanged</span><span class="params">(<span class="meta">@Nullable</span> List&lt;MediaSessionCompat.QueueItem&gt; queue)</span> </span>&#123;</span><br><span class="line">        List&lt;MediaItemMetadata&gt; filtered = queue == <span class="keyword">null</span> ? Collections.emptyList()</span><br><span class="line">                : queue.stream()</span><br><span class="line">                .filter(item -&gt; item != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; item.getDescription() != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; item.getDescription().getTitle() != <span class="keyword">null</span>)</span><br><span class="line">                .map(MediaItemMetadata::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        mSanitizedQueue.setValue(filtered);</span><br><span class="line">        mHasQueue.setValue(filtered.size() &gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPlaybackStateChanged</span><span class="params">(PlaybackStateCompat playbackState)</span> </span>&#123;</span><br><span class="line">        mPlaybackState = playbackState;</span><br><span class="line">        updatePlaybackStatus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePlaybackStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span> &amp;&amp; mPlaybackState != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPlaybackStateWrapper.setValue(</span><br><span class="line">                    <span class="keyword">new</span> PlaybackStateWrapper(mMediaController, mMediaMetadata, mPlaybackState));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlaybackStateWrapper.setValue(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓展-PlaybackState"><a href="#拓展-PlaybackState" class="headerlink" title="拓展 PlaybackState"></a>拓展 PlaybackState</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> PlaybackStateCompat&#125; 的扩展。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaybackStateWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaControllerCompat mMediaController;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaMetadataCompat mMetadata;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PlaybackStateCompat mState;</span><br><span class="line"></span><br><span class="line">    PlaybackStateWrapper(<span class="meta">@NonNull</span> MediaControllerCompat mediaController,</span><br><span class="line">                         <span class="meta">@Nullable</span> MediaMetadataCompat metadata, <span class="meta">@NonNull</span> PlaybackStateCompat state) &#123;</span><br><span class="line">        mMediaController = mediaController;</span><br><span class="line">        mMetadata = metadata;</span><br><span class="line">        mState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果状态中有足够的信息来显示它的 UI，则返回 true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// STATE_NONE means no content to play.</span></span><br><span class="line">        <span class="keyword">return</span> mState.getState() != PlaybackStateCompat.STATE_NONE &amp;&amp; ((mMetadata != <span class="keyword">null</span>) || (</span><br><span class="line">                getMainAction() != ACTION_DISABLED));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 主 action</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Action</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMainAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Actions</span> <span class="keyword">long</span> actions = mState.getActions();</span><br><span class="line">        <span class="meta">@Action</span> <span class="keyword">int</span> stopAction = ACTION_DISABLED;</span><br><span class="line">        <span class="keyword">if</span> ((actions &amp; (PlaybackStateCompat.ACTION_PAUSE</span><br><span class="line">                | PlaybackStateCompat.ACTION_PLAY_PAUSE)) != <span class="number">0</span>) &#123;</span><br><span class="line">            stopAction = ACTION_PAUSE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((actions &amp; PlaybackStateCompat.ACTION_STOP) != <span class="number">0</span>) &#123;</span><br><span class="line">            stopAction = ACTION_STOP;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mState.getState()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_PLAYING:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_BUFFERING:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_CONNECTING:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_FAST_FORWARDING:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_REWINDING:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_SKIPPING_TO_NEXT:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_SKIPPING_TO_PREVIOUS:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_SKIPPING_TO_QUEUE_ITEM:</span><br><span class="line">                <span class="keyword">return</span> stopAction;</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_STOPPED:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_PAUSED:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_NONE:</span><br><span class="line">            <span class="keyword">case</span> PlaybackStateCompat.STATE_ERROR:</span><br><span class="line">                <span class="keyword">return</span> (actions &amp; PlaybackStateCompat.ACTION_PLAY) != <span class="number">0</span> ? ACTION_PLAY</span><br><span class="line">                        : ACTION_DISABLED;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                Log.w(TAG, String.format(<span class="string">&quot;Unknown PlaybackState: %d&quot;</span>, mState.getState()));</span><br><span class="line">                <span class="keyword">return</span> ACTION_DISABLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前支持的播放动作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSupportedActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState.getActions();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回媒体项的持续时间（以毫秒为单位）。 可以通过调用 &#123;<span class="doctag">@link</span> #getProgress()&#125; 获取此持续时间内的当前位置。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMaxProgress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMetadata == <span class="keyword">null</span> ? <span class="number">0</span> :</span><br><span class="line">                mMetadata.getLong(MediaMetadataCompat.METADATA_KEY_DURATION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前媒体源是否正在播放媒体项。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPlaying</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState.getState() == PlaybackStateCompat.STATE_PLAYING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回媒体源是否支持跳到下一项。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSkipNextEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mState.getActions() &amp; PlaybackStateCompat.ACTION_SKIP_TO_NEXT) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回媒体源是否支持跳到上一项。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSkipPreviousEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mState.getActions() &amp; PlaybackStateCompat.ACTION_SKIP_TO_PREVIOUS) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回媒体源是否支持在媒体流中寻找新位置。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSeekToEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (mState.getActions() &amp; PlaybackStateCompat.ACTION_SEEK_TO) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回媒体源是否需要为跳到下一个操作保留空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSkipNextReserved</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMediaController.getExtras() != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mMediaController.getExtras().getBoolean(</span><br><span class="line">                MediaConstants.SLOT_RESERVATION_SKIP_TO_NEXT)</span><br><span class="line">                || mMediaController.getExtras().getBoolean(</span><br><span class="line">                MediaConstants.PLAYBACK_SLOT_RESERVATION_SKIP_TO_NEXT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回媒体源是否需要为跳到上一个操作保留空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">iSkipPreviousReserved</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMediaController.getExtras() != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mMediaController.getExtras().getBoolean(</span><br><span class="line">                MediaConstants.SLOT_RESERVATION_SKIP_TO_PREV)</span><br><span class="line">                || mMediaController.getExtras().getBoolean(</span><br><span class="line">                MediaConstants.PLAYBACK_SLOT_RESERVATION_SKIP_TO_PREV));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回媒体源是否正在加载（例如：缓冲、连接等）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = mState.getState();</span><br><span class="line">        <span class="keyword">return</span> state == PlaybackStateCompat.STATE_BUFFERING</span><br><span class="line">                || state == PlaybackStateCompat.STATE_CONNECTING</span><br><span class="line">                || state == PlaybackStateCompat.STATE_FAST_FORWARDING</span><br><span class="line">                || state == PlaybackStateCompat.STATE_REWINDING</span><br><span class="line">                || state == PlaybackStateCompat.STATE_SKIPPING_TO_NEXT</span><br><span class="line">                || state == PlaybackStateCompat.STATE_SKIPPING_TO_PREVIOUS</span><br><span class="line">                || state == PlaybackStateCompat.STATE_SKIPPING_TO_QUEUE_ITEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 见 &#123;<span class="doctag">@link</span> PlaybackStateCompat#getErrorMessage&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharSequence <span class="title">getErrorMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState.getErrorMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 见 &#123;<span class="doctag">@link</span> PlaybackStateCompat#getErrorCode()&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState.getErrorCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 见 &#123;<span class="doctag">@link</span> PlaybackStateCompat#getActiveQueueItemId&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getActiveQueueItemId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState.getActiveQueueItemId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 见 &#123;<span class="doctag">@link</span> PlaybackStateCompat#getState&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PlaybackStateCompat</span>.<span class="function">State</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState.getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 见 &#123;<span class="doctag">@link</span> PlaybackStateCompat#getExtras&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bundle <span class="title">getExtras</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState.getExtras();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="function">PlaybackStateCompat <span class="title">getStateCompat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回可用自定义操作的排序列表。</span></span><br><span class="line"><span class="comment">     * 调用&#123;<span class="doctag">@link</span> RawCustomPlaybackAction#fetchDrawable（Context）&#125;以获得适当的可绘制图标。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;RawCustomPlaybackAction&gt; <span class="title">getCustomActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;RawCustomPlaybackAction&gt; actions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        RawCustomPlaybackAction ratingAction = getRatingAction();</span><br><span class="line">        <span class="keyword">if</span> (ratingAction != <span class="keyword">null</span>) actions.add(ratingAction);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (PlaybackStateCompat.CustomAction action : mState.getCustomActions()) &#123;</span><br><span class="line">            String packageName = mMediaController.getPackageName();</span><br><span class="line">            actions.add(</span><br><span class="line">                    <span class="keyword">new</span> RawCustomPlaybackAction(action.getIcon(), packageName,</span><br><span class="line">                            action.getAction(),</span><br><span class="line">                            action.getExtras()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> actions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RawCustomPlaybackAction <span class="title">getRatingAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stdActions = mState.getActions();</span><br><span class="line">        <span class="keyword">if</span> ((stdActions &amp; PlaybackStateCompat.ACTION_SET_RATING) == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ratingType = mMediaController.getRatingType();</span><br><span class="line">        <span class="keyword">if</span> (ratingType != RatingCompat.RATING_HEART) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hasHeart = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mMetadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RatingCompat rating = mMetadata.getRating(</span><br><span class="line">                    MediaMetadataCompat.METADATA_KEY_USER_RATING);</span><br><span class="line">            hasHeart = rating != <span class="keyword">null</span> &amp;&amp; rating.hasHeart();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> iconResource = hasHeart ? R.drawable.ic_star_filled : R.drawable.ic_star_empty;</span><br><span class="line">        Bundle extras = <span class="keyword">new</span> Bundle();</span><br><span class="line">        extras.putBoolean(EXTRA_SET_HEART, !hasHeart);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RawCustomPlaybackAction(iconResource, <span class="keyword">null</span>, ACTION_SET_RATING, extras);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装媒体控制类"><a href="#封装媒体控制类" class="headerlink" title="封装媒体控制类"></a>封装媒体控制类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 &#123;<span class="doctag">@link</span> MediaControllerCompat&#125; 包装 &#123;<span class="doctag">@link</span> android.media.session.MediaController.TransportControls TransportControls&#125; 以发送命令。</span></span><br><span class="line"><span class="comment"> * TODO(arnaudberry) 这种包装有意义吗，因为我们仍然需要对包装进行空值检查？</span></span><br><span class="line"><span class="comment"> * 我们应该在模型类上调用动作方法吗？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaybackController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaControllerCompat mMediaController;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PlaybackController</span><span class="params">(<span class="meta">@Nullable</span> MediaControllerCompat mediaController)</span> </span>&#123;</span><br><span class="line">        mMediaController = mediaController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMediaController.getTransportControls().play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipToPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMediaController.getTransportControls().skipToPrevious();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipToNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMediaController.getTransportControls().skipToNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMediaController.getTransportControls().pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMediaController.getTransportControls().stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移动到媒体流中的新位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pos 要移动到的位置，以毫秒为单位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seekTo</span><span class="params">(<span class="keyword">long</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            PlaybackStateCompat oldState = mMediaController.getPlaybackState();</span><br><span class="line">            PlaybackStateCompat newState = <span class="keyword">new</span> PlaybackStateCompat.Builder(oldState)</span><br><span class="line">                    .setState(oldState.getState(), pos, oldState.getPlaybackSpeed())</span><br><span class="line">                    .build();</span><br><span class="line">            mMediaControllerCallback.onPlaybackStateChanged(newState);</span><br><span class="line">            mMediaController.getTransportControls().seekTo(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向媒体源发送自定义操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action 自定义动作的动作标识符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extras 附加额外数据以发送到媒体源。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCustomAction</span><span class="params">(String action, Bundle extras)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        MediaControllerCompat.TransportControls cntrl = mMediaController.getTransportControls();</span><br><span class="line">        <span class="keyword">if</span> (ACTION_SET_RATING.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> setHeart = extras != <span class="keyword">null</span> &amp;&amp; extras.getBoolean(EXTRA_SET_HEART, <span class="keyword">false</span>);</span><br><span class="line">            cntrl.setRating(RatingCompat.newHeartRating(setHeart));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cntrl.sendCustomAction(action, extras);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始播放给定的媒体项目。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playItem</span><span class="params">(MediaItemMetadata item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不要将额外内容传回，因为这不是官方 API，并且在 media2 中不受支持，因此应用程序不应依赖于此。</span></span><br><span class="line">            mMediaController.getTransportControls().playFromMediaId(item.getId(), <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳到媒体队列中的特定项目。 此 id 是通过 &#123;<span class="doctag">@link</span> PlaybackViewModel#getQueue()&#125; 获得的项目的 &#123;<span class="doctag">@link</span> MediaItemMetadata#mQueueId&#125;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skipToQueueItem</span><span class="params">(<span class="keyword">long</span> queueId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMediaController.getTransportControls().skipToQueueItem(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMediaController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMediaController.getTransportControls().prepare();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PlaybackFragment"><a href="#PlaybackFragment" class="headerlink" title="PlaybackFragment"></a>PlaybackFragment</h2><p>如图所示，播放界面分为显示媒体源信息、显示当前的Audio信息以及播放控制。</p>
<p><img src="/images/android_aosp_local_media05.png" alt="image"></p>
<h3 id="显示媒体资源信息"><a href="#显示媒体资源信息" class="headerlink" title="显示媒体资源信息"></a>显示媒体资源信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> LiveData&lt;MediaSource&gt; mMediaSource;</span><br><span class="line"></span><br><span class="line">mMediaSource = mMediaSourceViewModel.getPrimaryMediaSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 媒体源 APP名字</span></span><br><span class="line">mAppName = mapNonNull(mMediaSource, <span class="keyword">new</span> Function&lt;MediaSource, CharSequence&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharSequence <span class="title">apply</span><span class="params">(MediaSource mediaSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mediaSource.getDisplayName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 媒体源 APP图标</span></span><br><span class="line">mAppIcon = mapNonNull(mMediaSource, <span class="keyword">new</span> Function&lt;MediaSource, Bitmap&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bitmap <span class="title">apply</span><span class="params">(MediaSource mediaSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mediaSource.getCroppedPackageIcon();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类似于 Transformations.map(LiveData, Function)，但在 source 发出 null 时发出 nullValue。</span></span><br><span class="line"><span class="comment"> * func 的输入可能被视为不可为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">LiveData&lt;R&gt; <span class="title">mapNonNull</span><span class="params">(<span class="meta">@NonNull</span> LiveData&lt;T&gt; source,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="meta">@NonNull</span> Function&lt;T, R&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapNonNull(source, <span class="keyword">null</span>, func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">LiveData&lt;R&gt; <span class="title">mapNonNull</span><span class="params">(<span class="meta">@NonNull</span> LiveData&lt;T&gt; source, <span class="meta">@Nullable</span> R nullValue,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="meta">@NonNull</span> Function&lt;T, R&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Transformations.map(source, <span class="keyword">new</span> Function&lt;T, R&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> R <span class="title">apply</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nullValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> func.apply(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，界面上显示出的『Local Media』和应用的图标 都是从<code>MediaSourceViewModel</code>中的<code>getPrimaryMediaSource()</code>获取。在<code>MediaSourceViewModel</code>中则是通过<code>CarMediaManager</code>这个CarAndroid Framework层封装的API获取的，关于CarAndroid中Framework层的各个Service的实现，我们等应用都说完后再来一一解释。</p>
<h3 id="显示当前播放的媒体信息"><a href="#显示当前播放的媒体信息" class="headerlink" title="显示当前播放的媒体信息"></a>显示当前播放的媒体信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(FragmentActivity activity, MediaSourceViewModel mediaSourceViewModel,</span></span></span><br><span class="line"><span class="params"><span class="function">        PlaybackViewModel playbackViewModel, MediaItemsRepository mediaItemsRepository)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 当前播放的媒体的title</span></span><br><span class="line">mTitle = mapNonNull(playbackViewModel.getMetadata(), MediaItemMetadata::getTitle);</span><br><span class="line"><span class="comment">// 当前播放的媒体的子title</span></span><br><span class="line">mSubtitle = mapNonNull(playbackViewModel.getMetadata(), MediaItemMetadata::getArtist);</span><br><span class="line"><span class="comment">// 媒体列表数据</span></span><br><span class="line">mMediaItemsRepository.getRootMediaItems()</span><br><span class="line">        .observe(activity, <span class="keyword">this</span>::onRootMediaItemsUpdate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onRootMediaItemsUpdate</span><span class="params">(FutureData&lt;List&lt;MediaItemMetadata&gt;&gt; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.isLoading()) &#123;</span><br><span class="line">        mBrowseTreeHasChildren.setValue(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;MediaItemMetadata&gt; items =</span><br><span class="line">            MediaBrowserViewModelImpl.filterItems(<span class="comment">/*forRoot*/</span> <span class="keyword">true</span>, data.getData());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> browseTreeHasChildren = items != <span class="keyword">null</span> &amp;&amp; !items.isEmpty();</span><br><span class="line">    mBrowseTreeHasChildren.setValue(browseTreeHasChildren);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android系统开发</category>
        <category>车联网</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
        <tag>车载多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP-Framework自定义系统服务</title>
    <url>/2021/03/09/android_aosp_framework_custom_service/</url>
    <content><![CDATA[<p>我们开发过程中常见的ActivityManagerService，WindowManagerService，PackageManagerService等等都属于系统服务，运行于SystemServer进程，并且向ServiceManager进程注册了Binder以便其他进程获取binder与对应的服务进行通信。同样，在AOSP中我们也可以加入我们自定义的系统服务。</p>
<span id="more"></span>

<h1 id="增加自定义服务"><a href="#增加自定义服务" class="headerlink" title="增加自定义服务"></a>增加自定义服务</h1><p>AndroidStudio导入AOSP源码后，使用studio编写相关代码。</p>
<h2 id="编写服务接口aidl"><a href="#编写服务接口aidl" class="headerlink" title="编写服务接口aidl"></a>编写服务接口aidl</h2><p>在<code>frameworks/base/core/java/android/app</code>目录下创建<code>ITaurusManager.aidl</code>文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ITaurusManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> android.app;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* System private API for talking with the activity manager service. This</span></span><br><span class="line"><span class="comment">* provides calls from the application back to the activity manager.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITaurusManager</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">request</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Context中定义服务的常量名"><a href="#Context中定义服务的常量名" class="headerlink" title="Context中定义服务的常量名"></a>Context中定义服务的常量名</h2><p>在<code>frameworks/base/core/java/android/content/Context.java</code>中加入常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@StringDef(suffix = &#123; &quot;_SERVICE&quot; &#125;, value = &#123;</span></span><br><span class="line"><span class="meta">        POWER_SERVICE,</span></span><br><span class="line"><span class="meta">        //@hide: POWER_STATS_SERVICE,</span></span><br><span class="line"><span class="meta">        WINDOW_SERVICE,</span></span><br><span class="line"><span class="meta">        LAYOUT_INFLATER_SERVICE,</span></span><br><span class="line"><span class="meta">        ACCOUNT_SERVICE,</span></span><br><span class="line"><span class="meta">        ACTIVITY_SERVICE,</span></span><br><span class="line"><span class="meta">        TAURUS_SERVICE,</span></span><br><span class="line"><span class="meta">        ALARM_SERVICE,</span></span><br><span class="line"><span class="meta">        //......</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServiceName &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TaurusService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAURUS_SERVICE=<span class="string">&quot;taurus&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<h2 id="创建暴露给外部调用的Manager类TaurusManager"><a href="#创建暴露给外部调用的Manager类TaurusManager" class="headerlink" title="创建暴露给外部调用的Manager类TaurusManager"></a>创建暴露给外部调用的Manager类TaurusManager</h2><p>如同我们使用ActivityManager一样，我们需要一个自己的Manager</p>
<p>在<code>frameworks/base/core/java/android/app</code> 下编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> android.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.annotation.SystemService;</span><br><span class="line"><span class="keyword">import</span> android.compat.annotation.UnsupportedAppUsage;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.os.ServiceManager;</span><br><span class="line"><span class="keyword">import</span> android.util.Singleton;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SystemService(Context.TAURUS_SERVICE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaurusManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaurusManager</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;ITaurusManager&gt; iTaurusManagerSingleton</span><br><span class="line">            = <span class="keyword">new</span> Singleton&lt;ITaurusManager&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> ITaurusManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.TAURUS_SERVICE);</span><br><span class="line">            <span class="keyword">final</span> ITaurusManager im = ITaurusManager.Stub.asInterface(b);</span><br><span class="line">            <span class="keyword">return</span> im;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ITaurusManager <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iTaurusManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于aidl的代理方法</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">( <span class="meta">@Nullable</span> String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getService().request(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建服务的具体实现类即aidl接口的实现类TaurusManagerService"><a href="#创建服务的具体实现类即aidl接口的实现类TaurusManagerService" class="headerlink" title="创建服务的具体实现类即aidl接口的实现类TaurusManagerService"></a>创建服务的具体实现类即aidl接口的实现类TaurusManagerService</h2><p>在<code>frameworks/base/services/core/java/com/android/service/taurus</code> 中编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.android.server.taurus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.app.ITaurusManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TaurusManagerService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaurusManagerService</span> <span class="keyword">extends</span> <span class="title">ITaurusManager</span>.<span class="title">Stub</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(String msg)</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;TaurusManagerService receive data : &quot;</span> + msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ServiceManager中注册Binder实例"><a href="#ServiceManager中注册Binder实例" class="headerlink" title="ServiceManager中注册Binder实例"></a>ServiceManager中注册Binder实例</h2><p>在<code>frameworks/base/services/java/com/android/server/SystemServer.java</code>中 注册系统服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.android.server.taurus.TaurusManagerService;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    ServiceManager.addService(Context.TAURUS_SERVICE,<span class="keyword">new</span> TaurusManagerService());</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SystemServiceRegistry中注册服务获取器"><a href="#SystemServiceRegistry中注册服务获取器" class="headerlink" title="SystemServiceRegistry中注册服务获取器"></a>SystemServiceRegistry中注册服务获取器</h2><h3 id="为什么要在这里注册？"><a href="#为什么要在这里注册？" class="headerlink" title="为什么要在这里注册？"></a>为什么要在这里注册？</h3><p>通过ActivityManager的获取，我们追溯一下。</p>
<p>使用ActivityManager时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br></pre></td></tr></table></figure>

<p>我们追溯到<code>ContextImpl</code>中的<code>getSystemService</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//......</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vmIncorrectContextUseEnabled()) &#123;</span><br><span class="line">            <span class="comment">// Check incorrect Context usage.</span></span><br><span class="line">            <span class="keyword">if</span> (WINDOW_SERVICE.equals(name) &amp;&amp; !isUiContext()) &#123;</span><br><span class="line">                <span class="keyword">final</span> String errorMessage = <span class="string">&quot;Tried to access visual service &quot;</span></span><br><span class="line">                        + SystemServiceRegistry.getSystemServiceClassName(name)</span><br><span class="line">                        + <span class="string">&quot; from a non-visual Context:&quot;</span> + getOuterContext();</span><br><span class="line">                <span class="keyword">final</span> String message = <span class="string">&quot;WindowManager should be accessed from Activity or other &quot;</span></span><br><span class="line">                        + <span class="string">&quot;visual Context. Use an Activity or a Context created with &quot;</span></span><br><span class="line">                        + <span class="string">&quot;Context#createWindowContext(int, Bundle), which are adjusted to &quot;</span></span><br><span class="line">                        + <span class="string">&quot;the configuration and visual bounds of an area on screen.&quot;</span>;</span><br><span class="line">                <span class="keyword">final</span> Exception exception = <span class="keyword">new</span> IllegalAccessException(errorMessage);</span><br><span class="line">                StrictMode.onIncorrectContextUsed(message, exception);</span><br><span class="line">                Log.e(TAG, errorMessage + <span class="string">&quot; &quot;</span> + message, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<p>看最后return的代码，是从<code>SystemServiceRegistry</code>中进行获取的。所以，我们需要在<code>SystemServiceRegistry</code>中进行注册获取器。</p>
<p>在<code>frameworks/base/core/java/android/app/SystemServiceRegistry.java</code>的静态代码块中增加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//......</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerService(Context.TAURUS_SERVICE, TaurusManager.class,</span><br><span class="line">                <span class="keyword">new</span> CachedServiceFetcher&lt;TaurusManager&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> TaurusManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> <span class="keyword">throws</span> ServiceNotFoundException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> TaurusManager();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure>

<h2 id="配置SELinux权限"><a href="#配置SELinux权限" class="headerlink" title="配置SELinux权限"></a>配置SELinux权限</h2><p>在<code>system/sepolicy/prebuilts/api/31.0/private/</code> 与 <code>system/sepolicy/private/</code> 目录下，分别修改：service_contexts、service.te、untrusted_app_all.te</p>
<p><strong>service_contexts</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">//......</span><br><span class="line">activity 				u:object<span class="built_in">_</span>r:activity<span class="built_in">_</span>service:s0</span><br><span class="line"><span class="params">#</span>配置自定义服务selinux角色</span><br><span class="line">taurus 					u:object<span class="built_in">_</span>r:taurus<span class="built_in">_</span>service:s0<span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>//......</span><br></pre></td></tr></table></figure>

<p><strong>service.te</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span>配置自定义服务类型</span><br><span class="line">type taurus<span class="built_in">_</span>service, 		app<span class="built_in">_</span>api<span class="built_in">_</span>service, ephemeral<span class="built_in">_</span>app<span class="built_in">_</span>api<span class="built_in">_</span>service,system<span class="built_in">_</span>server<span class="built_in">_</span>service,service<span class="built_in">_</span>manager<span class="built_in">_</span>type;</span><br></pre></td></tr></table></figure>

<p><strong>untrusted_app_all.te</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span>允许所有app使用自定义服务</span><br><span class="line">allow untrusted<span class="built_in">_</span>app<span class="built_in">_</span>all taurus<span class="built_in">_</span>service:service<span class="built_in">_</span>manager find;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：两个目录下文件需要一致，否则报错，如：<br>Files system/sepolicy/prebuilts/api/31.0/private/untrusted_app_all.te and<br>system/sepolicy/private/untrusted_app_all.te differ<br>ninja failed with: exit status 1</p>
</blockquote>
<h2 id="更新并编译"><a href="#更新并编译" class="headerlink" title="更新并编译"></a>更新并编译</h2><p>在终端中操作以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 更新api</span></span><br><span class="line">make update-api</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line">m</span><br><span class="line"><span class="meta">#</span><span class="bash">运行模拟器</span></span><br><span class="line">emulator</span><br></pre></td></tr></table></figure>

<p>模拟器启动后，可以通过adb shell去查看服务是否存在</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jia@jia-virtual-machine:~/AOSP/aosp$ adb shell service list| grep taurus</span><br><span class="line"><span class="meta">#</span><span class="bash">输出： 表示成功加入自定义服务</span></span><br><span class="line">102 taurus: [android.app.ITaurusManager]</span><br></pre></td></tr></table></figure>

<h2 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h2><p>由于Android12编译时，开启了lint检查，在Android12新增系统服务后，执行update-api过程中遇到如下问题：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">out/srcjars/android/app/ITaurusManager.java:135: error: Methods calling system APIs should</span><br><span class="line">rethrow `RemoteException` as `RuntimeException` (but do not list it in the throws clause)</span><br><span class="line">[RethrowRemoteException]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:135: error: Missing nullability on method</span><br><span class="line">`request` return [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:135: error: Missing nullability on parameter</span><br><span class="line">`msg` in method `request` [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:11: error: Methods calling system APIs should</span><br><span class="line">rethrow `RemoteException` as `RuntimeException` (but do not list it in the throws clause)</span><br><span class="line">[RethrowRemoteException]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:11: error: Missing nullability on method</span><br><span class="line">`request` return [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:11: error: Missing nullability on parameter</span><br><span class="line">`msg` in method `request` [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:15: error: Missing nullability on method</span><br><span class="line">`asBinder` return [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:20: error: Raw AIDL interfaces must not be</span><br><span class="line">exposed: Stub extends Binder [RawAidl]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:28: error: Missing nullability on method</span><br><span class="line">`asInterface` return [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:32: error: Missing nullability on parameter</span><br><span class="line">`obj` in method `asInterface` [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:43: error: Missing nullability on method</span><br><span class="line">`asBinder` return [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:47: error: Methods calling system APIs should</span><br><span class="line">rethrow `RemoteException` as `RuntimeException` (but do not list it in the throws clause)</span><br><span class="line">[RethrowRemoteException]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:47: error: Missing nullability on parameter</span><br><span class="line">`data` in method `onTransact` [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:47: error: Missing nullability on parameter</span><br><span class="line">`reply` in method `onTransact` [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:117: error: Missing nullability on parameter</span><br><span class="line">`impl` in method `setDefaultImpl` [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:130: error: Missing nullability on method</span><br><span class="line">`getDefaultImpl` return [MissingNullability]</span><br><span class="line">frameworks/base/core/java/android/app/TaurusManager.java:15: error: Managers must always be</span><br><span class="line">obtained from Context; no direct constructors [ManagerConstructor]</span><br><span class="line">frameworks/base/core/java/android/app/TaurusManager.java:20: error: Missing nullability on</span><br><span class="line">method `getService` return [MissingNullability]Error: metalava detected the following</span><br><span class="line">problems:</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:135: error: Methods calling system APIs should</span><br><span class="line">rethrow `RemoteException` as `RuntimeException` (but do not list it in the throws clause)</span><br><span class="line">[RethrowRemoteException]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:135: error: Missing nullability on method</span><br><span class="line">`request` return [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:135: error: Missing nullability on parameter</span><br><span class="line">`msg` in method `request` [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:11: error: Methods calling system APIs should</span><br><span class="line">rethrow `RemoteException` as `RuntimeException` (but do not list it in the throws clause)</span><br><span class="line">[RethrowRemoteException]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:11: error: Missing nullability on method</span><br><span class="line">`request` return [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:11: error: Missing nullability on parameter</span><br><span class="line">`msg` in method `request` [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:15: error: Missing nullability on method</span><br><span class="line">`asBinder` return [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:20: error: Raw AIDL interfaces must not be</span><br><span class="line">exposed: Stub extends Binder [RawAidl]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:28: error: Missing nullability on method</span><br><span class="line">`asInterface` return [MissingNullability]</span><br><span class="line">out/srcjars/android/app/ITaurusManager.java:32: error: Missing nullability on parameter</span><br><span class="line">`obj` in method `asInterface` [MissingNullability]</span><br></pre></td></tr></table></figure>

<p>仔细查看日志，发现问题主要由TaurusManager以及aidl接口生成的ITaurusManager报错。主要是因为改加@hide与@Nullable注解的地方没有加上注解。</p>
<h1 id="使用自定义服务"><a href="#使用自定义服务" class="headerlink" title="使用自定义服务"></a>使用自定义服务</h1><h2 id="修改SDK配置"><a href="#修改SDK配置" class="headerlink" title="修改SDK配置"></a>修改SDK配置</h2><h3 id="拷贝出aosp下编译的SDK的jar文件"><a href="#拷贝出aosp下编译的SDK的jar文件" class="headerlink" title="拷贝出aosp下编译的SDK的jar文件"></a>拷贝出aosp下编译的SDK的jar文件</h3><p>通过<code>make sdk</code>生成SDK的jar包</p>
<p>在<code>out/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates/classes.jar</code>路径下。</p>
<h3 id="配置studio使用的SDK"><a href="#配置studio使用的SDK" class="headerlink" title="配置studio使用的SDK"></a>配置studio使用的SDK</h3><p>在SDK/platforms 目录下复制一份android-31（Android12）目录并改名为：android-31.car</p>
<p><img src="/images/android_aosp_framework_custom_service01.png" alt="image"></p>
<p>将classes.jar拷贝至该目录，删除原有的android.jar，重命名classes.jar为android.jar。</p>
<p><img src="/images/android_aosp_framework_custom_service02.png" alt="image"></p>
<p>同样，在SDK/sources 目录下复制一份android-31（Android12）目录并改名为：android-31.car</p>
<p>修改SDK/platforms/android-31.car目录下的source.properties为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span>指定自定义平台标识为311（可以是任意数字，但为了与原生标识区分，请使用三位数）</span><br><span class="line"><span class="params">#</span>修改：</span><br><span class="line">Pkg.Desc=Android SDK Platform 311</span><br><span class="line">Pkg.UserSrc=false</span><br><span class="line"><span class="params">#</span>修改：</span><br><span class="line">Platform.Version=311</span><br><span class="line">Platform.CodeName=</span><br><span class="line">Pkg.Revision=1</span><br><span class="line"><span class="params">#</span>修改：</span><br><span class="line">AndroidVersion.ApiLevel=311</span><br><span class="line">Layoutlib.Api=15</span><br><span class="line">Layoutlib.Revision=1</span><br><span class="line">Platform.MinToolsRev=22</span><br></pre></td></tr></table></figure>

<p>最后将SDK/platforms/package.xml中最后的内容改为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localPackage</span> <span class="attr">path</span>=<span class="string">&quot;platforms;android-311&quot;</span> <span class="attr">obsolete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type-details</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:type</span>=<span class="string">&quot;ns5:platformDetailsType&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 修改 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">api-level</span>&gt;</span>311<span class="tag">&lt;/<span class="name">api-level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">codename</span>&gt;</span><span class="tag">&lt;/<span class="name">codename</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layoutlib</span> <span class="attr">api</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">type-details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">revision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">major</span>&gt;</span>1<span class="tag">&lt;/<span class="name">major</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">revision</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 修改 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Android SDK Platform 311<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-license</span> <span class="attr">ref</span>=<span class="string">&quot;android-sdk-license&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">localPackage</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改SDK/sources/android-31.car目录下的source.properties为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Pkg.UserSrc=false</span><br><span class="line">Pkg.Revision=1</span><br><span class="line">AndroidVersion.ApiLevel=311</span><br></pre></td></tr></table></figure>

<p>修改SDK/sources/android-31.car目录下的package.xml最后的为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localPackage</span> <span class="attr">path</span>=<span class="string">&quot;sources;android-311&quot;</span> <span class="attr">obsolete</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type-details</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:type</span>=<span class="string">&quot;ns11:sourceDetailsType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">api-level</span>&gt;</span>311<span class="tag">&lt;/<span class="name">api-level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">codename</span>&gt;</span><span class="tag">&lt;/<span class="name">codename</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">base-extension</span>&gt;</span>true<span class="tag">&lt;/<span class="name">base-extension</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">type-details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">revision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">major</span>&gt;</span>1<span class="tag">&lt;/<span class="name">major</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">revision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Sources for Android 311<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-license</span> <span class="attr">ref</span>=<span class="string">&quot;android-sdk-license&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">localPackage</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写app使用自定义服务"><a href="#编写app使用自定义服务" class="headerlink" title="编写app使用自定义服务"></a>编写app使用自定义服务</h2><p>创建测试应用TestService</p>
<h3 id="修改gradle配置"><a href="#修改gradle配置" class="headerlink" title="修改gradle配置"></a>修改gradle配置</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    namespace <span class="string">&#x27;com.example.testservice&#x27;</span></span><br><span class="line">    <span class="comment">//指定为修改的SDK版本</span></span><br><span class="line">    compileSdk <span class="number">311</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.example.testservice&quot;</span></span><br><span class="line">        minSdk <span class="number">24</span></span><br><span class="line">        <span class="comment">//指定为修改的SDK版本</span></span><br><span class="line">        targetSdk <span class="number">311</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">&quot;1.0&quot;</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后同步一下gradle配置。</p>
<h3 id="编写调用自定义服务的测试代码"><a href="#编写调用自定义服务的测试代码" class="headerlink" title="编写调用自定义服务的测试代码"></a>编写调用自定义服务的测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.testservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.TaurusManager;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        TaurusManager taurusManager = (TaurusManager) getSystemService(Context.TAURUS_SERVICE);</span><br><span class="line"></span><br><span class="line">        String result = taurusManager.request(<span class="string">&quot;AppRequest&quot;</span>);</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, result, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可正常引用到SDK中添加的自定义服务类。安装到aosp下编译出的模拟器上，运行即可正常调用。</p>
]]></content>
      <categories>
        <category>Android系统开发</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP-FDBUS通信中间件编译、配置、通信测试</title>
    <url>/2021/07/16/android_aosp_fdbus_make_use/</url>
    <content><![CDATA[<p>智能座舱域主流采用Android+QNX组合的方式，其中QNX作为仪表信息系统，而Android作为IVI车载娱乐系统。两者不可避免需要进行通信。</p>
<span id="more"></span>

<p>基于安全性和独立性要求，不同的系统之间数据不能直接访问。但是不同域下的不同系统之间，同一域下的不同系统之间的通信需求现实存在。现有的解决方案主要是基于TCP/IP协议栈的Socket（套接字）通讯。</p>
<p>大众在FDBUS基础上开发通信中间件完成系统间的通信。</p>
<h1 id="FDBUS介绍"><a href="#FDBUS介绍" class="headerlink" title="FDBUS介绍"></a>FDBUS介绍</h1><blockquote>
<p>FDBus：<a href="https://gitee.com/jeremyczhen/fdbus">https://gitee.com/jeremyczhen/fdbus</a><br>Fast Distributed Bus，基于Socket（Unix Domain和TCP）的快速分布式总线。<br>UDS：Unix Domain Socket，专用于IPC。Zygote中的Local Socket即为UDS。</p>
</blockquote>
<p>FDBUS为了更方便的进行寻址，允许不通过IP+端口或者固定UDS地址，而是采用域名的方式进行寻址。类似于在浏览器输入 <a href="http://www.baidu.com/">www.baidu.com</a> ，与百度完成通信，则需要进行DNS解析，将域名转化为IP地址。<br>FDBUS同样提供了 name-server ,负责管理server名字（域名）与地址（IP）的映射，和DNS服务器一样，完成<br>server名字到IP的解析。</p>
<p><img src="/images/android_aosp_fdbus_make01.png" alt="image"></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>将FDBUS源码下载后放入Android AOSP源码 <code>/frameworks/native/services</code> 中：</p>
<blockquote>
<p>不是必须放入该目录，这里以此目录为例。</p>
</blockquote>
<p><img src="/images/android_aosp_fdbus_make02.png" alt="image"></p>
<h2 id="配置fdbus的android-bp文件"><a href="#配置fdbus的android-bp文件" class="headerlink" title="配置fdbus的android.bp文件"></a>配置fdbus的android.bp文件</h2><p>打开Android.bp文件，将其修改为如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">//=====================================================================================</span><br><span class="line">//                   makefile to build fdbus in aosp source tree                      |</span><br><span class="line">//=====================================================================================</span><br><span class="line"></span><br><span class="line">//=====================================================================================</span><br><span class="line">//                           build libfdbus.so                                  |</span><br><span class="line">//=====================================================================================</span><br><span class="line"></span><br><span class="line">SRC<span class="built_in">_</span>FILES = [</span><br><span class="line">    &quot;fdbus/CBaseClient.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbBaseObject.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbMessage.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbSimpleSerializer.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CBaseEndpoint.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbCJsonMsgBuilder.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbSessionContainer.cpp&quot;,</span><br><span class="line">    &quot;log/CLogProducer.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CBaseServer.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbContext.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbBaseContext.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbSession.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbMsgDispatcher.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CEventSubscribeHandle.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbUDPSession.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CBaseSession.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbWatchdog.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CFdbEventRouter.cpp&quot;,</span><br><span class="line">    &quot;platform/CEventFd<span class="built_in">_</span>eventfd.cpp&quot;,</span><br><span class="line">    &quot;platform/linux/CBaseMutexLock.cpp&quot;,</span><br><span class="line">    &quot;platform/linux/CBasePipe.cpp&quot;,</span><br><span class="line">    &quot;platform/linux/CBaseSysDep.cpp&quot;,</span><br><span class="line">    &quot;platform/linux/CBaseThread.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/CBaseSocketFactory.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/linux/CLinuxSocket.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/sckt-0.5/sckt.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/CGenericClientSocket.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/CGenericServerSocket.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/CGenericSession.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/CGenericSocket.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/CGenericTcpSession.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/CGenericUdpSession.cpp&quot;,</span><br><span class="line">    &quot;platform/socket/CGenericUdpSocket.cpp&quot;,</span><br><span class="line">    &quot;security/CApiSecurityConfig.cpp&quot;,</span><br><span class="line">    &quot;security/CFdbToken.cpp&quot;,</span><br><span class="line">    &quot;security/CFdbusSecurityConfig.cpp&quot;,</span><br><span class="line">    &quot;security/CHostSecurityConfig.cpp&quot;,</span><br><span class="line">    &quot;security/CServerSecurityConfig.cpp&quot;,</span><br><span class="line">    &quot;utils/fdb<span class="built_in">_</span>option<span class="built_in">_</span>parser.cpp&quot;,</span><br><span class="line">    &quot;worker/CBaseEventLoop.cpp&quot;,</span><br><span class="line">    &quot;worker/CBaseWorker.cpp&quot;,</span><br><span class="line">    &quot;worker/CFdEventLoop.cpp&quot;,</span><br><span class="line">    &quot;worker/CThreadEventLoop.cpp&quot;,</span><br><span class="line">    &quot;worker/CSysFdWatch.cpp&quot;,</span><br><span class="line">    &quot;utils/CBaseNameProxy.cpp&quot;,</span><br><span class="line">    &quot;fdbus/CIntraNameProxy.cpp&quot;,</span><br><span class="line">    &quot;server/CAddressAllocator.cpp&quot;,</span><br><span class="line">    &quot;log/CLogPrinter.cpp&quot;,</span><br><span class="line">    &quot;log/CFdbLogCache.cpp&quot;,</span><br><span class="line">    &quot;utils/cJSON/cJSON.c&quot;,</span><br><span class="line">    &quot;fdbus/CFdbAFComponent.cpp&quot;,</span><br><span class="line">    &quot;datapool/CDataPool.cpp&quot;,</span><br><span class="line">    &quot;datapool/CDpClient.cpp&quot;,</span><br><span class="line">    &quot;datapool/CDpServer.cpp&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>shared &#123;</span><br><span class="line">    name: &quot;libfdbus&quot;,</span><br><span class="line">    vendor<span class="built_in">_</span>available: true,</span><br><span class="line"></span><br><span class="line">    cppflags: [</span><br><span class="line">    	&quot;-Wno-non-virtual-dtor&quot;,</span><br><span class="line">	&quot;-Wno-format-extra-args&quot;,</span><br><span class="line">	&quot;-Wno-infinite-recursion&quot;,</span><br><span class="line">	&quot;-Wno-unused-private-field&quot;,</span><br><span class="line">	&quot;-Wno-unreachable-code-loop-increment&quot;,</span><br><span class="line">        &quot;-frtti&quot;,</span><br><span class="line">        &quot;-fexceptions&quot;,</span><br><span class="line">        &quot;-Wno-unused-parameter&quot;,</span><br><span class="line">        &quot;-D<span class="built_in">_</span><span class="built_in">_</span>LINUX<span class="built_in">_</span><span class="built_in">_</span>&quot;,</span><br><span class="line">        &quot;-DFDB<span class="built_in">_</span>CFG<span class="built_in">_</span>SOCKET<span class="built_in">_</span>PATH=<span class="keyword">\&quot;</span>/data/misc/fdbus<span class="keyword">\&quot;</span>&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>DEBUG<span class="built_in">_</span>LOG&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>SOCKET<span class="built_in">_</span>CONNECT<span class="built_in">_</span>TIMEOUT=0&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>LOG<span class="built_in">_</span>TO<span class="built_in">_</span>STDOUT&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>FDB<span class="built_in">_</span>NO<span class="built_in">_</span>RTTI&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>FDB<span class="built_in">_</span>MESSAGE<span class="built_in">_</span>METADATA&quot;,</span><br><span class="line">        &quot;-DFDB<span class="built_in">_</span>CONFIG<span class="built_in">_</span>UDS<span class="built_in">_</span>ABSTRACT&quot;,</span><br><span class="line">        &quot;-DCFG<span class="built_in">_</span>ALLOC<span class="built_in">_</span>PORT<span class="built_in">_</span>BY<span class="built_in">_</span>SYSTEM&quot;,</span><br><span class="line">    ],</span><br><span class="line">    cflags: [</span><br><span class="line">    	&quot;-Wno-non-virtual-dtor&quot;,</span><br><span class="line">	&quot;-Wno-format-extra-args&quot;,</span><br><span class="line">	&quot;-Wno-infinite-recursion&quot;,</span><br><span class="line">	&quot;-Wno-unused-private-field&quot;,</span><br><span class="line">	&quot;-Wno-unreachable-code-loop-increment&quot;,</span><br><span class="line">        &quot;-Wno-unused-parameter&quot;,</span><br><span class="line">        &quot;-D<span class="built_in">_</span><span class="built_in">_</span>LINUX<span class="built_in">_</span><span class="built_in">_</span>&quot;,</span><br><span class="line">        &quot;-DFDB<span class="built_in">_</span>CFG<span class="built_in">_</span>SOCKET<span class="built_in">_</span>PATH=<span class="keyword">\&quot;</span>/data/misc/fdbus<span class="keyword">\&quot;</span>&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>DEBUG<span class="built_in">_</span>LOG&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>SOCKET<span class="built_in">_</span>CONNECT<span class="built_in">_</span>TIMEOUT=0&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>LOG<span class="built_in">_</span>TO<span class="built_in">_</span>STDOUT&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>FDB<span class="built_in">_</span>MESSAGE<span class="built_in">_</span>METADATA&quot;,</span><br><span class="line">        &quot;-DFDB<span class="built_in">_</span>CONFIG<span class="built_in">_</span>UDS<span class="built_in">_</span>ABSTRACT&quot;,</span><br><span class="line">        &quot;-DCFG<span class="built_in">_</span>ALLOC<span class="built_in">_</span>PORT<span class="built_in">_</span>BY<span class="built_in">_</span>SYSTEM&quot;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    shared<span class="built_in">_</span>libs: [</span><br><span class="line">        &quot;liblog&quot;,</span><br><span class="line">        &quot;libutils&quot;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    srcs: SRC<span class="built_in">_</span>FILES,</span><br><span class="line"></span><br><span class="line">    export<span class="built_in">_</span>include<span class="built_in">_</span>dirs: [&quot;public&quot;],</span><br><span class="line"></span><br><span class="line">    local<span class="built_in">_</span>include<span class="built_in">_</span>dirs: [],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//=====================================================================================</span><br><span class="line">//                             build libfdbus-jni.so                                  |</span><br><span class="line">//=====================================================================================</span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>shared &#123;</span><br><span class="line">    name: &quot;libfdbus-jni&quot;,</span><br><span class="line"></span><br><span class="line">    cppflags: [</span><br><span class="line">    	&quot;-Wno-non-virtual-dtor&quot;,</span><br><span class="line">	&quot;-Wno-format-extra-args&quot;,</span><br><span class="line">	&quot;-Wno-infinite-recursion&quot;,</span><br><span class="line">	&quot;-Wno-unused-private-field&quot;,</span><br><span class="line">	&quot;-Wno-unreachable-code-loop-increment&quot;,</span><br><span class="line">        &quot;-frtti&quot;,</span><br><span class="line">        &quot;-fexceptions&quot;,</span><br><span class="line">        &quot;-Wno-unused-parameter&quot;,</span><br><span class="line">        &quot;-D<span class="built_in">_</span><span class="built_in">_</span>LINUX<span class="built_in">_</span><span class="built_in">_</span>&quot;,</span><br><span class="line">        &quot;-DFDB<span class="built_in">_</span>CFG<span class="built_in">_</span>SOCKET<span class="built_in">_</span>PATH=<span class="keyword">\&quot;</span>/data/misc/fdbus<span class="keyword">\&quot;</span>&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>DEBUG<span class="built_in">_</span>LOG&quot;,</span><br><span class="line">        &quot;-DCFG<span class="built_in">_</span>JNI<span class="built_in">_</span>ANDROID&quot;,</span><br><span class="line">        &quot;-DFDB<span class="built_in">_</span>CFG<span class="built_in">_</span>KEEP<span class="built_in">_</span>ENV<span class="built_in">_</span>TYPE&quot;,</span><br><span class="line">    ],</span><br><span class="line">    cflags: [</span><br><span class="line">    &quot;-Wno-non-virtual-dtor&quot;,</span><br><span class="line">	&quot;-Wno-format-extra-args&quot;,</span><br><span class="line">	&quot;-Wno-infinite-recursion&quot;,</span><br><span class="line">	&quot;-Wno-unused-private-field&quot;,</span><br><span class="line">	&quot;-Wno-unreachable-code-loop-increment&quot;,</span><br><span class="line">        &quot;-Wno-unused-parameter&quot;,</span><br><span class="line">        &quot;-D<span class="built_in">_</span><span class="built_in">_</span>LINUX<span class="built_in">_</span><span class="built_in">_</span>&quot;,</span><br><span class="line">        &quot;-DFDB<span class="built_in">_</span>CFG<span class="built_in">_</span>SOCKET<span class="built_in">_</span>PATH=<span class="keyword">\&quot;</span>/data/misc/fdbus<span class="keyword">\&quot;</span>&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>DEBUG<span class="built_in">_</span>LOG&quot;,</span><br><span class="line">        &quot;-DCFG<span class="built_in">_</span>JNI<span class="built_in">_</span>ANDROID&quot;,</span><br><span class="line">    ],</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;jni/src/cpp/CJniClient.cpp&quot;,</span><br><span class="line">        &quot;jni/src/cpp/CJniMessage.cpp&quot;,</span><br><span class="line">        &quot;jni/src/cpp/CJniServer.cpp&quot;,</span><br><span class="line">        &quot;jni/src/cpp/FdbusGlobal.cpp&quot;,</span><br><span class="line">        &quot;jni/src/cpp/CJniAFComponent.cpp&quot;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    shared<span class="built_in">_</span>libs: [&quot;libfdbus&quot;],</span><br><span class="line"></span><br><span class="line">    include<span class="built_in">_</span>dirs: [</span><br><span class="line">        &quot;frameworks/base/core/jni&quot;,</span><br><span class="line">        &quot;frameworks/base/core/jni/include&quot;,</span><br><span class="line">    ],</span><br><span class="line">    header<span class="built_in">_</span>libs: [&quot;jni<span class="built_in">_</span>headers&quot;],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//=====================================================================================</span><br><span class="line">//                                  build name-server                                 |</span><br><span class="line">//=====================================================================================</span><br><span class="line">cc<span class="built_in">_</span>binary &#123;</span><br><span class="line">    name: &quot;name-server&quot;,</span><br><span class="line">    vendor<span class="built_in">_</span>available: true,</span><br><span class="line">    //该行注释不用，使用init.rc中进行启动配置</span><br><span class="line">    //init<span class="built_in">_</span>rc: [&quot;fdbus-name-server.rc&quot;],</span><br><span class="line">    cppflags: [</span><br><span class="line">        &quot;-Wno-non-virtual-dtor&quot;,</span><br><span class="line">	&quot;-Wno-format-extra-args&quot;,</span><br><span class="line">	&quot;-Wno-infinite-recursion&quot;,</span><br><span class="line">	&quot;-Wno-unused-private-field&quot;,</span><br><span class="line">	&quot;-Wno-unreachable-code-loop-increment&quot;,</span><br><span class="line">        &quot;-frtti&quot;,</span><br><span class="line">        &quot;-fexceptions&quot;,</span><br><span class="line">        &quot;-Wno-unused-parameter&quot;,</span><br><span class="line">        &quot;-D<span class="built_in">_</span><span class="built_in">_</span>LINUX<span class="built_in">_</span><span class="built_in">_</span>&quot;,</span><br><span class="line">        &quot;-DFDB<span class="built_in">_</span>CFG<span class="built_in">_</span>SOCKET<span class="built_in">_</span>PATH=<span class="keyword">\&quot;</span>/data/misc/fdbus<span class="keyword">\&quot;</span>&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>DEBUG<span class="built_in">_</span>LOG&quot;,</span><br><span class="line">    ],</span><br><span class="line">    cflags: [</span><br><span class="line">        &quot;-Wno-non-virtual-dtor&quot;,</span><br><span class="line">	&quot;-Wno-format-extra-args&quot;,</span><br><span class="line">	&quot;-Wno-infinite-recursion&quot;,</span><br><span class="line">	&quot;-Wno-unused-private-field&quot;,</span><br><span class="line">	&quot;-Wno-unreachable-code-loop-increment&quot;,</span><br><span class="line">        &quot;-Wno-unused-parameter&quot;,</span><br><span class="line">        &quot;-D<span class="built_in">_</span><span class="built_in">_</span>LINUX<span class="built_in">_</span><span class="built_in">_</span>&quot;,</span><br><span class="line">        &quot;-DFDB<span class="built_in">_</span>CFG<span class="built_in">_</span>SOCKET<span class="built_in">_</span>PATH=<span class="keyword">\&quot;</span>/data/misc/fdbus<span class="keyword">\&quot;</span>&quot;,</span><br><span class="line">        &quot;-DCONFIG<span class="built_in">_</span>DEBUG<span class="built_in">_</span>LOG&quot;,</span><br><span class="line">    ],</span><br><span class="line">    srcs: [</span><br><span class="line">        &quot;server/main<span class="built_in">_</span>ns.cpp&quot;,</span><br><span class="line">        &quot;server/CNameServer.cpp&quot;,</span><br><span class="line">        &quot;server/CInterNameProxy.cpp&quot;,</span><br><span class="line">        &quot;server/CIntraHostProxy.cpp&quot;,</span><br><span class="line">        &quot;server/CBaseHostProxy.cpp&quot;,</span><br><span class="line">        &quot;server/CSvcAddrUtils.cpp&quot;,</span><br><span class="line">        &quot;server/CNameProxyContainer.cpp&quot;,</span><br><span class="line">        &quot;security/CServerSecurityConfig.cpp&quot;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    shared<span class="built_in">_</span>libs: [</span><br><span class="line">        &quot;libfdbus&quot;,</span><br><span class="line">        &quot;liblog&quot;,</span><br><span class="line">        &quot;libutils&quot;,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述脚本会编译出libfdbus.so、libfdbus-jni.so与name-server可执行文件。</p>
<p>libfdbus.so、libfdbus-jni.so的输出目录为：</p>
<blockquote>
<p>/home/jia/AOSP/aosp/out/target/product/emulator_x86_64/system/lib</p>
</blockquote>
<p>name-server的输出目录为：</p>
<blockquote>
<p>/home/jia/AOSP/aosp/out/target/product/emulator_x86_64/system/bin</p>
</blockquote>
<h1 id="部署启动与权限配置"><a href="#部署启动与权限配置" class="headerlink" title="部署启动与权限配置"></a>部署启动与权限配置</h1><h2 id="配置product"><a href="#配置product" class="headerlink" title="配置product"></a>配置product</h2><p>在Android12中在 /build/target/product/base_system.mk 中配置：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Base modules and settings for the system partition.</span></span><br><span class="line">PRODUCT_PACKAGES += \</span><br><span class="line">    ......</span><br><span class="line">    surfaceflinger \</span><br><span class="line">    name-server \</span><br><span class="line">    libfdbus-jni \</span><br><span class="line">    libfdbus \</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<h2 id="name-server启动配置"><a href="#name-server启动配置" class="headerlink" title="name-server启动配置"></a>name-server启动配置</h2><p>为了让name-server开机启动，需要在 init.rc 中配置启动脚本。</p>
<p>打开 /system/core/rootdir/init.rc 在文件最后加入：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#1</span>、在挂载 /data 后创建/data/misc/fdbus 并设置system用户组权限</span><br><span class="line">on post-fs-data</span><br><span class="line">	mkdir /data/misc/fdbus 0755 system system</span><br><span class="line"><span class="params">#2</span>、启动name-server</span><br><span class="line">service name-server /system/bin/name-server -u tcp://139.224.136.101:60000 -n android</span><br><span class="line">	class core</span><br><span class="line">	group inet</span><br><span class="line">	writepid /dev/cpuset/system-background/tasks</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1、因为FDBUS支持uds与tcp。在当前系统中其他进程需要连接name-server会采用UDS的方式，/data/misc/fdbus 则为name-server的uds固定地址。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">mkdir /data/misc/fdbus 0755 system system：创建文件并设置权限。</span><br></pre></td></tr></table></figure>

<p>2、-u 参数后文解释，-n 参数为当前name-server的别名可以随意传递。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">class core：当前服务属主，系统能根据属主统一管理同属主下所有的进程，同一个class的所有服务必须同时启动或者停止。</span><br><span class="line">group inet：当前服务的用户组。 inet 组表示允许网络访问！</span><br></pre></td></tr></table></figure>

<p>在<code>/framework/base/data/etc/platform.xml</code> 中可以查看权限对应的用户组：</p>
<p><img src="/images/android_aosp_fdbus_make03.png" alt="image"></p>
</blockquote>
<h2 id="name-server的SELinux权限配置"><a href="#name-server的SELinux权限配置" class="headerlink" title="name-server的SELinux权限配置"></a>name-server的SELinux权限配置</h2><p>完成上述配置后，系统启动就会拉起name-server，但是此时name-server还无法正常工作。Android是建立在标准<br>的Linux Kernel基础上，通过Linux的 SELinux（SEAndroid）进行访问权限控制。比如name-server需要访问<br>tcp_socket、unix_stream_socket则必须开启SElinux的访问限制。</p>
<p>修改 <code>system/sepolicy/prebuilts/api/31.0/private</code> 与 <code>system/sepolicy/private</code> 目录下同<br>样的：file_contexts、netd.te与untrusted_app_all.te文件，并在两个目录下都创建name-server.te文件。</p>
<p>在file_contexts的最后一行加入：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">/system/bin/name-server 	u:object<span class="built_in">_</span>r:name-server<span class="built_in">_</span>exec:s0</span><br></pre></td></tr></table></figure>

<p>新建name-server.te 文件中内容为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">type name-server, domain, coredomain, mlstrustedsubject;</span><br><span class="line">type name-server<span class="built_in">_</span>exec, system<span class="built_in">_</span>file<span class="built_in">_</span>type, exec<span class="built_in">_</span>type, file<span class="built_in">_</span>type;</span><br><span class="line"></span><br><span class="line">allow name-server self:tcp<span class="built_in">_</span>socket &#123; read write getattr getopt setopt shutdown create bind connect name<span class="built_in">_</span>connect &#125;;</span><br><span class="line">allow name-server self:netlink<span class="built_in">_</span>route<span class="built_in">_</span>socket &#123;create write read nlmsg<span class="built_in">_</span>readpriv nlmsg<span class="built_in">_</span>read&#125;;</span><br><span class="line">allow name-server fwmarkd<span class="built_in">_</span>socket:sock<span class="built_in">_</span>file &#123;write&#125;;</span><br><span class="line">allow name-server port:tcp<span class="built_in">_</span>socket &#123;name<span class="built_in">_</span>connect&#125;;</span><br><span class="line">allow name-server netd:unix<span class="built_in">_</span>stream<span class="built_in">_</span>socket &#123;connectto&#125;;</span><br><span class="line">allow name-server self:capability &#123;net<span class="built_in">_</span>raw&#125;;</span><br><span class="line">allow name-server node:tcp<span class="built_in">_</span>socket &#123;node<span class="built_in">_</span>bind&#125;;</span><br><span class="line"></span><br><span class="line">init<span class="built_in">_</span>daemon<span class="built_in">_</span>domain(name-server)</span><br></pre></td></tr></table></figure>

<p>同时name-server需要与netd进程（网络管理进程）交互，还需要在netd.te 增加：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">typeattribute netd coredomain;</span><br><span class="line">typeattribute netd domain<span class="built_in">_</span>deprecated;</span><br><span class="line"><span class="params">#</span>增加==============</span><br><span class="line">allow netd name-server:fd &#123;use&#125;;</span><br><span class="line">allow netd name-server:tcp<span class="built_in">_</span>socket &#123;getopt&#125;;</span><br><span class="line">allow netd name-server:tcp<span class="built_in">_</span>socket &#123;setopt&#125;;</span><br><span class="line">allow netd name-server:tcp<span class="built_in">_</span>socket &#123;read write&#125;;</span><br><span class="line"><span class="params">#</span>==============</span><br><span class="line"><span class="params">#</span>......</span><br></pre></td></tr></table></figure>

<p>如果需要普通APP使用name-server， 还需要在 untrusted_app_all.te 中加入:</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">allow untrusted<span class="built_in">_</span>app<span class="built_in">_</span>all app<span class="built_in">_</span>api<span class="built_in">_</span>service:service<span class="built_in">_</span>manager find;</span><br><span class="line">allow untrusted<span class="built_in">_</span>app<span class="built_in">_</span>all vr<span class="built_in">_</span>manager<span class="built_in">_</span>service:service<span class="built_in">_</span>manager find;</span><br><span class="line">allow untrusted<span class="built_in">_</span>app<span class="built_in">_</span>all lance<span class="built_in">_</span>service:service<span class="built_in">_</span>manager find;</span><br><span class="line"><span class="params">#</span> 加入此处规则</span><br><span class="line">allow untrusted<span class="built_in">_</span>app<span class="built_in">_</span>all name-server:unix<span class="built_in">_</span>stream<span class="built_in">_</span>socket&#123;connectto&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="FDBUS-API-Framework-SDK集成"><a href="#FDBUS-API-Framework-SDK集成" class="headerlink" title="FDBUS-API Framework-SDK集成"></a>FDBUS-API Framework-SDK集成</h1><p>在上一步，我们不仅完成了name-server的部署，同时编译出libfdbus-jni.so，该动态库为FDBUS的Java层API的JNI封装。为了在Java中完成FDBUS的使用，可以将FDBUS集成进入Framework与SDK中。</p>
<p>将FDBUS中的 jni\src\java 下的Java代码放入AOSP源码中的 /frameworks/base/core/java 中</p>
<p><img src="/images/android_aosp_fdbus_make04.png" alt="image"></p>
<p><img src="/images/android_aosp_fdbus_make05.png" alt="image"></p>
<p>修改AOSP源码中的 build/soong/scripts/check_boot_jars/package_allowed_list.txt 。</p>
<p><img src="/images/android_aosp_fdbus_make06.png" alt="image"></p>
<p>修改 <code>/framework/base/Android.bp</code>中的<strong>metalava_framework_docs_args</strong>与<strong>packages_to_document</strong> 。前者表示忽略我们的Java代码中的lint检查；后者则代表将我们的Java API打包进入文档，这样才能在SDK中可见，也就是说APP能够调用新增的Java API。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">metalava<span class="built_in">_</span>framework<span class="built_in">_</span>docs<span class="built_in">_</span>args = &quot;--manifest <span class="built_in">$</span>(location core/res/AndroidManifest.xml) &quot;+</span><br><span class="line">&quot;--api-lint-ignore-prefix ipc. &quot;</span><br><span class="line">//......</span><br><span class="line"></span><br><span class="line">packages<span class="built_in">_</span>to<span class="built_in">_</span>document = [</span><br><span class="line">    //......</span><br><span class="line">    &quot;ipc.fdbus&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="编译与集成过程中的错误及解决"><a href="#编译与集成过程中的错误及解决" class="headerlink" title="编译与集成过程中的错误及解决"></a>编译与集成过程中的错误及解决</h1><h2 id="clang-编译错误"><a href="#clang-编译错误" class="headerlink" title="clang 编译错误"></a>clang 编译错误</h2><p><img src="/images/android_aosp_fdbus_make07.png" alt="image"></p>
<p>在CBaseClient.cpp的118行存在如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOG_E</span>(<span class="string">&quot;CClientSocket: client %s shutdown but try to request address of and connect again...\n&quot;</span>,client-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>(), client-&gt;<span class="built_in">nsName</span>().<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<p>Android Log库输出日志，但是代码中传递了两个参数 client-&gt;name().c_str() 与 client-&gt;nsName().c_str() ，<br>然而只存在一个 %s 接收，此时参数不匹配。解决该问题的方式有两种：</p>
<h3 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h3><p>在第一个参数中加入一个 %s ，让参数与占位符数量匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOG_E</span>(<span class="string">&quot;CClientSocket: client %s shutdown but try to request address of and connect %s again...\n&quot;</span>,client-&gt;<span class="built_in">name</span>().<span class="built_in">c_str</span>(), client-&gt;<span class="built_in">nsName</span>().<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<h3 id="配置android-bp"><a href="#配置android-bp" class="headerlink" title="配置android.bp"></a>配置android.bp</h3><p>在Android.bp中的name-server配置处的cflags与cppflags处加入：”-Wno-format-extra-args”，表示忽略该问题。</p>
<h2 id="其他clang错误"><a href="#其他clang错误" class="headerlink" title="其他clang错误"></a>其他clang错误</h2><p>继续编译，会出现很多与上一个类似的问题日志，都是因为Android12在编译时cflags/cppflags设置了-Werror，将<br>原本默认为警告的类型指定为了错误。</p>
<blockquote>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">-Werror:把警告当作错误，出现任何警告就放弃编译；</span><br><span class="line">-Werror=【type】：将指定类型的警告设置为error，如-Werror=unused-variable（当存在未使用的变量时</span><br><span class="line">中断编译）；</span><br><span class="line">-Wno-error:忽略所有报错；</span><br><span class="line">-Wno-error=【type】：忽略指定类型错误；</span><br><span class="line">-Wno-【type】：忽略指定类型的警告；</span><br></pre></td></tr></table></figure>
</blockquote>
<p>按照日志提示，在Android.bp中所有模块的cflag与cppflags中加入：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&quot;-Wno-non-virtual-dtor&quot;,</span><br><span class="line">&quot;-Wno-format-extra-args&quot;,</span><br><span class="line">&quot;-Wno-infinite-recursion&quot;,</span><br><span class="line">&quot;-Wno-unused-private-field&quot;,</span><br><span class="line">&quot;-Wno-unreachable-code-loop-increment&quot;,</span><br></pre></td></tr></table></figure>

<p>最终Android.bp中所有的cflag与cpflags为：</p>
<p><img src="/images/android_aosp_fdbus_make08.png" alt="image"></p>
<h2 id="jni-h-not-found"><a href="#jni-h-not-found" class="headerlink" title="jni.h not found"></a>jni.h not found</h2><p>由于libfdbus-jni中需要使用jni，此时在Android12中编译会报出：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">In file included from frameworks/base/core/jni/fdbus/CJniAFComponent.cpp:17:</span><br><span class="line">frameworks/base/core/jni/fdbus/FdbusGlobal.h:19:10: fatal error: &#x27;jni.h&#x27; file not found</span><br><span class="line"><span class="params">#</span>include &lt;jni.h&gt;</span><br><span class="line"><span class="built_in">^</span>~~~~~~</span><br><span class="line">1 error generated.</span><br><span class="line">22:15:22 ninja failed with: exit status 1</span><br></pre></td></tr></table></figure>

<p>通过学习 framework/base/core/jni 下的Android.bp（编译libandroid_runtime.so）发现，其中存在如下配置：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">//......</span><br><span class="line">static<span class="built_in">_</span>libs: [</span><br><span class="line">    &quot;libnativehelper<span class="built_in">_</span>lazy&quot;,</span><br><span class="line">    &quot;libziparchive<span class="built_in">_</span>for<span class="built_in">_</span>incfs&quot;,</span><br><span class="line">],</span><br><span class="line">//......</span><br><span class="line">//导出头文件：谁依赖我，就能使用我导出的头文件</span><br><span class="line">export<span class="built_in">_</span>static<span class="built_in">_</span>lib<span class="built_in">_</span>headers: [</span><br><span class="line">    // AndroidRuntime.h depends on nativehelper/jni.h</span><br><span class="line">    &quot;libnativehelper<span class="built_in">_</span>lazy&quot;,</span><br><span class="line">],</span><br><span class="line">//......</span><br></pre></td></tr></table></figure>

<p>可以发现libandroid_runtime.so依赖于libnativehelper_lazy.a，同时会导出libnativehelper_lazy的头文件。在<br>源码根目录下找到libnativehelper中的Android.bp，其中部分内容如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">//头文件模块：jni<span class="built_in">_</span>headers，包含include<span class="built_in">_</span>jni下所有的头文件（该目录下存在一个头文件jni.h）</span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>headers &#123;</span><br><span class="line">    name: &quot;jni<span class="built_in">_</span>headers&quot;,</span><br><span class="line">    export<span class="built_in">_</span>include<span class="built_in">_</span>dirs: [&quot;include<span class="built_in">_</span>jni&quot;],</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br><span class="line">//头文件模块：libnativehelper<span class="built_in">_</span>header<span class="built_in">_</span>only，包含header<span class="built_in">_</span>only<span class="built_in">_</span>include下所有的头文件</span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>headers &#123;</span><br><span class="line">    name: &quot;libnativehelper<span class="built_in">_</span>header<span class="built_in">_</span>only&quot;,</span><br><span class="line">    export<span class="built_in">_</span>include<span class="built_in">_</span>dirs: [</span><br><span class="line">    	&quot;header<span class="built_in">_</span>only<span class="built_in">_</span>include&quot;,</span><br><span class="line">	],</span><br><span class="line">    header<span class="built_in">_</span>libs: [&quot;jni<span class="built_in">_</span>headers&quot;], //依赖jni<span class="built_in">_</span>headers模块</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br><span class="line">//头文件模块：jni<span class="built_in">_</span>platform<span class="built_in">_</span>headers，包含include<span class="built_in">_</span>platform<span class="built_in">_</span>header<span class="built_in">_</span>only下所有的头文件</span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>headers &#123;</span><br><span class="line">    name: &quot;jni<span class="built_in">_</span>platform<span class="built_in">_</span>headers&quot;,</span><br><span class="line">    export<span class="built_in">_</span>include<span class="built_in">_</span>dirs: [</span><br><span class="line">    	&quot;include<span class="built_in">_</span>platform<span class="built_in">_</span>header<span class="built_in">_</span>only&quot;,</span><br><span class="line">    ],</span><br><span class="line">    header<span class="built_in">_</span>libs: [&quot;jni<span class="built_in">_</span>headers&quot;],</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br><span class="line">//动态库模块:libnativehelper.so</span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>shared &#123;</span><br><span class="line">    name: &quot;libnativehelper&quot;,</span><br><span class="line">    //导出头文件</span><br><span class="line">    export<span class="built_in">_</span>include<span class="built_in">_</span>dirs: [</span><br><span class="line">    	&quot;header<span class="built_in">_</span>only<span class="built_in">_</span>include&quot;,</span><br><span class="line">        &quot;include&quot;,</span><br><span class="line">        &quot;include<span class="built_in">_</span>jni&quot;,</span><br><span class="line">        &quot;include<span class="built_in">_</span>platform&quot;,</span><br><span class="line">        &quot;include<span class="built_in">_</span>platform<span class="built_in">_</span>header<span class="built_in">_</span>only&quot;,</span><br><span class="line">    ],</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br><span class="line">//静态库：libnativehelper<span class="built_in">_</span>lazy.a</span><br><span class="line">cc<span class="built_in">_</span>library<span class="built_in">_</span>static &#123;</span><br><span class="line">    name: &quot;libnativehelper<span class="built_in">_</span>lazy&quot;,</span><br><span class="line">    export<span class="built_in">_</span>include<span class="built_in">_</span>dirs: [</span><br><span class="line">        &quot;header<span class="built_in">_</span>only<span class="built_in">_</span>include&quot;,</span><br><span class="line">        &quot;include&quot;,</span><br><span class="line">        &quot;include<span class="built_in">_</span>jni&quot;,</span><br><span class="line">        &quot;include<span class="built_in">_</span>platform&quot;,</span><br><span class="line">        &quot;include<span class="built_in">_</span>platform<span class="built_in">_</span>header<span class="built_in">_</span>only&quot;,</span><br><span class="line">    ],</span><br><span class="line">    //......</span><br><span class="line">&#125;</span><br><span class="line">//......</span><br></pre></td></tr></table></figure>

<p>很显然， framework/base/core/jni 下的libandroid_runtime.so 依赖静态库libnativehelper_lazy。同时在libnativehelper_lazy的配置中会导出 include_jni ,因此能使用 jni.h 。而我们的libfdbus-jni.so不需要依赖nativehelper，因此可以直接在libfdbus-jni的编译配置中加入：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">header<span class="built_in">_</span>libs: [&quot;jni<span class="built_in">_</span>headers&quot;]</span><br></pre></td></tr></table></figure>

<p>如果需要依赖nativehelper可以写成：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">//依赖libnativehelper<span class="built_in">_</span>lazy.a</span><br><span class="line">static<span class="built_in">_</span>libs: [</span><br><span class="line">	&quot;libnativehelper<span class="built_in">_</span>lazy&quot;,</span><br><span class="line">],</span><br><span class="line">//依赖libnativehelper.so</span><br><span class="line">shared<span class="built_in">_</span>libs:[</span><br><span class="line">	&quot;libnativehelper&quot;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>因为在静态库和动态库中都将 include_jni 目录导出，因此依赖这些库即可使用 jni.h 。</p>
<h2 id="package-allowed-list-txt"><a href="#package-allowed-list-txt" class="headerlink" title="package_allowed_list.txt"></a>package_allowed_list.txt</h2><p>由于我们在Framework中增加了对应的Java API，此时编译报错如下错误： ipc.fdbus 包不允许打包进入Framework。</p>
<p><img src="/images/android_aosp_fdbus_make09.png" alt="image"></p>
<p>按照提示，在 build/soong/scripts/check_boot_jars/package_allowed_list.txt 中加入我们的包名：</p>
<p><img src="/images/android_aosp_fdbus_make06.png" alt="image"></p>
<h2 id="selinux-file-contexts错误"><a href="#selinux-file-contexts错误" class="headerlink" title="selinux file_contexts错误"></a>selinux file_contexts错误</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Error: could not load context file from out/target/product/emulator<span class="built_in">_</span>x86<span class="built_in">_</span>64/obj/ETC/plat<span class="built_in">_</span>file<span class="built_in">_</span>contexts<span class="built_in">_</span>intermediates/plat<span class="built_in">_</span>file<span class="built_in">_</span>contexts</span><br><span class="line">16:31:55 ninja failed with: exit status 1</span><br></pre></td></tr></table></figure>

<p>这个错误最终定位到原因，挺扯淡的。是因为在file_contexts最后一行增加name_server上下文后没有增加空行引起的……</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> ......</span><br><span class="line">/system/bin/name-server 	u:object<span class="built_in">_</span>r:name-server<span class="built_in">_</span>exec:s0</span><br><span class="line"><span class="params">#</span> 最后一行配置之后必须预留一行，要不然编译时会报找不到最后一个file<span class="built_in">_</span>contexts错误</span><br></pre></td></tr></table></figure>

<h2 id="抓取开机日志排查问题"><a href="#抓取开机日志排查问题" class="headerlink" title="抓取开机日志排查问题"></a>抓取开机日志排查问题</h2><ol>
<li>先用命令<code>adb reboot</code>重启设备模拟器</li>
<li>然后立即输入命令<code>adb root</code></li>
<li>然后<code>adb wait-for-device shell dmesg &gt;dmesg.txt</code></li>
</ol>
<h1 id="FDBUS部署与跨系统通信测试"><a href="#FDBUS部署与跨系统通信测试" class="headerlink" title="FDBUS部署与跨系统通信测试"></a>FDBUS部署与跨系统通信测试</h1><p>车载系统中，由于Hypervisor的采用，有的域内可能会有多个节点。如智能座舱域，一个SOC芯片上可能会同时运行QNX和Android，虽然位于同一个SOC上，但还是被认为是两个节点。这两个节点必须打通，才能相互通信！</p>
<p><img src="/images/android_aosp_fdbus_make10.png" alt="image"></p>
<p>在Android与QNX系统中各自部署name-server，Android与QNX的name-server只能管理系统自身内部服务，为了<br>打通两个系统，FDBUS提供了host-server。<br>就好像DNS解析，本地DNS服务器无法解析，就会请求远程服务器。如果说name-server是本地DNS服务器，那么<br>host-server就是远程DNS服务器。</p>
<p><img src="/images/android_aosp_fdbus_make11.png" alt="image"></p>
<h2 id="host-server部署"><a href="#host-server部署" class="headerlink" title="host-server部署"></a>host-server部署</h2><p>host-server可以搭建在域内，也可以搭建在域外，只要保证Android与QNX都能够访问即可。</p>
<p>为了方便测试，我们模拟一个通信环境，大致描述一下环境：</p>
<blockquote>
<p>在ubuntu系统上跑一个android模拟器。</p>
<p>android模拟器可以理解为车载的android系统，内部运行有name-server</p>
<p>ubuntu系统可以理解为车载的QNX系统，内部运行了name-server、host-server和一个真正处理业务的service</p>
</blockquote>
<p>我们需要在Ubuntu上搭建name-server和host-server服务，然后启动一个测试的service server</p>
<p>fdbus的完整编译参照文章 <a href="https://blog.csdn.net/u012739527/article/details/124011570">https://blog.csdn.net/u012739527/article/details/124011570</a></p>
<p>编译完成后，启动name-server、host-server、fdbxserver(fdbus提供的测试服务)</p>
<p><img src="/images/android_aosp_fdbus_make12.png" alt="image"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jia@jia-virtual-machine:~/work/fdbus/fdbus/build$ ./host_server &amp;</span><br><span class="line">[5] 13494</span><br><span class="line">jia@jia-virtual-machine:~/work/fdbus/fdbus/build$ ./name_server &amp;</span><br><span class="line">[6] 13497</span><br><span class="line">jia@jia-virtual-machine:~/work/fdbus/fdbus/build$ ./fdbxserver</span><br></pre></td></tr></table></figure>

<h2 id="客户端测试app"><a href="#客户端测试app" class="headerlink" title="客户端测试app"></a>客户端测试app</h2><p>需要先将上文中aosp集成fdbus后编译出的SDK更新添加到studio的platform中以便app compile使用。</p>
<p>然后编写测试代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapplication</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> ipc.fdbus.FdbusClient</span><br><span class="line"><span class="keyword">import</span> ipc.fdbus.FdbusClientListener</span><br><span class="line"><span class="keyword">import</span> ipc.fdbus.FdbusMessage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QnxClient</span> : <span class="type">FdbusClientListener &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mClient: FdbusClient</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        mClient = FdbusClient()</span><br><span class="line">        mClient.setListener(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> client: FdbusClient</span><br><span class="line">        <span class="keyword">get</span>() = mClient</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onOnline</span><span class="params">(sid: <span class="type">Int</span>, i1: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onOnline: <span class="variable">$sid</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onOffline</span><span class="params">(sid: <span class="type">Int</span>, i1: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onOffline: <span class="variable">$sid</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onReply</span><span class="params">(fdbusMessage: <span class="type">FdbusMessage</span>)</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onReply: &quot;</span> + fdbusMessage.toString())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onGetEvent</span><span class="params">(fdbusMessage: <span class="type">FdbusMessage</span>)</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onGetEvent: &quot;</span> + fdbusMessage.toString())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onBroadcast</span><span class="params">(fdbusMessage: <span class="type">FdbusMessage</span>)</span></span> &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onGetEvent: &quot;</span> + fdbusMessage.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;QnxClient&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapplication</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.<span class="keyword">annotation</span>.SuppressLint</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> ipc.fdbus.Fdbus</span><br><span class="line"><span class="keyword">import</span> ipc.fdbus.FdbusAppListener</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> qnxClient: QnxClient? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="meta-string">&quot;WrongConstant&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        Fdbus()</span><br><span class="line">        qnxClient = QnxClient()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨系统通信</span></span><br><span class="line">        qnxClient!!.client.connect(<span class="string">&quot;svc://org.fdbus.xtest-server&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendQnx</span><span class="params">(view: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> fdbusMessage = qnxClient!!.client.invokeSync(<span class="number">1</span>, <span class="string">&quot;xxxxxx&quot;</span>.toByteArray())</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;qnx响应: &quot;</span> + String(fdbusMessage.byteArray()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">disconnectQnx</span><span class="params">(view: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        qnxClient!!.client.disconnect()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行app并点击测试</p>
<p><img src="/images/android_aosp_fdbus_make13.png" alt="image"></p>
<p>控制台输出</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">qnx响应: xxxxxx</span><br></pre></td></tr></table></figure>

<p>fdbxserver收到响应并回复</p>
<p><img src="/images/android_aosp_fdbus_make14.png" alt="image"></p>
]]></content>
      <categories>
        <category>Android系统开发</category>
        <category>车联网</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
        <tag>FDBUS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Binder机制相关的灵魂发问</title>
    <url>/2019/06/25/android_binder_faq/</url>
    <content><![CDATA[<p>Binder机制是Android系统中最重要的系统机制之一，关于Binder机制的细节问题更是多入牛毛。对于常见的一些问题整理如下：</p>
<span id="more"></span>

<h2 id="为什么要引入多进程"><a href="#为什么要引入多进程" class="headerlink" title="为什么要引入多进程"></a>为什么要引入多进程</h2><p>第一点：Android系统为每个APP会分配固定大小的内存。如果一个APP需要更多的内存空间，要么就可以引入多进程，让某些模块运行在另外的进程中，获取更大的内存；</p>
<p>第二点：由于每个APP运行在不同的进程中，若共享APP中的某些数据的时候，例如通讯录等。</p>
<h2 id="Android中常见的跨进程通信-IPC-的方式"><a href="#Android中常见的跨进程通信-IPC-的方式" class="headerlink" title="Android中常见的跨进程通信(IPC)的方式"></a>Android中常见的跨进程通信(IPC)的方式</h2><ul>
<li>Bundle：常用于四大组件之间的通信，实现了Parcelable接口；</li>
<li>ContentProvider：存储和获取数据，不同APP之间共享数据；</li>
<li>文件共享：常用于无并发，交换数据实时性不高；</li>
<li>Messenger：在不同进程通过Message传输，只支持Bundle支持的数据类型，不支持RPC（远程过程调用：Client调用Server的方法）；低并发的一对多的串行通信（串行的方式接收Client发出的消息）；最底层基于AIDL；</li>
<li>AIDL：一对多并发通信（Server支持同时处理大量消息），支持RPC；</li>
<li>Socket：网络数据交换</li>
</ul>
<h2 id="什么是Binder"><a href="#什么是Binder" class="headerlink" title="什么是Binder"></a>什么是Binder</h2><p>在Linux系统中，会将虚拟空间分为用户空间和内核空间。系统每启动一个APP，就会给APP在用户空间创建一个进程；由于Android系统对每个APP是有内存限制，如果想给该APP申请更大的内存，同样也可以在该APP中额外创建一个进程来运行其他模块。</p>
<p>由于进程间是不能互相访问的，只能通过内核空间进行中转，而Binder机制就是Android系统中的一种跨进程通信的方式。</p>
<p>Binder机制需要四部分组成：<strong>Server、Client、ServiceManager</strong>以及Binder驱动。前三个运行在用户空间，Binder驱动运行在内核空间。<strong>Server、Client、ServiceManager</strong>之间进行数据通信，都需要通过Binder驱动进行中转。</p>
<p>相对于Linux其他IPC方式来说，Binder机制只需要拷贝一次数据，并且在用Binder驱动传递数据的时候，分配和传输数据一样大的内存，节省了内存和时间。（因为Linux系统的其他IPC因为不知道传输数据的大小，所以目标进程为了能够有足够的空间来存放数据，通常会分配尽可能大的空间；或者有的IPC通过先解析消息头的信息来获取消息体的大小，例如Socket，浪费空间或时间）。</p>
<h2 id="ServiceManager进程"><a href="#ServiceManager进程" class="headerlink" title="ServiceManager进程"></a>ServiceManager进程</h2><p>用来管理Service的注册和查询。将字符串转换层对应的Binder引用。该进程为系统启动的时候，有init进程创建出来的。在ServiceManager进程创建的过程中，会执行两步操作：</p>
<ul>
<li>第一步：通过binder_open()打开“/dev/binder”设备文件，获取一个文件描述符，才可以与Binder驱动进行交互；</li>
<li>第二步：通过mmap将该设备文件映射到用户空间的虚拟内存，同时系统调用到内核，也在内核空间分配虚拟内存，同时申请一块物理内存，同时映射到用户空间对应的虚拟内存和内核空间对应的虚拟内存中；</li>
<li>第三步：通过ioctl发送指令，告诉Binder驱动，该进程为ServiceManager进程；</li>
<li>第四步：通过binder_loop()，开启一个循环，时刻等待Binder驱动发送过来的消息；</li>
<li>第五步：当接收Binder驱动发送的消息时，通过binder_parse()解析和处理消息。</li>
</ul>
<h2 id="Client进程"><a href="#Client进程" class="headerlink" title="Client进程"></a>Client进程</h2><p>通常APP进程会作为Client进程。</p>
<p>当Android系统启动的时候，启动的第一个用户进程为init进程，init进程fork出Zygote进程，Android的其他进程都是有Zygote进程fork出来的。</p>
<p>一个进程要经历创建、初始化以及加载功能。那么Zygote进程有init进程创建出来的，在完成初始化加载功能的时候，会创建一个Socket通信的ZygoteServer，用来接收AMS发出创建进程的请求；同时fork出system_server进程，完成system_server进程初始化、功能加载：system_server进程主要就是启动一些系统Service，如AMS、PMS、WMS等。</p>
<p>当Zygote进程接收到AMS创建APP进程的时候，维护的循环中就会通过Zygote进程fork出一个进程，完成APP进程的初始化、功能加载：主要加载了APP的入口类ActivityThread，通过维护的循环消息机制来完成对Activity、Broadcast、Service等操作。</p>
<p>APP进程需要通过Binder驱动与其他进程通信，同样需要获取“/dev/binder”设备文件的描述符，并且在用户空间分配虚拟内存，在内核空间对应分配虚拟内存，同时申请一块物理内存，完成映射。区别于ServiceManager进程，该APP进程会设置Binder驱动的最大连接数，默认的为15个，只会创建binder主线程，其他的线程有Binder驱动来控制创建。</p>
<h2 id="Server进程"><a href="#Server进程" class="headerlink" title="Server进程"></a>Server进程</h2><p>在APP中都是通过AMS来启动Service，在启动Service之前会判断该Service的进程是否和APP的进程一致，如果跟APP的进程一致，则直接通过ActivityThread中维护的消息队列来启动该Service；如果不在APP的进程中，则会通过AMS的startProcessLocked()，最终将进程的信息写入到与Zygote进程的socket通道中，Zygote进程收到消息之后，同样会通过Zygote进程fork出一个进程，并完成该进程的初始化、功能加载，同样也是加载了一个ActivityThread类。</p>
<p>只不过bindService在创建完进程之后，还会发送通过ActivityThread的消息机制完成Service的bind过程。</p>
<p>扩展几个小问题：</p>
<p>1.为什么Zygote进程与system_server进程之间的通信采用Socket，而不是Binder</p>
<ul>
<li>（1）Binder机制的前提的是ServiceManager进程创建出来，而SeviceManager进程和Zygote进程都是有init进程创建的，并且Zygote进程会先在ServiceManager进程前面一点点，而Zygote进程在fork出system_server进程的进程的时候，不能完全保证ServiceManager进程已经创建完。</li>
<li>（2）Zygote进程与system_server进程之间的socket的所有者是root，group是system，只有系统权限的用户才能读写，增加了安全保障。</li>
</ul>
<p>2.为什么Zygote进程是fork出APP或者Service进程，而不是新建进程<br> 每个APP都运行在各自的Dalivk虚拟机中，APP每次启动的时候都要初始化和启动虚拟机，这个过程会很费时间。而Zygote进程通过fork把已经运行的虚拟机和内存信息共享，可以预加载资源和类，缩短启动时间</p>
<h2 id="Binder机制中的一次拷贝原理"><a href="#Binder机制中的一次拷贝原理" class="headerlink" title="Binder机制中的一次拷贝原理"></a>Binder机制中的一次拷贝原理</h2><p>进程之间使用Binder驱动来进行通信，需要首先获取一个dev/binder设备文件的文件描述符，才可以与Binder驱动交互。Binder驱动会为每个进程创建一个binder_proc的结构体，然后将该结构体放到全局的hash队列binder_procs中，只要遍历该队列，就知道当前有多少进程在使用Binder通信。</p>
<p>其次还需要利用mmap内存映射，可以将/dev/binder设备文件映射到用户空间的虚拟内存中。系统在为该文件内存映射的时候，不仅在用户空间分配虚拟内存，并且还会在内核空间分配虚拟内存，并且Kernel还会申请一块物理内存同时映射到用户空间对应的虚拟内存和在内核空间对应的虚拟内存；这样如果将数据拷贝到用户空间，都是相当于拷贝到内核空间，反之亦然。</p>
<p>在将数据从发送进程传递到目标进程的时候：</p>
<ul>
<li>（1）首先将数据从发送进程的用户空间对应的虚拟内存拷贝到内核空间对应的虚拟内存中；</li>
<li>（2）然后使用Binder驱动传递数据的时候，Binder驱动会为该数据创建一个数据接收缓冲区，而该缓冲区是从目标进程在内核空间对应的虚拟内存开始分配虚拟内存，那么当把数据从发送进程对应的虚拟内存拷贝到Binder驱动的数据缓冲区的时候，其实就相当于直接拷贝到目标进程在内核空间对应的虚拟内存中。</li>
<li>（3）由于前面创建目标进程的时候，由于进程在用户空间分配的虚拟内存和在内核空间对应的虚拟内存存在映射关系，实际上上面的过程就是直接拷贝到了目标进程在用户空间分配的虚拟内存中。</li>
<li>（4）目标进程将数据从内核空间对应的虚拟内存拷贝到用户空间对应的虚拟内存。</li>
</ul>
<p>这样就完成了Binder机制中的一次拷贝，我觉得所谓的Binder机制的一次拷贝，指的是用Binder驱动传递数据的时候只需要拷贝一次数据。</p>
<h2 id="AIDL中的代理模式"><a href="#AIDL中的代理模式" class="headerlink" title="AIDL中的代理模式"></a>AIDL中的代理模式</h2><p>两个进程之间的跨进程通信必须通过Binder驱动进行中转。在应用层创建的AIDL文件，最终会将该文件编译成一个java文件。该文件包括三部分的内容：</p>
<ul>
<li>（1）公共接口：制定Server进程所要实现功能的标准，为代理模式的公共接口；</li>
<li>（2）Stub：继承Binder，用于Server进程来访问Binder驱动；实现公共接口的抽象类（这里还是一个适配器模式），实现公共接口的具体功能，为代理模式的被代理类；</li>
<li>（3）Stub.Proxy：实现公共接口，并持有Stub的对象（这个只不过是Binder驱动的本地对象BinderProxy，该BinderProxy对象用于Client进程来访问Binder驱动），实现两个进程的RPC，为代理模式的代理类。</li>
</ul>
<h2 id="AIDL的跨进程具体实现过程"><a href="#AIDL的跨进程具体实现过程" class="headerlink" title="AIDL的跨进程具体实现过程"></a>AIDL的跨进程具体实现过程</h2><p>AIDL服务是应用层的Service，区别与系统Service，系统Service是通过ServiceManager进程来管理，而应用Service是通过AMS来管理。</p>
<p>Client和Server之所以能够实现跨进程通信，都是通过Binder驱动进行中转。Android系统在Framework层和Native层对Binder驱动进行封装，使得应用层可以通过API调用到Binder驱动。</p>
<p><strong>在native层封装体现：</strong></p>
<ul>
<li>（1）进程在Native层会通过ProcessState初始化进程主要会完成下面内容：<br> 通过ProcessState来获取Binder驱动的设备文件”/dev/binder”的文件描述符，完成内存映射；<br> 开启Binder线程池，创建线程池中的第一个Binder主线程IPCThreadState；<br> 在该Binder主线程中维护一个循环，来读取Binder驱动发送过来的消息。</li>
<li>（2）Binder驱动在向进程中binder_read_thread的时候，都会先看下有没有空闲的Binder线程，如果没有则通知ProcesState的Binder线程池创建一个Binder非主线程来发送消息；</li>
<li>（3）进程通过IPCThreadState调用ioctl来与Binder驱动进行传递信息。Client进程通过BpBinder来调用到ioctl完成向Binder驱动发送数据，而在Server进程通过BBinder，准确的说是JavaBBinder完成向Binder驱动发送数据。<br> 在应用层主要是通过Framework封装的API来完成IPC的，在Framework层封装体现：</li>
<li>（1）Client通过bindService将ServiceConnection给到Server，当Server创建成功的时候，通过onBind将BinderProxy返回给Client；</li>
<li>（2）在Client进程就是通过BinderProxy来向Binder驱动发送数据，在Server进程会继承Stub，也是Binder的子类，通过Binder来向Binder驱动传递数据；<br> 当Client要访问Server进程的RPC（Remote Process Call远程过程调用）的时候：</li>
<li>（1）Client进程调用BinderProxy的transact()，通过jni调用到BpBinder的transact()，然后调用到IPCThreadState向Binder驱动发送数据；</li>
<li>（2）Binder驱动接收到Client进程发送的指令的时候，就会通过BBinder的ransact()调用到JavaBBinder的onTransact()，通过jni调用到Server进程的Binder的onTransact()，最终调用到Stub中对应的接口方法，完成RPC。</li>
</ul>
<h2 id="Binder如何精确制导，找到目标Binder实体，并唤醒进程或者线程"><a href="#Binder如何精确制导，找到目标Binder实体，并唤醒进程或者线程" class="headerlink" title="Binder如何精确制导，找到目标Binder实体，并唤醒进程或者线程"></a>Binder如何精确制导，找到目标Binder实体，并唤醒进程或者线程</h2><p>Binder实体服务其实有两种，一是通过addService注册到ServiceManager中的服务，比如ActivityManagerService、PackageManagerService、PowerManagerService等，一般都是系统服务；还有一种是通过bindService拉起的一些服务，一般是开发者自己实现的服务。这里先看通过addService添加的被ServiceManager所管理的服务。有很多分析ServiceManager的文章，本文不分析ServiceManager，只是简单提一下，ServiceManager是比较特殊的服务，所有应用都能直接使用，因为ServiceManager对于Client端来说Handle句柄是固定的，都是0，所以ServiceManager服务并不需要查询，可以直接使用。</p>
<p>理解Binder定向制导的关键是理解Binder的四棵红黑树，先看一下binder_proc结构体，在它内部有四棵红黑树，threads，nodes，refs_by_desc，refs_by_node，nodes就是Binder实体在内核中对应的数据结构，binder_node里记录进程相关的binder_proc，还有Binder实体自身的地址等信息，nodes红黑树位于binder_proc，可以知道Binder实体其实是进程内可见，而不是线程内。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span></span><br><span class="line">    。。。</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">    。。。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在假设存在一堆Client与Service，Client如何才能访问Service呢？首先Service会通过addService将binder实体注册到ServiceManager中去，Client如果想要使用Servcie，就需要通过getService向ServiceManager请求该服务。在Service通过addService向ServiceManager注册的时候，ServiceManager会将服务相关的信息存储到自己进程的Service列表中去，同时在ServiceManager进程的binder_ref红黑树中为Service添加binder_ref节点，这样ServiceManager就能获取Service的Binder实体信息。而当Client通过getService向ServiceManager请求该Service服务的时候，ServiceManager会在注册的Service列表中查找该服务，如果找到就将该服务返回给Client，在这个过程中，ServiceManager会在Client进程的binder_ref红黑树中添加binder_ref节点，可见<strong>本进程中的binder_ref红黑树节点都不是本进程自己创建的，要么是Service进程将binder_ref插入到ServiceManager中去，要么是ServiceManager进程将binder_ref插入到Client中去</strong>。之后，Client就能通过Handle句柄获取binder_ref，进而访问Service服务。</p>
<p><img src="/images/android_binder_faq_binder_ref_add_logic.png" alt="img"></p>
<p>binder_ref添加逻辑</p>
<p>getService之后，便可以获取binder_ref引用，进而获取到binder_proc与binder_node信息，之后Client便可有目的的将binder_transaction事务插入到binder_proc的待处理列表，并且，如果进程正在睡眠，就唤起进程，其实这里到底是唤起进程还是线程也有讲究，对于Client向Service发送请求的状况，一般都是唤醒binder_proc上睡眠的线程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node_entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> desc;</span><br><span class="line">    <span class="keyword">int</span> strong;</span><br><span class="line">    <span class="keyword">int</span> weak;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="binder-proc为何会有两棵binder-ref红黑树"><a href="#binder-proc为何会有两棵binder-ref红黑树" class="headerlink" title="binder_proc为何会有两棵binder_ref红黑树"></a>binder_proc为何会有两棵binder_ref红黑树</h2><p>binder_proc中存在两棵binder_ref红黑树，其实两棵红黑树中的节点是复用的，只是查询方式不同，一个通过handle句柄，一个通过node节点查找。个人理解：refs_by_node红黑树主要是为了<br> binder驱动往用户空间写数据所使用的，而refs_by_desc是用户空间向Binder驱动写数据使用的，只是方向问题。比如在服务addService的时候，binder驱动会在在ServiceManager进程的binder_proc中查找binder_ref结构体，如果没有就会新建binder_ref结构体，再比如在Client端getService的时候，binder驱动会在Client进程中通过 binder_get_ref_for_node为Client创建binder_ref结构体，并分配句柄，同时插入到refs_by_desc红黑树中，可见refs_by_node红黑树，主要是给binder驱动往用户空间写数据使用的。相对的refs_by_desc主要是为了用户空间往binder驱动写数据使用的，当用户空间已经获得Binder驱动为其创建的binder_ref引用句柄后，就可以通过binder_get_ref从refs_by_desc找到响应binder_ref，进而找到目标binder_node。可见有两棵红黑树主要是区分使用对象及数据流动方向，看下面的代码就能理解：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据32位的uint32_t desc来查找，可以看到，binder_get_ref不会新建binder_ref节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span> *binder_get_ref(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                     uint32_t desc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span> *n = proc-&gt;refs_by_desc.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span> *<span class="keyword">ref</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">ref</span> = rb_entry(n, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span>, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (desc &lt; <span class="keyword">ref</span>-&gt;desc)</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (desc &gt; <span class="keyword">ref</span>-&gt;desc)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">ref</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到binder_get_ref并具备binder_ref的创建功能，相对应的看一下binder_get_ref_for_node，binder_get_ref_for_node红黑树主要通过binder_node进行查找，如果找不到，就新建binder_ref，同时插入到两棵红黑树中去</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span> *binder_get_ref_for_node(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                          <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span></span> *node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span> *n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span> **p = &amp;proc-&gt;refs_by_node.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span></span> *parent = NULL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span> *<span class="keyword">ref</span>, *new_ref;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        <span class="keyword">ref</span> = rb_entry(parent, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span>, rb_node_node);</span><br><span class="line">        <span class="keyword">if</span> (node &lt; <span class="keyword">ref</span>-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node &gt; <span class="keyword">ref</span>-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">ref</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// binder_ref 可以在两棵树里面，但是，两棵树的查询方式不同，并且通过desc查询，不具备新建功能</span></span><br><span class="line">    new_ref = kzalloc(sizeof(*<span class="keyword">ref</span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (new_ref == NULL)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    binder_stats_created(BINDER_STAT_REF);</span><br><span class="line">    new_ref-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    new_ref-&gt;proc = proc;</span><br><span class="line">    new_ref-&gt;node = node;</span><br><span class="line">    rb_link_node(&amp;new_ref-&gt;rb_node_node, parent, p);</span><br><span class="line">    <span class="comment">// 插入到proc-&gt;refs_by_node红黑树中去</span></span><br><span class="line">    rb_insert_color(&amp;new_ref-&gt;rb_node_node, &amp;proc-&gt;refs_by_node);</span><br><span class="line">    <span class="comment">// 是不是ServiceManager的</span></span><br><span class="line">    new_ref-&gt;desc = (node == binder_context_mgr_node) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 分配Handle句柄，为了插入到refs_by_desc</span></span><br><span class="line">    <span class="keyword">for</span> (n = rb_first(&amp;proc-&gt;refs_by_desc); n != NULL; n = rb_next(n)) &#123;</span><br><span class="line">        <span class="keyword">ref</span> = rb_entry(n, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span>, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">ref</span>-&gt;desc &gt; new_ref-&gt;desc)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        new_ref-&gt;desc = <span class="keyword">ref</span>-&gt;desc + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到目标位置</span></span><br><span class="line">    p = &amp;proc-&gt;refs_by_desc.rb_node;</span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        <span class="keyword">ref</span> = rb_entry(parent, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span></span>, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (new_ref-&gt;desc &lt; <span class="keyword">ref</span>-&gt;desc)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (new_ref-&gt;desc &gt; <span class="keyword">ref</span>-&gt;desc)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    rb_link_node(&amp;new_ref-&gt;rb_node_desc, parent, p);</span><br><span class="line">    <span class="comment">// 插入到refs_by_desc红黑树中区</span></span><br><span class="line">    rb_insert_color(&amp;new_ref-&gt;rb_node_desc, &amp;proc-&gt;refs_by_desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        hlist_add_head(&amp;new_ref-&gt;node_entry, &amp;node-&gt;refs);</span><br><span class="line">        binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">                 <span class="string">&quot;binder: %d new ref %d desc %d for &quot;</span></span><br><span class="line">                 <span class="string">&quot;node %d\n&quot;</span>, proc-&gt;pid, new_ref-&gt;debug_id,</span><br><span class="line">                 new_ref-&gt;desc, node-&gt;debug_id);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">                 <span class="string">&quot;binder: %d new ref %d desc %d for &quot;</span></span><br><span class="line">                 <span class="string">&quot;dead node\n&quot;</span>, proc-&gt;pid, new_ref-&gt;debug_id,</span><br><span class="line">                  new_ref-&gt;desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数调用在binder_transaction函数中，其实就是在binder驱动访问target_proc的时候，这也也很容易理解，Handle句柄对于跨进程没有任何意义，进程A中的Handle，放到进程B中是无效的。</p>
<p><img src="/images/android_binder_faq_two_binder_ref_tree.png" alt="img"></p>
<p>两棵binder_ref红黑树</p>
<h2 id="Binder一次拷贝原理"><a href="#Binder一次拷贝原理" class="headerlink" title="Binder一次拷贝原理"></a>Binder一次拷贝原理</h2><p>Android选择Binder作为主要进程通信的方式同其性能高也有关系，Binder只需要一次拷贝就能将A进程用户空间的数据为B进程所用。这里主要涉及两个点：</p>
<ul>
<li><p>Binder的map函数，会将内核空间直接与用户空间对应，用户空间可以直接访问内核空间的数据</p>
</li>
<li><p>A进程的数据会被直接拷贝到B进程的内核空间（一次拷贝）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))</span></span><br><span class="line"></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>()</span><br><span class="line">    : <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>())</span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mManagesContexts</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">NULL</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">NULL</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ....</span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">   ...</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>mmap函数属于系统调用，mmap会从当前进程中获取用户态可用的虚拟地址空间（vm_area_struct *vma），并在mmap_region中真正获取vma，然后调用file-&gt;f_op-&gt;mmap(file, vma)，进入驱动处理，之后就会在内存中分配一块连续的虚拟地址空间，并预先分配好页表、已使用的与未使用的标识、初始地址、与用户空间的偏移等等，通过这一步之后，就能把Binder在内核空间的数据直接通过指针地址映射到用户空间，供进程在用户空间使用，这是一次拷贝的基础，一次拷贝在内核中的标识如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line"><span class="comment">// 四棵比较重要的树 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span></span><br><span class="line"><span class="keyword">int</span> pid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span> <span class="comment">//虚拟地址空间，用户控件传过来</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vma_vm_mm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line"><span class="keyword">int</span> deferred_work;</span><br><span class="line"><span class="keyword">void</span> *buffer; <span class="comment">//初始地址</span></span><br><span class="line"><span class="keyword">ptrdiff_t</span> user_buffer_offset; <span class="comment">//这里是偏移</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffers</span>;</span><span class="comment">//这个列表连接所有的内存块，以地址的大小为顺序，各内存块首尾相连</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">free_buffers</span>;</span><span class="comment">//连接所有的已建立映射的虚拟内存块，以内存的大小为index组织在以该节点为根的红黑树下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">allocated_buffers</span>;</span><span class="comment">//连接所有已经分配的虚拟内存块，以内存块的开始地址为index组织在以该节点为根的红黑树下</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是在APP启动的时候开启的地址映射，但并未涉及到数据的拷贝，下面看数据的拷贝操作。<strong>当数据从用户空间拷贝到内核空间的时候，是直从当前进程的用户空间接拷贝到目标进程的内核空间，这个过程是在请求端线程中处理的，操作对象是目标进程的内核空间</strong>。看如下代码：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> void binder_transaction(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span></span> *thread,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span> *tr, int reply)&#123;</span><br><span class="line">                   ...</span><br><span class="line">        在通过进行binder事物的传递时，如果一个binder事物（用<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span></span>结构体表示）需要使用到内存，</span><br><span class="line">        就会调用binder_alloc_buf函数分配此次binder事物需要的内存空间。</span><br><span class="line">        需要注意的是：这里是从目标进程的binder内存空间分配所需的内存</span><br><span class="line">        <span class="comment">//从target进程的binder内存空间分配所需的内存大小,这也是一次拷贝，完成通信的关键，直接拷贝到目标进程的内核空间</span></span><br><span class="line">        <span class="comment">//由于用户空间跟内核空间仅仅存在一个偏移地址，所以也算拷贝到用户空间</span></span><br><span class="line">        t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">            tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">        t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">        <span class="comment">//该binder_buffer对应的事务    </span></span><br><span class="line">        t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">        <span class="comment">//该事物对应的目标binder实体 ,因为目标进程中可能不仅仅有一个Binder实体</span></span><br><span class="line">        t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">        trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">        <span class="keyword">if</span> (target_node)</span><br><span class="line">            binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, NULL);</span><br><span class="line">        <span class="comment">// 计算出存放flat_binder_object结构体偏移数组的起始地址，4字节对齐。</span></span><br><span class="line">        offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));</span><br><span class="line">           <span class="comment">// struct flat_binder_object是binder在进程之间传输的表示方式 //</span></span><br><span class="line">           <span class="comment">// 这里就是完成binder通讯单边时候在用户进程同内核buffer之间的一次拷贝动作 //</span></span><br><span class="line">          <span class="comment">// 这里的数据拷贝，其实是拷贝到目标进程中去，因为t本身就是在目标进程的内核空间中分配的，</span></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">            binder_user_error(<span class="string">&quot;binder: %d:%d got transaction with invalid &quot;</span></span><br><span class="line">                <span class="string">&quot;data ptr\n&quot;</span>, proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            goto err_copy_data_failed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到binder_alloc_buf(target_proc, tr-&gt;data_size,tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY))函数在申请内存的时候，是从target_proc进程空间中去申请的，这样在做数据拷贝的时候copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size))，就会直接拷贝target_proc的内核空间，而由于Binder内核空间的数据能直接映射到用户空间，这里就不在需要拷贝到用户空间。这就是一次拷贝的原理。内核空间的数据映射到用户空间其实就是添加一个偏移地址，并且将数据的首地址、数据的大小都复制到一个用户空间的Parcel结构体，具体可以参考Parcel.cpp的Parcel::ipcSetDataReference函数。</p>
<p><img src="/images/android_binder_faq_one_copy.png" alt="img"></p>
<p>Binder一次拷贝原理.jpg</p>
<h2 id="Binder传输数据的大小限制"><a href="#Binder传输数据的大小限制" class="headerlink" title="Binder传输数据的大小限制"></a>Binder传输数据的大小限制</h2><p>虽然APP开发时候，Binder对程序员几乎不可见，但是作为Android的数据运输系统，Binder的影响是全面性的，所以有时候如果不了解Binder的一些限制，在出现问题的时候往往是没有任何头绪，比如在Activity之间传输BitMap的时候，如果Bitmap过大，就会引起问题，比如崩溃等，这其实就跟Binder传输数据大小的限制有关系，在上面的一次拷贝中分析过，mmap函数会为Binder数据传递映射一块连续的虚拟地址，这块虚拟内存空间其实是有大小限制的，不同的进程可能还不一样。</p>
<p>普通的由Zygote孵化而来的用户进程，所映射的Binder内存大小是不到1M的，准确说是 1<em>1024</em>1024) - (4096 *2) ：这个限制定义在ProcessState类中，如果传输说句超过这个大小，系统就会报错，因为Binder本身就是为了进程间频繁而灵活的通信所设计的，并不是为了拷贝大数据而使用的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))</span></span><br></pre></td></tr></table></figure>

<p>而在内核中，其实也有个限制，是4M，不过由于APP中已经限制了不到1M，这里的限制似乎也没多大用途：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> int binder_mmap(<span class="class"><span class="keyword">struct</span> <span class="title">file</span></span> *filp, <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span> *vma)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span></span> *area;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc = filp-&gt;private_data;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span> *failure_string;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span> *buffer;</span><br><span class="line">    <span class="comment">//限制不能超过4M</span></span><br><span class="line">    <span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">        vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line">    。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>有个特殊的进程ServiceManager进程，它为自己申请的Binder内核空间是128K，这个同ServiceManager的用途是分不开的，ServcieManager主要面向系统Service，只是简单的提供一些addServcie，getService的功能，不涉及多大的数据传输，因此不需要申请多大的内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅仅申请了128k</span></span><br><span class="line">    bs = <span class="built_in">binder_open</span>(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">binder_become_context_manager</span>(bs)) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;cannot become context manager (%s)\n&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    svcmgr_handle = svcmgr;</span><br><span class="line">    <span class="built_in">binder_loop</span>(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="系统服务与bindService等启动的服务的区别"><a href="#系统服务与bindService等启动的服务的区别" class="headerlink" title="系统服务与bindService等启动的服务的区别"></a>系统服务与bindService等启动的服务的区别</h2><p>服务可分为系统服务与普通服务，系统服务一般是在系统启动的时候，由SystemServer进程创建并注册到ServiceManager中的。而普通服务一般是通过ActivityManagerService启动的服务，或者说通过四大组件中的Service组件启动的服务。这两种服务在实现跟使用上是有不同的，主要从以下几个方面：</p>
<ul>
<li>服务的启动方式</li>
<li>服务的注册与管理</li>
<li>服务的请求使用方式</li>
</ul>
<p>首先看一下服务的启动上，系统服务一般都是SystemServer进程负责启动，比如AMS，WMS，PKMS，电源管理等，这些服务本身其实实现了Binder接口，作为Binder实体注册到ServiceManager中，被ServiceManager管理，而SystemServer进程里面会启动一些Binder线程，主要用于监听Client的请求，并分发给响应的服务实体类，可以看出，这些系统服务是位于SystemServer进程中（有例外，比如Media服务）。在来看一下bindService类型的服务，这类服务一般是通过Activity的startService或者其他context的startService启动的，这里的Service组件只是个封装，主要的是里面Binder服务实体类，这个启动过程不是ServcieManager管理的，而是通过ActivityManagerService进行管理的，同Activity管理类似。</p>
<p>再来看一下服务的注册与管理：系统服务一般都是通过ServiceManager的addService进行注册的，这些服务一般都是需要拥有特定的权限才能注册到ServiceManager，而bindService启动的服务可以算是注册到ActivityManagerService，只不过ActivityManagerService管理服务的方式同ServiceManager不一样，而是采用了Activity的管理模型，详细的可以自行分析</p>
<p>最后看一下使用方式，使用系统服务一般都是通过ServiceManager的getService得到服务的句柄，这个过程其实就是去ServiceManager中查询注册系统服务。而bindService启动的服务，主要是去ActivityManagerService中去查找相应的Service组件，最终会将Service内部Binder的句柄传给Client。</p>
<p><img src="/images/android_binder_faq_sys_binder_and_bind_service.png" alt="img"></p>
<p>系统服务与bindService启动服务的区别.jpg</p>
<h2 id="Binder线程、Binder主线程、Client请求线程的概念与区别"><a href="#Binder线程、Binder主线程、Client请求线程的概念与区别" class="headerlink" title="Binder线程、Binder主线程、Client请求线程的概念与区别"></a>Binder线程、Binder主线程、Client请求线程的概念与区别</h2><p>Binder线程是执行Binder服务的载体，只对于服务端才有意义，对请求端来说，是不需要考虑Binder线程的，但Android系统的处理机制其实大部分是互为C/S的。比如APP与AMS进行交互的时候，都互为对方的C与S，这里先不讨论这个问题，先看Binder线程的概念。</p>
<p>Binder线程就是执行Binder实体业务的线程，一个普通线程如何才能成为Binder线程呢？很简单，只要开启一个监听Binder字符设备的Loop线程即可，在Android中有很多种方法，不过归根到底都是监听Binder，换成代码就是通过ioctl来进行监听。</p>
<p>拿ServerManager进程来说，其主线就是Binder线程，其做法是通过binder_loop实现不死线程：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">void binder_loop(struct binder_state *bs, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">    <span class="comment">&lt;!--关键点1--&gt;</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">     <span class="comment">&lt;!--关键点2--&gt;</span></span><br><span class="line">        res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func);</span><br><span class="line">        。。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的关键代码1就是阻塞监听客户端请求，2 就是处理请求，并且这是一个死循环，不退出。再来看SystemServer进程中的线程，在Android4.3（6.0以后打代码就不一样了）中SystemSever主线程便是Binder线程，同时一个Binder主线程，Binder线程与Binder主线程的区别是：线程是否可以终止Loop，不过目前启动的Binder线程都是无法退出的，其实可以全部看做是Binder主线程，其实现原理是，<strong>在SystemServer主线程执行到最后的时候，Loop监听Binder设备，变身死循环线程</strong>，关键代码如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> status_t system_init()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ALOGI(<span class="string">&quot;System server: entering thread pool.\n&quot;</span>);</span><br><span class="line">    ProcessState::<span class="keyword">self</span>()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::<span class="keyword">self</span>()-&gt;joinThreadPool();</span><br><span class="line">    ALOGI(<span class="string">&quot;System server: exiting thread pool.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProcessState::self()-&gt;startThreadPool()是新建一个Binder主线程，而PCThreadState::self()-&gt;joinThreadPool()是将当前线程变成Binder主线程。其实startThreadPool最终也会调用joinThreadPool，看下其关键函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::joinThreadPool</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> cmd;</span><br><span class="line">        ...关键点<span class="number">1</span> </span><br><span class="line">        result = <span class="built_in">talkWithDriver</span>();</span><br><span class="line">        <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">           ...关键点<span class="number">2</span> </span><br><span class="line">            result = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非主线程的可以退出</span></span><br><span class="line">        <span class="keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 死循环，不完结，调用了这个，就好比是开启了Binder监听循环，</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ...关键点<span class="number">3</span> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">   &#125;   </span><br></pre></td></tr></table></figure>

<p>先看关键点1 talkWithDriver，其实质还是去掉用ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0)去不断的监听Binder字符设备，获取到Client传输的数据后，再通过executeCommand去执行相应的请求，joinThreadPool是普通线程化身Binder线程最常见的方式。不信，就再看一个MediaService,看一下main_mediaserver的main函数：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">int main(int argc, <span class="built_in">char</span>** argv)</span><br><span class="line">&#123;</span><br><span class="line">   。。。</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::<span class="keyword">self</span>());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">&quot;ServiceManager: %p&quot;</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        MediaPlayerService::instantiate();</span><br><span class="line">        CameraService::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        registerExtensions();</span><br><span class="line">        ProcessState::<span class="keyword">self</span>()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::<span class="keyword">self</span>()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实还是通过joinThreadPool变身Binder线程，至于是不是主线程，看一下下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::joinThreadPool</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessState::spawnPooledThread</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = <span class="built_in">makeBinderThreadName</span>();</span><br><span class="line">        <span class="built_in">ALOGV</span>(<span class="string">&quot;Spawning new pooled thread, name=%s\n&quot;</span>, name.<span class="built_in">string</span>());</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> <span class="built_in">PoolThread</span>(isMain);</span><br><span class="line">        t-&gt;<span class="built_in">run</span>(name.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实关键就是就是传递给joinThreadPool函数的isMain是否是true，不过是否是Binder主线程并没有什么用，因为源码中并没有为这两者的不同处理留入口，感兴趣可以去查看一下binder中的TIMED_OUT。</p>
<p>最后来看一下普通Client的binder请求线程，比如我们APP的主线程，在startActivity请求AMS的时候，APP的主线程成其实就是Binder请求线程，在进行Binder通信的过程中，Client的Binder请求线程会一直阻塞，知道Service处理完毕返回处理结果。</p>
<h2 id="Binder请求的同步与异步"><a href="#Binder请求的同步与异步" class="headerlink" title="Binder请求的同步与异步"></a>Binder请求的同步与异步</h2><p>很多人都会说，Binder是对Client端同步，而对Service端异步，其实并不完全正确，在单次Binder数据传递的过程中，其实都是同步的。只不过，Client在请求Server端服务的过程中，是需要返回结果的，即使是你看不到返回数据，其实还是会有个成功与失败的处理结果返回给Client，这就是所说的Client端是同步的。至于说服务端是异步的，可以这么理解：在服务端在被唤醒后，就去处理请求，处理结束后，服务端就将结果返回给正在等待的Client线程，将结果写入到Client的内核空间后，服务端就会直接返回了，不会再等待Client端的确认，这就是所说的服务端是异步的，可以从源码来看一下：</p>
<ul>
<li><p>Client端同步阻塞请求</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">         err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">     &#125; ...</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Client在请求服务的时候 Parcel* reply基本都是非空的（还没见过空用在什么位置），非空就会执行waitForResponse(reply)，如果看过几篇Binder分析文章的人应该都会知道，在A端向B写完数据之后，A会返回给自己一个BR_TRANSACTION_COMPLETE命令，告知自己数据已经成功写入到B的Binder内核空间中去了，如果是需要回复，在处理完BR_TRANSACTION_COMPLETE命令后会继续阻塞等待结果的返回：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">     cmd = mIn.<span class="built_in">readInt32</span>();</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (cmd) &#123;</span><br><span class="line">       &lt;!--关键点<span class="number">1</span> --&gt;</span><br><span class="line">      <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     &lt;!--关键点<span class="number">2</span> --&gt;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                  <span class="comment">// free buffer，先设置数据，直接</span></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 牵扯到数据利用，与内存释放</span></span><br><span class="line">                        reply-&gt;<span class="built_in">ipcSetDataReference</span>(...)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line"> finish:</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点1就是处理BR_TRANSACTION_COMPLETE，如果需要等待reply，还要通过talkWithDriver等待结果返回，最后执行关键点2，处理返回数据。<strong>对于服务端来说，区别就在于关键点1</strong>，来看一下服务端Binder线程的代码，拿常用的joinThreadPool来看，在talkWithDriver后，会执行executeCommand函数，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::joinThreadPool</span><span class="params">(<span class="keyword">bool</span> isMain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> cmd;</span><br><span class="line">        ...关键点<span class="number">1</span> </span><br><span class="line">        result = <span class="built_in">talkWithDriver</span>();</span><br><span class="line">        <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">           ...关键点<span class="number">2</span> </span><br><span class="line">            result = <span class="built_in">executeCommand</span>(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非主线程的可以退出</span></span><br><span class="line">        <span class="keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 死循环，不完结，调用了这个，就好比是开启了Binder监听循环，</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>executeCommand会进一步调用sendReply函数，看一下这里的特点waitForResponse(NULL, NULL)，这里传递的都是null，在上面的关键点1的地方我们知道，这里不需要等待Client返回，因此会直接 goto finish，这就是所说的Client同步，而服务端异步的逻辑。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BC_REPLY</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::sendReply</span><span class="params">(<span class="keyword">const</span> Parcel&amp; reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// flag 0</span></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">status_t</span> statusBuffer;</span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_REPLY, flags, <span class="number">-1</span>, <span class="number">0</span>, reply, &amp;statusBuffer);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">waitForResponse</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line"> <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line"> <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>请求同步最好的例子就是在Android6.0之前，国产ROM权限的申请都是同步的，在申请权限的时候，APP申请权限的线程会阻塞，就算是UI线程也会阻塞，ROM为了防止ANR，都会为权限申请设置一个倒计时，不操作，就给个默认操作，有兴趣可以自己分析。</p>
<h2 id="Android-APP进程天生支持Binder通信的原理是什么"><a href="#Android-APP进程天生支持Binder通信的原理是什么" class="headerlink" title="Android APP进程天生支持Binder通信的原理是什么"></a>Android APP进程天生支持Binder通信的原理是什么</h2><p>Android APP进程都是由Zygote进程孵化出来的。常见场景：点击桌面icon启动APP，或者startActivity启动一个新进程里面的Activity，最终都会由AMS去调用Process.start()方法去向Zygote进程发送请求，让Zygote去fork一个新进程，Zygote收到请求后会调用Zygote.forkAndSpecialize()来fork出新进程,之后会通过RuntimeInit.nativeZygoteInit来初始化Andriod APP运行需要的一些环境，而binder线程就是在这个时候新建启动的，看下面的源码（Android 4.3）：</p>
<p>这里不分析Zygote，只是给出其大概运行机制，Zygote在启动后，就会通过runSelectLoop不断的监听socket，等待请求来fork进程，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">()</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    FileDescriptor[] fdArray = <span class="keyword">new</span> FileDescriptor[<span class="number">4</span>];</span><br><span class="line">    ...     </span><br><span class="line">   <span class="keyword">int</span> loopCount = GC_LOOP_COUNT;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">         ...</span><br><span class="line">            <span class="keyword">boolean</span> done;</span><br><span class="line">            done = peers.get(index).runOnce();</span><br><span class="line">            ...</span><br><span class="line">        &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>每次fork请求到来都会调用ZygoteConnection的runOnce()来处理请求，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor[] descriptors;   </span><br><span class="line">        。。。</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       ...关键点<span class="number">1</span> </span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// in child</span></span><br><span class="line">         ...关键点<span class="number">2</span></span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">        。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>runOnce()有两个关键点，<strong>关键点1</strong> Zygote.forkAndSpecialize就是通过fork系统调用来新建进程，<strong>关键点2</strong> handleChildProc就是对新建的APP进程进行一些初始化工作，为Android Java进程创建一些必须的场景。Zygote.forkAndSpecialize没什么可看的，就是Linux中的fork进程，这里主要看一下handleChildProc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//从Process.start启动的parsedArgs.runtimeInit一般都是true            if (parsedArgs.runtimeInit) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                    parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                    pipeFd, parsedArgs.remainingArgs);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Android应用启动都走该分支</span></span><br><span class="line">       RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                    parsedArgs.remainingArgs); </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看 RuntimeInit.zygoteInit函数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> final <span class="keyword">void</span> zygoteInit(int targetSdkVersion, <span class="built_in">String</span>[] argv)</span><br><span class="line">        throws ZygoteInit.MethodAndArgsCaller &#123;</span><br><span class="line"></span><br><span class="line">    redirectLogStreams();</span><br><span class="line">    commonInit();</span><br><span class="line">    &lt;!--关键点<span class="number">1</span>--&gt;</span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">     &lt;!--关键点<span class="number">2</span>--&gt;</span><br><span class="line">    applicationInit(targetSdkVersion, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看关键点1，nativeZygoteInit属于Native方法，该方法位于AndroidRuntime.cpp中，其实就是调用调用到app_main.cpp中的onZygoteInit</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCurRuntime-&gt;<span class="built_in">onZygoteInit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键就是onZygoteInit</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> void onZygoteInit()</span><br><span class="line">&#123;</span><br><span class="line">    sp proc = ProcessState::<span class="keyword">self</span>();</span><br><span class="line">    <span class="comment">//启动新binder线程loop</span></span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，ProcessState::self()函数会调用open()打开/dev/binder设备，这个时候Client就能通过Binder进行远程通信；其次，proc-&gt;startThreadPool()负责新建一个binder线程，监听Binder设备，这样进程就具备了作为Binder服务端的资格。每个APP的进程都会通过onZygoteInit打开Binder，既能作为Client，也能作为Server，这就是Android进程天然支持Binder通信的原因。</p>
<p><img src="/images/android_binder_faq_app_support_binder.png" alt="img"></p>
<p>Android APP进程天然支持Binder通信.png</p>
<h2 id="Android-APP有多少Binder线程，是固定的么？"><a href="#Android-APP有多少Binder线程，是固定的么？" class="headerlink" title="Android APP有多少Binder线程，是固定的么？"></a>Android APP有多少Binder线程，是固定的么？</h2><p>通过上一个问题我们知道了Android APP线程为什么天然支持Binder通信，并且可以作为Binder的Service端，同时也对Binder线程有了一个了解，那么在一个Android APP的进程里面究竟有多少个Binder线程呢？是固定的吗。在分析上一个问题的时候，我们知道Android APP进程在Zygote fork之初就为它新建了一个Binder主线程，使得APP端也可以作为Binder的服务端，这个时候Binder线程的数量就只有一个，假设我们的APP自身实现了很多的Binder服务，一个线程够用的吗？这里不妨想想一下SystemServer进程，SystemServer拥有很多系统服务，一个线程应该是不够用的，如果看过SystemServer代码可能会发现，对于Android4.3的源码，其实一开始为该服务开启了两个Binder线程。还有个分析Binder常用的服务，media服务，也是在一开始的时候开启了两个线程。</p>
<p>先看下SystemServer的开始加载的线程：通过 ProcessState::self()-&gt;startThreadPool()新加了一个Binder线程，然后通过IPCThreadState::self()-&gt;joinThreadPool();将当前线程变成Binder线程，注意这里是针对Android4.3的源码，android6.0的这里略有不同。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> status_t system_init()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    ALOGI(<span class="string">&quot;System server: entering thread pool.\n&quot;</span>);</span><br><span class="line">    ProcessState::<span class="keyword">self</span>()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::<span class="keyword">self</span>()-&gt;joinThreadPool();</span><br><span class="line">    ALOGI(<span class="string">&quot;System server: exiting thread pool.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下Media服务,同SystemServer类似，也是开启了两个Binder线程：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">int main(int argc, <span class="built_in">char</span>** argv)</span><br><span class="line">&#123;      ...</span><br><span class="line">        ProcessState::<span class="keyword">self</span>()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::<span class="keyword">self</span>()-&gt;joinThreadPool();</span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>

<p>可以看出Android APP上层应用的进程一般是开启一个Binder线程，而对于SystemServer或者media服务等使用频率高，服务复杂的进程，一般都是开启两个或者更多。来看第二个问题，<strong>Binder线程的数目是固定的吗？答案是否定的，</strong>驱动会根据目标进程中是否存在足够多的Binder线程来告诉进程是不是要新建Binder线程，详细逻辑，首先看一下新建Binder线程的入口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (cmd) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 可以根据内核返回数据创建新的binder线程</span></span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;<span class="built_in">spawnPooledThread</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>executeCommand一定是从Bindr驱动返回的BR命令，这里是BR_SPAWN_LOOPER，什么时候，Binder驱动会向进程发送BR_SPAWN_LOOPER呢？全局搜索之后，发现只有一个地方binder_thread_read，<strong>如果直观的想一下，什么时候需要新建Binder线程呢？很简单，不够用的时候</strong>，注意上面使用的是spawnPooledThread(false)，也就是说这里启动的都是普通Binder线程。为了了解启动时机，先看一些binder_proc内部判定参数的意义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> max_threads;                <span class="comment">// 进程所能启动的最大非主Binder线程数目</span></span><br><span class="line">    <span class="keyword">int</span> requested_threads;          <span class="comment">// 请求启动的非主线程数</span></span><br><span class="line">    <span class="keyword">int</span> requested_threads_started;<span class="comment">//已经启动的非主线程数</span></span><br><span class="line">    <span class="keyword">int</span> ready_threads;              <span class="comment">// 当前可用的Binder线程数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再来看binder_thread_read函数中是么时候会去请求新建Binder线程，以Android APP进程为例子，通过前面的分析知道APP进程天然支持Binder通信，因为它有一个Binder主线程，启动之后就会阻塞等待Client请求,这里会更新proc-&gt;ready_threads，第一次阻塞等待的时候proc-&gt;ready_threads=1，之后睡眠。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">binder_thread_read（）&#123;</span><br><span class="line">  ...</span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">//当前线程todo队列为空且transaction栈为空，则代表该线程是空闲的 ，看看是不是自己被复用了</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp;</span><br><span class="line">        list_empty(&amp;thread-&gt;todo);</span><br><span class="line"> ...<span class="comment">//可用线程个数+1</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads++; </span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="comment">//当进程todo队列没有数据,则进入休眠等待状态</span></span><br><span class="line">            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//当线程todo队列没有数据，则进入休眠等待状态</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;    </span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    <span class="comment">//被唤醒可用线程个数-1</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads--; </span><br><span class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        uint32_t cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span> tr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span> *w;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span></span> *t = NULL;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//先考虑从线程todo队列获取事务数据</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo)) &#123;</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span>, entry);</span><br><span class="line">        <span class="comment">//线程todo队列没有数据, 则从进程todo对获取事务数据</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) &#123;</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span>, entry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">         ..</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            cmd = BR_TRANSACTION;  <span class="comment">//设置命令为BR_TRANSACTION</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cmd = BR_REPLY; <span class="comment">//设置命令为BR_REPLY</span></span><br><span class="line">        &#125;</span><br><span class="line">        .. </span><br><span class="line">done:</span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line">    <span class="comment">//创建线程的条件</span></span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">         BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">         <span class="comment">//需要新建的数目线程数+1</span></span><br><span class="line">        proc-&gt;requested_threads++;</span><br><span class="line">        <span class="comment">// 生成BR_SPAWN_LOOPER命令，用于创建新的线程</span></span><br><span class="line">        put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被Client唤醒后proc-&gt;ready_threads会-1，之后变成0，这样在执行到done的时候，就会发现proc-&gt;requested_threads + proc-&gt;ready_threads == 0，这是新建Binder线程的一个必须条件，再看下其他几个条件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">            (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">             BINDER_LOOPER_STATE_ENTERED)))  </span><br></pre></td></tr></table></figure>

<ul>
<li>proc-&gt;requested_threads + proc-&gt;ready_threads == 0 ：<strong>如果目前还没申请新建Binder线程，并且proc-&gt;ready_threads空闲Binder线程也是0，就需要新建一个Binder线程，其实就是为了保证有至少有一个空闲的线程</strong>。</li>
<li>proc-&gt;requested_threads_started &lt; proc-&gt;max_threads：<strong>目前启动的普通Binder线程数requested_threads_started还没达到上限（默认APP进程是15）</strong></li>
<li>thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED) 当先线程是Binder线程，这个是一定满足的，不知道为什么列出来</li>
</ul>
<p>proc-&gt;max_threads是多少呢？不同的进程其实设置的是不一样的，看普通的APP进程，在ProcessState::self()新建ProcessState单利对象的时候会调用ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);设置上限,可以看到默认设置的上限是15。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/binder&quot;</span>, O_RDWR);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">size_t</span> maxThreads = <span class="number">15</span>;</span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果满足新建的条件，就会将proc-&gt;requested_threads加1，并在驱动执行完毕后，利用put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)；通知服务端在用户空间发起新建Binder线程的操作，新建的是普通Binder线程，最终再进入binder_thread_write的BC_REGISTER_LOOPER:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">binder_thread_write</span>(<span class="params"><span class="keyword">struct</span> binder_proc *proc, <span class="keyword">struct</span> binder_thread *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">void</span> __user *buffer, <span class="built_in">int</span> size, signed <span class="built_in">long</span> *consumed</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</span><br><span class="line">              ...</span><br><span class="line">                <span class="comment">// requested_threads -- </span></span><br><span class="line">                proc-&gt;requested_threads--;</span><br><span class="line">                proc-&gt;requested_threads_started++;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会将proc-&gt;requested_threads复原，其实就是-1，并且启动的Binder线程数+1。</p>
<p>个人理解，之所以采用动态新建Binder线程的意义有两点，第一：如果没有Client请求服务，就保持线程数不变，减少资源浪费，需要的时候再分配新线程。第二：有请求的情况下，保证至少有一个空闲线程是给Client端，以提高Server端响应速度。</p>
<p>不过这里有一点要注意，对于同一个线程的请求，如果是阻塞的，那么没什么问题，肯定是等待上一个请求结束才能处理下一个，但是对于oneway方式的binder请求呢，这里就会存在这么一个场景，对于oneway的请求，如果上一个还没处理完，同一个线程的新的oneway请求会被塞到同一个目标线程等待执行，而不会触发创建新的Binder线程，因为这并不会妨碍另一端的处理，因为它压根无需等待，但是这可能会造成服务端单个线程任务繁重，而其他线程保持空闲，不过在一定程度上实现了同一种任务的顺序执行，可能也有一定的好处吧。</p>
<h2 id="同一个线程的请求必定是顺序执行，即使是异步请求-oneway"><a href="#同一个线程的请求必定是顺序执行，即使是异步请求-oneway" class="headerlink" title="同一个线程的请求必定是顺序执行，即使是异步请求(oneway)"></a>同一个线程的请求必定是顺序执行，即使是异步请求(oneway)</h2><p>一般而言，Client同步阻塞请求Service，直到Service提供完服务后才返回，不过，也有特殊的，比如请求用ONE_WAY方式，这种场景一般主要是用来通知，至于通知被谁消费，是否被消费压根不会关心。拿ContentService服务为例子，它是一个全局的通知中心，负责转发通知，而且，一般是群发，由于在转发的时候，ContentService被看做Client，如果这个时候采用普通的同步阻塞势必会造成通知的延时发送，所以这里的Client采用了oneway，异步。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IContentObserver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment"><span class="markdown">/<span class="strong">**</span></span></span></span><br><span class="line"><span class="strong"><span class="markdown"><span class="comment">     <span class="emphasis">* This method is called when </span></span></span>an<span class="markdown"><span class="strong"><span class="emphasis"> update occurs to </span></span></span>the<span class="markdown"><span class="strong"><span class="emphasis"> cursor that is being</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="markdown"><span class="comment">     *</span> observed. selfUpdate is true if </span></span>the<span class="markdown"><span class="strong"> update was caused by </span></span>a<span class="markdown"><span class="strong"> call to</span></span></span></span><br><span class="line"><span class="strong"><span class="markdown"><span class="comment">     <span class="emphasis">* commit on </span></span></span>the<span class="markdown"><span class="strong"><span class="emphasis"> cursor that is being observed.</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="markdown"><span class="comment">     *</span>/</span></span></span></span><br><span class="line">    oneway <span class="keyword">void</span> onChange(boolean selfUpdate, <span class="keyword">in</span> <span class="built_in">Uri</span> uri, <span class="built_in">int</span> userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种机制可能也会影响Service的性能，比如<strong>同一个线程中的Client</strong>请求的服务是一个耗时操作的时候，通过oneway的方式发送请求的话，如果之前的请求还没被执行完，则Service不会启动新的线程去响应，该请求线程的所有操作都会被放到同一个Binder线程中依次执行，这样其实没有利用Binder机制的动态线程池，如果是多个线程中的Client并发请求，则还是会动态增加Binder线程的，大概这个是为了保证同一个线程中的Binder请求要依次执行吧，这种表现好像是反过来了，Client异步，而Service阻塞了，也就是说虽然解决了Client请求不被阻塞的问题，但是请求的处理并未被加速。</p>
<h2 id="Client端线程睡眠在哪个队列上，唤醒Server端哪个等待队列上的线程"><a href="#Client端线程睡眠在哪个队列上，唤醒Server端哪个等待队列上的线程" class="headerlink" title="Client端线程睡眠在哪个队列上，唤醒Server端哪个等待队列上的线程"></a>Client端线程睡眠在哪个队列上，唤醒Server端哪个等待队列上的线程</h2><p>先看第一部分：发送端线程睡眠在哪个队列上？</p>
<p><strong>发送端线程一定睡眠在自己binder_thread的等待队列上，并且，该队列上有且只有自己一个睡眠线程</strong></p>
<p>再看第二部分：在Binder驱动去唤醒线程的时候，唤醒的是哪个等待队列上的线程？</p>
<p>理解这个问题需要理解binder_thread中的 struct binder_transaction * transaction_stack栈，这个栈规定了transaction的执行顺序：栈顶的一定先于栈内执行。</p>
<p>如果本地操作是BC_REPLY,一定是唤醒之前发送等待的线程，这个是100%的，但是如果是BC_TRANSACTION，那就不一定了,尤其是当两端互为服务相互请求的时候，场景如下：</p>
<ul>
<li>进程A的普通线程AT1请求B进程的B1服务，唤醒B进程的Binder线程，AT1睡眠等待服务结束</li>
<li>B进程的B1服务在执行的的时候，需要请求进程A的A1服务，则B进程的Binder线程BT1睡眠，等待服务结束。</li>
</ul>
<p>这个时候就会遇到一个问题：唤醒哪个线程比较合适？是睡眠在进程队列上的线程，还是之前睡眠的线程AT1？答案是：之前睡眠等待B服务返回的线程AT1，具体看下面的图解分析</p>
<p>首先第一步A普通线程去请求B进程的B1服务，这个时候在A进程的AT1线程的binder_ref中会将binder_transaction1入栈，而同样B的Binder线程在读取binder_work之后，也会将binder_transaction1加入自己的堆栈，如下图：</p>
<p><img src="/images/android_binder_faq_binder_wake_stack_list01.png" alt="img"></p>
<p>binder_transaction堆栈及唤醒那个队列1.jpg</p>
<p>而当B的Binder线程被唤醒后，执行Binder实体中的服务时，发现服务函数需要反过来去请求A端的A1服务，那就需要通过Binder向A进程发送请求，并新建binder_transaction2压入自己的binder_transaction堆栈，这个没有任何问题。但是，在A端入栈的时候，会面临一个抉择，写入那个队列？是binder_proc上的队列，还是正在等候B1服务返回的AT1线程的队列？</p>
<p><img src="/images/android_binder_faq_binder_wake_stack_list02.png" alt="img"></p>
<p>binder_transaction堆栈及唤醒那个队列2.jpg</p>
<p>结果已经说过，是AT1的队列，为什么呢？因为AT1队列上的之前的binder_transaction1在等待B进程执行完，但是B端执行binder_transaction1时候，需要等待binder_transaction2执行完，也就是说，在binder_transaction2执行完毕前，A端的binder_transaction1一定是不会被执行的，也就是线程AT1在B执行binder_transaction2的时候，一定是空闲的，那么，不妨唤醒AT1线程，让它帮忙执行完binder_transaction2，执行完之后，AT1又会睡眠等待B端返回，这样，既不妨碍binder_transaction1的执行，同样也能提高AT1线程利用率，出栈的过程其实就简单了，</p>
<ul>
<li>AT1 执行binder_transaction2，唤醒B端BT1 Binder线程，并且AT1继续睡眠（因为还有等待的transaction）</li>
<li>BT1 处理binder_transaction2结果，并执行完binder_transaction1，唤醒AT1</li>
<li>AT1处理binder_transaction1返回结果 执行结束</li>
</ul>
<p>不妨再深入一点，如果A端binder_transaction2又需要B进程B2服务，这个时候是什么效果唤醒谁，答案是BT1，这就杜绝了两端循环请求的，不断增加线程池容量。</p>
<p><img src="/images/android_binder_faq_binder_wake_stack_list03.png" alt="img"></p>
<p>binder_transaction堆栈及唤醒那个队列3.jpg</p>
<p>从这里可以看出，Binder其实设计的还是很巧妙的，让线程复用，提高了效率，还避免了新建不必要的Binder线程，这段优化在binder驱动实现代码如下：其实就是根据binder_transaction记录，处理入栈唤醒问题</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> void binder_transaction(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span></span> *thread,</span><br><span class="line">                   <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span> *tr, int reply)</span><br><span class="line">    &#123;..</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                    <span class="comment">// 找到对方正在等待自己进程的线程，如果线程没有在等待自己进程的返回，就不要找了</span></span><br><span class="line">        </span><br><span class="line">                    <span class="comment">// 判断是不target_proc中，是不是有线程，等待当前线程</span></span><br><span class="line">                    <span class="comment">// thread-&gt;transaction_stack，这个时候，</span></span><br><span class="line">                    <span class="comment">// 是binder线程的，不是普通线程 B去请求A服务，</span></span><br><span class="line">                    <span class="comment">// 在A服务的时候，又请求了B，这个时候，A的服务一定要等B处理完，才能再返回B，可以放心用B</span></span><br><span class="line">                        <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</span><br><span class="line">                            target_thread = tmp-&gt;from;</span><br><span class="line">                        tmp = tmp-&gt;from_parent;</span><br><span class="line">          ...           &#125;</span><br><span class="line">        &#125; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binder协议中BC与BR的区别"><a href="#Binder协议中BC与BR的区别" class="headerlink" title="Binder协议中BC与BR的区别"></a>Binder协议中BC与BR的区别</h2><p>BC与BR主要是标志数据及Transaction流向，其中BC是从用户空间流向内核，而BR是从内核流线用户空间，比如Client向Server发送请求的时候，用的是BC_TRANSACTION，当数据被写入到目标进程后，target_proc所在的进程被唤醒，在内核空间中，会将BC转换为BR，并将数据与操作传递该用户空间。</p>
<p><img src="/images/android_binder_faq_br_bc.png" alt="img"></p>
<p>BR与BC区别</p>
<h2 id="Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装）"><a href="#Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装）" class="headerlink" title="Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装）"></a>Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装）</h2><p>内核中，与用户空间对应的结构体对象都需要新建，但传输数据的数据只拷贝一次，就是一次拷贝的时候。</p>
<p>从Client端请求开始分析，暂不考虑java层，只考虑Native，以ServiceManager的addService为例，具体看一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MediaPlayerService::<span class="built_in">instantiate</span>();</span><br></pre></td></tr></table></figure>

<p>MediaPlayerService会新建Binder实体，并将其注册到ServiceManager中:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MediaPlayerService::instantiate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">defaultServiceManager</span>()-&gt;<span class="built_in">addService</span>(</span><br><span class="line">            <span class="built_in">String16</span>(<span class="string">&quot;media.player&quot;</span>), <span class="keyword">new</span> <span class="built_in">MediaPlayerService</span>());</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>这里defaultServiceManager其实就是获取ServiceManager的远程代理：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将代码简化其实就是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> gDefaultServiceManager = <span class="built_in">BpServiceManager</span> (<span class="keyword">new</span> <span class="built_in">BpBinder</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>addService就是调用BpServiceManager的addService，</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">virtual status_t addService(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span><br><span class="line">        bool allowIsolated)</span><br><span class="line">&#123;</span><br><span class="line">    Parcel <span class="keyword">data</span>, reply;</span><br><span class="line">    <span class="keyword">data</span>.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">    <span class="keyword">data</span>.writeString16(name);</span><br><span class="line">    <span class="keyword">data</span>.writeStrongBinder(service);</span><br><span class="line">    <span class="keyword">data</span>.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, <span class="keyword">data</span>, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会开始第一步的封装，数据封装，其实就是讲具体的传输数据写入到Parcel对象中，与Parcel对应是ADD_SERVICE_TRANSACTION等具体操作。比较需要注意的就是data.writeStrongBinder，这里其实就是把Binder实体压扁：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">status_t Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="keyword">val</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), <span class="keyword">val</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体做法就是转换成flat_binder_object，以传递Binder的类型、指针之类的信息：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">status_t flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line">    </span><br><span class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder *local = binder-&gt;localBinder();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">&quot;null proxy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> int32_t handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = local-&gt;getWeakRefs();</span><br><span class="line">            obj.cookie = local;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="literal">NULL</span>;</span><br><span class="line">        obj.cookie = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看 remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); 在上面的环境中，remote()函数返回的就是BpBinder(0)，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpBinder::transact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">transact</span>(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后通过  IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags)进行进一步封装:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">            err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; </span><br><span class="line">        ..</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);是进一步封装的入口，在这个函数中Parcel&amp; data、handle、code、被进一步封装成binder_transaction_data对象，并拷贝到mOut的data中去，同时也会将BC_TRANSACTION命令也写入mOut，这里与binder_transaction_data对应的CMD是BC_TRANSACTION，binder_transaction_data也存储了数据的指引新信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; ..</span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mOut封装结束后，会通过waitForResponse调用talkWithDriver继续封装：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    <span class="comment">// Is the read buffer empty? 这里会有同时返回两个命令的情况 BR_NOOP、BR_COMPLETE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.<span class="built_in">dataPosition</span>() &gt;= mIn.<span class="built_in">dataSize</span>();</span><br><span class="line">    <span class="comment">// We don&#x27;t want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.<span class="built_in">dataSize</span>() : <span class="number">0</span>;</span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.<span class="built_in">data</span>();      <span class="comment">// This is what we&#x27;ll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.<span class="built_in">dataCapacity</span>();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.<span class="built_in">data</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        。。</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR；</span><br><span class="line">        <span class="keyword">if</span> (mProcess-&gt;mDriverFD &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            err = -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; (<span class="keyword">ssize_t</span>)mOut.<span class="built_in">dataSize</span>())</span><br><span class="line">                mOut.<span class="built_in">remove</span>(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mOut.<span class="built_in">setDataSize</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.<span class="built_in">setDataSize</span>(bwr.read_consumed);</span><br><span class="line">            mIn.<span class="built_in">setDataPosition</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>talkWithDriver会将mOut中的数据与命令继续封装成binder_write_read对象，其中bwr.write_buffer就是mOut中的data（binder_transaction_data+BC_TRRANSACTION），之后就会通过ioctl与binder驱动交互，进入内核，这里与binder_write_read对象对应的CMD是BINDER_WRITE_READ，进入驱动后，是先写后读的顺序，所以才叫BINDER_WRITE_READ命令，与BINDER_WRITE_READ层级对应的几个命令码一般都是跟线程、进程、数据整体传输相关的操作，不涉及具体的业务处理,比如BINDER_SET_CONTEXT_MGR是将线程编程ServiceManager线程，并创建0号Handle对应的binder_node、BINDER_SET_MAX_THREADS是设置最大的非主Binder线程数，而BINDER_WRITE_READ就是表示这是一次读写操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_CURRENT_PROTOCOL_VERSION 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_WRITE_READ _IOWR(<span class="meta-string">&#x27;b&#x27;</span>, 1, struct binder_write_read)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_TIMEOUT _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 3, int64_t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_MAX_THREADS _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 5, size_t)</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_IDLE_PRIORITY _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 6, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_CONTEXT_MGR _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 7, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT _IOW(<span class="meta-string">&#x27;b&#x27;</span>, 8, int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VERSION _IOWR(<span class="meta-string">&#x27;b&#x27;</span>, 9, struct binder_version)</span></span><br></pre></td></tr></table></figure>

<p>详细看一下binder_ioctl对于BINDER_WRITE_READ的处理，</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">    switch (cmd) &#123;</span><br><span class="line">    case BINDER_WRITE_READ: &#123;</span><br><span class="line">        struct binder_write_read bwr;</span><br><span class="line">        ..</span><br><span class="line">        <span class="comment">&lt;!--拷贝binder_write_read对象到内核空间--&gt;</span></span><br><span class="line">        if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            goto err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">&lt;!--根据是否需要写数据处理是不是要写到目标进程中去--&gt;</span></span><br><span class="line">        if (bwr.write_size &gt; 0) &#123;</span><br><span class="line">            ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">&lt;!--根据是否需要写数据处理是不是要读，往自己进程里读数据--&gt;</span></span><br><span class="line">        if (bwr.read_size &gt; 0) &#123;</span><br><span class="line">            ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            <span class="comment">&lt;!--是不是要同时唤醒进程上的阻塞队列--&gt;</span></span><br><span class="line">            if (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    case BINDER_SET_MAX_THREADS:</span><br><span class="line">        if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case BINDER_SET_CONTEXT_MGR:</span><br><span class="line">       .. break;</span><br><span class="line">    case BINDER_THREAD_EXIT:</span><br><span class="line">        binder_free_thread(proc, thread);</span><br><span class="line">        thread = NULL;</span><br><span class="line">        break;</span><br><span class="line">    case BINDER_VERSION:</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_thread_write(proc, thread, (void __user <em>)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed)这里其实就是把解析的binder_write_read对象再剥离，*<em>bwr.write_buffer</em></em> 就是上面的（BC_TRANSACTION+ binder_transaction_data），</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// binder_transaction_data  BC_XXX+binder_transaction_data</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get_user</span>(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))  (BC_TRANSACTION)</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (cmd) &#123;</span><br><span class="line">        ..</span><br><span class="line">        <span class="keyword">case</span> BC_FREE_BUFFER: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(&amp;tr, ptr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(tr);</span><br><span class="line">            <span class="built_in">binder_transaction</span>(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BC_REGISTER_LOOPER:</span><br><span class="line">            ..</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">            ...</span><br><span class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BC_EXIT_LOOPER:</span><br><span class="line">        <span class="comment">// 这里会修改读取的数据，</span></span><br><span class="line">        *consumed = ptr - buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_thread_write会进一步根据CMD剥离出binder_transaction_data tr，交给binder_transaction处理，其实到binder_transaction数据几乎已经剥离极限，剩下的都是业务相关的，但是这里牵扯到一个Binder实体与Handle的转换过程，同城也牵扯两个进程在内核空间共享一些数据的问题，因此这里又进行了一次进一步的封装与拆封装，这里新封装了连个对象 binder_transaction与binder_work，有所区别的是binder_work可以看做是进程私有，但是binder_transaction是两个交互的进程共享的：binder_work是插入到线程或者进程的work todo队列上去的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">int</span> looper;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction_stack</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error; <span class="comment">/* Write failed, return error code in read buf */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error2; <span class="comment">/* Write failed, return error code in read */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里主要关心一下<strong>binder_transaction</strong>：binder_transaction主要记录了当前transaction的来源，去向，同时也为了返回做准备，buffer字段是一次拷贝后数据在Binder的内存地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">from_parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">to_parent</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</span><br><span class="line">    <span class="keyword">long</span>    priority;</span><br><span class="line">    <span class="keyword">long</span>    saved_priority;</span><br><span class="line">    <span class="keyword">uid_t</span>   sender_euid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>binder_transaction函数主要负责的工作：</p>
<ul>
<li><p>新建binder_transaction对象，并插入到自己的binder_transaction堆栈中</p>
</li>
<li><p>新建binder_work对象，插入到目标队列</p>
</li>
<li><p>Binder与Handle的转换 (flat_binder_object)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">static</span> <span class="keyword">void</span> binder_transaction(struct binder_proc *proc,</span><br><span class="line">                    struct binder_thread *thread,</span><br><span class="line">                    struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span><br><span class="line"> &#123;</span><br><span class="line">     struct binder_transaction *t;</span><br><span class="line">     struct binder_work *tcomplete;</span><br><span class="line">     size_t *offp, *off_end;</span><br><span class="line">     struct binder_proc *target_proc;</span><br><span class="line">     struct binder_thread *target_thread = <span class="literal">NULL</span>;</span><br><span class="line">     struct binder_node *target_node = <span class="literal">NULL</span>;</span><br><span class="line">  **关键点<span class="number">1</span>** </span><br><span class="line"> <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">     in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">     thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">     target_thread = in_reply_to-&gt;from;</span><br><span class="line">     target_proc = target_thread-&gt;proc;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">         struct binder_ref * ref;</span><br><span class="line">             ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">             target_node = ref-&gt;node;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             target_node = binder_context_mgr_node;</span><br><span class="line">         &#125;</span><br><span class="line">       ..。</span><br><span class="line"> **关键点<span class="number">2</span>**</span><br><span class="line">  t = kzalloc(sizeof( * t), GFP_KERNEL); </span><br><span class="line">  ...</span><br><span class="line">  tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);</span><br><span class="line">  </span><br><span class="line">**关键点<span class="number">3</span> **</span><br><span class="line"> off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">     struct flat_binder_object *fp;</span><br><span class="line">     fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">     <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">     <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">     <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">         struct binder_ref *ref;</span><br><span class="line">         struct binder_node *node = binder_get_node(proc, fp-&gt;binder);</span><br><span class="line">         <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">         &#125;..</span><br><span class="line">         ref = (target_proc, node);                 <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">             fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">         fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">     &#125; <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">     <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">         struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</span><br><span class="line">         <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">             <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">                 fp-&gt;type = BINDER_TYPE_BINDER;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">             fp-&gt;binder = ref-&gt;node-&gt;ptr;</span><br><span class="line">             fp-&gt;cookie = ref-&gt;node-&gt;cookie;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             struct binder_ref *new_ref;</span><br><span class="line">             new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">             fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">break</span>;</span><br><span class="line">     </span><br><span class="line">**关键点<span class="number">4</span>** 将binder_work 插入到目标队列</span><br><span class="line"></span><br><span class="line"> t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line"> list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line"> tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line"> list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line"> <span class="keyword">if</span> (target_wait)</span><br><span class="line">     wake_up_interruptible(target_wait);</span><br><span class="line"> <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>}</p>
</li>
</ul>
<p>关键点1，找到目标进程，关键点2 创建binder_transaction与binder_work，关键点3 处理Binder实体与Handle转化，关键点4，将binder_work插入目标队列，并唤醒相应的等待队列，在处理Binder实体与Handle转化的时候，有下面几点注意的：</p>
<ul>
<li>第一次注册Binder实体的时候，是向别的进程注册的，ServiceManager，或者SystemServer中的AMS服务</li>
<li>Client请求服务的时候，一定是由Binder驱动为Client分配binder_ref，如果本进程的线程请求，fp-&gt;type = BINDER_TYPE_BINDER，否则就是fp-&gt;type = BINDER_TYPE_HANDLE。</li>
<li>Android中的Parcel里面的对象一定是flat_binder_object</li>
</ul>
<p>如此下来，写数据的流程所经历的数据结构就完了。再简单看一下被唤醒一方的读取流程，读取从阻塞在内核态的binder_thread_read开始，以传递而来的BC_TRANSACTION为例，binder_thread_read会根据一些场景添加BRXXX参数，标识驱动传给用户空间的数据流向：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">BinderDriverReturnProtocol</span></span> &#123;</span><br><span class="line"></span><br><span class="line"> BR_ERROR = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">0</span>, int),</span><br><span class="line"> BR_OK = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">1</span>),</span><br><span class="line"> BR_TRANSACTION = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">2</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span>),</span><br><span class="line"> BR_REPLY = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">3</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span>),</span><br><span class="line"></span><br><span class="line"> BR_ACQUIRE_RESULT = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">4</span>, int),</span><br><span class="line"> BR_DEAD_REPLY = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">5</span>),</span><br><span class="line"> BR_TRANSACTION_COMPLETE = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">6</span>),</span><br><span class="line"> BR_INCREFS = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">7</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ptr_cookie</span></span>),</span><br><span class="line"></span><br><span class="line"> BR_ACQUIRE = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">8</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ptr_cookie</span></span>),</span><br><span class="line"> BR_RELEASE = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">9</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ptr_cookie</span></span>),</span><br><span class="line"> BR_DECREFS = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">10</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_ptr_cookie</span></span>),</span><br><span class="line"> BR_ATTEMPT_ACQUIRE = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">11</span>, <span class="class"><span class="keyword">struct</span> <span class="title">binder_pri_ptr_cookie</span></span>),</span><br><span class="line"></span><br><span class="line"> BR_NOOP = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">12</span>),</span><br><span class="line"> BR_SPAWN_LOOPER = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">13</span>),</span><br><span class="line"> BR_FINISHED = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">14</span>),</span><br><span class="line"> BR_DEAD_BINDER = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">15</span>, void *),</span><br><span class="line"></span><br><span class="line"> BR_CLEAR_DEATH_NOTIFICATION_DONE = _IOR_BAD(<span class="string">&#x27;r&#x27;</span>, <span class="number">16</span>, void *),</span><br><span class="line"> BR_FAILED_REPLY = _IO(<span class="string">&#x27;r&#x27;</span>, <span class="number">17</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后，read线程根据binder_transaction新建binder_transaction_data对象，再通过copy_to_user，传递给用户空间，</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> int</span><br><span class="line">binder_thread_read(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc, <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span></span> *thread,</span><br><span class="line">    void  __user *buffer, int size, signed long *consumed, int non_block)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            uint32_t cmd;</span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span></span> tr ;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span> *w;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span></span> *t = NULL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span>, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span></span>, entry);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                goto retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 数据大小</span></span><br><span class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// 偏移地址要加上</span></span><br><span class="line">        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset;</span><br><span class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *));</span><br><span class="line">    <span class="comment">// 写命令</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">// 写数据结构体到用户空间，</span></span><br><span class="line">        ptr += sizeof(uint32_t);</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, sizeof(tr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += sizeof(tr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上层通过ioctrl等待的函数被唤醒,假设现在被唤醒的是服务端，一般会执行请求,这里首先通过Parcel的ipcSetDataReference函数将数据将数据映射到Parcel对象中，之后再通过BBinder的transact函数处理具体需求；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// read到了数据请求，这里是需要处理的逻辑 ，处理完毕，</span></span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">     ...</span><br><span class="line"> <span class="comment">// 这里是处理 如果非空，就是数据有效，</span></span><br><span class="line">    <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">        <span class="comment">// 这里什么是tr.cookie</span></span><br><span class="line">        <span class="function">sp&lt;BBinder&gt; <span class="title">b</span><span class="params">((BBinder*)tr.cookie)</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;<span class="built_in">transact</span>(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">        <span class="keyword">if</span> (error &lt; NO_ERROR) reply.<span class="built_in">setError</span>(error);</span><br><span class="line"></span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure>

<p>这里的 b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);就同一开始Client调用transact( mHandle, code, data, reply, flags)函数对应的处理类似，进入相对应的业务逻辑。</p>
<p><img src="/images/android_binder_faq_transport_cover.png" alt="img"></p>
<p>Binder在传输数据的时候是如何层层封装的–不同层次使用的数据结构（命令的封装.jpg</p>
<h2 id="Binder驱动传递数据的释放（释放时机）"><a href="#Binder驱动传递数据的释放（释放时机）" class="headerlink" title="Binder驱动传递数据的释放（释放时机）"></a>Binder驱动传递数据的释放（释放时机）</h2><p>在Binder通信的过程中，数据是从发起通信进程的用户空间直接写到目标进程内核空间，而这部分数据是直接映射到用户空间，必须等用户空间使用完数据才能释放，也就是说<strong>Binder通信中内核数据的释放时机应该是用户空间控制的</strong>，内种中释放内存空间的函数是binder_free_buf，其他的数据结构其实可以直接释放掉，执行这个函数的命令是BC_FREE_BUFFER。上层用户空间常用的入口是IPCThreadState::freeBuffer：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IPCThreadState::freeBuffer</span><span class="params">(Parcel* parcel, <span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">const</span> <span class="keyword">size_t</span>* objects, <span class="keyword">size_t</span> objectsSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="keyword">void</span>* cookie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) parcel-&gt;<span class="built_in">closeFileDescriptors</span>();</span><br><span class="line">    IPCThreadState* state = <span class="built_in">self</span>();</span><br><span class="line">    state-&gt;mOut.<span class="built_in">writeInt32</span>(BC_FREE_BUFFER);</span><br><span class="line">    state-&gt;mOut.<span class="built_in">writeInt32</span>((<span class="keyword">int32_t</span>)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那什么时候会调用这个函数呢？在之前分析数据传递的时候，有一步是将binder_transaction_data中的数据映射到Parcel中去，其实这里是关键</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            <span class="comment">// 注意这里是没有传输数据拷贝的，只有一个指针跟数据结构的拷贝，</span></span><br><span class="line">            err = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line">            <span class="built_in">ALOG_ASSERT</span>(err == NO_ERROR, <span class="string">&quot;Not enough command data for brREPLY&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="comment">// free buffer，先设置数据，直接</span></span><br><span class="line">            <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 牵扯到数据利用，与内存释放</span></span><br><span class="line">                    reply-&gt;<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>),</span><br><span class="line">                        freeBuffer, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>Parcel 的ipcSetDataReference函数不仅仅能讲数据映射到Parcel对象，同时还能将数据的清理函数映射进来</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parcel::ipcSetDataReference</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">size_t</span>* objects, <span class="keyword">size_t</span> objectsCount, release_func relFunc, <span class="keyword">void</span>* relCookie)</span></span></span><br></pre></td></tr></table></figure>

<p>看函数定义中的release_func relFunc参数，这里就是指定内存释放函数，这里指定了IPCThreadState::freeBuffer函数，在Native层，Parcel在使用完，并走完自己的生命周期后，就会调用自己的析构函数，在其析构函数中调用了freeDataNoInit()，这个函数会间接调用上面设置的内存释放函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Parcel::~<span class="built_in">Parcel</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">freeDataNoInit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是数据释放的入口，进入内核空间后，执行binder_free_buf，将这次分配的内存释放，同时更新binder_proc的binder_buffer表，重新标记那些内存块被使用了，哪些没被使用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> void binder_free_buf(<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc,</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span> *buffer)</span><br><span class="line">&#123;</span><br><span class="line">    size_t size, buffer_size;</span><br><span class="line">    buffer_size = binder_buffer_size(proc, buffer);</span><br><span class="line">    size = ALIGN(buffer-&gt;data_size, sizeof(void *)) +</span><br><span class="line">        ALIGN(buffer-&gt;offsets_size, sizeof(void *));</span><br><span class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">             <span class="string">&quot;binder: %d: binder_free_buf %p size %zd buffer&quot;</span></span><br><span class="line">             <span class="string">&quot;_size %zd\n&quot;</span>, proc-&gt;pid, buffer, size, buffer_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;async_transaction) &#123;</span><br><span class="line">        proc-&gt;free_async_space += size + sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span>);</span><br><span class="line">        binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</span><br><span class="line">                 <span class="string">&quot;binder: %d: binder_free_buf size %zd &quot;</span></span><br><span class="line">                 <span class="string">&quot;async free %zd\n&quot;</span>, proc-&gt;pid, size,</span><br><span class="line">                 proc-&gt;free_async_space);</span><br><span class="line">    &#125;</span><br><span class="line">    binder_update_page_range(proc, <span class="number">0</span>,</span><br><span class="line">        (void *)PAGE_ALIGN((uintptr_t)buffer-&gt;data),</span><br><span class="line">        (void *)(((uintptr_t)buffer-&gt;data + buffer_size) &amp; PAGE_MASK),</span><br><span class="line">        NULL);</span><br><span class="line">    rb_erase(&amp;buffer-&gt;rb_node, &amp;proc-&gt;allocated_buffers);</span><br><span class="line">    buffer-&gt;free = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!list_is_last(&amp;buffer-&gt;entry, &amp;proc-&gt;buffers)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span> *next = list_entry(buffer-&gt;entry.next,</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span>, entry);</span><br><span class="line">        <span class="keyword">if</span> (next-&gt;free) &#123;</span><br><span class="line">            rb_erase(&amp;next-&gt;rb_node, &amp;proc-&gt;free_buffers);</span><br><span class="line">            binder_delete_free_buffer(proc, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;buffers.next != &amp;buffer-&gt;entry) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span> *prev = list_entry(buffer-&gt;entry.prev,</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span></span>, entry);</span><br><span class="line">        <span class="keyword">if</span> (prev-&gt;free) &#123;</span><br><span class="line">            binder_delete_free_buffer(proc, buffer);</span><br><span class="line">            rb_erase(&amp;prev-&gt;rb_node, &amp;proc-&gt;free_buffers);</span><br><span class="line">            buffer = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_insert_free_buffer(proc, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java层类似，通过JNI调用Parcel的freeData()函数释放内存，在用户空间，每次执行BR_TRANSACTION或者BR_REPLY，都会利用freeBuffer发送请求，去释放内核中的内存</p>
<h2 id="ServiceManager-addService的限制"><a href="#ServiceManager-addService的限制" class="headerlink" title="ServiceManager addService的限制"></a>ServiceManager addService的限制</h2><p>并非所有服务都能通过addService添加到ServiceManager</p>
<p>ServiceManager其实主要的面向对象是系统服务，大部分系统服务都是由SystemServer进程总添加到ServiceManager中去的，在通过ServiceManager添加服务的时候，是有些权限校验的，源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svc_can_register</span><span class="params">(<span class="keyword">unsigned</span> uid, <span class="keyword">uint16_t</span> *name)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n;</span><br><span class="line">    <span class="comment">// 谁有权限add_service 0进程，或者 AID_SYSTEM进程</span></span><br><span class="line">    <span class="keyword">if</span> ((uid == <span class="number">0</span>) || (uid == AID_SYSTEM))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(allowed) / <span class="built_in"><span class="keyword">sizeof</span></span>(allowed[<span class="number">0</span>]); n++)</span><br><span class="line">        <span class="keyword">if</span> ((uid == allowed[n].uid) &amp;&amp; <span class="built_in">str16eq</span>(name, allowed[n].name))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 (uid == 0) 或者 (uid == AID_SYSTEM)的进程都是可以添加服务的，uid=0，代表root用户，而uid=AID_SYSTEM，代表系统用户    。或者是一些特殊的配置进程。SystemServer进程在被Zygote创建的时候，就被分配了UID 是AID_SYSTEM（1000），</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    <span class="comment">/* Hardcoded command line to start the system server */</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">&quot;--setuid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgid=1000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,3001,3002,3003,3006,3007&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--capabilities=130104352,130104352&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--runtime-init&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--nice-name=system_server&quot;</span>,</span><br><span class="line">        <span class="string">&quot;com.android.server.SystemServer&quot;</span>,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>Android每个APP的UID，都是不同的，用了Linux的UID那一套，但是没完全沿用，这里不探讨，<strong>总之，普通的进程是没有权限注册到ServiceManager中的，那么APP平时通过bindService启动的服务怎么注册于查询的呢？接管这个任务的就是SystemServer的ActivityManagerService</strong>。</p>
<h2 id="bindService启动Service与Binder服务实体的流程-（ActivityManagerService）"><a href="#bindService启动Service与Binder服务实体的流程-（ActivityManagerService）" class="headerlink" title="bindService启动Service与Binder服务实体的流程 （ActivityManagerService）"></a>bindService启动Service与Binder服务实体的流程 （ActivityManagerService）</h2><ul>
<li>bindService的框架</li>
<li>binder服务实例化与转化</li>
<li>业务逻辑的唤醒</li>
<li>请求代理的转化与唤醒</li>
</ul>
<p>bindService比startService多了一套Binder通信，其余的流程基本相同，而startService的流程，同startActivity差不多，四大组件的启动流程这里不做分析点，主要看bindService中C/S通信的建立流程，在这个流程里面，APP与服务端互为C/S的特性更明显，在APP开发的时候，binder服务是通过Service来启动的。Service的启动方式有两种startService，与bindService，这里只考虑后者，另外启动的binder服务也分为两种情况：第一种，client同server位于同一进程，可以看做内部服务，第二种，Client与Server跨进程，即使是位于同一个APP，第一桶可以不用AIDL来编写，但是第二种必须通过AIDL实现跨进程通信，看一个最简单的AIDL例子，首先在定义一个aidl接口：</p>
<blockquote>
<p>IMyAidlInterface.aidl</p>
</blockquote>
<p>interface IMyAidlInterface {<br> void communicate(int count);<br> }</p>
<p>IMyAidlInterface.aidl定义了通信的借口，通过build之后，构建工具会自动为IMyAidlInterface.aidl生成一些辅助类，这些辅助类主要作用是生成Binder通信协议框架，必须保证两方通信需要指令相同，才能解析通信内容。天王盖地虎，宝塔镇河妖。Java层Binder的对应关系Binder与BinderProxy从这里可以看出，binder采用了代理模式 stub与proxy对应，使用aidl实现的服务时候，Client如果想要获得Binder实体的代理可以通过asInterface来处理，比如如果在同一进程就是实体，不在就新建代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">snail</span>.<span class="title">labaffinity</span>.<span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">&quot;com.snail.labaffinity.IMyAidlInterface&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.snail.labaffinity.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.snail.labaffinity.IMyAidlInterface))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.snail.labaffinity.IMyAidlInterface) iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.snail.labaffinity.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_communicate: &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">int</span> _arg0;</span><br><span class="line">                    _arg0 = data.readInt();</span><br><span class="line">                    <span class="keyword">this</span>.communicate(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">snail</span>.<span class="title">labaffinity</span>.<span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">            Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">communicate</span><span class="params">(<span class="keyword">int</span> count)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    _data.writeInt(count);</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_communicate, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_communicate = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">communicate</span><span class="params">(<span class="keyword">int</span> count)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动Binder服务端封装Service，之所以成为封装Service，是因为Service对于Binder实体的最大作用是个作为新建服务的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AidlService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BBinderService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BBinderService</span> <span class="keyword">extends</span> <span class="title">IMyAidlInterface</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">communicate</span><span class="params">(<span class="keyword">int</span> count)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而启动的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Intent intent = createExplicitFromImplicitIntent(MainActivity.<span class="keyword">this</span>, <span class="keyword">new</span> Intent(<span class="string">&quot;com.snail.labaffinity.service.AidlService&quot;</span>));</span><br><span class="line">    bindService(intent, <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</span><br><span class="line">            IMyAidlInterface  iMyAidlInterface = IMyAidlInterface.Stub.asInterface(iBinder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上四个部分就组成了AIDL跨进程服务的基本组件，现在从ActivitybindService入口开始分析：bindService大部分的流程与startActivity类似，其实都是通过AMS启动组件，这里只将一些不同的地方，Activity启动只需要Intent就可以了，而Service的bind需要一个ServiceConnection对象，这个对象其实是为了AMS端在启动Service后回调用的，ServiceConnection是个接口，其实例在ContextImpl的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  UserHandle user)</span> </span>&#123;</span><br><span class="line">    IServiceConnection sd;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;connection is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(),</span><br><span class="line">                mMainThread.getHandler(), flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Not supported in system context&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags &amp; BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line">        service.prepareToLeaveProcess();</span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">                mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">                service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">                sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">&quot;Not allowed to bind to service &quot;</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mPackageInfo是一个LoadApk类，通过它的getServiceDispatcher获得一个IServiceConnection对象，这个对象一个Binder实体，看一下具体原理</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">IServiceConnection</span> getServiceDispatcher(<span class="type">ServiceConnection</span> c,</span><br><span class="line">        <span class="type">Context</span> context, <span class="type">Handler</span> handler, int flags) &#123;</span><br><span class="line">    synchronized (mServices) &#123;</span><br><span class="line">        <span class="type">LoadedApk</span>.<span class="type">ServiceDispatcher</span> sd <span class="operator">=</span> null;</span><br><span class="line">        <span class="type">ArrayMap</span>&lt;<span class="type">ServiceConnection</span>, <span class="type">LoadedApk</span>.<span class="type">ServiceDispatcher</span>&gt; map <span class="operator">=</span> mServices.get(context);</span><br><span class="line">        <span class="keyword">if</span> (map <span class="operator">!=</span> null) &#123;</span><br><span class="line">            sd <span class="operator">=</span> map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sd <span class="operator">==</span> null) &#123;</span><br><span class="line">            sd <span class="operator">=</span> new <span class="type">ServiceDispatcher</span>(c, context, handler, flags);</span><br><span class="line">            <span class="keyword">if</span> (map <span class="operator">==</span> null) &#123;</span><br><span class="line">                map <span class="operator">=</span> new <span class="type">ArrayMap</span>&lt;<span class="type">ServiceConnection</span>, <span class="type">LoadedApk</span>.<span class="type">ServiceDispatcher</span>&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c, sd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在LoadApk中IServiceConnection对象是通过context键值来存储ServiceDispatcher对象，而ServiceDispatcher对象内存会有个InnerConnection对象，该对象就是getServiceDispatcher的返回对象。因此bindServiceCommon最终调用<br> ActivityManagerNative.getDefault().bindService(x,x,x,x,x sd, x, x, x) 的时候，传递的参数sd其实就是一个InnerConnection对象，这是个Binder实体。但是，Binder.java中的Binder只是对native层BBinder的一个简单封装,真正的实例化还是通过JNI到native层去创建一个JavaBBinderHolder对象，并初始化gBinderOffsets，让其能映射Java层Binder对象，而JavaBBinderHolder中又可以实例化BBinder的实例JavaBBinder，不过BBinder的实例化时机并不在这里，而是在Parcel对象writeStrongBinder的时候，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">bindernative_offsets_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Class state.</span></span><br><span class="line">    jclass mClass;</span><br><span class="line">    jmethodID mExecTransact;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object state.</span></span><br><span class="line">    jfieldID mObject;</span><br><span class="line"></span><br><span class="line">&#125; gBinderOffsets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Binder_init</span><span class="params">(JNIEnv* env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JavaBBinderHolder* jbh = <span class="keyword">new</span> <span class="built_in">JavaBBinderHolder</span>();</span><br><span class="line">    jbh-&gt;<span class="built_in">incStrong</span>((<span class="keyword">void</span>*)android_os_Binder_init);</span><br><span class="line">    env-&gt;<span class="built_in">SetIntField</span>(obj, gBinderOffsets.mObject, (<span class="keyword">int</span>)jbh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往下看bindService，会调用到ActivityManagerProxy的bindService</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> int bindService(IApplicationThread caller, IBinder token,</span><br><span class="line">        Intent service, String resolvedType, IServiceConnection connection,</span><br><span class="line">        int flags, int userId) throws RemoteException &#123;</span><br><span class="line">    Parcel <span class="keyword">data</span> = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    <span class="keyword">data</span>.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    <span class="keyword">data</span>.writeStrongBinder(caller != <span class="literal">null</span> ? caller.asBinder() : <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">data</span>.writeStrongBinder(token);</span><br><span class="line">    service.writeToParcel(<span class="keyword">data</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">data</span>.writeString(resolvedType);</span><br><span class="line">    <span class="keyword">data</span>.writeStrongBinder(connection.asBinder());</span><br><span class="line">    <span class="keyword">data</span>.writeInt(flags);</span><br><span class="line">    <span class="keyword">data</span>.writeInt(userId);</span><br><span class="line">    mRemote.transact(BIND_SERVICE_TRANSACTION, <span class="keyword">data</span>, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    int res = reply.readInt();</span><br><span class="line">    <span class="keyword">data</span>.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用Parcel的writeStrongBinder会将Binder实体写入到Parcel中去，这里首先看一下 Parcel data = Parcel.obtain();在java层Parcel只是一个容器，具体Parcel相关的操作都在Native层</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">android_os_Parcel_create</span><span class="params">(JNIEnv* env, jclass clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">new</span> <span class="built_in">Parcel</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jint&gt;(parcel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的返回值，其实就是Parcel对象的地址，被赋值给了Parcel.java的mNativePtr成员变量，方便Native调用，接着看writeStrongBinder的实现，其实就是调用Parcel.cpp中的对应方法，通过flatten_binder将Binder实体对象打扁，创建flat_binder_object写入Parcel中，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_Parcel_writeStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jint nativePtr, jobject object)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">status_t</span> err = parcel-&gt;<span class="built_in">writeStrongBinder</span>(<span class="built_in">ibinderForJavaObject</span>(env, object));</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">signalExceptionForError</span>(env, clazz, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ibinderForJavaObject主要为Java层Binder实例化native binder对象：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ibinderForJavaObject(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderOffsets.mClass)) &#123;</span><br><span class="line">        JavaBBinderHolder* jbh = (JavaBBinderHolder*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderOffsets.mObject);</span><br><span class="line">        <span class="keyword">return</span> jbh != <span class="literal">NULL</span> ? jbh-&gt;get(env, obj) : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;IsInstanceOf(obj, gBinderProxyOffsets.mClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (IBinder*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果BBinder还没实例化，要通过JavaBBinderHolder的get函数实例化一个BBinder对象，这里就是<strong>JavaBBinder</strong>对象，综上分析Java层与Native的Binder其对应关系如下：</p>
<p><img src="/images/android_binder_faq_native_bbinder_java_binder.png" alt="img"></p>
<p>Java层Binder与native 层BBiner.png</p>
<p>BBinder对象被Parcel转换成flat_binder_object，经过一次拷贝写入目标进程，并执行BINDER_TYPE_BINDER与BINDER_TYPE_HANDLE的转换，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static</span> <span class="keyword">void</span></span><br><span class="line">binder_transaction(struct binder_proc *proc, struct binder_thread *thread,</span><br><span class="line">    struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span><br><span class="line">    ...</span><br><span class="line"> fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;..</span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;..</span><br><span class="line">            struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</span><br><span class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_BINDER;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                struct binder_ref *new_ref;</span><br><span class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核中，bindService中的InnerConnection会由BINDER_TYPE_BINDER转换成BINDER_TYPE_HANDLE，之后，AMS线程被唤醒后，执行后面的流程，在前文分析Parcel数据转换的时候，在Binder线程被唤醒继续执行的时候，会将数据映射到一个natvie Parcel对象中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::executeCommand</span><span class="params">(<span class="keyword">int32_t</span> cmd)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (cmd) &#123;</span><br><span class="line">     ..</span><br><span class="line">    <span class="comment">// read到了数据请求，这里是需要处理的逻辑 ，处理完毕，</span></span><br><span class="line">    <span class="keyword">case</span> BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result = mIn.<span class="built_in">read</span>(&amp;tr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line">            Parcel buffer;</span><br><span class="line">            &lt;!--关键点<span class="number">1</span> --&gt;</span><br><span class="line">            buffer.<span class="built_in">ipcSetDataReference</span>(</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size/<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>), freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">            ...</span><br><span class="line">          &lt;!--关键点<span class="number">2</span> --&gt;</span><br><span class="line">        <span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">            <span class="function">sp&lt;BBinder&gt; <span class="title">b</span><span class="params">((BBinder*)tr.cookie)</span></span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;<span class="built_in">transact</span>(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            <span class="keyword">if</span> (error &lt; NO_ERROR) reply.<span class="built_in">setError</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">        ..</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;        </span><br></pre></td></tr></table></figure>

<p>首先看一下关键点1 ，这里将内核数据映射到一个用户空间的Parcel对象中去，之后在调用目标Service的transact函数，进而调用他的onTrasanct函数 , 通过前面的分析知道，Java层Binder在注册时候，最终注册的是JavaBBinder对象，看一下它的onTrasanct函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        JNIEnv* env = <span class="built_in">javavm_to_jnienv</span>(mVM);</span><br><span class="line">        IPCThreadState* thread_state = IPCThreadState::<span class="built_in">self</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> strict_policy_before = thread_state-&gt;<span class="built_in">getStrictModePolicy</span>();</span><br><span class="line">        thread_state-&gt;<span class="built_in">setLastTransactionBinderFlags</span>(flags);</span><br><span class="line">        ..</span><br><span class="line">        jboolean res = env-&gt;<span class="built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">            code, (<span class="keyword">int32_t</span>)&amp;data, (<span class="keyword">int32_t</span>)reply, flags);</span><br><span class="line">        ..</span><br><span class="line">        <span class="keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>关键代码只有一句：env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, (int32_t)&amp;data, (int32_t)reply, flags)，其实就是调用Binder.java的execTransact函数，该函数首先将Native的Parcel映射成Jave层Parcel，之后调用BBinder子类的onTransact函数执行对应的业务逻辑，最后会通过data.recycle通知释放内存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">int</span> dataObj, <span class="keyword">int</span> replyObj,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        Parcel data = Parcel.obtain(dataObj);</span><br><span class="line">        Parcel reply = Parcel.obtain(replyObj);</span><br><span class="line">        <span class="keyword">boolean</span> res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            res = onTransact(code, data, reply, flags);</span><br><span class="line">        &#125; ...</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>对于AMS而bindService对应的操作如下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean onTransact(int code, Parcel <span class="keyword">data</span>, Parcel reply, int flags)</span><br><span class="line">    throws RemoteException &#123;</span><br><span class="line">    。。</span><br><span class="line">    case BIND_SERVICE_TRANSACTION: &#123;</span><br><span class="line">    <span class="keyword">data</span>.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder b = <span class="keyword">data</span>.readStrongBinder();</span><br><span class="line">    IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">    IBinder token = <span class="keyword">data</span>.readStrongBinder();</span><br><span class="line">    Intent service = Intent.CREATOR.createFromParcel(<span class="keyword">data</span>);</span><br><span class="line">    String resolvedType = <span class="keyword">data</span>.readString();</span><br><span class="line">    b = <span class="keyword">data</span>.readStrongBinder();</span><br><span class="line">    int fl = <span class="keyword">data</span>.readInt();</span><br><span class="line">    int userId = <span class="keyword">data</span>.readInt();</span><br><span class="line">    IServiceConnection conn = IServiceConnection.Stub.asInterface(b);</span><br><span class="line">    int res = bindService(app, token, service, resolvedType, conn, fl, userId);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    reply.writeInt(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>b = data.readStrongBinder()会先读取Binder对象，这里会调用本地函数nativeReadStrongBinder(mNativePtr)，mNativePtr就是Native层Parcel的首地址：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title">readStrongBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nativeReadStrongBinder(mNativePtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeReadStrongBinder(mNativePtr)会将本地Binder对象转化成Java层对象，其实就是将传输的InnerConnection读取出来，不过由于Binder驱动将BINDER_TYPE_BINDER转换成了BINDER_TYPE_HANDLE，对于AMS其实是实例化BinderProxy</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_Parcel_readStrongBinder</span><span class="params">(JNIEnv* env, jclass clazz, jint nativePtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">if</span> (parcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// /parcel-&gt;readStrongBinder() 其实就会创建BpBInder、</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">javaObjectForIBinder</span>(env, parcel-&gt;<span class="built_in">readStrongBinder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会利用Parcel.cpp的parcel-&gt;readStrongBinder()，读取binder对象，这里会根据flat_binder_object的类型，分别进行BBinder与BpBinder映射，如果是Binder实体直接将指针赋值out，如果不是，则根据handle获取或者新建BpBinder返回给out。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">unflatten_binder</span><span class="params">(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.<span class="built_in">readObject</span>(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">static_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finish_unflatten_binder</span>(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                *out = proc-&gt;<span class="built_in">getStrongProxyForHandle</span>(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">finish_unflatten_binder</span>(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;<span class="built_in">get</span>()), *flat, in);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后会牵扯一个将native binder转换成java层Binder的操作，javaObjectForIBinder，这个函数很关键，是理解Java层BinderProxy或者BBinder实体的关键：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">jobject javaObjectForIBinder(JNIEnv* env, const sp<span class="tag">&lt;<span class="name">IBinder</span>&gt;</span>&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    if (val == NULL) return NULL;</span><br><span class="line">    <span class="comment">&lt;!--关键点1--&gt;</span></span><br><span class="line">    if (val-&gt;checkSubclass(&amp;gBinderOffsets)) &#123;</span><br><span class="line">        jobject object = static_cast&lt;JavaBBinder*&gt;(val.get())-&gt;object();</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">    AutoMutex _l(mProxyLock);</span><br><span class="line">    <span class="comment">&lt;!--关键点2--&gt;</span></span><br><span class="line">    jobject object = (jobject)val-&gt;findObject(&amp;gBinderProxyOffsets);</span><br><span class="line">    if (object != NULL) &#123;</span><br><span class="line">        android_atomic_dec(&amp;gNumProxyRefs);</span><br><span class="line">        val-&gt;detachObject(&amp;gBinderProxyOffsets);</span><br><span class="line">        env-&gt;DeleteGlobalRef(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">&lt;!--关键点3--&gt;</span></span><br><span class="line">    object = env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor);</span><br><span class="line">    if (object != NULL) &#123;</span><br><span class="line">        env-&gt;SetIntField(object, gBinderProxyOffsets.mObject, (int)val.get());</span><br><span class="line">        val-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line">        jobject refObject = env-&gt;NewGlobalRef(</span><br><span class="line">                env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf));</span><br><span class="line">        val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject,</span><br><span class="line">                jnienv_to_javavm(env), proxy_cleanup);</span><br><span class="line">        sp<span class="tag">&lt;<span class="name">DeathRecipientList</span>&gt;</span> drl = new DeathRecipientList;</span><br><span class="line">        drl-&gt;incStrong((void*)javaObjectForIBinder);</span><br><span class="line">        env-&gt;SetIntField(object, gBinderProxyOffsets.mOrgue, reinterpret_cast<span class="tag">&lt;<span class="name">jint</span>&gt;</span>(drl.get()));</span><br><span class="line">        android_atomic_inc(&amp;gNumProxyRefs);</span><br><span class="line">        incRefsCreated(env);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看关键点1， checkSubclass默认返回false，但是JavaBBinder，该类对此函数进行了覆盖，如果是JavaBBinder，就会返回true，但入股是BpBinder，则会返回false，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span>    <span class="title">checkSubclass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* subclassID)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subclassID == &amp;gBinderOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看关键点2，如果是BpBinder，则需要首先在gBinderProxyOffsets中查找，是不是已经新建了Java层代理BinderProxy对象，如果没有，则新建即可，如果新建就看是否还存在缓存有效的BinderProxy。最后看关键点3 ：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">env-&gt;NewObject(gBinderProxyOffsets<span class="selector-class">.mClass</span>, gBinderProxyOffsets<span class="selector-class">.mConstructor</span>)</span><br></pre></td></tr></table></figure>

<p>其实就是新建BinderProxy对象，Java层的BinderProxy都是Native新建的，Java层并没有BinderProxy的新建入口，之后，再通过IServiceConnection.Stub.asInterface(b)进行转换，实例化一个IServiceConnection.Proxy代理对，该对象在Binder通信的基础上封装了业务逻辑，其实就是一些具体的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> XXXAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">           <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> XXXAidlInterface))) &#123;</span><br><span class="line">               <span class="keyword">return</span> ((XXXAidlInterface) iin);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> XXXAidlInterface.Stub.Proxy(obj);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>这里注意一点杜宇BinderProxy，obj.queryLocalInterface(DESCRIPTOR)返回为null，对于Binder实体，返回的是Binder自身，这样就能为上层区分出是生成代理还是存根自身，整体对象转换流程如下：</p>
<p><img src="/images/android_binder_faq_service_connection.png" alt="img"></p>
<p>ServiceConnection的回调作用</p>
<p>到这里分析了一半，Java层命令及回调Binder入口已经被传递给AMS，AMS之后需要负责启动Service，并通过回调入口为Client绑定服务，跟踪到AMS源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token,</span></span></span><br><span class="line"><span class="params"><span class="function">        Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="params"><span class="function">        IServiceConnection connection, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service, resolvedType,</span><br><span class="line">                connection, flags, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用ActiveService的bindServiceLocked，这里会分三中情况，</p>
<ul>
<li>Service已经经启动</li>
<li>Service未启动，但是进程已经启动</li>
<li>Service与进程君未启动</li>
</ul>
<p>不过这里只讨论“ Service未启动，但是进程已经启动的情况”，关键代码如下</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"> int <span class="function"><span class="title">bindServiceLocked</span>(<span class="params">IApplicationThread caller, IBinder token,</span></span></span><br><span class="line"><span class="params"><span class="function">            Intent service, <span class="built_in">String</span> resolvedType,</span></span></span><br><span class="line"><span class="params"><span class="function">            IServiceConnection connection, int flags, int userId</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            .。。</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">                s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">          &lt;!--关键点<span class="number">1</span>--&gt;</span><br><span class="line">                <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), <span class="literal">false</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &lt;!--关键点<span class="number">2</span>--&gt;</span><br><span class="line">           ..</span><br><span class="line">           requestServiceBindingLocked(s, b.intent, <span class="literal">false</span>);</span><br><span class="line">           ..</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点1其实就是启动Service，主要是通过ApplicationThread的binder通信通知App端启动Service，这个流程同Activity启动一样。关键点2是Service特有的：requestServiceBindingLocked，这个命令是告诉APP端：“在Service启动后需要向AMS发消息，之后AMS才能向其他需要绑定该Service的Client发送反馈”。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">AMS端</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> boolean requestServiceBindingLocked(ServiceRecord r,</span><br><span class="line">        IntentBindRecord i, boolean rebind) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       ..</span><br><span class="line">          r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind);</span><br><span class="line">       ..</span><br><span class="line">      &#125;        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> APP端</span><br><span class="line"> <span class="keyword">private</span> void handleBindService(BindServiceData <span class="keyword">data</span>) &#123;</span><br><span class="line">    Service s = mServices.<span class="keyword">get</span>(<span class="keyword">data</span>.token);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">data</span>.rebind) &#123;</span><br><span class="line">        IBinder binder = s.onBind(<span class="keyword">data</span>.intent);</span><br><span class="line">        ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                <span class="keyword">data</span>.token, <span class="keyword">data</span>.intent, binder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ActivityManagerNative.getDefault().publishService会将启动的Binder服务实体传递给AMS，上面分析过Binder实体传输，这里的原理是一样的，AMS端在传输结束后，会获得Service端服务实体的引用，这个时候，就能通过最初的InnerConnection的回调将这个服务传递给Client端。Binder实体与引用的整体流程图如下：</p>
<p><img src="/images/android_binder_faq_bind_service_global_flow.png" alt="img"></p>
<p>bindSerivce整体流程图</p>
<p>如果要深究Activity的bindService流程，可以按以下几步来分析</p>
<ul>
<li>1、Activity调用bindService：通过Binder通知ActivityManagerService，要启动哪个Service</li>
<li>2、ActivityManagerService创建ServiceRecord，并利用ApplicationThreadProxy回调，通知APP新建并启动Service启动起来</li>
<li>3、ActivityManagerService把Service启动起来后，继续通过ApplicationThreadProxy，通知APP，bindService，其实就是让Service返回一个Binder对象给ActivityManagerService，以便AMS传递给Client</li>
<li>4、ActivityManagerService把从Service处得到这个Binder对象传给Activity，这里是通过IServiceConnection binder实现。</li>
<li>5、Activity被唤醒后通过Binder Stub的asInterface函数将Binder转换为代理Proxy，完成业务代理的转换，之后就能利用Proxy进行通信了。</li>
</ul>
<p><img src="/images/android_binder_faq_bind_service_flow.png" alt="img"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>总结</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP-下载、编译、调试、刷机</title>
    <url>/2021/02/27/android_aosp_down_make/</url>
    <content><![CDATA[<p>开启新世界，开始搞机啦，第一步就是先整系统源码。</p>
<span id="more"></span>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li><p>基于Ubuntu系统下的操作（Linux和MacOS也可以）。</p>
</li>
<li><p>Ubuntu设置中设置为永不休眠。</p>
</li>
<li><p>分配大一点的存储空间，至少200G（推荐500G+）。</p>
</li>
</ul>
<h1 id="下载AOSP源码"><a href="#下载AOSP源码" class="headerlink" title="下载AOSP源码"></a>下载AOSP源码</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>用于下载和管理源码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>安装依赖工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install git-core libssl-dev libffi-dev gnupg flex bison gperf build-essential zip curl zlib1g-dev</span><br><span class="line">gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev libz-dev ccache libgl1-</span><br><span class="line">mesa-dev libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure>

<p>接下来创建一个bin文件夹，并加入到PATH中，有点像Windows的环境变量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">PATH=~/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>然后初始化Git，邮箱和用户名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;xxx@gmail.com&quot;</span><br><span class="line">git config --global user.name &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<h2 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h2><p>下载Python3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd Downloads</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz</span><br></pre></td></tr></table></figure>

<p>解压Python3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xvf Python-3.7.1.tgz</span><br></pre></td></tr></table></figure>

<p>编译与安装Python3</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>配置Python版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 2</span><br><span class="line">sudo update-alternatives --install /usr/bin/python python python3的安装地址</span><br><span class="line">(/usr/local/bin/python3.7) 3(权重号)</span><br></pre></td></tr></table></figure>

<p>选择Python版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config python</span><br></pre></td></tr></table></figure>

<h3 id="如果Ubuntu自带Python环境的话"><a href="#如果Ubuntu自带Python环境的话" class="headerlink" title="如果Ubuntu自带Python环境的话"></a>如果Ubuntu自带Python环境的话</h3><p>已有Python环境时可能会遇到这个错误</p>
<p><code>/usr/bin/env: ‘python’: No such file or directory</code></p>
<p>首先，检查Python环境，使用python/python2/python3 –version查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 --version</span><br></pre></td></tr></table></figure>

<p>查找Python安装位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whereis python3</span><br></pre></td></tr></table></figure>

<p>为其创建符号连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure>

<h2 id="安装repo及配置"><a href="#安装repo及配置" class="headerlink" title="安装repo及配置"></a>安装repo及配置</h2><p>repo 是一个python 脚本(所以我们上面要配置Python环境)，因为Android源码包含数百个git库，简化帮助管理git Android版本库的工具。</p>
<p>安装curl下载的库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install curl</span><br></pre></td></tr></table></figure>

<p>下载repo并设置可以运行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>

<p>添加下载源</p>
<p>google 的AOSP 的话，因为FQ和数据量太大，且需要需要翻墙影响速度，因此优先考虑国内的镜像(本文使用的是清华的源)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="初始化同步源码"><a href="#初始化同步源码" class="headerlink" title="初始化同步源码"></a>初始化同步源码</h2><p>第一次同步数据量特别大，如果网络不稳定，中间失败就要从头再来了。所以推荐使用打包的 AOSP 镜像，为一个 tar 包，大约 200G（单文件 200G，注意你的磁盘格式要支持）。这样你 就可以通过 HTTP(S) 的方式下载，该方法支持断点续传。</p>
<p>下载地址 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</a></p>
<p>下载完成后记得根据 checksum.txt 的内容校验一下。</p>
<p>由于所有代码都是从隐藏的 <code>.repo</code> 目录中 checkout 出来的，所以我们只保留了 <code>.repo</code> 目录，下载后解压 再 <code>repo sync</code> 一遍即可得到完整的目录。</p>
<p>使用方法如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar xf aosp-latest.tar</span><br><span class="line">cd AOSP   # 解压得到的 AOSP 工程目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录</span></span><br><span class="line">repo sync # 正常同步一遍即可得到完整目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或 repo sync -l 仅checkout代码</span></span><br></pre></td></tr></table></figure>

<p>此后，每次只需运行 <code>repo sync</code> 即可保持同步。 </p>
<p>同步代码过程中如果报错，进入 <code>aosp/.repo/repo$</code></p>
<p><code>git status</code>查看是否已经落后远程分支，如果落后，git pull，然后再同步一次代码。</p>
<p>查看分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd .repo/manifests </span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<p>查找并切换到对应的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo init -b android-12.0.0_r30</span><br><span class="line">repo sync # 正常同步一遍即可得到完整目录</span><br></pre></td></tr></table></figure>

<p>如果仅加载具体模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">repo sync platform/prebuilts/clang/host/darwin-x86</span><br></pre></td></tr></table></figure>

<h2 id="防止下载源码执行脚本卡死"><a href="#防止下载源码执行脚本卡死" class="headerlink" title="防止下载源码执行脚本卡死"></a>防止下载源码执行脚本卡死</h2><p>通过自定义Shell脚本启动源码下载可以有效防止，同步源码时脚本被卡死的问题。</p>
<p>在AOSP文件夹中新建down.sh文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo “======= start repo sync =======”</span><br><span class="line">cd ~/Desktop/AOSP</span><br><span class="line">repo sync -j4</span><br><span class="line">while [ $? == 1 ]; do</span><br><span class="line">echo “====== sync failed! re-sync again =====”</span><br><span class="line">sleep 3</span><br><span class="line">repo sync -j4</span><br></pre></td></tr></table></figure>

<p>执行down.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh down.sh</span><br></pre></td></tr></table></figure>

<h1 id="AOSP源码目录结构"><a href="#AOSP源码目录结构" class="headerlink" title="AOSP源码目录结构"></a>AOSP源码目录结构</h1><ul>
<li><p>abi Application Binary Interface 应用程序二进制接口，abi相信同学们在SO库调用上遇到过，如果不支持该平台的话就说不ABI不支持。</p>
</li>
<li><p>art Android Runtime 安卓运行时。这个会提前把字节码编译成二进制机器码保存起来，执行的时候加载速度比较快。Dalvik虚拟机则是在加载以后再去编译的，所以速度上ART会比Dalvik快一点。牺牲空间来赢取时间。</p>
</li>
<li><p>bionic 基础库，Android系统与Linux内核的桥梁。Bionic 音标为 bīˈänik，翻译为”仿生”。</p>
</li>
<li><p>bootable 系统启动引导相关程序</p>
</li>
<li><p>build 用于构建Android系统的工具，也就是用于编译Android系统的</p>
</li>
<li><p>cts Compatibility Test Suite 兼容性测试</p>
</li>
<li><p>dalvik dalvik虚拟机，用于解析执行dex文件的虚拟机</p>
</li>
<li><p>developers 开发者目录</p>
</li>
<li><p>developerment 开发目录，比如说应用，application就在里面了，apps</p>
</li>
<li><p>devices 设备相关的配置信息，什么索尼、HTC、自己的产品，就可以定义在这个目录下了</p>
</li>
<li><p>docs 文档</p>
</li>
<li><p>external 开源模组相关文件</p>
</li>
<li><p>frameworks 系统架构，Android的核心了</p>
</li>
<li><p>hardware hal层代码，硬件抽象层</p>
</li>
<li><p>libcore 核心库</p>
</li>
<li><p>libnativehelper native帮助库，实现JNI的相关文件</p>
</li>
<li><p>ndk native development kit</p>
</li>
<li><p>out 输出目录，编译以后生成的目录，相关的产出就在这里了</p>
</li>
<li><p>packages 应用程序包。一些系统的应用就在这里了，比如说蓝牙，Launcher，相机，拨号之类的。</p>
</li>
<li><p>pdk Plug-in Development Kit (PDK) is designed to help you build your own pattern projects</p>
</li>
<li><p>platform_testing 平台测试</p>
</li>
<li><p>prebuilts x86/arm架构下预编译的文件</p>
</li>
<li><p>sdk software development kit</p>
</li>
<li><p>system 底层系统文件</p>
</li>
<li><p>toolchain 工具链</p>
</li>
<li><p>tools 工具文件</p>
</li>
<li><p>Makefile mk文件，用于控制编译</p>
</li>
</ul>
<h1 id="AOSP源码编译"><a href="#AOSP源码编译" class="headerlink" title="AOSP源码编译"></a>AOSP源码编译</h1><h2 id="编译前准备"><a href="#编译前准备" class="headerlink" title="编译前准备"></a>编译前准备</h2><h3 id="交换空间设置"><a href="#交换空间设置" class="headerlink" title="交换空间设置"></a>交换空间设置</h3><p>编译时非常吃内存，比如Android12,16G都是不够的，我这边主机是32G的，虚拟机分配了16G，交换空间又给了32G。（一开始虚拟机分配了8G，结果编译到95%时OOM了……）</p>
<p>Linux 的交换分区（swap），或者叫内存置换空间（swap space），是磁盘上的一块区域，可以是一个分区，也可以是一个文件，或者是他们的组合。交换分区的作用是，当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap上的数据加载到内存中，也就是常说的 swap out 和 swap in。我们安装的Ubuntu默认一般是2G左右的swap空间，（可以提供过free -m命令查看虚拟内存与交换空间大小）使用以下命令查看swap详情：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_aosp_down_make06.png" alt="image-20230310144708667"></p>
<h3 id="配置交换空间"><a href="#配置交换空间" class="headerlink" title="配置交换空间"></a>配置交换空间</h3><p>停用交换文件：(根据自己虚拟机来指定/swapfile 还是其他的挂载文件)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo swapoff /swapfile</span><br></pre></td></tr></table></figure>

<p>删除文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm /swapfile</span><br></pre></td></tr></table></figure>

<p>删除后继续创建。<br>新建swap空间，以32G为例，创建文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo fallocate -l 32G /swapfile</span><br></pre></td></tr></table></figure>

<p>这里我们是命名为“swapfile”，当然你也可以随意写。设置文件权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod 600 /swapfile</span><br></pre></td></tr></table></figure>

<p>挂载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkswap /swapfile</span><br></pre></td></tr></table></figure>

<p>激活启用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo swapon /swapfile</span><br></pre></td></tr></table></figure>

<p>接着把交换信息写入系统配置，不然Ubuntu重启后以上配置swap空间工作得重新做。<br>使用vim编辑器打开配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure>

<p>如果提示vim找不到命令，使用以下命令安装vim，然后再次打开配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>

<p>在最后一行插入（vim打开后按i进入编辑模式，移动光标到最后回车换行）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/swapfile swap swap defaults 0 0</span><br></pre></td></tr></table></figure>

<p>编辑好之后按ESC键退出编辑模式，然后依次输入:wq(英文冒号+wq)保存退出，并重启即可。</p>
<h3 id="交换空间未使用"><a href="#交换空间未使用" class="headerlink" title="交换空间未使用"></a>交换空间未使用</h3><p>系统只有当虚拟内存不足才会启动Swap，比如系统默认内存只有6000KB时才会启用交换空间，但是此时系统可能已经卡死，无法启动swap，所以需要更改设置。</p>
<p>终端输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<p>在最后面添加如下语句（按i进入编辑模式，光标移到最后，插入语句）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vm.min_free_kbytes=1500000 #大致1.5G</span><br></pre></td></tr></table></figure>

<p>保存退出（按ESC退出编辑模式，输入:wq保存退出）然后重启开机。<br>以上配置的意思是，当系统内存不足1.5G时就启用交换空间，这是因为我分配给Ubuntu<br>的内存为8G。而如果你虚拟机分配的内存是4G，那建议不要设置1.5G就启用交换空间，<br>可以调小一些，比如调整为1G：<br>vm.min_free_kbytes=1000000</p>
<h2 id="配置java环境"><a href="#配置java环境" class="headerlink" title="配置java环境"></a>配置java环境</h2><p>已有请忽略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>

<h2 id="进入AOSP文件夹进行编译"><a href="#进入AOSP文件夹进行编译" class="headerlink" title="进入AOSP文件夹进行编译"></a>进入AOSP文件夹进行编译</h2><p>初始化编译环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br></pre></td></tr></table></figure>

<p>删除上一次编译的结果，初次编译可以不需要这一步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">make clean</span></span><br><span class="line"><span class="meta">#</span><span class="bash">它会删除本次设置所生成的所有的output与中间文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">等价于指令 rm -rf <span class="variable">$OUT</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="variable">$OUT</span>指的是out/target/product/[product_name]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash">make clobber</span></span><br><span class="line"><span class="meta">#</span><span class="bash">它会删除所有设置所生成的所有的output与中间文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">等价于指令 rm -rf out/</span></span><br><span class="line"><span class="meta">#</span><span class="bash">可以看到，make clobber的严格在于它把整个out目录都删除了。</span></span><br><span class="line">make clobber</span><br></pre></td></tr></table></figure>

<p>选择与设备对应的编译版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lunch XX</span><br></pre></td></tr></table></figure>

<p>选择与设备对应的编译版本.如:编译开发工程师的版本<code>lunch aosp_x86-eng</code>，可以方便debug<br><a href="https://links.jianshu.com/go?to=https://source.android.com/setup/build/running%23selecting-device-build">编译版本选择</a></p>
<p>如果<code>lunch</code>命令没有加对应的编译版本则会有以下信息输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">You&#x27;re building on Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     1. aosp_arm-eng //这种是必须有 arm CPU架构的 Google手机 才能尝试</span><br><span class="line">     2. aosp_arm64-eng//这种是必须有 arm64 CPU架构的 Google手机 才能尝试</span><br><span class="line">     3. aosp_barbet-userdebug//这种是 开放部分权限，运行root的版本</span><br><span class="line">     4. aosp_blueline-userdebug</span><br><span class="line">     5. aosp_blueline_car-userdebug</span><br><span class="line">     6. aosp_bonito-userdebug</span><br><span class="line">     7. aosp_bonito_car-userdebug</span><br><span class="line">     8. aosp_bramble-userdebug</span><br><span class="line">     9. aosp_bramble_car-userdebug</span><br><span class="line">     10. aosp_car_arm-userdebug//车载级别的，真正的车企设备才会尝试，arm</span><br><span class="line">CPU指令 的 车载设备</span><br><span class="line">     11. aosp_car_arm64-userdebug</span><br><span class="line">     12. aosp_car_x86-userdebug</span><br><span class="line">     13. aosp_car_x86_64-userdebug</span><br><span class="line">     14. aosp_cf_arm64_auto-userdebug</span><br><span class="line">     15. aosp_cf_arm64_phone-userdebug</span><br><span class="line">     16. aosp_cf_x86_64_foldable-userdebug</span><br><span class="line">     17. aosp_cf_x86_64_pc-userdebug</span><br><span class="line">     18. aosp_cf_x86_64_phone-userdebug</span><br><span class="line">     19. aosp_cf_x86_64_tv-userdebug</span><br><span class="line">     20. aosp_cf_x86_auto-userdebug</span><br><span class="line">     21. aosp_cf_x86_phone-userdebug</span><br><span class="line">     22. aosp_cf_x86_tv-userdebug</span><br><span class="line">     23. aosp_coral-userdebug</span><br><span class="line">     24. aosp_coral_car-userdebug</span><br><span class="line">     25. aosp_crosshatch-userdebug</span><br><span class="line">     26. aosp_crosshatch_car-userdebug</span><br><span class="line">     27. aosp_crosshatch_vf-userdebug</span><br><span class="line">     28. aosp_flame-userdebug</span><br><span class="line">     29. aosp_flame_car-userdebug</span><br><span class="line">     30. aosp_redfin-userdebug</span><br><span class="line">     31. aosp_redfin_car-userdebug</span><br><span class="line">     32. aosp_redfin_vf-userdebug</span><br><span class="line">     33. aosp_sargo-userdebug</span><br><span class="line">     34. aosp_sargo_car-userdebug</span><br><span class="line">     35. aosp_sunfish-userdebug</span><br><span class="line">     36. aosp_sunfish_car-userdebug</span><br><span class="line">     37. aosp_trout_arm64-userdebug</span><br><span class="line">     38. aosp_trout_x86-userdebug</span><br><span class="line">     39. aosp_x86-eng</span><br><span class="line">     40. aosp_x86_64-eng</span><br><span class="line">     41. arm_krait-eng</span><br><span class="line">     42. arm_v7_v8-eng</span><br><span class="line">     43. armv8-eng</span><br><span class="line">     44. armv8_cortex_a55-eng</span><br><span class="line">     45. armv8_kryo385-eng</span><br><span class="line">     46. beagle_x15-userdebug</span><br><span class="line">     47. beagle_x15_auto-userdebug</span><br><span class="line">     48. car_x86_64-userdebug</span><br><span class="line">     49. db845c-userdebug</span><br><span class="line">     50. fuchsia_arm64-eng</span><br><span class="line">     51. fuchsia_x86_64-eng</span><br><span class="line">     52. gsi_car_arm64-userdebug</span><br><span class="line">     53. gsi_car_x86_64-userdebug</span><br><span class="line">     54. hikey-userdebug</span><br><span class="line">     55. hikey64_only-userdebug</span><br><span class="line">     56. hikey960-userdebug</span><br><span class="line">     57. hikey960_tv-userdebug</span><br><span class="line">     58. hikey_tv-userdebug</span><br><span class="line">     59. pixel3_mainline-userdebug</span><br><span class="line">     60. poplar-eng</span><br><span class="line">     61. poplar-user</span><br><span class="line">     62. poplar-userdebug</span><br><span class="line">     63. qemu_trusty_arm64-userdebug</span><br><span class="line">     64. sdk_car_arm-userdebug</span><br><span class="line">     65. sdk_car_arm64-userdebug</span><br><span class="line">     66. sdk_car_x86-userdebug</span><br><span class="line">     67. sdk_car_x86_64-userdebug//这个是车载，车载AOSP运行到，车载设备</span><br><span class="line">x86_64 CPU指令的版本</span><br><span class="line">     68. silvermont-eng</span><br><span class="line">     69. uml-userdebug</span><br><span class="line">     70. yukawa-userdebug</span><br><span class="line">     71. yukawa_sei510-userdebug</span><br><span class="line"></span><br><span class="line">Which would you like? [aosp_arm-eng]</span><br></pre></td></tr></table></figure>

<p>这里需要选择编译目标的格式(选择前面的序号，按回车即可)，编译目标的格式组成为<code>BUILD-BUILDTYPE</code>，比如aosp_arm-eng的BUILD为aosp_arm，BUILDTYPE为eng。 其中BUILD表示编译出的镜像可以运行在什么环境，aosp代表Android开源项目，arm表示系统是运行在arm架构的处理器上。 更多参考官方文档<a href="https://links.jianshu.com/go?to=https://source.android.google.cn/source/running.html%23selecting-device-build">文档</a>。<br> BUILDTYPE 指的是编译类型，有以下三种：</p>
<ul>
<li>user：用来正式发布到市场的版本，权限受限，如没有 root 权限，不能 dedug，adb默认处于停用状态。</li>
<li>userdebug：在user版本的基础上开放了 root 权限和 debug 权限，adb默认处于启用状态。一般用于调试真机。</li>
<li>eng：开发工程师的版本，拥有最大的权限(root等)，具有额外调试工具的开发配置。一般用于模拟器。<br> 如果你没有Nexus设备，只想编译完后运行在模拟器查看，那么BUILD可以选择aosp_x86，BUILDTYPE选择eng。</li>
</ul>
<p>如果需要跑模拟器，则必须选择sdk开头的。</p>
<p>开始编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">m或者make均可</span></span><br><span class="line"><span class="meta">#</span><span class="bash">m，会根据当前CPU的能力，自动控制性能来编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash">make -j4，开启多线程来编译，数字即为线程数</span></span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<p>j后面数字几就是多少线程，最多不超过你的cpu总线程，<br>编译成功会显示如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Creating filesystem with parameters:</span><br><span class="line">    Size: 2147483648</span><br><span class="line">    Block size: 4096</span><br><span class="line">    Blocks per group: 32768</span><br><span class="line">    Inodes per group: 8192</span><br><span class="line">    Inode size: 256</span><br><span class="line">    Journal blocks: 8192</span><br><span class="line">    Label: system</span><br><span class="line">    Blocks: 524288</span><br><span class="line">    Block groups: 16</span><br><span class="line">    Reserved block group size: 127</span><br><span class="line">Created filesystem with 2216/131072 inodes and 199826/524288 blocks</span><br><span class="line"><span class="meta">[100%</span><span class="bash"> 7669/7669] Install system fs ima.../target/product/generic_x86/system.img</span></span><br><span class="line">out/target/product/generic_x86/system.img+ maxsize=2192446080 blocksize=2112 total=2147483648 reserve=22146432</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### make completed successfully (01:24:41 (hh:mm:ss)) ####</span></span></span><br></pre></td></tr></table></figure>

<p>会在源码跟目录out/target/product/angler目录下生成镜像文件：</p>
<ul>
<li>system.img：系统镜像</li>
<li>ramdisk.img：根文件系统镜像</li>
<li>userdata.img：用户数据镜像</li>
<li>recovery.img:recovery镜像</li>
<li>boot.img:启动镜像</li>
<li>vendor.img:驱动镜像</li>
</ul>
<p>最终会在 out/target/product/generic_x86/目录生成了三个重要的镜像文件： system.img、userdata.img、ramdisk.img。大概介绍着三个镜像文件：</p>
<ul>
<li>system.img：系统镜像，里面包含了Android系统主要的目录和文件，通过init.c进行解析并mount挂载到/system目录下。</li>
<li>userdata.img：用户镜像，是Android系统中存放用户数据的，通过init.c进行解析并mount挂载到/data目录下。</li>
<li>ramdisk.img：根文件系统镜像，包含一些启动Android系统的重要文件，比如init.rc。</li>
</ul>
<h2 id="编译错误解决"><a href="#编译错误解决" class="headerlink" title="编译错误解决"></a>编译错误解决</h2><h3 id="缺少libncurses-so-5"><a href="#缺少libncurses-so-5" class="headerlink" title="缺少libncurses.so.5"></a>缺少libncurses.so.5</h3><p>报错信息:<br> <code>error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory</code><br> 解决方式:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>for 32-bit binaries :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libncurses5:i386</span><br></pre></td></tr></table></figure>

<p>for 64-bit binaries :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libncurses5</span><br></pre></td></tr></table></figure>

<h3 id="缺少M4"><a href="#缺少M4" class="headerlink" title="缺少M4"></a>缺少M4</h3><p>报错信息:<br><code>/bin/bash: m4: command not found</code><br>解决方式:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install m4</span><br></pre></td></tr></table></figure>

<h3 id="去除所有本地化设置"><a href="#去除所有本地化设置" class="headerlink" title="去除所有本地化设置"></a>去除所有本地化设置</h3><p>报错信息:<br><code>FAILED: out/host/linux-x86/obj/EXECUTABLES/checkpolicy_intermediates/policy_scan.c</code><br>解决方法:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LC_ALL=C</span><br></pre></td></tr></table></figure>

<p>LC_ALL=C 是为了去除所有本地化的设置，让命令能正确执行， 但是不可以修改~/.bashrc，会导致终端内中文显示为数字(应该是对应的编码)</p>
<h3 id="jack-server问题"><a href="#jack-server问题" class="headerlink" title="jack-server问题"></a>jack-server问题</h3><p><strong>jack server交互命令:</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jack-admin start-server</span><br><span class="line">jack-admin kill-server</span><br><span class="line">jack-admin list-server</span><br><span class="line">jack-admin uninstall-server</span><br><span class="line">mm -j32 showcommands &amp;&gt; mm.out</span><br><span class="line">jack-admin install-server jack-launcher.jar  jack-server-4.8.ALPHA.jar</span><br><span class="line">jack-admin dump-report</span><br><span class="line">jack-admin dump-re</span><br><span class="line">jack-admin server-log  查找log所在目录</span><br></pre></td></tr></table></figure>

<p><strong>问题一：多用户同时编译时报错</strong><br>错误信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FAILED: setup-jack-server</span><br><span class="line">/bin/bash -c &quot;(prebuilts/sdk/tools/jack-admin install-server prebuilts/sdk/tools/jack-launcher.jar prebuilts/sdk/tools/jack-server-4.11.ALPHA.jar  2&gt;&amp;1 || (exit 0) ) &amp;&amp; (JACK_SERVER_VM_ARGUMENTS=\&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation\&quot; prebuilts/sdk/tools/jack-admin start-server 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update server prebuilts/sdk/tools/jack-server-4.11.ALPHA.jar 4.11.ALPHA 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-4.31.CANDIDATE.jar 4.31.CANDIDATE || exit 47 )&quot;</span><br><span class="line">Jack server already installed in &quot;/home/disk/lixialong/.jack-server&quot;</span><br><span class="line">Communication error with Jack server (35), try &#x27;jack-diagnose&#x27; or see Jack server log</span><br><span class="line">SSL error when connecting to the Jack server. Try &#x27;jack-diagnose&#x27;</span><br><span class="line">SSL error when connecting to the Jack server. Try &#x27;jack-diagnose&#x27;</span><br></pre></td></tr></table></figure>

<p>解决方案：同时修改<img src="https://math.jianshu.com/math?formula=HOME/.jack-settings%E5%92%8C" alt="HOME/.jack-settings和">HOME/.jack-server/config.properties中的端口号（比如都改为8386/8387，端口号值为0~65535，1024下的值不要用），方可支持多用户同时编译。<br> 查看端口是否一致：cat ~/.jack-server/config.properties|grep -i port &amp;&amp; cat ~/.jack|grep -i port|grep -v LOG &amp;&amp;cat ~/.jack-settings|grep -i port</p>
<ol>
<li>$HOME/.jack-settings</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SERVER_PORT_SERVICE=8386</span><br><span class="line">SERVER_PORT_ADMIN=8387</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>$HOME/.jack-server/config.properties</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jack.server.service.port=8386</span><br><span class="line">jack.server.admin.port=8387</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>$HOME/.jack</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SERVER_PORT_SERVICE=8288</span><br><span class="line">SERVER_PORT_ADMIN=8289</span><br></pre></td></tr></table></figure>

<p><strong>问题二： No Jack server running. Try ‘jack-admin start-server’</strong><br>错误信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">com.android.jack.server.api.v01.ServerException: &#x27;./config.properties&#x27; musthave permission rw------- but have rwx------</span><br><span class="line">Caused by: java.io.IOException: &#x27;./config.properties&#x27; must have permissionrw------- but have rwx------</span><br><span class="line">... </span><br></pre></td></tr></table></figure>

<p>解决方案：通过查看文件 <img src="https://math.jianshu.com/math?formula=HOME/.jack-server/logs/jack-server-0-0.log%EF%BC%9A%20%E5%8F%91%E7%8E%B0%E6%98%AF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E4%B8%8D%E5%AF%B9%E9%80%A0%E6%88%90%E7%9A%84%EF%BC%8C%E6%8A%8A%E6%96%87%E4%BB%B6" alt="HOME/.jack-server/logs/jack-server-0-0.log： 发现是配置文件的权限不对造成的，把文件">HOME/.jack-server/config.properties的权限由rwx改为rw即可解决问题。<br><strong>问题三：未配置变量信息导致问题</strong><br>错误信息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR: Communication error with Jack server (52) make: *** [out/target/common/obj/JAVA_LIBRARIES/libutil_intermediates/classes.jack] Error</span><br></pre></td></tr></table></figure>

<p>这种情况多半属于jack-admin缺少变量JACK_JAR而导致的。</p>
<p>解决方案：<br>工程根目录内执行以下三句，再进行编译。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JACK_JAR=./out/host/linux-x86/framework/jack.jar</span><br><span class="line"></span><br><span class="line">./out/host/linux-x86/bin/jack-admin stop-server</span><br><span class="line"></span><br><span class="line">./out/host/linux-x86/bin/jack-admin start-server</span><br></pre></td></tr></table></figure>

<p><strong>问题四:TLSv1， TLSv1.1 禁用</strong><br>报错信息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Ensuring Jack server is installed and started</span><br></pre></td></tr></table></figure>

<p>解决方式:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/java-8-openjdk/security/java.security</span><br></pre></td></tr></table></figure>

<p>vim里面输入/搜索jdk.tls.disabledAlgorithms= 将TLSv1， TLSv1.1 光标选中输入x删除掉取消禁用.然后wq保存.<br>修改后:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, \</span><br><span class="line">    DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \</span><br><span class="line">    include jdk.disabled.namedCurves</span><br></pre></td></tr></table></figure>

<p>aosp/prebuilts/sdk/tools/ 目录下执行./jack-admin kill-server &amp;&amp; ./jack-admin start-server 成功。</p>
<h3 id="xmllint的问题"><a href="#xmllint的问题" class="headerlink" title="xmllint的问题"></a>xmllint的问题</h3><p>报错信息:<br><code>/bin/bash: xmllint: command not found</code><br>解决方案:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get  install libxml2-utils</span><br></pre></td></tr></table></figure>

<h3 id="编译内存不足"><a href="#编译内存不足" class="headerlink" title="编译内存不足"></a>编译内存不足</h3><p>报错信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Try increasing heap size with java option &#x27;-Xmx&lt;size&gt;&#x27;错误</span><br></pre></td></tr></table></figure>

<p>解决方案:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JACK_SERVER_VM_ARGUMENTS=&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jack-admin kill-server</span><br><span class="line">jack-admin start-server</span><br></pre></td></tr></table></figure>

<h1 id="运行模拟器"><a href="#运行模拟器" class="headerlink" title="运行模拟器"></a>运行模拟器</h1><h2 id="启动模拟器"><a href="#启动模拟器" class="headerlink" title="启动模拟器"></a>启动模拟器</h2><p>在编译完成之后，就可以通过以下命令运行Android虚拟机了，由于之前已经执行过source和lunch命令了，可以直接运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">lunch sdk_car_x86_64-userdebug</span><br><span class="line">emulator</span><br></pre></td></tr></table></figure>

<h2 id="启动模拟器失败"><a href="#启动模拟器失败" class="headerlink" title="启动模拟器失败"></a>启动模拟器失败</h2><h3 id="libncurses-so-5缺少"><a href="#libncurses-so-5缺少" class="headerlink" title="libncurses.so.5缺少"></a>libncurses.so.5缺少</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aosp error while loading shared libraries: libncurses.so.5</span><br></pre></td></tr></table></figure>

<p>解决方案</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">解决方法：</span></span><br><span class="line">sudo apt install apt-file</span><br><span class="line">sudo apt-file update</span><br><span class="line">sudo apt-file find libncurses.so.5</span><br><span class="line">sudo apt install libncurses5</span><br></pre></td></tr></table></figure>

<h3 id="缺少文件userdata-qemu-img"><a href="#缺少文件userdata-qemu-img" class="headerlink" title="缺少文件userdata-qemu.img"></a>缺少文件userdata-qemu.img</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cannot addlibrary /root/aosp/prebuilts/android-emulator/linux-</span><br><span class="line">x86_64/qemu/linux-x86_64/lib64/vulkan/libvulkan.so: failedadded library</span><br><span class="line">/root/aosp/prebuilts/android-emulator/linux-</span><br><span class="line">x86_64/lib64/vulkan/libvulkan.soemulator: ERROR:</span><br><span class="line">VkCommonOperations.cpp:537: Failed to create Vulkan instance.qemu-</span><br><span class="line">system-x86_64: Could not</span><br><span class="line">open&#x27;/root/aosp/out/target/product/generic_x86_64/userdata-qemu.img&#x27;:No</span><br><span class="line">such fileor directory</span><br></pre></td></tr></table></figure>

<p>解决方案</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编译“aosp_car_x86_64-userdebug”，完成后执行emulator无法正常进入模拟器</span></span><br><span class="line"><span class="meta">#</span><span class="bash">由于编译“aosp_car_x86_64-userdebug”不会生成qemu所需镜像， 所以必须编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash">SDK_xxx <span class="string">&quot;sdk_car_x86_64-userdebug&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">解决方法：</span></span><br><span class="line">source build/envsetup.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">lunch aosp_car_x86_64-userdebug 【这一行是 错误的关键点】</span></span><br><span class="line"><span class="meta">#</span><span class="bash">【换成sdk后，才能启动车载模拟器】</span></span><br><span class="line">lunch sdk_car_x86_64-userdebug</span><br><span class="line">make -j4</span><br><span class="line">emulator</span><br></pre></td></tr></table></figure>

<h3 id="模拟器启动后界面一直处于phone-is-starting"><a href="#模拟器启动后界面一直处于phone-is-starting" class="headerlink" title="模拟器启动后界面一直处于phone is starting"></a>模拟器启动后界面一直处于phone is starting</h3><p><img src="/images/android_aosp_down_make07.png" alt="image"></p>
<p>解决方案</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用emulator命令和emulator -partition-size 200来回重试</span></span><br><span class="line"><span class="meta">#</span><span class="bash">我遇到的这种情况时一般重试两次就好了，挺奇怪的一个问题……</span></span><br><span class="line">emulator</span><br><span class="line">emulator -partition-size 200</span><br></pre></td></tr></table></figure>



<h1 id="AOSP源码编译某个单独的模块"><a href="#AOSP源码编译某个单独的模块" class="headerlink" title="AOSP源码编译某个单独的模块"></a>AOSP源码编译某个单独的模块</h1><p>上面的编译我们都是对整个Android系统进行编译的.如果我们要编译系统的Settings应用模块，这就属于源码单编某一个模块.<br> 在AOSP根目录执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">lunch aosp_x86-eng</span><br></pre></td></tr></table></figure>

<p>进入Settings的目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd packages/apps/Settings</span><br></pre></td></tr></table></figure>

<p>通过mm编译当前目录下的模块，不编译依赖模块。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mm</span><br></pre></td></tr></table></figure>

<p>编译成功后会有提示生成文件的存放路径。除了Settings.odex文件，还会在out/target/product/generic_x86/system/priv-app/Settings目录下生成Settings.apk。<br> 此外还有以下命令可以进行单编：</p>
<ul>
<li>mmm：编译指定目录下的模块，不编译它所依赖的其它模块。</li>
<li>mma：编译当前目录下的模块及其依赖项。</li>
<li>mmma：编译指定路径下所有模块，并且包含依赖。</li>
</ul>
<p>如果对系统模块的源码进行修改，查看生成的APK文件，有两种方式：</p>
<ul>
<li>通过adb push或者adb install 来安装APK。</li>
<li>使用make snod命令，重新生成 system.img，运行模拟器查看。</li>
</ul>
<h1 id="导入源码到AndroidStudio"><a href="#导入源码到AndroidStudio" class="headerlink" title="导入源码到AndroidStudio"></a>导入源码到AndroidStudio</h1><h2 id="编译idegen模块，生成IDE项目文件"><a href="#编译idegen模块，生成IDE项目文件" class="headerlink" title="编译idegen模块，生成IDE项目文件"></a>编译idegen模块，生成IDE项目文件</h2><p>在源码中，存在idegen模块，该模块专门用来为idea工具生成系统源码的project.默认情况下aosp编译并不会生成该文件。<br> 在开始编译该模块之前，首先确保你已经编译过Android源码了，如果没有，先要进行AOSP编译.和编译普通的模块一样，我们用mmm命令编译idegen.<br> 在开始编译之前，检查out/host/linux-x86/framework/目录下是否存在idegen.jar文件，存在则说明你已经编译过该模块，否者，则需要编译.执行如下命令即可:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh 将脚本添加到系统内</span><br><span class="line">lunch 并选择要编译的项目</span><br><span class="line">mmm development/tools/idegen/ </span><br><span class="line">sudo ./development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>

<p>其中mmm development/tools/idegen/执行完成后会生成idegen.jar，而sodo ./development/tools/idegen/idegen.sh则会在源码目录下生成IEDA工程配置文件:android.ipr，android.iml及android.iws.</p>
<p>简单的说明一下这三个文件的作用:</p>
<ul>
<li>android.ipr:通常是保存工程相关的设置，比如编译器配置，入口，相关的libraries等</li>
<li>android.iml:则是主要是描述了modules，比如modules的路径，依赖关系等.</li>
<li>android.iws:则主要是包含了一些个人工作区的设置.</li>
</ul>
<blockquote>
<p>“android.iml”和”android.ipr”一般是”只读”的属性，我们这里建议大家，把这两个文件改成可读可写，否则，在更改一些项目配置的时候可能会出现无法保存的情况，执行如下两条命令即可。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod 777 android.iml</span><br><span class="line">sudo chmod 777 android.ipr</span><br></pre></td></tr></table></figure>

<h2 id="导入源码到AndroidStudio-1"><a href="#导入源码到AndroidStudio-1" class="headerlink" title="导入源码到AndroidStudio"></a>导入源码到AndroidStudio</h2><h3 id="配置AS"><a href="#配置AS" class="headerlink" title="配置AS"></a>配置AS</h3><p>IDE内存优化<br> 因为源码数量非常多，所以导入时IDEA/AS会需要大量内存。所以我们需要编辑IDE的VM选项。配置文件为</p>
<p>IDEA的是IDEA_HOME/bin/idea.vmoptions<br> AS的是AS_HOME/bin/studio.vmoptions<br> 注意，AS有一个64位版本的配置文件studio64.vmoptions最好一并修改了。</p>
<p>找到上面的配置文件，将对应的内容修改为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xms748m -Xmx748m</span><br></pre></td></tr></table></figure>

<p>即将VM的堆内存最小和最大都设置为748m。官方要求至少在748m以上，根据实际情况进行配置即可</p>
<h3 id="导入源码"><a href="#导入源码" class="headerlink" title="导入源码"></a>导入源码</h3><p>接下来，我们导入源码:打开Android Studio，点击File-&gt;Open，选择刚才生成的android.ipr文件即可，然后就是漫长的等待，注意此时是将源码完全导入到AS中了。<br> 如果AS运行比较慢我们就需要排除一些不需要导入的模块。</p>
<h3 id="排除模块"><a href="#排除模块" class="headerlink" title="排除模块"></a>排除模块</h3><p>很多情况下，我们希望不导入某些模块，那么就可以在导入前修改android.iml文件，通过添加配置的方式告诉AS不导入某些模块，比如现在我不想导入art模块，那么就在android.iml文件中添加:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">excludeFloder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$&quot;</span>/<span class="attr">abi</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不难发现，其格式为:<code>&lt;excludeFloder url=&quot;file://$MODULE_DIR$&quot;/模块名&gt;</code></p>
<blockquote>
<p>注:编译生成的android.iml文件中已经默认排除了一些模块，通过搜索excludeFolder关键字可找到.</p>
</blockquote>
<p>如果比较关心framworks和packages模块，则保留framworks和packages模块，将其他模块全部排除，在android.iml中添加了以下配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/.repo&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/abi&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/art&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/bionic&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/bootable&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/build&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/cts&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/dalvik&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/developers&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/development&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/device&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/docs&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/external&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/external/bluetooth&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/external/chromium&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/external/emma&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/external/icu4c&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/external/jdiff&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/external/webkit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/frameworks/base/docs&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/frameworks/base/extension&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/hardware&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/kernel&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/kernel-3.18&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/libcore&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/libnativehelper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/ndk&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/oem-release&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/out&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/out/eclipse&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/out/host&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/out/target/common/docs&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/out/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/out/target/product&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/pdk&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/platform_testing&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/prebuilt&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/prebuilts&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/rc_projects&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/sdk&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/system&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/tools&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/trusty&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">&quot;file://$MODULE_DIR$/vendor&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>完成之后，按照上面说的步骤，使用Android Studio选中”android.ipr”打开项目即可。</p>
<blockquote>
<p>等项目加载完成后，我们还可以通过Android Studio对Exclude的Module进行调整，所以也不用害怕这里Exclude掉了有用的代码，或少Exclude了一部分代码，在项目加载完以后再进行调整就行了。此处和在android.iml文件中添加excludeFolder 的功能是一样的；</p>
</blockquote>
<p>打开”Project Structure”，中间的窗口选择”android”，在弹出的窗口中左边栏中选择”Modules”，而后在右边的窗口中选择”Sources”。<br> 在这里我们可以看到项目的所有代码目录，我们可以选中不需要的module，并点击上面的”Excluded”按钮，当被选中的目录变为橙色，即表示完成Exclude操作；<br> 如果想要取消对某代码目录的Exclude操作，选中该目录，再次点击”Excluded”按钮，等待目录变为蓝色即可。</p>
<p><img src="/images/android_aosp_down_make01.png" alt="img"></p>
<h3 id="配置源码正确跳转"><a href="#配置源码正确跳转" class="headerlink" title="配置源码正确跳转"></a>配置源码正确跳转</h3><p>当我们导入完源码后，就可以查看整个系统的源码，但是有个问题，打开的Java代码，查看集成关系或者调用关系的时候，还是会跳转到.class文件中，而不是相应的Java类，<br> 比如PhoneWindow.java继承了Window.java，但是我们跳转的时候却跳到了Window.class，并没有跳转到frameworks目录下对应的源码类，而是jar包中的类。<br> 我们需要让其跳转到相应的类中。我们就需要新建一个没有任何jar库的SDK给到系统源码项目的依赖， 这里的配置JDK/SDK，是用于解决在分析和调试源码的过程，能正确地跳转到目标源码，<br> 而非SDK中的代码。</p>
<ul>
<li>新建JDK<br> Project Structure -&gt; SDKs， 新建 JDK， 其中JDK目录可选择跟原本JDK一致即可，任意取一个名字，这里取empty_jdk 然后删除这里取empty_jdk其classpath和SourcePath的内容，确保使用Android系统源码文件</li>
</ul>
<p><img src="/images/android_aosp_down_make02.png" alt="img"></p>
<ul>
<li>配置SDK<br> Project Structure -&gt; SDKs， 选中与自己编译的AOSP对应的SDk版本(如果没有对应的就到SDKmanager里面取下载一个对应的版本) Android API 28 Platform， 然后选择其Java SDK为前面新建的empty_jdk</li>
</ul>
<p><img src="/images/android_aosp_down_make03.png" alt="img"></p>
<ul>
<li>选择SDK<br>Project Structure -&gt; Project -&gt; 选中Project SDK， 选择前面的Android API 28 Platform</li>
</ul>
<p><img src="/images/android_aosp_down_make04.png" alt="img"></p>
<ul>
<li>建立依赖<br> Project Structure -&gt; Modules -&gt; android -&gt; Dependencies: Module选择我们上面编辑过的SDK。然后点击下图绿色的+号来选择Jars or directories，将 aosp/frameworks 目录添加进来，再按照同样的步骤将aosp/external 目录， 也可添加其他所关注的源码；<br> 然后选中其他所有的依赖，点击右边的下移箭头将其他依赖移动到我们添加的目录下面。(或者将其他的所有依赖删除)</li>
</ul>
<p><img src="/images/android_aosp_down_make05.png" alt="img"></p>
<blockquote>
<p>注意，一般我们大部分人不在ubuntu下开发app ，为了能在Windows或Mac系统下也能使用Android Studio查看源码，<br> 可以按照上面的步骤，那样直接拷贝ubuntu下的android.iml和android.ipr文件到Windows或Mac系统下的android源码根目录下，<br> 然后导入Adnroid Studio中，这样就可以在这两个平台上进行查看源码了。</p>
</blockquote>
<h1 id="通过AS调试源码"><a href="#通过AS调试源码" class="headerlink" title="通过AS调试源码"></a>通过AS调试源码</h1><h2 id="打开模拟器"><a href="#打开模拟器" class="headerlink" title="打开模拟器"></a>打开模拟器</h2><p>要调试代码，首先要打开模拟器，注意不是Android Studio自带的模拟器，而是通过编译后的代码启动的模拟器，否则可能出现代码不对应的问题。<br> 直接运行emulator命令是无法启动的，执行方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source build/envsteup.sh</span><br><span class="line"></span><br><span class="line">lunch 6 //和编译时对应</span><br><span class="line"></span><br><span class="line">emulator</span><br></pre></td></tr></table></figure>

<p>接下来通过Run-&gt;Attache debugger to Android process，在弹出的Choose Process框内必须选择Show all processes，否则看不到相关的进程:然后选择system_process，就可以进行调试了。</p>
<h1 id="Android刷机知识"><a href="#Android刷机知识" class="headerlink" title="Android刷机知识"></a>Android刷机知识</h1><h2 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h2><p>机器首先要启动，CPU 最先执行的一段程序就是 BootLoader，是在操作系统内核运行之前运行的一段小程序。其实Bootloader就相当于电脑的bios。 通过这段小程序，进行硬件初始化，获取内存大小信息等，调整手机到适配状态，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。<br> 。很多的手机厂商都会锁住BootLoader，这样你就只能使用官方的系统，想要第三方的ROM能够运行，或者破解官方系统这时候就需要进行bootloader解锁!这是刷机的第一步， 当然也有很多手机没有bootloader锁!我们只需要知道要想刷机就得先bootloader解锁。</p>
<h2 id="FastBoot"><a href="#FastBoot" class="headerlink" title="FastBoot"></a>FastBoot</h2><p>fastboot，它是bootloader后期进入的一个特殊阶段。例如小米手机开机同时按音量下建就会进入这个模式.也是一种模式。可以通过数据线与电脑连接，然后在电脑上执行一些命令，如刷系统镜像到手机上。fastboot可以理解为实现了一个简单的通信协议，接收命令并更新镜像文件，其他什么的干不了。<br> 需使用USB数据线连接电脑和手机的一种线刷刷机模式，大部分第三方的Recovery刷入，或者救砖均是在Fastboot模式下进行，所以这种方式称为线刷。 fastboot需要bootloader的支持，所以不是每家手机都会支持这种模式。Fastboot 可以说是一个通信协议，电脑可以通过这个通信协议，直接向手机系统不同分区中写入文件（.img 文件）。</p>
<h3 id="fastboot-bootloader-模式怎么进入？"><a href="#fastboot-bootloader-模式怎么进入？" class="headerlink" title="fastboot(bootloader)模式怎么进入？"></a>fastboot(bootloader)模式怎么进入？</h3><p>大多数安卓手机，都可以在关机状态下，然后同时按住【电源键】+【音量+】键，大约2-3s后，就可以进入Fastboot模式。 作为开发者在开机状态下可以用下面的方式进入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>

<h3 id="fastboot命令"><a href="#fastboot命令" class="headerlink" title="fastboot命令"></a>fastboot命令</h3><p>然后就可以执行下面的fastboot命令了:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fastboot flashing unlock    #6.0以上设备 设备必须解锁，开始刷机（这个不同的手机厂商不同）</span><br><span class="line">fastboot erase &#123;partition&#125;  # 擦除分区</span><br><span class="line">fastboot  erase  frp    # 擦除 frp 分区，frp 即 Factory Reset Protection，用于防止用户信息在手机丢失后外泄</span><br><span class="line">fastboot  flash  boot  boot.img    # 刷入 boot 分区</span><br><span class="line">fastboot  flash  system  system.img    # 刷入 system 分区</span><br><span class="line">fastboot  flash  recovery  recovery.img    # 刷入 recovery 分区</span><br><span class="line">fastboot flashall    #烧写所有分区，注意：此命令会在当前目录中查找所有img文件，将这些img文件烧写到所有对应的分区中，并重新启动手机。</span><br><span class="line">fastboot  format  data    # 格式化 data 分区</span><br><span class="line">fastboot  flashing lock    # 设备上锁，刷机完毕</span><br><span class="line">fastboot  continue    # 自动重启设备</span><br><span class="line">fastboot reboot# 重启手机</span><br><span class="line">fastboot reboot-bootloader# 重启到bootloader 刷机用</span><br><span class="line">fastboot devices  ## 发现手机，显示当前哪些手机通过fastboot连接了</span><br></pre></td></tr></table></figure>

<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>如果没有进入fastboot，bootloader继续执行，如果又发现有特殊的按键组合，比如小米上是音量上键和开机键，则会进入recovery模式。它里面包含了一个kernel以及一个可执行程序recovery，以<br> 及一些初始化文件。Recovery模式指的是一种可以对安卓机内部的数据或系统进行修改的模式，也叫工程模式，像是电脑上的小型winPE系统，winPE可以在电脑上安装操作系统，或者做些删除备份、管理的工作。<br> 官方Recovery用处不大，所以通常会刷入一个第三方的Recovery ，Recovery 更类似于一个小型的管理系统。只不过功能简单，所做的管理有限。在recovery模式下，会加载了部分文件系统，所以才可以读sdcard中的update.zip进行刷机，当然，也可以清除cache和用户数据。<br> 该模式可根据用户的需要进行修改，因此有官方recovery模式以及第三方recovery模式。第三方recovery模式可以识别第三方rom包，因此可以用来刷机。而官方recovery一般不能识别第三方zip文件。好用的第三方RE:TWRP 和 CWM Recovery刷机包是称为Google Update 格式。在用Recovery恢复时，刷机包通常放在SD卡里，所以这里刷机一般称为卡刷。</p>
<h2 id="线刷和卡刷"><a href="#线刷和卡刷" class="headerlink" title="线刷和卡刷"></a>线刷和卡刷</h2><ul>
<li>线刷： 直接想手机硬盘写入*.img 文件，我个人觉得这种方法比较快捷，而且省事。但是必须借助电脑和数据线。</li>
<li>卡刷：就是利用recovery的从SD卡中更新系统的这个功能，如果你想刷第三方Rom，必须刷入个第三方recovery，只有fastboot模式才能刷recovery.img。卡刷有个限制，必须要把想要更新的ROM（Android系统）拷贝到SD卡上。如果手机已经是砖了。那只能用线刷了。</li>
</ul>
<h1 id="手机硬件驱动知识"><a href="#手机硬件驱动知识" class="headerlink" title="手机硬件驱动知识"></a>手机硬件驱动知识</h1><h2 id="硬件驱动的作用"><a href="#硬件驱动的作用" class="headerlink" title="硬件驱动的作用"></a>硬件驱动的作用</h2><p>AOSP是一个由谷歌维护的开源操作系统开发项目，既然是开源项目，也就意味着任何人都可以自由地审查和贡献代码以及修复项目仓库，而谷歌引领着大方向和大部分的开发工作。AOSP会定期为Android加入最新的安全补丁，谷歌每年也会在其I/O开发者大会上公布操作系统的新功能。除了开放贡献代码外，AOSP还可以在开源许可下自由使用和修改。<br> 比如，小米，华为等厂商根据自己的目的自由调整该项目，并开发了自己的衍生产品，包括多用途的emui和miui。需要注意的是，AOSP包含了开发者构建Android所需的一切，但它并不包括成品智能手机所需的一切。<br> 谷歌和AOSP无法为所有硬件配置提供内核设备驱动。所谓设备驱动，是指手机硬件所需的固件，比如处理器或摄像头。手机和SoC制造商，如高通和三星，必须将这些驱动程序纳入他们的Android构建中。<br> 这也是为什么从AOSP到实际设备的系统更新需要一定时间的原因。其次AOSP也不包含谷歌的软件应用套件，如Chrome浏览器、YouTube，甚至谷歌Play商店。<br> 它也不包括谷歌的一些底层技术和API，而这些技术和API可以实现移动支付、语音命令和云存储等功能，这些都是作为谷歌移动服务（GMS）单独授权的。 任何厂商想要在系统中安装GMS，都必须为自己的设备获得GMS授权和移动应用分发协议（MADA），然后通过多项兼容性测试。有Android兼容性测试套件（CTS）来验证软件和硬件以及API。<br> 正因为AOSP开源的特性，许多的硬件厂商的驱动代码并不是开源的，所以AOSP会有一个硬件抽象层 (HAL)，来保证驱动程序代码不被泄露。大多数手机厂商都是从高通等芯片厂商那里获得AOSP版本，该AOSP版本为硬件量身定坐了高通驱动程序，所以刷入真机是可以正常的运行。</p>
<h2 id="如何添加硬件驱动"><a href="#如何添加硬件驱动" class="headerlink" title="如何添加硬件驱动"></a>如何添加硬件驱动</h2><p>在上面步骤中我们编译好了AOSP可以直接通过模拟器运行.编译aosp时也会生成system.img文件，这个文件是最终刷机用的，但是system.img文件必须依赖驱动文件生成，<br> 如果没有放入对应的驱动就编译，那么生成的镜像也是无法正常刷机的。通过上文我们知道aosp 仅是一套源码，真机运行需要厂商的驱动，厂商的驱动是不包含在AOSP中的，<br> 第三方ROM(如CM等)的厂家驱动是自行提取的。但是google也开源了nexus和pixel对应的AOSP版本的硬件驱动代码.如果我们有nexus或者是pixel设备就可以下载相应的驱动进行编译，<br> 然后将编译好的系统输入到设备中去.</p>
<h3 id="下载对应的驱动"><a href="#下载对应的驱动" class="headerlink" title="下载对应的驱动"></a>下载对应的驱动</h3><p>需要根据你选择的<a href="https://links.jianshu.com/go?to=https://source.android.com/source/build-numbers.html">版本</a><br> 去<a href="https://links.jianshu.com/go?to=https://developers.google.com/android/nexus/drivers%23shamulrx21o">驱动页面</a>下载合适的驱动。</p>
<h3 id="生成驱动"><a href="#生成驱动" class="headerlink" title="生成驱动"></a>生成驱动</h3><p>将驱动文件下载后，解压到AOSP根目录，得到几个.sh文件，执行后，会在AOSP下创建vendor目录，里面包含了驱动。</p>
<h3 id="编译带有驱动的AOSP"><a href="#编译带有驱动的AOSP" class="headerlink" title="编译带有驱动的AOSP"></a>编译带有驱动的AOSP</h3><p>再次<code>make -j4</code>，此次编译的结果就包含了驱动，编译出新的系统.</p>
<h1 id="ROM编译及烧录"><a href="#ROM编译及烧录" class="headerlink" title="ROM编译及烧录"></a>ROM编译及烧录</h1><p>一般定制ROM其实就是对手机内存里的system/app文件夹的内容进行自定义，系统所有的程序都在这个文件夹里，比如浏览器、拨号器、联系人等。自己安装的软件\data\文件夹中。</p>
<h2 id="真机驱动下载"><a href="#真机驱动下载" class="headerlink" title="真机驱动下载"></a>真机驱动下载</h2><p>在上文中可以了解到厂商的驱动是不包含在AOSP中的.因此编译出来的AOSP系统源码要在真机上运行，还需要加上厂商驱动进行编译才能烧录到真机上使用.<br> Google提供了Nexus和Pixel这两个太子机的驱动，我们可以在驱动页面下载合适的驱动。<br> <a href="https://links.jianshu.com/go?to=https://developers.google.com/android/drivers%23walleye">Driver Binaries for Nexus and Pixel Devices</a></p>
<h2 id="配置真机驱动到AOSP"><a href="#配置真机驱动到AOSP" class="headerlink" title="配置真机驱动到AOSP"></a>配置真机驱动到AOSP</h2><ol>
<li>在上面链接里面,两个文件都进行下载，一个是google vendor，一个qcom。</li>
<li>解压得到<code>extract-google_devices-blueline.sh</code>，<code>extract-qcom-blueline.sh</code></li>
<li>将这两个脚本放到aosp代码目录下，进行提取<br> <code>sh extract-google_devices-blueline.sh</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vendor/</span><br><span class="line">vendor/google_devices/</span><br><span class="line">vendor/google_devices/marlin/</span><br><span class="line">vendor/google_devices/marlin/device-vendor-marlin.mk</span><br><span class="line">vendor/google_devices/marlin/android-info.txt</span><br><span class="line">vendor/google_devices/marlin/BoardConfigVendor.mk</span><br><span class="line">vendor/google_devices/marlin/BoardConfigPartial.mk</span><br><span class="line">vendor/google_devices/marlin/proprietary/</span><br><span class="line">vendor/google_devices/marlin/proprietary/vendor.img</span><br><span class="line">vendor/google_devices/marlin/device-partial.mk</span><br><span class="line"></span><br><span class="line">Files extracted successfully.</span><br></pre></td></tr></table></figure>

<p>第2个 高通驱动<br> <code>sh extract-qcom-blueline.sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vendor/</span><br><span class="line">vendor/qcom/</span><br><span class="line">vendor/qcom/marlin/</span><br><span class="line">vendor/qcom/marlin/BoardConfigPartial.mk</span><br><span class="line">vendor/qcom/marlin/proprietary/</span><br><span class="line">vendor/qcom/marlin/proprietary/lib64/</span><br><span class="line">vendor/qcom/marlin/proprietary/lib64/libbcc.so</span><br><span class="line">vendor/qcom/marlin/proprietary/lib64/libLLVM_android.so</span><br><span class="line">vendor/qcom/marlin/proprietary/lib64/libiperf.so</span><br><span class="line">vendor/qcom/marlin/proprietary/lib64/libminui.so</span><br><span class="line">vendor/qcom/marlin/proprietary/ATT_profiles.xml</span><br><span class="line">vendor/qcom/marlin/proprietary/pktlogconf</span><br><span class="line">vendor/qcom/marlin/proprietary/VZW_profiles.xml</span><br><span class="line">vendor/qcom/marlin/proprietary/ROW_profiles.xml</span><br><span class="line">vendor/qcom/marlin/proprietary/libclcore_neon.bc</span><br><span class="line">vendor/qcom/marlin/proprietary/sanitizer-status</span><br><span class="line">vendor/qcom/marlin/proprietary/libiperf.so</span><br><span class="line">vendor/qcom/marlin/proprietary/qcrilhook.jar</span><br><span class="line">vendor/qcom/marlin/proprietary/libminui.so</span><br><span class="line">vendor/qcom/marlin/proprietary/libion.so</span><br><span class="line">vendor/qcom/marlin/proprietary/iperf3</span><br><span class="line">vendor/qcom/marlin/device-partial.mk</span><br><span class="line">vendor/google_devices/</span><br><span class="line">vendor/google_devices/marlin/</span><br><span class="line">vendor/google_devices/marlin/device-vendor-marlin.mk</span><br><span class="line">vendor/google_devices/marlin/android-info.txt</span><br><span class="line">vendor/google_devices/marlin/BoardConfigVendor.mk</span><br><span class="line"></span><br><span class="line">Files extracted successfully.</span><br></pre></td></tr></table></figure>

<p>执行后，会在AOSP下创建vendor目录，里面包含了驱动。编译完成后，执行<code>make fastboot adb</code>单独编译fastboot和adb。</p>
<h2 id="编译Rom"><a href="#编译Rom" class="headerlink" title="编译Rom"></a>编译Rom</h2><p>重新对AOSP进行编译.此次编译的结果就包含了驱动，编译完成后，执行make fastboot adb 单独编译fastboot和adb。</p>
<h2 id="烧录Rom到手机"><a href="#烧录Rom到手机" class="headerlink" title="烧录Rom到手机"></a>烧录Rom到手机</h2><ol>
<li>手机启用开发者模式，打开 USB 调试 adb shell 能进入。</li>
<li>开机键 + 音量- 进入 bootloader 模式。</li>
<li>电脑上能识别出来手机并装上了驱动。</li>
<li>fastboot devices 能看到设备。</li>
<li>再次执行./fastboot -w flashall将开始刷机，刷完会自动重启，over!</li>
</ol>
<p>参考资料:<br> <a href="https://links.jianshu.com/go?to=https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">Android 镜像使用帮助</a><br> <a href="https://links.jianshu.com/go?to=https://www.xiaomi.cn/post/10984220">MIUI ROM适配之旅第一天——认识Android手机</a><br> <a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/liumce/p/8027559.html">Android FrameWork 学习之Android 系统源码调试</a><br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/luoshengyang/article/details/29688041">从CM刷机过程和原理分析Android系统结构</a><br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/weixin_30924087/article/details/98030409">Android ROM移植</a><br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/innost/article/details/7623951">android rom移植知识普及</a><br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/huil0925/category_6259725_2.html">Android系统源码修改</a><br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/uglychild/article/details/79550793">android系统的分区结构</a><br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/u010142437/article/details/72834972">Android ROM的制作与烧录</a><br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/zhonglunshun/article/details/70256727">android系统源码中添加app源码（源码部署移植）</a></p>
<p>参考资料:<br> <a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/caoxinyu/p/10568480.html">Ubentu编译Android源码（AOSP）</a><br> <a href="https://links.jianshu.com/go?to=http://mouxuejie.com/blog/2019-11-17/aosp-setup/">AOSP源码下载/编译/刷机/调试</a><br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/zy199701/article/details/106478670/">Android rom移植一</a><br> <a href="https://links.jianshu.com/go?to=http://blog.sina.com.cn/s/blog_b278ce3b010186bw.html">目前通用的Android拼包移植方法均是正向移植</a><br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/u010783226/article/details/94406309">Android驱动开发全过程</a></p>
]]></content>
      <categories>
        <category>Android系统开发</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android应用架构设计</title>
    <url>/2018/10/18/android_app_arch_design/</url>
    <content><![CDATA[<p>MVC，MVP和MVVM是软件比较常用的三种软件架构，这三种架构的目的都是分离，避免将过多的逻辑全部堆积在一个类中。<br>在Android中，Activity中既有UI的相关处理逻辑，又有数据获取逻辑，从而导致Activity逻辑复杂不单一难以维护。<br>为了一个应用可以更好的维护和扩展，我们需要很好的区分相关层级，要不然以后将数据获取方式从数据库变为网络获取时，我们需要去修改整个Activity。架构使得View和数据相互独立，我们把应用分成三个不同层级，这样我们就能够单独测试相关层级，使用架构能够把大多数逻辑从Activity中移除，方便进行单元测试。</p>
<span id="more"></span>

<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>MVC是模型(Model)－视图(View)－控制器(Controller)的缩写，用一种业务逻辑、数据、界面显示分离的方法组织代码。其实Android Studio创建一个项目的模式就是一个简化的mvc模式。</p>
<h2 id="Android中的MVC含义"><a href="#Android中的MVC含义" class="headerlink" title="Android中的MVC含义"></a>Android中的MVC含义</h2><ul>
<li><strong>Model</strong>：实体类(数据的获取、存储、数据状态变化)。</li>
<li><strong>View</strong>：布局文件</li>
<li><strong>Controller</strong>：Activity(处理数据、业务和UI)。</li>
</ul>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/images/android_app_arch_design01.png" alt="img"></p>
<ul>
<li>1.View接受用户的交互请求。</li>
<li>2.View将请求转交给Controller。</li>
<li>3.Controller操作Model进行数据更新。</li>
<li>4.数据更新之后，Model通知View数据变化。</li>
<li>5.View显示更新之后的数据。</li>
</ul>
<h2 id="MVC的缺点"><a href="#MVC的缺点" class="headerlink" title="MVC的缺点"></a>MVC的缺点</h2><p>随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。</p>
<p>为了解决MVC的缺点，MVP 框架被提出来。</p>
<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>MVP是MVC架构的一个演化版，全称是Model-View-Presenter。将MVC中的V和C结合生成MVP中的V，引入新的伙伴Presenter。</p>
<h2 id="Android中的MVP含义"><a href="#Android中的MVP含义" class="headerlink" title="Android中的MVP含义"></a>Android中的MVP含义</h2><ul>
<li><strong>Model</strong>：实体类(数据的获取、存储、数据状态变化)。</li>
<li><strong>View</strong>：布局文件+Activity。</li>
<li><strong>Presenter</strong>：中介，负责完成View与Model间的交互和业务逻辑。</li>
</ul>
<h2 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/images/android_app_arch_design02.png" alt="img"></p>
<ul>
<li><p>1.View 接收用户交互请求</p>
</li>
<li><p>2.View 将请求转交给 Presenter(V调用P接口)</p>
</li>
<li><p>3.Presenter 操作Model进行数据更新(P调用M接口)</p>
</li>
<li><p>4.Model 通知Presenter数据发生变化(M调用P接口)</p>
</li>
<li><p>5.Presenter 更新View数据(P执行接口,V相应回调)</p>
</li>
</ul>
<h2 id="MVP的优点"><a href="#MVP的优点" class="headerlink" title="MVP的优点"></a>MVP的优点</h2><ul>
<li><p>1.复杂的逻辑处理放在Presenter进行处理，减少了Activity的臃肿。</p>
</li>
<li><p>2.解耦。Model层与View层完全分离，修改V层不会影响M层，降低了耦合性。</p>
</li>
<li><p>3.可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。</p>
</li>
<li><p>4.Presenter层与View层的交互是通过接口来进行的，便于单元测试。</p>
</li>
</ul>
<h2 id="MVP的缺点"><a href="#MVP的缺点" class="headerlink" title="MVP的缺点"></a>MVP的缺点</h2><p>维护困难。Presenter中除了业务逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。</p>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>是 Model-View-ViewModel 的简写。MVVM与MVP的结构还是很相似的，就是将Presenter升级为ViewModel。在MVVM中，View层和Model层进行了双向绑定(即Data Binding)，所以Model数据的更改会表现在View上，反之亦然。ViewModel就是用来根据具体情况处理View或Model的变化。</p>
<h2 id="Android中的MVVM含义"><a href="#Android中的MVVM含义" class="headerlink" title="Android中的MVVM含义"></a>Android中的MVVM含义</h2><ul>
<li><strong>Model</strong>：实体类(数据的获取、存储、数据状态变化)。</li>
<li><strong>View</strong>：布局文件+Activity。</li>
<li><strong>ViewModel</strong>： 关联层，将Model和View进行绑定，Model或View更改时，实时刷新对方。</li>
</ul>
<h2 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/images/android_app_arch_design03.png" alt="img"></p>
<ul>
<li>1.View 接收用户交互请求</li>
<li>2.View 将请求转交给ViewModel</li>
<li>3.ViewModel 操作Model数据更新</li>
<li>4.Model 更新完数据，通知ViewModel数据发生变化</li>
<li>5.ViewModel 更新View数据</li>
</ul>
<p><strong>View/Model的变动，只要改其中一方，另一方都能够及时更新到</strong></p>
<h2 id="MVVM的优点"><a href="#MVVM的优点" class="headerlink" title="MVVM的优点"></a>MVVM的优点</h2><ul>
<li><p>1.提高可维护性。Data Binding可以实现双向的交互，使得视图和控制层之间的耦合程度进一步降低，分离更为彻底，同时减轻了Activity的压力。</p>
</li>
<li><p>2.简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。</p>
</li>
<li><p>3.ViewModle易于单元测试。</p>
</li>
</ul>
<h2 id="MVVM的缺点"><a href="#MVVM的缺点" class="headerlink" title="MVVM的缺点"></a>MVVM的缺点</h2><ul>
<li>1.对于简单的项目，使用MVVM有点大材小用。</li>
<li>2.对于过大的项目，数据绑定会导致内存开销大，影响性能。</li>
<li>3.ViewModel和View的绑定，使页面异常追踪变得不方便。有可能是View出错，也有可能是ViewModel的业务逻辑有问题，也有可能是Model的数据出错。</li>
</ul>
<h1 id="MVP和MVC的最大区别"><a href="#MVP和MVC的最大区别" class="headerlink" title="MVP和MVC的最大区别"></a>MVP和MVC的最大区别</h1><p>在MVP中View并不直接使用Model，它们之间的通信是通过Presenter 来进行的，所有的交互都发生在Presenter内部，而在MVC中View直接从Model中读取数据而不是通过 Controller。</p>
<h1 id="Google推荐的应用架构"><a href="#Google推荐的应用架构" class="headerlink" title="Google推荐的应用架构"></a>Google推荐的应用架构</h1><p><a href="https://developer.android.com/topic/architecture">https://developer.android.com/topic/architecture</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>应用架构</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP-系统服务生命周期</title>
    <url>/2021/03/10/android_aosp_system_service_lifecycle/</url>
    <content><![CDATA[<p>我们知道像系统中的AMS，WMS，PKMS等这些系统服务均是通过<code>ServiceManager.addService(&quot;xxx&quot;, new XXManagerService())</code>将自己的Binder Stub注册进入SM才能够让其他进程利用Binder与之通信。</p>
<span id="more"></span>

<p>如果自定义系统服务如果需要根据系统启动的不同阶段进行不同的处理则需要注册生命周期回调，需要通过<br><code>mSystemServiceManager.startService</code> 来完成生命周期的注册。下面就以AMS的启动进行浅析。</p>
<h1 id="SystemServer中的启动入口"><a href="#SystemServer中的启动入口" class="headerlink" title="SystemServer中的启动入口"></a>SystemServer中的启动入口</h1><p>见<code>/frameworks/base/services/java/com/android/server/SystemServer</code>中的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    t.traceBegin(<span class="string">&quot;startBootstrapServices&quot;</span>);</span><br><span class="line">	<span class="comment">// Activity manager runs the show.</span></span><br><span class="line">    t.traceBegin(<span class="string">&quot;StartActivityManager&quot;</span>);</span><br><span class="line">    <span class="comment">//,,,,,,</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Might need to move after migration to WM.</span></span><br><span class="line">    ActivityTaskManagerService atm = mSystemServiceManager.startService(</span><br><span class="line">            ActivityTaskManagerService.Lifecycle.class).getService();</span><br><span class="line">    <span class="comment">//注册生命周期</span></span><br><span class="line">    mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">            mSystemServiceManager, atm);</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line">    mWindowManagerGlobalLock = atm.getGlobalLock();</span><br><span class="line">    t.traceEnd();</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// Set up the Application instance for the system process and get started.</span></span><br><span class="line">    t.traceBegin(<span class="string">&quot;SetSystemProcess&quot;</span>);</span><br><span class="line">    <span class="comment">//注册AMS服务</span></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line">    t.traceEnd();</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    t.traceEnd(); <span class="comment">// startBootstrapServices</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实<code>mActivityManagerService.setSystemProcess()</code>就是我们所熟知的注册Binder的实现了，看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="comment">/* allowIsolated= */</span> <span class="keyword">true</span>,</span><br><span class="line">                DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;meminfo&quot;</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>), <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">                DUMP_FLAG_PRIORITY_HIGH);</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;gfxinfo&quot;</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;dbinfo&quot;</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line">        mAppProfiler.setCpuInfoService();</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;permission&quot;</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;processinfo&quot;</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;cacheinfo&quot;</span>, <span class="keyword">new</span> CacheBinder(<span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">&quot;Unable to find android system package&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="服务生命周期监听"><a href="#服务生命周期监听" class="headerlink" title="服务生命周期监听"></a>服务生命周期监听</h1><p>上文中我们看到在setSystemProcess前有一行为：</p>
<p><code>mActivityManagerService = ActivityManagerService.Lifecycle.startService(mSystemServiceManager, atm);</code></p>
<p>这就是接下来要说的为服务注册的生命周期监听。</p>
<p><code>ActivityManagerService.Lifecycle</code>就相当于生命周期的回调接口对象，它继承自</p>
<p><code>/frameworks/base/services/core/java/com/android/server/SystemService</code></p>
<p>SystemService中主要需要实现两个方法：</p>
<ul>
<li><p><strong>onStart()</strong> ：mSystemServiceManager.startService第一时间回调该函数。</p>
</li>
<li><p><strong>onBootPhase(int phase)</strong> ： 系统启动的各个阶段会回调该函数</p>
<ul>
<li><p><code>SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY</code></p>
<p>这是一个依赖项，只有DisplayManagerService中进行了对应处理；</p>
</li>
<li><p><code>SystemService.PHASE_LOCK_SETTINGS_READY</code></p>
<p>经过这个引导阶段后，服务才可以接收到wakelock相关设置数据；</p>
</li>
<li><p><code>SystemService.PHASE_SYSTEM_SERVICES_READY</code></p>
<p>经过这个引导阶段 后，服务才可以安全地使用核心系统服务</p>
</li>
<li><p><code>SystemService.PHASE_ACTIVITY_MANAGER_READY</code></p>
<p>经过这个引导阶 段后，服务可以发送广播</p>
</li>
<li><p><code>SystemService.PHASE_THIRD_PARTY_APPS_CAN_START</code></p>
<p>经过这个引导阶段后，服务可以启动第三方应用，第三方应用也可以通过Binder来调用服务。</p>
</li>
<li><p><code>SystemService.PHASE_BOOT_COMPLETED</code></p>
<p>经过这个引导阶段后，说明服务启动完成，这时用户就可以和设备进行交互。</p>
</li>
</ul>
</li>
</ul>
<p>我们看下AMS中的Lifecycle实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActivityManagerService mService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ActivityTaskManagerService sAtm;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lifecycle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mService = <span class="keyword">new</span> ActivityManagerService(context, sAtm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityManagerService <span class="title">startService</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            SystemServiceManager ssm, ActivityTaskManagerService atm)</span> </span>&#123;</span><br><span class="line">        sAtm = atm;</span><br><span class="line">        <span class="keyword">return</span> ssm.startService(ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mService.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBootPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">        mService.mBootPhase = phase;</span><br><span class="line">        <span class="keyword">if</span> (phase == PHASE_SYSTEM_SERVICES_READY) &#123;</span><br><span class="line">            mService.mBatteryStatsService.systemServicesReady();</span><br><span class="line">            mService.mServices.systemServicesReady();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase == PHASE_ACTIVITY_MANAGER_READY) &#123;</span><br><span class="line">            mService.startBroadcastObservers();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123;</span><br><span class="line">            mService.mPackageWatchdog.onPackagesReady();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserStopped</span><span class="params">(<span class="meta">@NonNull</span> TargetUser user)</span> </span>&#123;</span><br><span class="line">        mService.mBatteryStatsService.onCleanupUser(user.getUserIdentifier());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActivityManagerService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如在AMS中在 <code>PHASE_ACTIVITY_MANAGER_READY</code> 为广播做准备工作 ，经过这个阶段后，也就是需要在下一个阶段 <code>PHASE_THIRD_PARTY_APPS_CAN_START</code> 才可以发送广播。</p>
]]></content>
      <categories>
        <category>Android系统开发</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android图形系统-Choreographer</title>
    <url>/2019/10/09/android_choreographer/</url>
    <content><![CDATA[<p>在Android4.1之后增加了Choreographer机制，用于同Vsync机制配合，统一动画、输入和绘制时机。</p>
<span id="more"></span>

<h1 id="从绘制流程开始"><a href="#从绘制流程开始" class="headerlink" title="从绘制流程开始"></a>从绘制流程开始</h1><p>ViewRootImpl的requestLayout开启绘制流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();<span class="comment">//检查是否在当前线程</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;<span class="comment">//mLayoutRequested 是否measure和layout布局。</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;<span class="comment">//同一帧内不会多次调用遍历</span></span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();<span class="comment">//拦截同步Message</span></span><br><span class="line">        <span class="comment">//Choreographer回调，执行绘制操作</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要关注两点：</p>
<p><code>postSyncBarrier</code> : Handler 的同步屏障。它的作用是可以拦截 Looper 对同步消息的获取和分发，加入同步屏障之后，Looper 只会获取和处理异步消息，如果没有异步消息那么就会进入阻塞状态。也就是说，对View绘制渲染的处理操作可以优先处理（设置为异步消息）。</p>
<p><code>Choreographer</code>: 编舞者。统一动画、输入和绘制时机。也是这章需要重点分析的内容。</p>
<h1 id="Choreographer启动"><a href="#Choreographer启动" class="headerlink" title="Choreographer启动"></a>Choreographer启动</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取Choreographer实例</span></span><br><span class="line">    mChoreographer = Choreographer.getInstance();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>frameworks\base\core\java\android\view\Choreographer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Choreographer <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The current thread must have a looper!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Choreographer(looper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每一个Looper线程都有自己的Choreographer，其他线程发送的回调只能运行在对应Choreographer所属的Looper线程上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">   mLooper = looper;</span><br><span class="line">   mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">   <span class="comment">// 根据是否使用了VSYNC来创建一个FrameDisplayEventReceiver对象</span></span><br><span class="line">   mDisplayEventReceiver = USE_VSYNC ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper) : <span class="keyword">null</span>;</span><br><span class="line">   mLastFrameTimeNanos = Long.MIN_VALUE;<span class="comment">//是指上一次帧绘制时间点</span></span><br><span class="line">   mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());<span class="comment">//帧间时长，一般等于16.7ms</span></span><br><span class="line">   <span class="comment">// CALLBACK_LAST + 1 = 4，创建一个容量为4的CallbackQueue数组，用来存放4种不同的Callback</span></span><br><span class="line">   mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">       mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Choreographer类中有一个Looper和一个FrameHandler变量。变量USE_VSYNC用于表示系统是否是用了Vsync同步机制，该值是通过读取系统属性debug.choreographer.vsync来获取的。如果系统使用了Vsync同步机制，则创建一个FrameDisplayEventReceiver对象用于请求并接收Vsync事件，最后Choreographer创建了一个大小为3的CallbackQueue队列数组，用于保存不同类型的Callback。</p>
<p>这里，不同类型的Callback包括如下4种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_INPUT = <span class="number">0</span>; <span class="comment">//输入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_ANIMATION = <span class="number">1</span>; <span class="comment">//动画</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_TRAVERSAL = <span class="number">2</span>; <span class="comment">//视图绘制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_COMMIT = <span class="number">3</span>; <span class="comment">//提交 （ 这一类型是在API level=23的时候添加的）</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/android_choreographer01.png" alt="img"></p>
<p>CallbackQueue是一个容量为4的数组，每一个元素作为头指针，引出对应类型的链表，4种事件就是通过这4个链表来维护的。</p>
<p>而FrameHandler中主要处理三类消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(looper);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">           <span class="keyword">case</span> MSG_DO_FRAME:</span><br><span class="line">               doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">               doScheduleVsync();   <span class="comment">// 请求VSYNC信号</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">               doScheduleCallback(msg.arg1);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Choreographer执行流程"><a href="#Choreographer执行流程" class="headerlink" title="Choreographer执行流程"></a>Choreographer执行流程</h1><p><img src="/images/android_choreographer02.png" alt="android_choreographer"></p>
<p>Choreographer提供了两类添加回调的方式：postCallback 与 postFrameCallback，当然对应类型也包含delay的方法，算上其实有4个方法。</p>
<p>postCallback对应的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="params"><span class="function">        Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;action must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (callbackType &lt; <span class="number">0</span> || callbackType &gt; CALLBACK_LAST) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;callbackType is invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postFrameCallback对应的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postFrameCallbackDelayed</span><span class="params">(FrameCallback callback, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;callback must not be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    postCallbackDelayedInternal(CALLBACK_ANIMATION,</span><br><span class="line">            callback, FRAME_CALLBACK_TOKEN, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比之下postCallback更灵活一点。两者最终都会调到：postCallbackDelayedInternal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="params"><span class="function">       Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">       <span class="comment">// 当前时间</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">       <span class="comment">// 回调执行时间，为当前时间加上延迟的时间</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">       <span class="comment">// obtainCallbackLocked(long dueTime, Object action, Object token)会将传入的3个参数转换为CallbackRecord(具体请看源码，非主要部分，此处略过)，然后CallbackQueue根据回调类型将CallbackRecord添加到链表上。</span></span><br><span class="line">       mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line">       <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">           <span class="comment">// 如果delayMillis=0的话，dueTime=now，则会马上执行</span></span><br><span class="line">           scheduleFrameLocked(now);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果dueTime&gt;now，则发送一个what为MSG_DO_SCHEDULE_CALLBACK类型的定时消息，等时间到了再处理，其最终处理也是执行scheduleFrameLocked(long now)方法</span></span><br><span class="line">           Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">           msg.arg1 = callbackType;</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mCallbackQueues先把对应的callback添加到链表上来，然后判断是否有延迟，如果没有则会马上执行scheduleFrameLocked，如果有，则发送一个what为MSG_DO_SCHEDULE_CALLBACK类型的定时消息，等时间到了再处理，其最终处理也是执行scheduleFrameLocked(long now)方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">       mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">           <span class="comment">// 如果使用了VSYNC，由系统值确定</span></span><br><span class="line">           <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">               Log.d(TAG, <span class="string">&quot;Scheduling next frame on vsync.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">               <span class="comment">// 请求VSYNC信号，最终会调到Native层，Native处理完成后触发FrameDisplayEventReceiver的onVsync回调，回调中最后也会调用doFrame(long frameTimeNanos, int frame)方法</span></span><br><span class="line">               scheduleVsyncLocked();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 在UI线程上直接发送一个what=MSG_DO_SCHEDULE_VSYNC的消息，最终也会调到scheduleVsyncLocked()去请求VSYNC信号</span></span><br><span class="line">               Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">               msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">               mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 没有使用VSYNC</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                   mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">           <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">               Log.d(TAG, <span class="string">&quot;Scheduling next frame in &quot;</span> + (nextFrameTime - now) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 直接发送一个what=MSG_DO_FRAME的消息，消息处理时调用doFrame(long frameTimeNanos, int frame)方法</span></span><br><span class="line">           Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">           mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先判断USE_VSYNC，如果使用了VSYNC:走scheduleVsyncLocked，即请求VSYNC信号，最终调用doFrame，如果没使用VSYNC，则通过消息执行doFrame。</p>
<p>那么我们先简单了解下请求VSYNC信号的流程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDisplayEventReceiver.<span class="built_in">scheduleVsync</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.<span class="built_in">w</span>(TAG, <span class="string">&quot;Attempted to schedule a vertical sync pulse but the display event &quot;</span></span><br><span class="line">                + <span class="string">&quot;receiver has already been disposed.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">nativeScheduleVsync</span>(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mDisplayEventReceiver 对应的是FrameDisplayEventReceiver，它继承自 DisplayEventReceiver ， 主要是用来接收同步脉冲信号 VSYNC。scheduleVsync()方法通过底层nativeScheduleVsync()向SurfaceFlinger 服务注册，即在下一次脉冲接收后会调用 DisplayEventReceiver的dispatchVsync()方法。这里类似于订阅者模式，但是每次调用nativeScheduleVsync()方法都有且只有一次dispatchVsync()方法回调。</p>
<p>然后再看看接收VSYNC信号：</p>
<p><img src="/images/android_choreographer03.png" alt="img"></p>
<p>底层向应用层发送VSYNC信号，java层通过dispatchVsync()接收，最后回调在FrameDisplayEventReceiver的onVsync</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHavePendingVsync;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mTimestampNanos;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFrame;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//忽略来自第二显示屏的Vsync</span></span><br><span class="line">        <span class="keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">            scheduleVsync();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        mTimestampNanos = timestampNanos;</span><br><span class="line">        mFrame = frame;</span><br><span class="line">        <span class="comment">//该消息的callback为当前对象FrameDisplayEventReceiver</span></span><br><span class="line">        Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//此处mHandler为FrameHandler</span></span><br><span class="line">        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">        doFrame(mTimestampNanos, mFrame); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见onVsync()过程是通过FrameHandler向主线程Looper发送了一个自带callback的消息 callback为FrameDisplayEventReceiver。 当主线程Looper执行到该消息时，则调用FrameDisplayEventReceiver.run()方法，紧接着便是调用doFrame。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// mFrameScheduled=false，则直接返回。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos; <span class="comment">//原本计划的绘帧时间点</span></span><br><span class="line">        startNanos = System.nanoTime();<span class="comment">//保存起始时间</span></span><br><span class="line">        <span class="comment">//由于Vsync事件处理采用的是异步方式，因此这里计算消息发送与函数调用开始之间所花费的时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="comment">//如果线程处理该消息的时间超过了屏幕刷新周期</span></span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="comment">//计算函数调用期间所错过的帧数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="comment">//当掉帧个数超过30，则输出相应log</span></span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;Skipped &quot;</span> + skippedFrames + <span class="string">&quot; frames! &quot;</span></span><br><span class="line">                        + <span class="string">&quot;The application may be doing too much work on its main thread.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            frameTimeNanos = startNanos - lastFrameOffset; <span class="comment">//对齐帧的时间间隔</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//如果frameTimeNanos小于一个屏幕刷新周期，则重新请求VSync信号</span></span><br><span class="line">        <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">        mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">&quot;Choreographer#doFrame&quot;</span>);</span><br><span class="line">        <span class="comment">//分别回调CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL事件</span></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line">        mFrameInfo.markAnimationsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">        mFrameInfo.markPerformTraversalsStart();</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Vsync事件到来时，顺序执行4种事件对应CallbackQueue队列中注册的回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">//从指定类型的CallbackQueue队列中查找执行时间到的CallbackRecord</span></span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now);</span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallbacksRunning = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//由于CallbackQueues是按时间先后顺序排序的，因此遍历执行所有时间到的CallbackRecord</span></span><br><span class="line">        <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</span><br><span class="line">            c.run(frameTimeNanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mCallbacksRunning = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> CallbackRecord next = callbacks.next;</span><br><span class="line">                recycleCallbackLocked(callbacks);</span><br><span class="line">                callbacks = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (callbacks != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按时间顺序先后执行CallbackRecord对应的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</span><br><span class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接开篇讲的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">        Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mTraversalRunnable对应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       doTraversal();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run方法被执行，所以doTraversal()被执行，开启View的绘制流程。</p>
<p>所以整个绘制过程总的流程如下所示：</p>
<p><img src="/images/android_choreographer04.png" alt="img"></p>
<p>简单总结：</p>
<ul>
<li>Choreographer支持4种类型事件：输入、绘制、动画、提交，并通过postCallback在对应需要同步vsync进行刷新处进行注册，等待回调。</li>
<li>Choreographer监听底层Vsync信号，一旦接收到回调信号，则通过doFrame统一对java层4种类型事件进行回调。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>图形系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化-App卡顿监控技术方案及原理</title>
    <url>/2019/12/12/android_block_monitor/</url>
    <content><![CDATA[<p>APP经过长期迭代后随着业务的臃肿就会逐渐呈现出某些点位上有阻塞卡顿的地方，这就需要我们要采取一些行之有效的方案去监控发现，并尽早介入解决。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>目前业界主流的几种有效的监控方式如下：</p>
<ul>
<li>子线程不断轮询主线程。</li>
<li>通过Looper Printer计算打印日志的时间差</li>
<li>Choreographer FrameCallback</li>
<li>插桩的方式对函数的出入口进行记录</li>
</ul>
<h1 id="子线程不断轮询主线程"><a href="#子线程不断轮询主线程" class="headerlink" title="子线程不断轮询主线程"></a>子线程不断轮询主线程</h1><p>我们可以开一个子线程不断去轮询主线程，原理和实现方法也很简单：就是不断向主线程发送Message，每隔一段时间检查一次刚刚发送的消息是否被处理，如果没被处理，说明这段时间主线程被卡住了。</p>
<p>这种方式<strong>优点</strong>就是：实现简单，能够监控各种类型的卡顿，<strong>缺点</strong>就是：使用轮询方式，不够优雅，而且轮询时间长短不好确定，时间间隔越短，对性能影响越大，反之，容易漏报。</p>
<p><img src="/images/android_block_monitor01.png" alt="img"></p>
<p>原因：如我的轮询间隔设了3s，在1.5s~4.5s发生了卡顿，我是监测不到的，因为0～3s 和 3s ~ 6s 都有不卡顿的地方，发送的Message 都能被处理掉, 所以当我设置卡顿阈值为 3s 时, 这个卡顿就被漏报了。没什么特别好办法，只能调整时间阈值与漏报率达到一个平衡。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UiMonitorThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">            <span class="comment">// 每隔 1.5s 往主线程发一次消息</span></span><br><span class="line">            uiMonitorHandler.sendEmptyMessage(id);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果连续两次消息都没被处理掉，则认为发生了卡顿</span></span><br><span class="line">            checkMessageHandled();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="通过Looper-Printer计算打印日志的时间差"><a href="#通过Looper-Printer计算打印日志的时间差" class="headerlink" title="通过Looper Printer计算打印日志的时间差"></a>通过Looper Printer计算打印日志的时间差</h1><p>我们可以使用系统方法 setMessageLogging 替换掉主线程 Looper 的 Printer 对象，通过计算 Printer 打印日志的时间差，来拿到系统 dispatchMessage 方法的执行时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.getMainLooper().setMessageLogging(str -&gt; &#123;</span><br><span class="line">    <span class="comment">// 计算相邻两次日志时间间隔</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种方式的<strong>优点</strong>就是：实现简单，不会漏报，<strong>缺点</strong>就是，一些类型的卡顿无法被监控到。</p>
<p>系统Looper.loop方法源码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loopOnce</span><span class="params">(<span class="keyword">final</span> Looper me,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">final</span> <span class="keyword">long</span> ident, <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride)</span> </span>&#123;</span><br><span class="line">    Message msg = me.mQueue.next(); <span class="comment">// might block</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">    <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span></span><br><span class="line">                        + msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    msg.target.dispatchMessage(msg);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">    <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码可看到，仅监控 dispatchMessage 并不能cover 住所有卡顿，mQueue.next 注释很清楚了，might block。其中包括：nativePollOnce 方法和 idler.queueIdle()方法。其中</p>
<p>MessageQueue.next()方法片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativePollOnce 方法很重要，除了主线程空闲时会阻塞在这里，view 的touch事件也都是在这里被处理的。所以如果应用内包含了很多自定义 view，或处理了很多 onTouch 事件，就很难接受了。</p>
<p>不仅这样，Native Message 也会卡在 nativePollOnce 方法内，所以同样无法监控到。</p>
<p>queueIdle() 方法会在主线程空闲的时候被调用，所以如果我们在这里有耗时操作，也有可能引起卡顿的，而这种卡顿同样无法监控。</p>
<p>另一种引起卡顿的场景：就是常说的同步屏障了（第一次听到这个名字一脸懵逼）。我们 Message 默认都是同步消息，当我们调用 invalidate 来刷新UI 时，最终都会调用到 ViewRootImpl中的scheduleTraversals 方法，会向主线程 Looper postSyncBarrier 插入同步屏障消息，目的是刷新 UI 时，让 Looper 中的同步消息都被跳过，使渲染UI的同步屏障消息得到优先处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        mChoreographer.removeCallbacks(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为啥说同步屏障会引起卡顿了，根据代码可看到，scheduleTraversals 方法和 unscheduleTraversals 是配对的，但都不是线程安全的方法。如果在异步线程 invalidate，导致多次执行 scheduleTraversals 方法，而 unscheduleTraversals 又只能移除最后的 mTraversalBarrier，那就会造成主线程的 Looper 的同步消息一直得不到处理，从而引起卡死。</p>
<p>虽然说了这么多问题，但是呢，作为一个主流的监控方案，一些缺陷已经有了解决方案。</p>
<p><strong>nativePollOnce 的 onTouchEvent监控</strong></p>
<p>我们可以通过ELF Hook, hook 到 libinput.so 的 recvform 和 sendto 方法，用我们自己的方法替换，在这里做监控，当调用 recvform 方法时，说明我们的应用接收到了 onTouch 事件，当被调用 sendto 方法时，说明 onTouch 事件已经被消费。</p>
<p><strong>IdleHandler#queueIdle 监控</strong></p>
<p>看源码可知，ArrayList mIdleHandlers 保存着全部我们所需的 IdleHandler，那么我们完全可以通过反射赋值成我们自己的MyArrayList，并重写 MyArrayList 的 add 方法，是不是就可以监控到每个被添加的 IdleHandler呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 add 方法内拿到被添加的 IdleHandler 后，我们就可以监控 queueIdle 方法执行的时间了，代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> MessageQueue.IdleHandler) &#123;</span><br><span class="line">            <span class="keyword">super</span>.add(<span class="keyword">new</span> MyIdleHandler((MessageQueue.IdleHandler)o));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIdleHandler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageQueue.IdleHandler idleHandler;</span><br><span class="line">    MyIdleHandler(MessageQueue.IdleHandler idleHandler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.idleHandler = idleHandler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 监控 idleHandler.queueIdle() 耗时即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.idleHandler.queueIdle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>同步屏障卡死监控</strong></p>
<p>我们可以定时的通过反射去拿 MessageQueue 的 mMessages，如果发现 mMessages.target=null，并且 mMessages.when 已经很长时间了，就有可能发生同步屏障消息泄漏了，这时我们可以再主动向主线程Looper 发送一个同步消息和一个异步消息，如果同步消息无法执行，但异步消息被处理，这时基本可以确定泄漏了。</p>
<p>我们可以通过反射去 removeSyncBarrier(token)，其中token 为 mMessages.arg1。</p>
<h1 id="Choreographer-FrameCallback"><a href="#Choreographer-FrameCallback" class="headerlink" title="Choreographer FrameCallback"></a>Choreographer FrameCallback</h1><p>Android 从4.1开始加入 Choreographer 用于同 VSync 机制配合，实现统一调度绘制界面。我们可以设置 Choreographer 类的 FrameCallback 函数，当每一帧被渲染时会触发 FrameCallback 回调，FrameCallback 回调 doFrame(long frameTimeNanos) 函数，一次界面渲染会回调 doFrame，如果两次 doFrame 间隔大于16.6ms 则发生了卡顿。而 1s 内有多少次 callback，就代表了实际的帧率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以统计相邻间隔，判断卡顿，也可以统计doFrame 帧率</span></span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种方式<strong>优点</strong>：使用简单，不仅支持卡顿监控，还支持计算帧率。<strong>缺点</strong>就是：需要另开子线程来获取堆栈信息，会消耗部分系统资源。</p>
<h1 id="插桩的方式对函数的出入口进行记录"><a href="#插桩的方式对函数的出入口进行记录" class="headerlink" title="插桩的方式对函数的出入口进行记录"></a>插桩的方式对函数的出入口进行记录</h1><p>在 Android 的编译流程中，在 class 文件编译成 dex 之前，我们可以通过 plugin 提供的 Transform 机制，来对编译好的 class 文件进行二次处理，每个Transform 的输出作为下个 Transform 的输入，从而对字节码进行改造。推荐使用 ASM，具体的插桩方法就不在这里说了，后续有机会介绍。</p>
<p>插桩的目的在于：对函数的出入口进行记录，包括动作、方法名称、时间戳，方便我们统计耗时和还原调用栈，</p>
<p><img src="/images/android_block_monitor02.png" alt="img"></p>
<p>这种方式的<strong>优点</strong>就是：可以溯源，其他方式都需要获取卡顿的堆栈和各种必要信息，这块要做好太不容易了，<strong>缺点</strong>就是：项目的数据量、运算量、IO瓶颈都应该纳入考量之中，当然这里说的都比较空啊，技术调研和实际实现总是有差距的。</p>
<p>在插桩的覆盖面上，我们可以有选择的插，避免大量插桩造成CPU的消耗：</p>
<ol>
<li>可以排除掉不需要的三方库和系统库。</li>
<li>可以过滤掉一些非常简单的函数。</li>
<li>过滤编译器自动生成的代码</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化-Bitmap内存优化</title>
    <url>/2018/10/04/android_bitmap_better_performace/</url>
    <content><![CDATA[<p>Android中的bitmap是比较占用内存的，bitmap的大小直接影响到了应用占用内存的大小。Bitmap内存优化属于性能优化中较为重要的点。如何更好的使用 bitmap,减少其对 App内存的使用，是我们开发中不可回避的问题。<br>为了解决这个问题，就出现了Bitmap 的高效加载策略。其实核心思想很简单。假设通过InmageView 来显示图片，很多时候 ImageVIew并没有原始图片的尺寸那么大，这个时候把整个图片加载进来再设置ImageView,显示是没有必要的，因为ImageView根本没办法显示原始图片。这时候就可以按一定的采样率来将图片缩小后在加载进来，这样图片既能在ImageView显示出来，又能降低内存占用从而在一定程度上避免OOM，提高了Bitmap加载时的性能。</p>
<span id="more"></span>

<h1 id="基础了解"><a href="#基础了解" class="headerlink" title="基础了解"></a>基础了解</h1><p>我们先了解一下，Bitmap到底占用多大的内存。</p>
<p>Bitmap作为位图，需要读入一张图片每一个像素点的数据，其主要占用内存的地方也正是这些像素数据。对于像素数据总大小，我们可以猜想为：像素总数量 x 每个像素的字节大小，而像素总数量在矩形屏幕的表现下，应该是：横向像素数量 x 纵向像素数量，结合得到：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">bitmap内存大小 = bitmap宽度(px) * bitmap长度(px) * 一个像素点占用的字节数</span><br></pre></td></tr></table></figure>

<p>单个像素的字节大小由Bitmap 的一个可配置参数 Config 来决定。</p>
<p>Bitmap 中，存在一个 枚举类 Config,定义了Android 中支持的 Bitmap配置。</p>
<p><img src="/images/android_bitmap_better_performance01.png" alt="image"></p>
<p>而Bitmap默认是使用24位真彩色加载的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Image are loaded with the &#123;<span class="doctag">@link</span> Bitmap.Config#ARGB_8888&#125; config by default.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> Bitmap.Config inPreferredConfig = Bitmap.Config.ARGB_8888;</span><br></pre></td></tr></table></figure>

<h2 id="Bitmap的加载"><a href="#Bitmap的加载" class="headerlink" title="Bitmap的加载"></a>Bitmap的加载</h2><p><strong>加载Bitamp的方式</strong><br>bitmap在Android中指的是一张图片。通过BitmapFactory类提供的4类方法：</p>
<p>decodeFile,decodeResouce,decodeStream和 decodeByteArray,分别从文件系统，资源，输入流和字节数组中加载出一个 Bitmap 对象，其中decodeFiled,decodeResource又间接调用了 decodeStream 方法，这4类 方法最终是在Android的底层实现的，对应着BitmapFactory类的几个native方法。</p>
<p><strong>BitmapFactory.Options的参数</strong><br><em><strong>inSampleSize参数(采样率)</strong></em><br>上述4类方法都支持BitmapFactory.Options参数，而Bitmap的按一定采样率进行缩放就是通过 BitmapFactory.Options参数实现的，主要用到了 inSampleSize参数，即采样率。通过对 inSampleSize 的设置，对图片的像素的高和款进行缩放。</p>
<p>当 inSampleSize=1 ,即采样后的图片大小为图片的原始大小，小于1，也按照1来计算。当 inSampleSize&gt;1,即采样后的拖欠将会缩小，缩放比例为1/(inSampleSize的二次方)。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">例如：一张 1024—1024像素的图片，采用ARG8888 格式存储，那么内存大小1024x1024x4=4m.如果 inSampleSize=2,即采样后图片内存大小为 512x512X4=1m</span><br></pre></td></tr></table></figure>

<p><strong>注意：官方文档中指出，inSampleSize的取值应该总是2的指数，如1，2，4，8等。如果外界传入的 inSampleSize的值不为2的指数，那么系统会向下取整并选择成立一个最接近2的指数来代替。比如3，系统会选择2来代替。不过并非在所有的Android版本都成立</strong></p>
<p><strong>关于 inSampleSize 取值的注意事项：</strong>通常是根据图片宽高实际的大小/需要的宽高大小，分别计算出宽和高的缩放比。单应该取其中最小的缩放比，避免缩放图片大小，到达指定控件中不能铺满，需要拉伸从而导致模糊。</p>
<p>例如：ImageView的大小是 100x100 像素，而图片的原始大小是 200x300，那么宽的缩放比是 2，高的缩放比是 3，如果最终 inSampleSize=2,那么缩放后的图片大小 100x150，仍然合适 ImageView。如果inSamleSize=3,那么缩放后的图片大小小于 ImageView所期望的大小。这样图片就会被拉伸而导致模糊。</p>
<p><em><strong>inJustDecodeBounds 参数</strong></em><br>我们需要获取加载的图片的宽高信息，然后交给inSampleSize 参数选择缩放比缩放，那么如何能不先加载图片却能获取得图片的宽高信息，通过 inJustDecodeBunds=true,然后加载图片就可以实现只解析图片的宽高信息，并不会真正的加载图片，所以这个操作是轻量级的。当获取了宽高信息，计算出缩放比后，然后在将 inJustDecodeBounds=false,再重新加载图片，就可以加载缩放后的图片。</p>
<p><strong>注意：BitmapFactory 获取得图片宽高信息和图片的位置以及程序运行的设备有关，比如同一张图片放在不同的drawable目录下或者程序运行在不同屏幕密度的设备上，都可能导致BitmapFactory 获取到不同的结果，和 Android 的资源加载机制有关。</strong></p>
<p><strong>高效加载Bitmap的流程</strong></p>
<ol>
<li>将BitmapFactory.Options的 inJustDecodeBounds 参数设置为true并加载图片。</li>
<li>从BitmapFactory.Options中取出图片的原始宽高信息，他们对应于uouytWidth 和 outHeight参数。</li>
<li>根据采样率的规则并结合目标View 的所需大小计算出采样率 inSampleSize.</li>
<li>将BitmapFactory.Options 的inJustDecodeBounds 参数设为 false,然后重新加载图片。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">showBit</span><span class="params">(Resources resources, <span class="keyword">int</span> id, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    Bitmap bitmap;</span><br><span class="line">    <span class="comment">//加载图片</span></span><br><span class="line">    BitmapFactory.decodeResource(resources, id, options);</span><br><span class="line">    Log.e(<span class="string">&quot;demo&quot;</span>,<span class="string">&quot;w&quot;</span>+options.outWidth+<span class="string">&quot;----h&quot;</span>+options.outHeight);</span><br><span class="line">    <span class="comment">//计算缩放比</span></span><br><span class="line">    options.inSampleSize = calculateInsamplSize(options, width, height);</span><br><span class="line">    <span class="comment">//重新加载图片</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    bitmap = BitmapFactory.decodeResource(resources, id, options);</span><br><span class="line">    Log.e(<span class="string">&quot;demo&quot;</span>,bitmap.getWidth()</span><br><span class="line">            +<span class="string">&quot;------height&quot;</span>+bitmap.getHeight()+<span class="string">&quot;------size&quot;</span></span><br><span class="line">            +options.inSampleSize+<span class="string">&quot;-----byte&quot;</span>+bitmap.getRowBytes());</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateInsamplSize</span><span class="params">(BitmapFactory.Options options, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> height = options.outHeight;</span><br><span class="line">    <span class="keyword">int</span> width = options.outWidth;</span><br><span class="line">    <span class="keyword">int</span> sizeSimple = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (height &gt; reqHeight &amp;&amp; width &gt; reqWidth) &#123;</span><br><span class="line">        <span class="keyword">int</span> sizew=width/reqWidth;</span><br><span class="line">        <span class="keyword">int</span> sizeh=height/reqHeight;</span><br><span class="line">        <span class="comment">//选其中最小的边为标准</span></span><br><span class="line">        <span class="keyword">int</span> sizemode=sizew&gt;sizeh?sizeh:sizew;</span><br><span class="line">        <span class="keyword">if</span> (sizemode&gt;sizeSimple)&#123;</span><br><span class="line">            <span class="keyword">return</span> sizeSimple*sizemode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizeSimple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察打印数据：<br><img src="/images/android_bitmap_better_performance02.png" alt="Bitmap内存优化"><br>经过我们压缩之后，其图片大小占用1260字节，分辨率也是随之下降，不过都在我们所设定的范围之内，下面我们看看，如果不压缩，结果是怎么样。<br>更改inSampleSize=1，也就是默认原图显示。效果如下：<br><img src="/images/android_bitmap_better_performance03.png" alt="Bitmap内存优化"></p>
<h1 id="改变Bitmap大小"><a href="#改变Bitmap大小" class="headerlink" title="改变Bitmap大小"></a>改变Bitmap大小</h1><p>根据上面的原理，我们可以从两个方面减少Bitmap的内存占用，一个是改变Bitmap的宽高，另一个是改变Bitmap.Config的值，将Bitmap.Config.ARGB_8888改为占用字节更少的Bitmap.Config.ARGB_4444或者Bitmap.Config.RGB_565。<br>除了上文中的更改采样率的方式进行压缩外，还有没有别的？显然是有的。</p>
<p>1、通过martix进行压缩(改变Bitmap大小)。Bitmap.createBitmap或者Bitmap.createScaledBitmap方法。<br>2、更改Bitmap.Config格式。<br>3、通过Bitmap#compress方法压缩。</p>
<p>原图信息如下：</p>
<p><img src="/images/android_bitmap_better_performance04.png" alt="原图"></p>
<h2 id="通过martix进行压缩-改变Bitmap大小"><a href="#通过martix进行压缩-改变Bitmap大小" class="headerlink" title="通过martix进行压缩(改变Bitmap大小)"></a>通过martix进行压缩(改变Bitmap大小)</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> matrix = Matrix()</span><br><span class="line">matrix.setScale(<span class="number">0.1f</span>, <span class="number">0.1f</span>)</span><br><span class="line"><span class="keyword">val</span> bmpMatrixJpg = Bitmap.createBitmap(</span><br><span class="line">    bmpOriginJpg, <span class="number">0</span>, <span class="number">0</span>, bmpOriginJpg.getWidth(),</span><br><span class="line">    bmpOriginJpg.getHeight(), matrix, <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// Bitmap.createScaledBitmap内部也会使用Matrix进行缩放</span></span><br><span class="line"><span class="comment">//            val bmpMatrixJpg = Bitmap.createScaledBitmap(</span></span><br><span class="line"><span class="comment">//                bmpOriginJpg,</span></span><br><span class="line"><span class="comment">//                ScreenUtils.dip2px(this, 60f),</span></span><br><span class="line"><span class="comment">//                ScreenUtils.dip2px(this, 45f),</span></span><br><span class="line"><span class="comment">//                true</span></span><br><span class="line"><span class="comment">//            )</span></span><br><span class="line"><span class="keyword">val</span> descBmpConfigJpg =</span><br><span class="line">	<span class="string">&quot;height:<span class="subst">$&#123;bmpMatrixJpg?.height&#125;</span>,\nwidth:<span class="subst">$&#123;bmpMatrixJpg?.width&#125;</span>,\nallocationByteCount:<span class="subst">$&#123;bmpMatrixJpg?.allocationByteCount&#125;</span>byte,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;byteCount:<span class="subst">$&#123;bmpMatrixJpg?.byteCount&#125;</span>byte,\nrowBytes:<span class="subst">$&#123;bmpMatrixJpg?.rowBytes&#125;</span>byte,\ndensity:<span class="subst">$&#123;bmpMatrixJpg?.density&#125;</span>&quot;</span></span><br><span class="line">tvMatrixJpgInfo.text = <span class="string">&quot;Jpg通过Matrix压缩后的信息：<span class="variable">$descBmpConfigJpg</span>&quot;</span></span><br><span class="line">ivMatrixJpg.setImageBitmap(bmpMatrixJpg)</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_bitmap_better_performance05.png" alt="Matrix缩放Bitmap"></p>
<p>由于我们设置的缩放比是0.1f，也就是宽高均是之前的1/10，所以压缩后的bitmap占用的内存大小变为原来的1/100。</p>
<p>这种情况适用原图大小和目标bitmap大小均已知的情况。</p>
<h2 id="更改Bitmap-Config格式"><a href="#更改Bitmap-Config格式" class="headerlink" title="更改Bitmap.Config格式"></a>更改Bitmap.Config格式</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> option = BitmapFactory.Options()</span><br><span class="line">option.inPreferredConfig = Bitmap.Config.ARGB_4444</span><br><span class="line"><span class="comment">//  option.inPreferredConfig = Bitmap.Config.RGB_565 // 对透明度没要求的话可以试一下rgb_565</span></span><br><span class="line"><span class="keyword">val</span> bmpBmpConfigJpg = BitmapFactory.decodeStream(assets.<span class="keyword">open</span>(<span class="string">&quot;maomi.jpg&quot;</span>), <span class="literal">null</span>, option)</span><br><span class="line"><span class="keyword">val</span> descBmpConfigJpg =</span><br><span class="line">    <span class="string">&quot;height:<span class="subst">$&#123;bmpBmpConfigJpg?.height&#125;</span>,\nwidth:<span class="subst">$&#123;bmpBmpConfigJpg?.width&#125;</span>,\nallocationByteCount:<span class="subst">$&#123;bmpBmpConfigJpg?.allocationByteCount&#125;</span>byte,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;byteCount:<span class="subst">$&#123;bmpBmpConfigJpg?.byteCount&#125;</span>byte,\nrowBytes:<span class="subst">$&#123;bmpBmpConfigJpg?.rowBytes&#125;</span>byte,\ndensity:<span class="subst">$&#123;bmpBmpConfigJpg?.density&#125;</span>&quot;</span></span><br><span class="line">tvBmpConfigJpgInfo.text = <span class="string">&quot;Jpg通过Bitmap.Config压缩后的信息：<span class="variable">$descBmpConfigJpg</span>&quot;</span></span><br><span class="line">ivBmpConfigJpg.setImageBitmap(bmpBmpConfigJpg)</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_bitmap_better_performance06.png" alt="Bitmap.Config减少内存占用"></p>
<p>我们将Bitmap.Config的值改为了根据输出的byteCount的值改为了Bitmap.Config.ARGB_4444，根据byteCount输出的值可以明显的看到，bitmap的内存大小减少了一半。</p>
<p>如果对透明度没要求的话可以试一下Bitmap.Config.RGB_565。</p>
<p>这种情况适用于对图片分辨率要求不高的情况。</p>
<h2 id="通过Bitmap-compress方法压缩，质量压缩"><a href="#通过Bitmap-compress方法压缩，质量压缩" class="headerlink" title="通过Bitmap#compress方法压缩，质量压缩"></a>通过Bitmap#compress方法压缩，质量压缩</h2><p>还有一种很重要的压缩方式，通过Bitmap#compress方法，修改quality的值，来改变Bitmap生成的字节流的大小。这种方法不会改变Bitmap占用的内存大小。</p>
<p>质量压缩不会减少图片的像素，它是在保持像素的前提下改变图片的位深及透明度等，来达到压缩图片的目的。图片的长，宽，像素都不变，那么bitmap所占内存大小是不会变的。这里改变的是bitmap对应的字节数组的大小，适合去传递二进制的图片数据，比如微信分享。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> bytearray = getBytesFromCompressBitmap(bmpOriginJpg, <span class="number">32</span> * <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">val</span> bmpQualityJpg = BitmapFactory.decodeByteArray(bytearray, <span class="number">0</span>, bytearray.size)</span><br><span class="line"><span class="keyword">val</span> descQualityJpg =</span><br><span class="line">    <span class="string">&quot;height:<span class="subst">$&#123;bmpQualityJpg.height&#125;</span>,\nwidth:<span class="subst">$&#123;bmpQualityJpg.width&#125;</span>,\nallocationByteCount:<span class="subst">$&#123;bmpQualityJpg.allocationByteCount&#125;</span>byte,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;byteCount:<span class="subst">$&#123;bmpQualityJpg.byteCount&#125;</span>byte,\nrowBytes:<span class="subst">$&#123;bmpQualityJpg.rowBytes&#125;</span>byte,\ndensity:<span class="subst">$&#123;bmpQualityJpg.density&#125;</span>,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;bytearray:<span class="subst">$&#123;bytearray.size&#125;</span>&quot;</span></span><br><span class="line">tvQualityJpgInfo.text = <span class="string">&quot;Jpg进行Quality压缩后的信息：<span class="variable">$descQualityJpg</span>&quot;</span></span><br><span class="line">ivQualityJpg.setImageBitmap(bmpQualityJpg)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Bitmap的字节流压缩为目标大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@targetSize</span>  单位为Byte</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBytesFromCompressBitmap</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    bitmap: <span class="type">Bitmap</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    targetSize: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: ByteArray &#123;</span><br><span class="line">    <span class="keyword">val</span> baos = ByteArrayOutputStream()</span><br><span class="line">    <span class="keyword">var</span> quality = <span class="number">100</span></span><br><span class="line">    bitmap.compress(Bitmap.CompressFormat.PNG, quality, baos)</span><br><span class="line">    <span class="keyword">var</span> bytes = baos.toByteArray()</span><br><span class="line">    <span class="keyword">while</span> (bytes.size &gt; targetSize &amp;&amp; quality &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        quality -= <span class="number">5</span></span><br><span class="line">        <span class="keyword">if</span> (quality &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            quality = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置，不然会累加</span></span><br><span class="line">        baos.reset()</span><br><span class="line">        bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos)</span><br><span class="line">        bytes = baos.toByteArray()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        baos.close()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_bitmap_better_performance07.png" alt="质量压缩"></p>
<p>可以看到，质量压缩不会改变原有bitmap的大小，它改变的是通过Bitmap#compress方法的字节流。</p>
<p>具体开发过程中，可以根据需要自行选择合适的方式。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android车载多媒体架构</title>
    <url>/2021/09/04/android_aosp_media_service/</url>
    <content><![CDATA[<p>音频和视频多媒体的处理是每个操作系统中必不可少的一部分，多媒体架构的作用是规范了媒体服务和界面的通信接口，达到了完全解耦，可以自由、高效进行不同的媒体的切换。</p>
<span id="more"></span>

<p>播放音频或视频的多媒体应用通常由两部分组成：</p>
<ul>
<li>播放器，用于吸收数字媒体并将其呈现为视频和/或音频</li>
<li>界面，带有用于运行播放器并显示播放器状态（可选）的传输控件</li>
</ul>
<p><img src="/images/android_aosp_media_service01.png" alt="ui-and-player"></p>
<p>在 Android 中，您可以从零开始构建自己的播放器，也可以从以下选项中进行选择：</p>
<ul>
<li>MediaPlayer 类提供准系统播放器的基本功能，支持最常见的音频/视频格式和数据源。</li>
<li>ExoPlayer 是一个提供低层级 Android 音频 API 的开放源代码库。ExoPlayer 支持 DASH 和 HLS 流等高性能功能，这些功能在 <code>MediaPlayer</code> 中未提供。您可以自定义 ExoPlayer 代码，从而轻松添加新组件。ExoPlayer 只能用于 Android 4.1 及更高版本。</li>
</ul>
<p>众所周知，如果需要在应用的后台继续播放音频，我们就需要把Player放置在Service中，那么<strong>界面</strong>与<strong>播放器</strong>之间通信就非常值得研究了。很长一段时间里，都是由Service提供一个Binder来实现与<strong>播放器</strong>之间的通信。但是往往<strong>下拉的状态栏</strong>和<strong>桌面的Widget</strong>都需要与Service之间进行通信，这时候Service就不得不通过实现一系列AIDL接口/广播/ContentProvider完成与其它应用之间的通信，而这些通信手段既增加了应用开发者之间的沟通成本，也增加了应用之间的耦合度。</p>
<p>为了解决上面的问题，Android官方从Android5.0开始提供了<strong>MediaSession</strong>框架。</p>
<h1 id="MediaSession框架"><a href="#MediaSession框架" class="headerlink" title="MediaSession框架"></a>MediaSession框架</h1><p>虽然界面和播放器采用的 API 可能各不相同，但是对所有媒体播放器应用来说，这两部分之间的交互的性质都基本相同。Android 框架定义了两个类（媒体会话和媒体控制器），它们为构建媒体播放器应用提供了一个完善的结构。</p>
<p>媒体会话和媒体控制器通过以下方式相互通信：使用与标准播放器操作（播放、暂停、停止等）相对应的预定义回调，以及用于定义应用独有的特殊行为的可扩展自定义调用。</p>
<p><img src="/images/android_aosp_media_service02.png" alt="controller-and-session"></p>
<h2 id="MediaSession"><a href="#MediaSession" class="headerlink" title="MediaSession"></a>MediaSession</h2><p>媒体会话负责与播放器的所有通信。它会对应用的其他部分隐藏播放器的 API。系统只能从控制播放器的媒体会话中调用播放器。</p>
<p>会话会维护播放器状态（播放/暂停）的表示形式以及播放内容的相关信息。会话可以接收来自一个或多个媒体控制器的回调。响应回调的逻辑必须保持一致。无论哪个客户端应用发起了回调，对 <code>MediaSession</code> 回调的响应都应该相同。<strong>MediaSession</strong>框架属于典型的<strong>C/S</strong>架构，有四个常用的成员类，是整个MediaSession框架流程控制的核心。</p>
<h3 id="客户端媒体浏览器-MediaBrowser"><a href="#客户端媒体浏览器-MediaBrowser" class="headerlink" title="客户端媒体浏览器-MediaBrowser"></a>客户端媒体浏览器-MediaBrowser</h3><p><strong>媒体浏览器</strong>，用来<strong>连接</strong><code>MediaBrowserService</code>和<strong>订阅数据</strong>，通过它的回调接口我们可以获取与<strong>Service</strong>的连接状态以及获取在<strong>Service</strong>中的音乐库数据。在<strong>客户端</strong>（也就是上文我们提到的<strong>界面</strong>，或者说是<strong>控制端</strong>）中创建。<br> <strong>媒体浏览器</strong>不是线程安全的。所有调用都应在构造<code>MediaBrowser</code>的线程上进行。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.M)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> component = ComponentName(<span class="keyword">this</span>, MediaService::<span class="keyword">class</span>.java)</span><br><span class="line">    mMediaBrowser = MediaBrowser(<span class="keyword">this</span>, component, connectionCallback, <span class="literal">null</span>);</span><br><span class="line">    mMediaBrowser.connect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MediaBrowser-ConnectionCallback"><a href="#MediaBrowser-ConnectionCallback" class="headerlink" title="MediaBrowser.ConnectionCallback"></a>MediaBrowser.ConnectionCallback</h4><p>用于接收与<strong>MediaBrowserService</strong>连接事件的回调，在创建<code>MediaBrowser</code>时传入。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.M)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> component = ComponentName(<span class="keyword">this</span>, MediaService::<span class="keyword">class</span>.java)</span><br><span class="line">    mMediaBrowser = MediaBrowser(<span class="keyword">this</span>, component, connectionCallback, <span class="literal">null</span>);</span><br><span class="line">    mMediaBrowser.connect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connectionCallback = <span class="keyword">object</span> : MediaBrowser.ConnectionCallback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onConnected()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnectionFailed</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onConnectionFailed()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnectionSuspended</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onConnectionSuspended()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MediaBrowser-ItemCallback"><a href="#MediaBrowser-ItemCallback" class="headerlink" title="MediaBrowser.ItemCallback"></a>MediaBrowser.ItemCallback</h4><p>用于返回MediaBrowser.getItem()的结果。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connectionCallback = <span class="keyword">object</span> : MediaBrowser.ConnectionCallback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onConnected()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span>(mMediaBrowser.isConnected) &#123;</span><br><span class="line">            <span class="keyword">val</span> mediaId = mMediaBrowser.root</span><br><span class="line">            mMediaBrowser.getItem(mediaId, itemCallback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi(Build.VERSION_CODES.M)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> itemCallback = <span class="keyword">object</span> : MediaBrowser.ItemCallback()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemLoaded</span><span class="params">(item: <span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onItemLoaded(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(mediaId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onError(mediaId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MediaBrowser-MediaItem"><a href="#MediaBrowser-MediaItem" class="headerlink" title="MediaBrowser.MediaItem"></a>MediaBrowser.MediaItem</h4><p>包含有关单个媒体项的信息，用于浏览/搜索媒体。<code>MediaItem</code>依赖于<strong>服务端</strong>提供，因此框架本身无法保证它包含的值都是正确的。</p>
<h4 id="MediaBrowser-SubscriptionCallback"><a href="#MediaBrowser-SubscriptionCallback" class="headerlink" title="MediaBrowser.SubscriptionCallback"></a>MediaBrowser.SubscriptionCallback</h4><p>用于订与<strong>MediaBrowserService</strong>中<strong>MediaBrowser.MediaItem</strong>列表变化的回调。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connectionCallback = <span class="keyword">object</span> : MediaBrowser.ConnectionCallback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onConnected()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span>(mMediaBrowser.isConnected) &#123;</span><br><span class="line">            <span class="keyword">val</span> mediaId = mMediaBrowser.root</span><br><span class="line">            <span class="comment">// 需要先取消订阅</span></span><br><span class="line">            mMediaBrowser.unsubscribe(mediaId)</span><br><span class="line">            <span class="comment">// 服务端会调用onLoadChildren</span></span><br><span class="line">            mMediaBrowser.subscribe(mediaId, subscribeCallback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> subscribeCallback = <span class="keyword">object</span> : MediaBrowser.SubscriptionCallback()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChildrenLoaded</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parentId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        children: <span class="type">MutableList</span>&lt;<span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onChildrenLoaded(parentId, children)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChildrenLoaded</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parentId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        children: <span class="type">MutableList</span>&lt;<span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        options: <span class="type">Bundle</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onChildrenLoaded(parentId, children, options)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(parentId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onError(parentId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(parentId: <span class="type">String</span>, options: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onError(parentId, options)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MediaController"><a href="#MediaController" class="headerlink" title="MediaController"></a>MediaController</h2><p>官方解释：</p>
<blockquote>
<p>媒体控制器会隔离您的界面。您的界面代码只与媒体控制器（而非播放器本身）通信。媒体控制器会将传输控制操作转换为对媒体会话的回调。每当会话状态发生变化时，它也会接收来自媒体会话的回调。这提供了一种自动更新关联界面的机制。媒体控制器一次只能连接到一个媒体会话。</p>
<p>当您使用媒体控制器和媒体会话时，您可以在运行时部署不同的接口和/或播放器。您可以根据运行应用的设备的功能单独更改该应用的外观和/或性能。</p>
</blockquote>
<p><strong>媒体控制器</strong>，用来向服务端发送控制指令，例如：播放、暂停等等，在客户端中创建。媒体控制器是线程安全的。MediaController还有一个关联的权限***android.permission.MEDIA_CONTENT_CONTROL***（不是必须加的权限）必须是系统级应用才可以获取，幸运的是车载应用一般都是系统级应用。<br> <code>MediaController</code>必须在MediaBrowser连接成功后才可以创建。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connectionCallback = <span class="keyword">object</span> : MediaBrowser.ConnectionCallback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onConnected()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span>(mMediaBrowser.isConnected) &#123;</span><br><span class="line">            <span class="keyword">val</span> sessionToken = mMediaBrowser.sessionToken</span><br><span class="line">            mMediaController = MediaController(applicationContext,sessionToken)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MediaController-Callback"><a href="#MediaController-Callback" class="headerlink" title="MediaController.Callback"></a>MediaController.Callback</h3><p>用于从MediaSession接收回调。使用方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connectionCallback = <span class="keyword">object</span> : MediaBrowser.ConnectionCallback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onConnected()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span>(mMediaBrowser.isConnected) &#123;</span><br><span class="line">            <span class="keyword">val</span> sessionToken = mMediaBrowser.sessionToken</span><br><span class="line">            mMediaController = MediaController(applicationContext,sessionToken)</span><br><span class="line">            mMediaController.registerCallback(controllerCallback)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> controllerCallback = <span class="keyword">object</span> : MediaController.Callback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAudioInfoChanged</span><span class="params">(info: <span class="type">MediaController</span>.<span class="type">PlaybackInfo</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onAudioInfoChanged(info)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onExtrasChanged</span><span class="params">(extras: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onExtrasChanged(extras)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MediaController-PlaybackInfo"><a href="#MediaController-PlaybackInfo" class="headerlink" title="MediaController.PlaybackInfo"></a>MediaController.PlaybackInfo</h3><p>保存有关当前播放以及如何处理此会话的音频的信息。使用方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前回话播放的音频信息</span></span><br><span class="line"><span class="keyword">val</span> playbackInfo = mMediaController.playbackInfo</span><br></pre></td></tr></table></figure>

<h3 id="MediaController-TransportControls"><a href="#MediaController-TransportControls" class="headerlink" title="MediaController.TransportControls"></a>MediaController.TransportControls</h3><p>用于控制会话中媒体播放的接口。这允许客户端向Session发送媒体控制命令。使用方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connectionCallback = <span class="keyword">object</span> : MediaBrowser.ConnectionCallback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onConnected()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span>(mMediaBrowser.isConnected) &#123;</span><br><span class="line">            <span class="keyword">val</span> sessionToken = mMediaBrowser.sessionToken</span><br><span class="line">            mMediaController = MediaController(applicationContext,sessionToken)</span><br><span class="line">            <span class="comment">// 播放媒体</span></span><br><span class="line">            mMediaController.transportControls.play()</span><br><span class="line">            <span class="comment">// 暂停媒体</span></span><br><span class="line">            mMediaController.transportControls.pause()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端媒体浏览服务-MediaBrowserService"><a href="#服务端媒体浏览服务-MediaBrowserService" class="headerlink" title="服务端媒体浏览服务-MediaBrowserService"></a>服务端媒体浏览服务-MediaBrowserService</h2><p><strong>媒体浏览器服务</strong>，继承自<code>Service</code>，<code>MediaBrowserService</code>属于<strong>服务端</strong>，也是承载<strong>播放器</strong>（如MediaPlayer、ExoPlayer等）和<code>MediaSession</code>的容器。<br> 实现<code>MediaBrowserService</code>时会要求复写<code>onGetRoot</code>和<code>onLoadChildren</code>两个方法。<br> <code>onGetRoot</code>通过的返回值决定是否允许客户端的<code>MediaBrowser</code>连接到<code>MediaBrowserService</code>。<br> 当客户端调用<code>MediaBrowser.subscribe</code>时会触发<code>onLoadChildren</code>方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> FOLDERS_ID = <span class="string">&quot;__FOLDERS__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ARTISTS_ID = <span class="string">&quot;__ARTISTS__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ALBUMS_ID = <span class="string">&quot;__ALBUMS__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> GENRES_ID = <span class="string">&quot;__GENRES__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ROOT_ID = <span class="string">&quot;__ROOT__&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaService</span> : <span class="type">MediaBrowserService</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGetRoot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        clientPackageName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        clientUid: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        rootHints: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: BrowserRoot? &#123;</span><br><span class="line">        <span class="comment">// 由MediaBrowser.connect触发，可以通过返回null拒绝客户端的连接。</span></span><br><span class="line">        <span class="keyword">return</span> BrowserRoot(ROOT_ID, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLoadChildren</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parentId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">MutableList</span>&lt;<span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">    <span class="comment">// 由MediaBrowser.subscribe触发</span></span><br><span class="line">        <span class="keyword">when</span> (parentId) &#123;</span><br><span class="line">            ROOT_ID -&gt; &#123;</span><br><span class="line">                <span class="comment">// 查询本地媒体库</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="comment">// 将此消息与当前线程分离，并允许稍后进行sendResult调用</span></span><br><span class="line">                result.detach()</span><br><span class="line">                <span class="comment">// 设定到 result 中</span></span><br><span class="line">                result.sendResult()</span><br><span class="line">            &#125;</span><br><span class="line">            FOLDERS_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ALBUMS_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ARTISTS_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            GENRES_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后还需要在manifest中注册这个Service。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MediaService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/service_name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.media.browse.MediaBrowserService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="MediaBrowserService-BrowserRoot"><a href="#MediaBrowserService-BrowserRoot" class="headerlink" title="MediaBrowserService.BrowserRoot"></a>MediaBrowserService.BrowserRoot</h3><p>包含<strong>浏览器服务</strong>首次连接时需要返回给<strong>客户端</strong>的信息。</p>
<p><strong>MediaBrowserService.BrowserRoot API 列表</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Bundle getExtras()</td>
<td>获取有关浏览器服务的附加信息。</td>
</tr>
<tr>
<td>String getRootId()</td>
<td>获取用于浏览的根 ID。</td>
</tr>
</tbody></table>
<h3 id="MediaBrowserService-Result"><a href="#MediaBrowserService-Result" class="headerlink" title="MediaBrowserService.Result"></a>MediaBrowserService.Result<T></h3><p>包含<strong>浏览器服务</strong>返回给<strong>客户端</strong>的结果集。通过调用<code>sendResult()</code>将结果返回给调用方，但是在此之前需要调用<code>detach()</code>。</p>
<h3 id="MediaBrowserService-Result-API-列表"><a href="#MediaBrowserService-Result-API-列表" class="headerlink" title="MediaBrowserService.Result API 列表"></a>MediaBrowserService.Result API 列表</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>void detach()</td>
<td>将此消息与当前线程分离，并允许稍后进行调用sendResult(T)</td>
</tr>
<tr>
<td>void sendResult(T result)</td>
<td>将结果发送回调用方。</td>
</tr>
</tbody></table>
<h2 id="服务端媒体会话-MediaSession"><a href="#服务端媒体会话-MediaSession" class="headerlink" title="服务端媒体会话-MediaSession"></a>服务端媒体会话-MediaSession</h2><p><strong>媒体会话</strong>，即<strong>受控端。</strong>通过设定<code>MediaSession.Callback</code>回调来接收媒体控制器<code>MediaController</code>发送的指令。<br> 创建<code>MediaSession</code>后还需要调用<code>setSessionToken()</code>方法设置用于和**控制器配对的令牌。使用方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> FOLDERS_ID = <span class="string">&quot;__FOLDERS__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ARTISTS_ID = <span class="string">&quot;__ARTISTS__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ALBUMS_ID = <span class="string">&quot;__ALBUMS__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> GENRES_ID = <span class="string">&quot;__GENRES__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ROOT_ID = <span class="string">&quot;__ROOT__&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaService</span> : <span class="type">MediaBrowserService</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mediaSession: MediaSession;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        mediaSession = MediaSession(<span class="keyword">this</span>, <span class="string">&quot;TAG&quot;</span>)</span><br><span class="line">        mediaSession.setCallback(callback)</span><br><span class="line">        sessionToken = mediaSession.sessionToken</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与MediaController.transportControls中的大部分方法都是一一对应的</span></span><br><span class="line">    <span class="comment">// 在该方法中实现对 播放器 的控制，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> callback = <span class="keyword">object</span> : MediaSession.Callback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPlay</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onPlay()</span><br><span class="line">            <span class="comment">// 处理 播放器 的播放逻辑。</span></span><br><span class="line">            <span class="comment">// 车载应用的话，别忘了处理音频焦点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onPause()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGetRoot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        clientPackageName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        clientUid: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        rootHints: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: BrowserRoot? &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onGetRoot: <span class="variable">$rootHints</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> BrowserRoot(ROOT_ID, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLoadChildren</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parentId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">MutableList</span>&lt;<span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onLoadChildren: <span class="variable">$parentId</span>&quot;</span>)</span><br><span class="line">        result.detach()</span><br><span class="line">        <span class="keyword">when</span> (parentId) &#123;</span><br><span class="line">            ROOT_ID -&gt; &#123;</span><br><span class="line">                result.sendResult(<span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            FOLDERS_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ALBUMS_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ARTISTS_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            GENRES_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLoadItem</span><span class="params">(itemId: <span class="type">String</span>?, result: <span class="type">Result</span>&lt;<span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onLoadItem(itemId, result)</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onLoadItem: <span class="variable">$itemId</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MediaSession-Callback"><a href="#MediaSession-Callback" class="headerlink" title="MediaSession.Callback"></a>MediaSession.Callback</h3><p>接收来自控制器和系统的媒体按钮、传输控件和命令。与MediaController.transportControls中的大部分方法都是一一对应的。使用方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate()</span><br><span class="line">    mediaSession = MediaSession(<span class="keyword">this</span>, <span class="string">&quot;TAG&quot;</span>)</span><br><span class="line">    mediaSession.setCallback(callback)</span><br><span class="line">    sessionToken = mediaSession.sessionToken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与MediaController.transportControls中的方法是一一对应的。</span></span><br><span class="line"><span class="comment">// 在该方法中实现对 播放器 的控制，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> callback = <span class="keyword">object</span> : MediaSession.Callback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPlay</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPlay()</span><br><span class="line">        <span class="comment">// 处理 播放器 的播放逻辑。</span></span><br><span class="line">        <span class="comment">// 车载应用的话，别忘了处理音频焦点</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!mediaSession.isActive) &#123;</span><br><span class="line">            mediaSession.isActive = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新播放状态.</span></span><br><span class="line">        <span class="keyword">val</span> state = PlaybackState.Builder()</span><br><span class="line">            .setState(</span><br><span class="line">                PlaybackState.STATE_PLAYING,<span class="number">1</span>,<span class="number">1f</span></span><br><span class="line">            )</span><br><span class="line">            .build()</span><br><span class="line">        <span class="comment">// 此时MediaController.Callback.onPlaybackStateChanged会回调</span></span><br><span class="line">        mediaSession.setPlaybackState(state)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MediaSession-QueueItem"><a href="#MediaSession-QueueItem" class="headerlink" title="MediaSession.QueueItem"></a>MediaSession.QueueItem</h3><p>作为播放队列一部分的单个项目。它包含队列中项目及其 ID 的说明。<br> <strong>MediaSession.QueueItem API 列表</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://developer.android.google.cn/guide/topics/media-apps/working-with-a-media-session?hl=zh_cn">MediaDescription</a> getDescription()</td>
<td>返回介质的说明。包含媒体的基础信息如：标题、封面等等。</td>
</tr>
<tr>
<td>long getQueueId()</td>
<td>获取此项目的队列 ID。</td>
</tr>
</tbody></table>
<h3 id="MediaSession-Token"><a href="#MediaSession-Token" class="headerlink" title="MediaSession.Token"></a>MediaSession.Token</h3><p>表示正在进行的会话。这可以通过会话所有者传递给<strong>客户端</strong>，以允许客户端与服务端之间建立通信。</p>
<h2 id="播放器状态-PlaybackState"><a href="#播放器状态-PlaybackState" class="headerlink" title="播放器状态-PlaybackState"></a>播放器状态-PlaybackState</h2><p>用于承载播放状态的类。如当前播放位置和当前控制功能。<br> 在<code>MediaSession.Callback</code>更改状态后需要调用<code>MediaSession.setPlaybackState</code>把状态同步给<strong>客户端</strong>。使用方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> callback = <span class="keyword">object</span> : MediaSession.Callback() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPlay</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onPlay()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 更新状态</span></span><br><span class="line">        <span class="keyword">val</span> state = PlaybackState.Builder()</span><br><span class="line">            .setState(</span><br><span class="line">                PlaybackState.STATE_PLAYING,<span class="number">1</span>,<span class="number">1f</span></span><br><span class="line">            )</span><br><span class="line">            .build()</span><br><span class="line">        mediaSession.setPlaybackState(state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PlaybackState-Builder"><a href="#PlaybackState-Builder" class="headerlink" title="PlaybackState.Builder"></a>PlaybackState.Builder</h3><p>基于建造者模式来生成PlaybackState对象。使用方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">PlaybackState state = new PlaybackState.Builder()</span><br><span class="line">        .setState(PlaybackState.STATE_PLAYING,</span><br><span class="line">                mMediaPlayer.getCurrentPosition(), PLAYBACK_SPEED)</span><br><span class="line">        .setActions(PLAYING_ACTIONS)</span><br><span class="line">        .addCustomAction(mShuffle)</span><br><span class="line">        .setActiveQueueItemId(mQueue.<span class="keyword">get</span>(mCurrentQueueIdx).getQueueId())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<h3 id="PlaybackState-CustomAction"><a href="#PlaybackState-CustomAction" class="headerlink" title="PlaybackState.CustomAction"></a>PlaybackState.CustomAction</h3><p><code>CustomActions</code>可用于通过将特定于应用程序的操作发送给<code>MediaControllers</code>，这样就可以扩展标准传输控件的功能。使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CustomAction action = <span class="keyword">new</span> CustomAction</span><br><span class="line">        .Builder(<span class="string">&quot;android.car.media.localmediaplayer.shuffle&quot;</span>,</span><br><span class="line">        mContext.getString(R.string.shuffle),</span><br><span class="line">        R.drawable.shuffle)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">PlaybackState state = <span class="keyword">new</span> PlaybackState.Builder()</span><br><span class="line">        .setState(PlaybackState.STATE_PLAYING,</span><br><span class="line">                mMediaPlayer.getCurrentPosition(), PLAYBACK_SPEED)</span><br><span class="line">        .setActions(PLAYING_ACTIONS)</span><br><span class="line">        .addCustomAction(action)</span><br><span class="line">        .setActiveQueueItemId(mQueue.get(mCurrentQueueIdx).getQueueId())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<h3 id="PlaybackState-CustomAction-API-说明"><a href="#PlaybackState-CustomAction-API-说明" class="headerlink" title="PlaybackState.CustomAction API 说明"></a>PlaybackState.CustomAction API 说明</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>String getAction()</td>
<td>返回CustomAction的action。</td>
</tr>
<tr>
<td>Bundle getExtras()</td>
<td>返回附加项，这些附加项提供有关操作的其他特定于应用程序的信息，如果没有，则返回 null。</td>
</tr>
<tr>
<td>int getIcon()</td>
<td>返回package中图标的资源 ID。</td>
</tr>
<tr>
<td>CharSequence getName()</td>
<td>返回此操作的显示名称。</td>
</tr>
</tbody></table>
<h2 id="元数据类-MediaMetadata"><a href="#元数据类-MediaMetadata" class="headerlink" title="元数据类 - MediaMetadata"></a>元数据类 - MediaMetadata</h2><p>包含有关项目的基础数据，例如标题、艺术家等。一般需要<strong>服务端</strong>从本地数据库或远端查询出原始数据在封装成MediaMetadata再通过<code>MediaSession.setMetadata(metadata)</code>返回到<strong>客户端</strong>的<code>MediaController.Callback.onMetadataChanged</code>中。</p>
<h3 id="MediaMetadata-API-说明"><a href="#MediaMetadata-API-说明" class="headerlink" title="MediaMetadata API 说明"></a>MediaMetadata API 说明</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>boolean containsKey(String key)</td>
<td>如果给定的key包含在元数据中，则返回 true</td>
</tr>
<tr>
<td>int describeContents()</td>
<td>描述此可打包实例的封送处理表示中包含的特殊对象的种类。</td>
</tr>
<tr>
<td>Bitmap getBitmap(String key)</td>
<td>返回给定的key的Bitmap;如果给定key不存在位图，则返回 null。</td>
</tr>
<tr>
<td>int getBitmapDimensionLimit()</td>
<td>获取创建此元数据时位图的宽度/高度限制（以像素为单位）。</td>
</tr>
<tr>
<td>MediaDescription getDescription()</td>
<td>获取此元数据的简单说明以进行显示。</td>
</tr>
<tr>
<td>long getLong(String key)</td>
<td>返回与给定key关联的值，如果给定key不再存在，则返回 0L。</td>
</tr>
<tr>
<td>Rating getRating(String key)</td>
<td>对于给定的key返回Rating;如果给定key不存在Rating，则返回 null。</td>
</tr>
<tr>
<td>String getString(String key)</td>
<td>以 String 格式返回与给定key关联的文本值，如果给定key不存在所需类型的映射，或者null值显式与该key关联，则返回 null。</td>
</tr>
<tr>
<td>CharSequence  getText(String key)</td>
<td>返回与给定键关联的值，如果给定键不存在所需类型的映射，或者与该键显式关联 null 值，则返回 null。</td>
</tr>
<tr>
<td>Set<String> keySet()</td>
<td>返回一个 Set，其中包含在此元数据中用作key的字符串。</td>
</tr>
<tr>
<td>int size()</td>
<td>返回此元数据中的字段数。</td>
</tr>
</tbody></table>
<h3 id="MediaMetadata-常用Key"><a href="#MediaMetadata-常用Key" class="headerlink" title="MediaMetadata 常用Key"></a>MediaMetadata 常用Key</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>METADATA_KEY_ALBUM</td>
<td>媒体的唱片集标题。</td>
</tr>
<tr>
<td>METADATA_KEY_ALBUM_ART</td>
<td>媒体原始来源的相册的插图，Bitmap格式</td>
</tr>
<tr>
<td>METADATA_KEY_ALBUM_ARTIST</td>
<td>媒体原始来源的专辑的艺术家。</td>
</tr>
<tr>
<td>METADATA_KEY_ALBUM_ART_URI</td>
<td>媒体原始源的相册的图稿，Uri格式（推荐使用）</td>
</tr>
<tr>
<td>METADATA_KEY_ART</td>
<td>媒体封面，Bitmap格式</td>
</tr>
<tr>
<td>METADATA_KEY_ART_URI</td>
<td>媒体的封面，Uri格式。</td>
</tr>
<tr>
<td>METADATA_KEY_ARTIST</td>
<td>媒体的艺术家。</td>
</tr>
<tr>
<td>METADATA_KEY_AUTHOR</td>
<td>媒体的作者。</td>
</tr>
<tr>
<td>METADATA_KEY_BT_FOLDER_TYPE</td>
<td>蓝牙 AVRCP 1.5 的 6.10.2.2 节中指定的媒体的蓝牙文件夹类型。</td>
</tr>
<tr>
<td>METADATA_KEY_COMPILATION</td>
<td>媒体的编译状态。</td>
</tr>
<tr>
<td>METADATA_KEY_COMPOSER</td>
<td>媒体的作曲家。</td>
</tr>
<tr>
<td>METADATA_KEY_DATE</td>
<td>媒体的创建或发布日期。</td>
</tr>
<tr>
<td>METADATA_KEY_DISC_NUMBER</td>
<td>介质原始来源的光盘编号。</td>
</tr>
<tr>
<td>METADATA_KEY_DISPLAY_DESCRIPTION</td>
<td>适合向用户显示的说明。</td>
</tr>
<tr>
<td>METADATA_KEY_DISPLAY_ICON</td>
<td>适合向用户显示的图标或缩略图。</td>
</tr>
<tr>
<td>METADATA_KEY_DISPLAY_ICON_URI</td>
<td>适合向用户显示的图标或缩略图， Uri格式。</td>
</tr>
<tr>
<td>METADATA_KEY_DISPLAY_SUBTITLE</td>
<td>适合向用户显示的副标题。</td>
</tr>
<tr>
<td>METADATA_KEY_DISPLAY_TITLE</td>
<td>适合向用户显示的标题。</td>
</tr>
<tr>
<td>METADATA_KEY_DURATION</td>
<td>媒体的持续时间（以毫秒为单位）。</td>
</tr>
<tr>
<td>METADATA_KEY_GENRE</td>
<td>媒体的流派。</td>
</tr>
<tr>
<td>METADATA_KEY_MEDIA_ID</td>
<td>用于标识内容的字符串Key。</td>
</tr>
<tr>
<td>METADATA_KEY_MEDIA_URI</td>
<td>媒体内容，Uri格式。</td>
</tr>
<tr>
<td>METADATA_KEY_NUM_TRACKS</td>
<td>媒体原始源中的曲目数。</td>
</tr>
<tr>
<td>METADATA_KEY_RATING</td>
<td>媒体的总体评分。</td>
</tr>
<tr>
<td>METADATA_KEY_TITLE</td>
<td>媒体的标题。</td>
</tr>
<tr>
<td>METADATA_KEY_TRACK_NUMBER</td>
<td>媒体的磁道编号。</td>
</tr>
<tr>
<td>METADATA_KEY_USER_RATING</td>
<td>用户对媒体的分级。</td>
</tr>
<tr>
<td>METADATA_KEY_WRITER</td>
<td>媒体作家。</td>
</tr>
<tr>
<td>String METADATA_KEY_YEAR</td>
<td>媒体创建或发布为长的年份。</td>
</tr>
</tbody></table>
<h1 id="MediaSession简单实践"><a href="#MediaSession简单实践" class="headerlink" title="MediaSession简单实践"></a>MediaSession简单实践</h1><p>MediaSession 框架核心类通信过程如下图所示。</p>
<p><img src="/images/android_aosp_media_service03.png" alt="img"></p>
<p>客户端源码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mMediaBrowser: MediaBrowser</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mMediaController: MediaController</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresApi(Build.VERSION_CODES.M)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> component = ComponentName(<span class="keyword">this</span>, MediaService::<span class="keyword">class</span>.java)</span><br><span class="line">        mMediaBrowser = MediaBrowser(<span class="keyword">this</span>, component, connectionCallback, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 连接到MediaBrowserService，会触发MediaBrowserService的onGetRoot方法。</span></span><br><span class="line">        mMediaBrowser.connect()</span><br><span class="line"></span><br><span class="line">        findViewById&lt;Button&gt;(R.id.btn_play).setOnClickListener &#123;</span><br><span class="line">            mMediaController.transportControls.play()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> connectionCallback = <span class="keyword">object</span> : MediaBrowser.ConnectionCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onConnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onConnected()</span><br><span class="line">            <span class="keyword">if</span> (mMediaBrowser.isConnected) &#123;</span><br><span class="line">                <span class="keyword">val</span> sessionToken = mMediaBrowser.sessionToken</span><br><span class="line">                mMediaController = MediaController(applicationContext, sessionToken)</span><br><span class="line">                mMediaController.registerCallback(controllerCallback)</span><br><span class="line">                <span class="comment">// 获取根mediaId</span></span><br><span class="line">                <span class="keyword">val</span> rootMediaId = mMediaBrowser.root</span><br><span class="line">                <span class="comment">// 获取根mediaId的item列表，会触发MediaBrowserService.onLoadItem方法</span></span><br><span class="line">                mMediaBrowser.getItem(rootMediaId,itemCallback)</span><br><span class="line">                mMediaBrowser.unsubscribe(rootMediaId)</span><br><span class="line">                <span class="comment">// 订阅服务端 media item的改变，会触发MediaBrowserService.onLoadChildren方法</span></span><br><span class="line">                mMediaBrowser.subscribe(rootMediaId, subscribeCallback)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> controllerCallback = <span class="keyword">object</span> : MediaController.Callback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPlaybackStateChanged</span><span class="params">(state: <span class="type">PlaybackState</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onPlaybackStateChanged(state)</span><br><span class="line">            Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onPlaybackStateChanged: <span class="variable">$state</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">when</span>(state?.state)&#123;</span><br><span class="line">                PlaybackState.STATE_PLAYING -&gt;&#123;</span><br><span class="line">                    <span class="comment">// 处理UI</span></span><br><span class="line">                &#125;</span><br><span class="line">                PlaybackState.STATE_PAUSED -&gt;&#123;</span><br><span class="line">                    <span class="comment">// 处理UI</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 还有其它状态需要处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 音频信息，音量</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onAudioInfoChanged</span><span class="params">(info: <span class="type">MediaController</span>.<span class="type">PlaybackInfo</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onAudioInfoChanged(info)</span><br><span class="line">            <span class="keyword">val</span> currentVolume = info?.currentVolume</span><br><span class="line">            <span class="comment">// 显示在UI上</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMetadataChanged</span><span class="params">(metadata: <span class="type">MediaMetadata</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onMetadataChanged(metadata)</span><br><span class="line">            <span class="keyword">val</span> artUri = metadata?.getString(MediaMetadata.METADATA_KEY_ALBUM_ART_URI)</span><br><span class="line">            <span class="comment">// 显示UI上</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSessionEvent</span><span class="params">(event: <span class="type">String</span>, extras: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onSessionEvent(event, extras)</span><br><span class="line">            Log.d(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onSessionEvent: <span class="variable">$event</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> subscribeCallback = <span class="keyword">object</span> : MediaBrowser.SubscriptionCallback() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChildrenLoaded</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            parentId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            children: <span class="type">MutableList</span>&lt;<span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onChildrenLoaded(parentId, children)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onChildrenLoaded</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            parentId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            children: <span class="type">MutableList</span>&lt;<span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">            options: <span class="type">Bundle</span></span></span></span><br><span class="line"><span class="params"><span class="function">        )</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onChildrenLoaded(parentId, children, options)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(parentId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onError(parentId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> itemCallback = <span class="keyword">object</span> : MediaBrowser.ItemCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onItemLoaded</span><span class="params">(item: <span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>?)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onItemLoaded(item)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(mediaId: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onError(mediaId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>服务端源码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> FOLDERS_ID = <span class="string">&quot;__FOLDERS__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ARTISTS_ID = <span class="string">&quot;__ARTISTS__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ALBUMS_ID = <span class="string">&quot;__ALBUMS__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> GENRES_ID = <span class="string">&quot;__GENRES__&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> ROOT_ID = <span class="string">&quot;__ROOT__&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaService</span> : <span class="type">MediaBrowserService</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制是否允许客户端连接，并返回root media id给客户端</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGetRoot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        clientPackageName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        clientUid: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        rootHints: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: BrowserRoot? &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onGetRoot: <span class="variable">$rootHints</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> BrowserRoot(ROOT_ID, <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理客户端的订阅信息</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLoadChildren</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        parentId: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        result: <span class="type">Result</span>&lt;<span class="type">MutableList</span>&lt;<span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>&gt;&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onLoadChildren: <span class="variable">$parentId</span>&quot;</span>)</span><br><span class="line">        result.detach()</span><br><span class="line">        <span class="keyword">when</span> (parentId) &#123;</span><br><span class="line">            ROOT_ID -&gt; &#123;</span><br><span class="line">                result.sendResult(<span class="literal">null</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            FOLDERS_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ALBUMS_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            ARTISTS_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            GENRES_ID -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onLoadItem</span><span class="params">(itemId: <span class="type">String</span>?, result: <span class="type">Result</span>&lt;<span class="type">MediaBrowser</span>.<span class="type">MediaItem</span>&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onLoadItem(itemId, result)</span><br><span class="line">        Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onLoadItem: <span class="variable">$itemId</span>&quot;</span>)</span><br><span class="line">        <span class="comment">// 根据itemId，返回对用MediaItem</span></span><br><span class="line">        result?.detach()</span><br><span class="line">        result?.sendResult(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mediaSession: MediaSession;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        mediaSession = MediaSession(<span class="keyword">this</span>, <span class="string">&quot;TAG&quot;</span>)</span><br><span class="line">        mediaSession.setCallback(callback)</span><br><span class="line">        <span class="comment">// 设置token</span></span><br><span class="line">        sessionToken = mediaSession.sessionToken</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与MediaController.transportControls中的方法是一一对应的。</span></span><br><span class="line">    <span class="comment">// 在该方法中实现对 播放器 的控制，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> callback = <span class="keyword">object</span> : MediaSession.Callback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPlay</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onPlay()</span><br><span class="line">            <span class="comment">// 处理 播放器 的播放逻辑。</span></span><br><span class="line">            <span class="comment">// 车载应用的话，别忘了处理音频焦点</span></span><br><span class="line">            Log.e(<span class="string">&quot;TAG&quot;</span>, <span class="string">&quot;onPlay:&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (!mediaSession.isActive) &#123;</span><br><span class="line">                mediaSession.isActive = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新状态</span></span><br><span class="line">            <span class="keyword">val</span> state = PlaybackState.Builder()</span><br><span class="line">                .setState(</span><br><span class="line">                    PlaybackState.STATE_PLAYING, <span class="number">1</span>, <span class="number">1f</span></span><br><span class="line">                )</span><br><span class="line">                .build()</span><br><span class="line">            mediaSession.setPlaybackState(state)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onPause()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onStop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还有其它方法需要复写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的代码只是帮助理解MediaSession框架的通信过程，本身的功能非常的简陋。</p>
<h1 id="MediaSession相关API列表"><a href="#MediaSession相关API列表" class="headerlink" title="MediaSession相关API列表"></a>MediaSession相关API列表</h1><h2 id="MediaBrowser-相关组件-API-列表"><a href="#MediaBrowser-相关组件-API-列表" class="headerlink" title="MediaBrowser 相关组件 API 列表"></a>MediaBrowser 相关组件 API 列表</h2><h3 id="MediaBrowser"><a href="#MediaBrowser" class="headerlink" title="MediaBrowser"></a>MediaBrowser</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>void connect()</td>
<td>连接到媒体浏览器服务。</td>
</tr>
<tr>
<td>void disconnect()</td>
<td>断开与媒体浏览器服务的连接。</td>
</tr>
<tr>
<td>Bundle getExtras()</td>
<td>获取介质服务的任何附加信息。</td>
</tr>
<tr>
<td>void getItem(String mediaId, MediaBrowser.ItemCallback cb)</td>
<td>从连接的服务中检索特定的MediaItem</td>
</tr>
<tr>
<td>String getRoot()</td>
<td>获取根ID。</td>
</tr>
<tr>
<td>ComponentName getServiceComponent()</td>
<td>获取媒体浏览器连接到的服务组件。</td>
</tr>
<tr>
<td>MediaSession.Token getSessionToken()</td>
<td>获取与媒体浏览器关联的媒体会话Token。</td>
</tr>
<tr>
<td>boolean isConnected()</td>
<td>返回浏览器是否连接到服务。</td>
</tr>
<tr>
<td>void subscribe(String parentId,Bundle options, MediaBrowser.SubscriptionCallback callback)</td>
<td>使用特定于服务的参数进行查询，以获取有关指定 ID 中包含的媒体项的信息，并订阅以在更新更改时接收更新。</td>
</tr>
<tr>
<td>void subscribe(String parentId, MediaBrowser.SubscriptionCallback callback)</td>
<td>询有关包含在指定 ID 中的媒体项的信息，并订阅以在更改时接收更新。</td>
</tr>
<tr>
<td>void unsubscribe(String parentId)</td>
<td>取消订阅指定媒体 ID 。</td>
</tr>
<tr>
<td>void unsubscribe(String parentId, MediaBrowser.SubscriptionCallback callback)</td>
<td>通过回调取消订阅对指定媒体 ID。</td>
</tr>
</tbody></table>
<h3 id="MediaBrowser-ConnectionCallback-1"><a href="#MediaBrowser-ConnectionCallback-1" class="headerlink" title="MediaBrowser.ConnectionCallback"></a>MediaBrowser.ConnectionCallback</h3><table>
<thead>
<tr>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>onConnected()</td>
<td>与MediaBrowserService连接成功。在调用<code>MediaBrowser.connect()</code>后才会有回调。</td>
</tr>
<tr>
<td>onConnectionFailed()</td>
<td>与MediaBrowserService连接失败。</td>
</tr>
<tr>
<td>onConnectionSuspended()</td>
<td>与MediaBrowserService连接断开。</td>
</tr>
</tbody></table>
<h3 id="MediaBrowser-ItemCallback-1"><a href="#MediaBrowser-ItemCallback-1" class="headerlink" title="MediaBrowser. ItemCallback"></a>MediaBrowser. ItemCallback</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>onError(String mediaId)</td>
<td>检索时出错，或者连接的服务不支持时回调。</td>
</tr>
<tr>
<td>onItemLoaded(MediaBrowser.MediaItem item)</td>
<td>返回Item时调用。</td>
</tr>
</tbody></table>
<h3 id="MediaBrowser-MediaItem-1"><a href="#MediaBrowser-MediaItem-1" class="headerlink" title="MediaBrowser. MediaItem"></a>MediaBrowser. MediaItem</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>int describeContents()</td>
<td>描述此可打包实例的封送处理表示中包含的特殊对象的种类。</td>
</tr>
<tr>
<td><a href="https://developer.android.google.cn/reference/android/media/MediaDescription">MediaDescription</a> getDescription()</td>
<td>获取介质的说明。包含媒体的基础信息如：标题、封面等等。</td>
</tr>
<tr>
<td>int getFlags()</td>
<td>获取项的标志。<code>FLAG_BROWSABLE</code>：表示Item具有自己的子项。<code>FLAG_PLAYABLE</code>：表示Item可播放</td>
</tr>
<tr>
<td>String getMediaId()</td>
<td>返回此项的媒体 ID。</td>
</tr>
<tr>
<td>boolean isBrowsable()</td>
<td>返回此项目是否可浏览。</td>
</tr>
<tr>
<td>boolean isPlayable()</td>
<td>返回此项是否可播放。</td>
</tr>
</tbody></table>
<h3 id="MediaBrowser-SubscriptionCallback-1"><a href="#MediaBrowser-SubscriptionCallback-1" class="headerlink" title="MediaBrowser.SubscriptionCallback"></a>MediaBrowser.SubscriptionCallback</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>onChildrenLoaded(String parentId, List&lt;MediaBrowser.MediaItem&gt; children)</td>
<td>在加载或更新子项列表时回调。</td>
</tr>
<tr>
<td>onChildrenLoaded(String parentId, List&lt;MediaBrowser.MediaItem&gt; children,Bundle options)</td>
<td>在加载或更新子项列表时回调。</td>
</tr>
<tr>
<td>onError(String parentId)</td>
<td>当 ID 不存在或订阅时出现其他错误时回调。</td>
</tr>
<tr>
<td>onError(String parentId, Bundle options)</td>
<td>当 ID 不存在或订阅时出现其他错误时回调。</td>
</tr>
</tbody></table>
<h2 id="MediaController-相关组件-API-列表"><a href="#MediaController-相关组件-API-列表" class="headerlink" title="MediaController 相关组件 API 列表"></a>MediaController 相关组件 API 列表</h2><h3 id="MediaController-1"><a href="#MediaController-1" class="headerlink" title="MediaController"></a>MediaController</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>void adjustVolume (int direction, int flags)</td>
<td>调整此会话正在播放的输出的音量。</td>
</tr>
<tr>
<td>boolean dispatchMediaButtonEvent (KeyEvent keyEvent)</td>
<td>将指定的媒体按钮事件发送到会话。</td>
</tr>
<tr>
<td>Bundle getExtras()</td>
<td>获取此会话的附加内容。</td>
</tr>
<tr>
<td>long getFlags()</td>
<td>获取此会话的标志。</td>
</tr>
<tr>
<td>MediaMetadata getMetadata()</td>
<td>获取此会话的当前Metadata。</td>
</tr>
<tr>
<td>String getPackageName()</td>
<td>获取会话所有者的程序包名称。</td>
</tr>
<tr>
<td>MediaController.PlaybackInfo getPlaybackInfo()</td>
<td>获取此会话的当前播放信息。</td>
</tr>
<tr>
<td>PlaybackState getPlaybackState()</td>
<td>获取此会话的当前播放状态。</td>
</tr>
<tr>
<td>List&lt;MediaSession.QueueItem&gt; getQueue()</td>
<td>获取此会话的当前播放队列（如果已设置）。</td>
</tr>
<tr>
<td>CharSequence getQueueTitle()</td>
<td>获取此会话的队列标题。</td>
</tr>
<tr>
<td>int getRatingType()</td>
<td>获取会话支持的评级类型。</td>
</tr>
<tr>
<td>PendingIntent getSessionActivity()</td>
<td>获取启动与此会话关联的 UI 的意图（如果存在）。</td>
</tr>
<tr>
<td>Bundle getSessionInfo()</td>
<td>获取创建会话时设置的其他会话信息。</td>
</tr>
<tr>
<td>MediaSession.Token getSessionToken()</td>
<td>获取连接到的会话的令牌。</td>
</tr>
<tr>
<td>String getTag()</td>
<td>获取会话的标记以进行调试。</td>
</tr>
<tr>
<td>MediaController.TransportControls getTransportControls()</td>
<td>获取TransportControls实例以将控制操作发送到关联的会话。</td>
</tr>
<tr>
<td>void registerCallback (MediaController.Callback callback, Handler handler)</td>
<td>注册回调以从会话接收更新。</td>
</tr>
<tr>
<td>void registerCallback (MediaController.Callback callback)</td>
<td>注册回调以从会话接收更新。</td>
</tr>
<tr>
<td>void sendCommand (String command, Bundle args, ResultReceiver cb)</td>
<td>向会话发送通用命令。</td>
</tr>
<tr>
<td>void setVolumeTo (int value, int flags)</td>
<td>设置此会话正在播放的输出的音量。</td>
</tr>
<tr>
<td>void unregisterCallback (MediaController.Callback callback)</td>
<td>注销指定的回调。</td>
</tr>
</tbody></table>
<h3 id="MediaController-Callback-1"><a href="#MediaController-Callback-1" class="headerlink" title="MediaController.Callback"></a>MediaController.Callback</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>void onAudioInfoChanged (MediaController.PlaybackInfo info)</td>
<td>当前音频信息发生改变。</td>
</tr>
<tr>
<td>void onExtrasChanged (Bundle extras)</td>
<td>当前附加内容发生改变。</td>
</tr>
<tr>
<td>void onMetadataChanged (MediaMetadata metadata)</td>
<td>当前Metadata发生改变。</td>
</tr>
<tr>
<td>void onPlaybackStateChanged(PlaybackState state)</td>
<td>当前播放状态发生改变。客户端通过该回调来显示界面上音视频的播放状态。</td>
</tr>
<tr>
<td>void onQueueChanged (List&lt;MediaSession.QueueItem&gt; queue)</td>
<td>当前队列中项目发生改变。</td>
</tr>
<tr>
<td>void onQueueTitleChanged (CharSequence title)</td>
<td>当前队列标题发生改变。</td>
</tr>
<tr>
<td>void onSessionDestroyed()</td>
<td>会话销毁。</td>
</tr>
<tr>
<td>void onSessionEvent (String event, Bundle extras)</td>
<td>MediaSession所有者发送的自定义事件。</td>
</tr>
</tbody></table>
<h3 id="MediaController-PlaybackInfo-1"><a href="#MediaController-PlaybackInfo-1" class="headerlink" title="MediaController. PlaybackInfo"></a>MediaController. PlaybackInfo</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>AudioAttributes getAudioAttributes()</td>
<td>获取此会话的音频属性。</td>
</tr>
<tr>
<td>int getCurrentVolume()</td>
<td>获取此会话的当前音量。</td>
</tr>
<tr>
<td>int getMaxVolume()</td>
<td>获取可为此会话设置的最大音量。</td>
</tr>
<tr>
<td>int getPlaybackType()</td>
<td>获取影响音量处理的播放类型。</td>
</tr>
<tr>
<td>int getVolumeControl()</td>
<td>获取可以使用的音量控件的类型。</td>
</tr>
<tr>
<td>String getVolumeControlId()</td>
<td>获取此会话的音量控制 ID。</td>
</tr>
</tbody></table>
<h3 id="MediaController-TransportControls-1"><a href="#MediaController-TransportControls-1" class="headerlink" title="MediaController. TransportControls"></a>MediaController. TransportControls</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>void fastForward()</td>
<td>开始快进。</td>
</tr>
<tr>
<td>void pause()</td>
<td>请求播放器暂停播放并保持在当前位置。</td>
</tr>
<tr>
<td>void play()</td>
<td>请求播放器在其当前位置开始播放。</td>
</tr>
<tr>
<td>void playFromMediaId (String mediaId, Bundle extras)</td>
<td>请求播放器开始播放特定媒体 ID。</td>
</tr>
<tr>
<td>void playFromSearch (String query, Bundle extras)</td>
<td>请求播放器开始播放特定的搜索查询。</td>
</tr>
<tr>
<td>void playFromUri (Uri uri, Bundle extras)</td>
<td>请求播放器开始播放特定Uri。</td>
</tr>
<tr>
<td>void prepare()</td>
<td>请求播放器准备播放。</td>
</tr>
<tr>
<td>void prepareFromMediaId (String mediaId, Bundle extras)</td>
<td>请求播放器为特定媒体 ID 准备播放。</td>
</tr>
<tr>
<td>void prepareFromSearch (String query, Bundle extras)</td>
<td>请求播放器为特定搜索查询准备播放。</td>
</tr>
<tr>
<td>void prepareFromUri (Uri uri, Bundle extras)</td>
<td>请求播放器为特定Uri。</td>
</tr>
<tr>
<td>void rewind()</td>
<td>开始倒带。</td>
</tr>
<tr>
<td>void seekTo(long pos)</td>
<td>移动到媒体流中的新位置。</td>
</tr>
<tr>
<td>void sendCustomAction (PlaybackState.CustomAction customAction, Bundle args)</td>
<td>发送自定义操作以供MediaSession执行。</td>
</tr>
<tr>
<td>void sendCustomAction (String action,Bundle args)</td>
<td>将自定义操作中的 id 和 args 发送回去，以便MediaSession执行。</td>
</tr>
<tr>
<td>void setPlaybackSpeed (float speed)</td>
<td>设置播放速度。</td>
</tr>
<tr>
<td>void setRating(Rating rating)</td>
<td>对当前内容进行评级。</td>
</tr>
<tr>
<td>void skipToNext()</td>
<td>跳到下一项。</td>
</tr>
<tr>
<td>void skipToPrevious()</td>
<td>跳到上一项。</td>
</tr>
<tr>
<td>void skipToQueueItem(long id)</td>
<td>在播放队列中播放具有特定 ID 的项目。</td>
</tr>
<tr>
<td>void stop()</td>
<td>请求播放器停止播放;它可以以任何适当的方式清除其状态。</td>
</tr>
</tbody></table>
<h2 id="MediaBrowserService-相关组件-API-列表"><a href="#MediaBrowserService-相关组件-API-列表" class="headerlink" title="MediaBrowserService 相关组件 API 列表"></a>MediaBrowserService 相关组件 API 列表</h2><h3 id="MediaBrowserService"><a href="#MediaBrowserService" class="headerlink" title="MediaBrowserService"></a>MediaBrowserService</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>final Bundle getBrowserRootHints()</td>
<td>获取从当前连接 MediaBrowser的发送的根提示。</td>
</tr>
<tr>
<td>final MediaSessionManager.RemoteUserInfo getCurrentBrowserInfo()</td>
<td>获取发送当前请求的浏览器信息。</td>
</tr>
<tr>
<td>MediaSession.Token getSessionToken()</td>
<td>获取会话令牌，如果尚未创建会话令牌或已销毁会话令牌，则获取 null。</td>
</tr>
<tr>
<td>void notifyChildrenChanged(String parentId)</td>
<td>通知所有连接的媒体浏览器指定父 ID 的子级已经更改。</td>
</tr>
<tr>
<td>void notifyChildrenChanged(String parentId, Bundle options)</td>
<td>通知所有连接的媒体浏览器指定父 ID 的子级已经更改。</td>
</tr>
<tr>
<td>abstract MediaBrowserService.BrowserRoot onGetRoot(String clientPackageName,int clientUid, Bundle rootHints)</td>
<td>获取供特定客户端浏览的根信息。由<code>MediaBrowser.connect</code>触发，可以通过返回null拒绝客户端的连接。</td>
</tr>
<tr>
<td>abstract void onLoadChildren(String parentId, Result&lt;List&lt;MediaBrowser.MediaItem&gt;&gt; result)</td>
<td>获取有关媒体项的子项的信息。由<code>MediaBrowser.subscribe</code>触发。</td>
</tr>
<tr>
<td>void onLoadChildren(String parentId, Result&lt;List&lt;MediaBrowser.MediaItem&gt;&gt; result,Bundle options)</td>
<td>获取有关媒体项的子项的信息。由<code>MediaBrowser.subscribe</code>触发。</td>
</tr>
<tr>
<td>void onLoadItem(String itemId, Result&lt;MediaBrowser.MediaItem&gt; result)</td>
<td>获取有关特定媒体项的信息。由<code>MediaBrowser.getItem</code>触发。</td>
</tr>
<tr>
<td>void setSessionToken(MediaSession.Token token)</td>
<td>设置媒体会话。</td>
</tr>
</tbody></table>
<h3 id="MediaBrowserService-BrowserRoot-1"><a href="#MediaBrowserService-BrowserRoot-1" class="headerlink" title="MediaBrowserService.BrowserRoot"></a>MediaBrowserService.BrowserRoot</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Bundle getExtras()</td>
<td>获取有关浏览器服务的附加信息。</td>
</tr>
<tr>
<td>String getRootId()</td>
<td>获取用于浏览的根 ID。</td>
</tr>
</tbody></table>
<h3 id="MediaBrowserService-Result-1"><a href="#MediaBrowserService-Result-1" class="headerlink" title="MediaBrowserService.Result"></a>MediaBrowserService.Result</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>void detach()</td>
<td>将此消息与当前线程分离，并允许稍后进行调用sendResult(T)</td>
</tr>
<tr>
<td>void sendResult(T result)</td>
<td>将结果发送回调用方。</td>
</tr>
</tbody></table>
<h2 id="MediaSession-相关组件-API-列表"><a href="#MediaSession-相关组件-API-列表" class="headerlink" title="MediaSession 相关组件 API 列表"></a>MediaSession 相关组件 API 列表</h2><h3 id="MediaSession-1"><a href="#MediaSession-1" class="headerlink" title="MediaSession"></a>MediaSession</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>MediaController getController()</td>
<td>获取此会话的控制器。</td>
</tr>
<tr>
<td>MediaSessionManager.RemoteUserInfo getCurrentControllerInfo()</td>
<td>获取发送当前请求的控制器信息。</td>
</tr>
<tr>
<td>MediaSession.Token getSessionToken()</td>
<td>获取此会话令牌对象。</td>
</tr>
<tr>
<td>boolean isActive()</td>
<td>获取此会话的当前活动状态。</td>
</tr>
<tr>
<td>void release()</td>
<td>当应用完成播放时，必须调用此项。</td>
</tr>
<tr>
<td>void sendSessionEvent (String event, Bundle extras)</td>
<td>将专有事件发送给监听此会话的所有MediaController。会触发MediaController.Callback.onSessionEvent。</td>
</tr>
<tr>
<td>void setActive(boolean active)</td>
<td>设置此会话当前是否处于活动状态并准备好接收命令。</td>
</tr>
<tr>
<td>void setCallback (MediaSession.Callback callback)</td>
<td>设置回调以接收媒体会话的更新。</td>
</tr>
<tr>
<td>void setCallback (MediaSession.Callback callback,Handler handler)</td>
<td>设置回调以接收媒体会话的更新。</td>
</tr>
<tr>
<td>void setExtras(Bundle extras)</td>
<td>设置一些可与MediaSession关联的附加功能。</td>
</tr>
<tr>
<td>void setFlags(int flags)</td>
<td>为会话设置标志。</td>
</tr>
<tr>
<td>void setMediaButtonBroadcastReceiver(ComponentName broadcastReceiver)</td>
<td>设置应接收媒体按钮的清单声明类的组件名称。</td>
</tr>
<tr>
<td>void setMediaButtonReceiver(PendingIntent mbr)</td>
<td>此方法在 API 级别 31 中已弃用。改用setMediaButtonBroadcastReceiver（android.content.ComponentName）。</td>
</tr>
<tr>
<td>void setMetadata(MediaMetadata metadata)</td>
<td>更新当前MediaMetadata。</td>
</tr>
<tr>
<td>void setPlaybackState(PlaybackState state)</td>
<td>更新当前播放状态。</td>
</tr>
<tr>
<td>void setPlaybackToLocal(AudioAttributes attributes)</td>
<td>设置此会话音频的属性。</td>
</tr>
<tr>
<td>void setPlaybackToRemote(VolumeProvider volumeProvider)</td>
<td>将此会话配置为使用远程音量处理。</td>
</tr>
<tr>
<td>void setQueue(List&lt;MediaSession.QueueItem&gt; queue)</td>
<td>更新播放队列中的项目列表。</td>
</tr>
<tr>
<td>void setQueueTitle(CharSequence title)</td>
<td>设置播放队列的标题。</td>
</tr>
<tr>
<td>void setRatingType(int type)</td>
<td>设置此会话使用的评级样式。</td>
</tr>
<tr>
<td>void setSessionActivity(PendingIntent pi)</td>
<td>设置启动此会话的Activity的Intent。</td>
</tr>
</tbody></table>
<h3 id="MediaSession-Callback-1"><a href="#MediaSession-Callback-1" class="headerlink" title="MediaSession.Callback"></a>MediaSession.Callback</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>void onCommand(String command,Bundle args,ResultReceiver cb)</td>
<td>当控制器已向此会话发送命令时调用。</td>
</tr>
<tr>
<td>void onCustomAction(String action, Bundle extras)</td>
<td>当要执行MediaControllerPlaybackState.CustomAction时调用。</td>
</tr>
<tr>
<td>void onFastForward()</td>
<td>处理快进请求。</td>
</tr>
<tr>
<td>boolean onMediaButtonEvent(Intent mediaButtonIntent)</td>
<td>当按下媒体按钮并且此会话具有最高优先级或控制器向会话发送媒体按钮事件时调用。</td>
</tr>
<tr>
<td>void onPause()</td>
<td>处理暂停播放的请求。</td>
</tr>
<tr>
<td>void onPlay()</td>
<td>处理开始播放的请求。</td>
</tr>
<tr>
<td>void onPlayFromMediaId(String mediaId, Bundle extras)</td>
<td>处理播放应用提供的特定mediaId的播放请求。</td>
</tr>
<tr>
<td>void onPlayFromSearch(String query, Bundle extras)</td>
<td>处理从搜索查询开始播放的请求。</td>
</tr>
<tr>
<td>void onPlayFromUri(Uri uri, Bundle extras)</td>
<td>处理播放由URI表示的特定媒体项的请求。</td>
</tr>
<tr>
<td>void onPrepare()</td>
<td>处理准备播放的请求。</td>
</tr>
<tr>
<td>void onPrepareFromMediaId(String mediaId, Bundle extras)</td>
<td>处理应用提供的特定mediaId的准备播放请求</td>
</tr>
<tr>
<td>void onPrepareFromSearch(String query, Bundle extras)</td>
<td>处理准备从搜索查询播放的请求。</td>
</tr>
<tr>
<td>void onPrepareFromUri(Uri uri, Bundle extras)</td>
<td>处理由URI表示的特定媒体项的准备请求。</td>
</tr>
<tr>
<td>void onRewind()</td>
<td>处理倒带请求。</td>
</tr>
<tr>
<td>void onSeekTo(long pos)</td>
<td>处理跳转到特定位置的请求。</td>
</tr>
<tr>
<td>void onSetPlaybackSpeed(float speed)</td>
<td>处理修改播放速度的请求。</td>
</tr>
<tr>
<td>void onSetRating(Rating rating)</td>
<td>处理设定评级的请求。</td>
</tr>
<tr>
<td>void onSkipToNext()</td>
<td>处理要跳到下一个媒体项的请求。</td>
</tr>
<tr>
<td>void onSkipToPrevious()</td>
<td>处理要跳到上一个媒体项的请求。</td>
</tr>
<tr>
<td>void onSkipToQueueItem(long id)</td>
<td>处理跳转到播放队列中具有给定 ID 的项目的请求。</td>
</tr>
<tr>
<td>void onStop()</td>
<td>处理停止播放的请求。</td>
</tr>
</tbody></table>
<h3 id="MediaSession-QueueItem-1"><a href="#MediaSession-QueueItem-1" class="headerlink" title="MediaSession.QueueItem"></a>MediaSession.QueueItem</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://developer.android.google.cn/reference/android/media/MediaDescription">MediaDescription</a> getDescription()</td>
<td>返回介质的说明。包含媒体的基础信息如：标题、封面等等。</td>
</tr>
<tr>
<td>long getQueueId()</td>
<td>获取此项目的队列 ID。</td>
</tr>
</tbody></table>
<h2 id="PlaybackState-相关组件-API-列表"><a href="#PlaybackState-相关组件-API-列表" class="headerlink" title="PlaybackState 相关组件 API 列表"></a>PlaybackState 相关组件 API 列表</h2><h3 id="PlaybackState"><a href="#PlaybackState" class="headerlink" title="PlaybackState"></a>PlaybackState</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>long getActions()</td>
<td>获取此会话上可用的当前操作。</td>
</tr>
<tr>
<td>long getActiveQueueItemId()</td>
<td>获取队列中当前活动项的 ID。</td>
</tr>
<tr>
<td>long getBufferedPosition()</td>
<td>获取当前缓冲位置（以毫秒为单位）。</td>
</tr>
<tr>
<td>List&lt;PlaybackState.CustomAction&gt; getCustomActions()</td>
<td>获取自定义操作的列表。</td>
</tr>
<tr>
<td>CharSequence getErrorMessage()</td>
<td>获取用户可读的错误消息。</td>
</tr>
<tr>
<td>Bundle getExtras()</td>
<td>获取在此播放状态下设置的任何自定义附加内容。</td>
</tr>
<tr>
<td>long getLastPositionUpdateTime()</td>
<td>获取上次更新位置的经过的实时时间。</td>
</tr>
<tr>
<td>float getPlaybackSpeed()</td>
<td>获取当前播放速度作为正常播放的倍数。</td>
</tr>
<tr>
<td>long getPosition()</td>
<td>获取当前播放位置（以毫秒为单位）。</td>
</tr>
<tr>
<td>int getState()</td>
<td>获取当前播放状态。</td>
</tr>
<tr>
<td>boolean isActive()</td>
<td>返回是否将其视为活动播放状态。</td>
</tr>
</tbody></table>
<h3 id="PlaybackState-Builder-1"><a href="#PlaybackState-Builder-1" class="headerlink" title="PlaybackState.Builder"></a>PlaybackState.Builder</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>PlaybackState.Builder addCustomAction(String action, String name, int icon)</td>
<td>将自定义操作添加到播放状态。</td>
</tr>
<tr>
<td>PlaybackState.Builder addCustomAction (PlaybackState.CustomAction customAction)</td>
<td>将自定义操作添加到播放状态。</td>
</tr>
<tr>
<td>PlaybackState.Builder setActions(long actions)</td>
<td>设置此会话上可用的当前操作。</td>
</tr>
<tr>
<td>PlaybackState.Builder setActiveQueueItemId(long id)</td>
<td>通过指定活动项目的 id 来设置播放队列中的活动项目。</td>
</tr>
<tr>
<td>PlaybackState.Builder setBufferedPosition(long bufferedPosition)</td>
<td>设置当前缓冲位置（以毫秒为单位）。</td>
</tr>
<tr>
<td>PlaybackState.Builder setErrorMessage(CharSequence error)</td>
<td>设置用户可读的错误消息。</td>
</tr>
<tr>
<td>PlaybackState.Builder setExtras(Bundle extras)</td>
<td>设置要包含在播放状态中的任何自定义附加内容。</td>
</tr>
<tr>
<td>PlaybackState.Builder setState(int state, long position, float playbackSpeed)</td>
<td>设置当前播放状态。</td>
</tr>
<tr>
<td>PlaybackState.Builder setState(int state, long position, float playbackSpeed, long updateTime)</td>
<td>设置当前播放状态。</td>
</tr>
<tr>
<td>PlaybackState build()</td>
<td>生成并返回具有这些值的PlaybackState实例。</td>
</tr>
</tbody></table>
<h3 id="PlaybackState-CustomAction-1"><a href="#PlaybackState-CustomAction-1" class="headerlink" title="PlaybackState.CustomAction"></a>PlaybackState.CustomAction</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>String getAction()</td>
<td>返回CustomAction的action。</td>
</tr>
<tr>
<td>Bundle getExtras()</td>
<td>返回附加项，这些附加项提供有关操作的其他特定于应用程序的信息，如果没有，则返回 null。</td>
</tr>
<tr>
<td>int getIcon()</td>
<td>返回package中图标的资源 ID。</td>
</tr>
<tr>
<td>CharSequence getName()</td>
<td>返回此操作的显示名称。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Android系统开发</category>
        <category>车联网</category>
      </categories>
      <tags>
        <tag>AOSP</tag>
        <tag>车载多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Context详解</title>
    <url>/2017/09/14/android_context_introduction/</url>
    <content><![CDATA[<p>我们最常用的Activity，Service，Application都是Context的子类。所以知道Context的具体实现是非常有必要的。</p>
<span id="more"></span>

<h1 id="Context体系结构"><a href="#Context体系结构" class="headerlink" title="Context体系结构"></a>Context体系结构</h1><p><img src="/images/android_context_introduction01.png" alt="image"></p>
<p>Context本身是一个抽象类。他的实现类是ContextImpl。而ContextWrapper是一个包装类（装饰设计模式）。在我们用IDE查看Context继承关系的时候，我们是不能直接看到ContextImpl这个类的，通过这种手段让程序员不能直接看到ContextImpl这个类，而只能看到ContextWrapper这个类。但如果我们真的要想弄明白Context原理的话，ContextImpl才是最重要的，而ContextWrapper只是个外壳而已。</p>
<p>ContextWrapper的子类我们非常熟悉了，Application,Service,ContextThemeWrapper。前两个就不用多说了，ContextThemeWrapper其实我们也不用太关心，有需要的时候可以看看，就是和主题相关的，他的子类Activity也不用多说。所以其实最核心的类就是ContextImpl类。</p>
<p>Context类是一个抽象类，差不多有5000多行，而且几乎都是没有实现的抽象方法，并且差不多4000多行都是注释。真正的内容可能1000行不到。所以Context类几乎就是一个接口说明文档。而ContextImpl也才2700多行。而且很多都是get方法。ContextImpl类继承了抽象类Context并且实现所有的抽象方法，并且自身还实现了很多get，create,check开头的方法，即使这样，也才2700行代码。要理解Context，核心也就在这2700行代码了（很多是get方法），而且还有Context这个文档说明类。</p>
<p>在这2700行代码里面，最重要的是 ActivityThread mMainThread;这个全局变量。他被用的地方最多。<br>我们最常看到的getApplicationContext，startActivity，getMainLooper都是在这里实现，实现方法也非常的简单。这都是ActivityThread封装好的，具体内容需要看ActivityThread这个类。这里不展开，会写一篇文章专门讨论。其中绝大部分使用和广播有光，如果专门需要研究广播的时候可以看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMainThread.getLooper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPackageInfo != <span class="keyword">null</span>) ?</span><br><span class="line">        mPackageInfo.getApplication() : mMainThread.getApplication();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, Bundle options)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line"></span><br><span class="line">    mMainThread.getInstrumentation().execStartActivity(</span><br><span class="line">        getOuterContext(), mMainThread.getApplicationThread(), <span class="keyword">null</span>,</span><br><span class="line">        (Activity) <span class="keyword">null</span>, intent, -<span class="number">1</span>, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//差不多有10个类似方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent, String receiverPermission, <span class="keyword">int</span> appOp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ActivityManager.getService().broadcastIntent(</span><br><span class="line">        mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">        Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, receiverPermissions, appOp, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">        getUserId());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二重要的是LoadedApk mPackageInfo 这个变量，因为他被引用的次数是第二多的，要么通过mPackageInfo获取一些内容，要么通过他做判断。当然，这些功能也都是LoadedApk这个类封装的，通过他的名字也就知道他是干嘛的，这个类可以管理运行的.apk文件。这个类的详细说明也可以单独写一篇文章。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Context <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mPackageInfo != <span class="keyword">null</span>) ?</span><br><span class="line">        mPackageInfo.getApplication() : mMainThread.getApplication();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPackageName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageInfo.getPackageName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No mPackageInfo means this is a Context for the system itself,</span></span><br><span class="line">    <span class="comment">// and this here is its name.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;android&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ApplicationInfo <span class="title">getApplicationInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageInfo.getApplicationInfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Not supported in system context&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPackageResourcePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mPackageInfo.getResDir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Not supported in system context&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//差不多有10个</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendOrderedBroadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多处用mPackageInfo做判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Context的不同获取方法的区别"><a href="#Context的不同获取方法的区别" class="headerlink" title="Context的不同获取方法的区别"></a>Context的不同获取方法的区别</h1><p>context的获取可以通过以下方法：</p>
<ul>
<li><p>getContext()</p>
</li>
<li><p>getBaseContxet()</p>
</li>
<li><p>getApplication</p>
</li>
<li><p>getApplicationContext</p>
</li>
</ul>
<p>这几个对于新手来说，非常的迷惑。到底有说明区别？</p>
<p>先说说<strong>getApplication</strong>和<strong>getApplicationContext</strong>的区别。如果你在Activity里面打印这个两个方法的话，得到对象内存地址是一样的，也就是这两个方法获取的对象是一样的？实际上，这两个获取到的对象就是同一个对象。只是可以使用的范围是不一样的，getApplication这个方法只有Activity和Service才有,要想在别的地方获取Application就只能通过getApplicationContext获取。也就是他们几乎是等价的。唯一的区别就是有没有getApplication这个方法给你用而已。</p>
<p><strong>getContext()</strong>,<strong>getBaseContxet()</strong>,<strong>getApplicationContext</strong><br>这三个有什么区别？<br>首先Activity,Service和Application都有getBaseContxet(),getApplicationContext()这两个方法。但没有getContext方法。在Fragment中，才有getContext方法。而Fragment的getContext方法获取的对象是他的寄主对象，也就是Activity。如果查看getContext源码，在一系列包装后，实际上获取的就是他所在的Activity对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    @<span class="title">Override</span></span></span><br><span class="line"><span class="class">    <span class="title">protected</span> <span class="title">void</span> <span class="title">onCreate</span>(<span class="title">Bundle</span> <span class="title">savedInstanceState</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;getBaseContext():&quot;</span> + getBaseContext());<span class="comment">//ContextImpl对象</span></span><br><span class="line">        Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;getApplicationContext():&quot;</span> + getApplicationContext());</span><br><span class="line">        Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;getApplication():&quot;</span> + getApplication());</span><br><span class="line">        Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;this:&quot;</span> + <span class="keyword">this</span>);<span class="comment">//Activity对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlankFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.d(<span class="string">&quot;BlankFragment&quot;</span>, <span class="string">&quot;getContext():&quot;</span> + getContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">getBaseContext():androidx.appcompat.view.ContextThemeWrapper@72a2522</span><br><span class="line">getApplicationContext():android.app.Application@e8e5bb3</span><br><span class="line">getApplication():android.app.Application@e8e5bb3</span><br><span class="line">this:com.example.viewpagerdemo.MainActivity@b0be2f</span><br><span class="line">getContext():com.example.viewpagerdemo.MainActivity@b0be2f</span><br></pre></td></tr></table></figure>

<p>在输出中，我们可以看到getContext和MainActivity的this是同一个对象，getApplicationContext和getApplication获取到的也是同一个对象，也是符合我们的证明的。</p>
<h1 id="正确使用Context"><a href="#正确使用Context" class="headerlink" title="正确使用Context"></a>正确使用Context</h1><p> 一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：<br>    1：当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。<br>    2：不要让生命周期长于Activity的对象持有Activity的引用。<br>    3：尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</p>
<h1 id="ContextImpl实例什么时候生成"><a href="#ContextImpl实例什么时候生成" class="headerlink" title="ContextImpl实例什么时候生成"></a>ContextImpl实例什么时候生成</h1><p>   <em>ContextImpl实例生成对应着mBase的赋值过程：</em><br>    在启动Activity时，在ActivityThread内部通过handleLaunchActivity()方法一系列调用，在通过Instrucmentation创建完Activity后，会先调用Activity的attach()方法，会传入已创建好的ContextImpl对象，在Attach()方法内部会先调用attachBaseContext(context)方法，会将ContextImpl通过super.attachBaseContext(context)一步一步最后赋值给ContextWrapper的mBase，接下来再调用activity的onCreate()。</p>
<h1 id="ContentProvider里的Context初始化"><a href="#ContentProvider里的Context初始化" class="headerlink" title="ContentProvider里的Context初始化"></a>ContentProvider里的Context初始化</h1><p>   ContentProvider本身不是Context ，但是它有一个成员变量 mContext ，是通过构造函数传入的。mContext初始化对应着ContentProvider创建时机。<br>    应用创建Application是通过调用 ActivityThread.handleBindApplication方法，这个方法的相关流程有：<br>    <em>创建 Application</em><br>    <em>初始化 Application的Context</em><br>    <em>调用installContentProviders()并传入刚创建好的context来创建ContentProvider</em><br>    <em>调用Application.onCreate()</em><br>    ContentProvider的Context是在Applicaiton创建之后，但是 onCreate方法调用之前初始化的。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Context</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Dalvik虚拟机与类加载机制</title>
    <url>/2018/07/14/android_dalvik_vm_class_loader/</url>
    <content><![CDATA[<p>之前的文章有讲到JVM，JVM是Java Virtual Machine，本质上就是一个软件，JAVA在编译后会生成类似于汇编语言的JVM字节码（.class文件），与C语言编译后产生的汇编语言不同的是，C编译成的汇编语言会直接在硬件上跑，但JAVA编译后生成的字节码是在JVM上跑，需要由JVM把字节码翻译成机器指令，才能使JAVA程序跑起来。JVM的作用是把平台无关的.class里面的字节码翻译成平台相关的机器码，来实现跨平台。</p>
<span id="more"></span>

<p>而本篇要讲的是在Android系统上跑的虚拟机DVM即Dalvik VIrtual Machine。所有安卓程序都运行在安卓系统进程里，每个进程对应着一个Dalvik虚拟机实例。Android应用程序运行在Dalvik/ART虚拟机，并且每一个应用程序对应有一个单独的Dalvik虚拟机实例。Dalvik虚拟机实则也算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。</p>
<p>Dalvik虚拟机与Java虚拟机共享有差不多的特性，差别在于两者执行的指令集是不一样的，前者的指令集是基于<strong>寄存器</strong>的，而后者的指令集是基于<strong>堆栈</strong>的。</p>
<p><img src="/images/android_dalvik_vm_class_loader_jvm_dvm.png" alt="image-20210704141500769"></p>
<h2 id="基于栈的虚拟机"><a href="#基于栈的虚拟机" class="headerlink" title="基于栈的虚拟机"></a>基于栈的虚拟机</h2><p>对于基于栈的虚拟机来说，每一个运行时的线程，都有一个独立的栈。栈中记录了方法调用的历史，每有一次方法调用，栈中便会多一个栈桢。最顶部的栈桢称作当前栈桢，其代表着当前执行的方法。基于栈的虚拟机通过操作数栈进行所有操作。</p>
<p><img src="/images/android_dalvik_vm_class_loader_base_stack.png" alt="image-20210704144455995"></p>
<h2 id="基于寄存器的虚拟机"><a href="#基于寄存器的虚拟机" class="headerlink" title="基于寄存器的虚拟机"></a>基于寄存器的虚拟机</h2><p>寄存器是CPU的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。</p>
<p><img src="/images/android_dalvik_vm_class_loader_base_register.png" alt="image-20210704144636398"></p>
<p>基于寄存器的虚拟机中没有操作数栈，但是有很多虚拟寄存器。其实和操作数栈相同，这些寄存器也存放在运行时栈中，本质上就是一个数组。与JVM相似，在Dalvik VM中每个线程都有自己的PC寄存器和调用栈，方法调用的活动记录以帧为单位保存在调用栈上。</p>
<p><img src="/images/android_dalvik_vm_class_loader_register_voke.png" alt="image-20210704144837931"></p>
<p>与JVM版相比，可以发现Dalvik版程序的指令数明显减少了，数据移动次数也明显减少了。</p>
<h2 id="ART与Dalvik"><a href="#ART与Dalvik" class="headerlink" title="ART与Dalvik"></a>ART与Dalvik</h2><p>Dalvik虚拟机执行的是dex字节码，解释执行。从Android 2.2版本开始，支持JIT即时编译（Just In Time）在程序运行的过程中进行选择热点代码（经常执行的代码）进行编译或者优化。</p>
<p>而ART（Android Runtime） 是在 Android 4.4 中引入的一个开发者选项，也是 Android 5.0 及更高版本的默认 Android 运行时。ART虚拟机执行的是本地机器码。Android的运行时从Dalvik虚拟机替换成ART虚拟机，并不要求开发者将自己的应用直接编译成目标机器码，APK仍然是一个包含dex字节码的文件。</p>
<p>那么，ART虚拟机执行的本地机器码是从哪里来？</p>
<p>Dalvik下应用在安装的过程，会执行一次优化，将dex字节码进行优化生成odex文件。而Art下将应用的dex字节码翻译成本地机器码的最恰当AOT时机也就发生在应用安装的时候。ART 引入了<strong>预先编译机制（Ahead Of Time）</strong>，在安装时，ART 使用设备自带的 **dex2oat **工具来编译应用，dex中的字节码将被编译成本地机器码。</p>
<p><img src="/images/android_dalvik_vm_class_loader_art_oat.png" alt="image-20210704145238126"></p>
<p><strong>ART 使用预先 (AOT) 编译，并且从 Android N混合使用AOT编译，解释和JIT。</strong></p>
<p>1、最初安装应用时不进行任何 AOT 编译（安装又快了），运行过程中解释执行，对经常执行的方法进行JIT，经过 JIT 编译的方法将会记录到<strong>Profile</strong>配置文件中。</p>
<p>2、当设备闲置和充电时，编译守护进程会运行，根据<strong>Profile</strong>文件对常用代码进行 AOT 编译。待下次运行时直接使用。</p>
<p><img src="/images/android_dalvik_vm_class_loader_art_android_n.png" alt="image-20210704145438007"></p>
<h2 id="Android下的类加载机制"><a href="#Android下的类加载机制" class="headerlink" title="Android下的类加载机制"></a>Android下的类加载机制</h2><p><img src="/images/android_dalvik_vm_class_loader_flow.png" alt="image-20210704145747215"></p>
<h3 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h3><p>某个类加载器在加载类时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务或者没有父类加载器时，才自己去加载。</p>
<p><img src="/images/android_dalvik_vm_class_loader_parent_code.png" alt="image-20210704145929618"></p>
<p>这种机制的好处：</p>
<p>1、避免重复加载，当父加载器已经加载了该类的时候，就没有必要子ClassLoader再加载一次。</p>
<p>2、安全性考虑，防止核心API库被随意篡改。</p>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><p><img src="/images/android_dalvik_vm_class_loader_find_class_flow.png" alt="image-20210704150112925"></p>
<p>依据dex的加载机制可以开发APP的热修复功能，具体热修复的实现，后面的文章会详细讲。敬请期待~</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Dex加壳原理</title>
    <url>/2019/04/08/android_dex_shell/</url>
    <content><![CDATA[<p>有过Android开发经验的人应该都知道apk的包安全是开发者面对的最直接的应用安全问题。</p>
<span id="more"></span>

<p>apk的安全相当于应用安全的第一道防线。我们常说的apk加固，简单来说就是对源APK进行加密，然后再套上一层壳，在运行时对源APK进行解密并动态加载。apk的加固处理可以一定程度上有效阻止apk的反编译操作。</p>
<h2 id="加固方案"><a href="#加固方案" class="headerlink" title="加固方案"></a>加固方案</h2><h3 id="反模拟器"><a href="#反模拟器" class="headerlink" title="反模拟器"></a>反模拟器</h3><p>模拟器运行apk，可 以用模拟器监控到 apk的各种行为，所 以在实际的加固apk 运行中，一旦发现 模拟器在运行该APK， 就停止核心代码的 运行。</p>
<h3 id="代码虚拟化"><a href="#代码虚拟化" class="headerlink" title="代码虚拟化"></a>代码虚拟化</h3><p>代码虚拟化在桌面平台应用保护中已经是非常的常见了，主要的思路是自建一个虚拟执行引擎，然后把原生的可执行代码转换成自定义的指令进行虚拟执行</p>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>样本的部分可执行代码是以压缩或者加密的形式存在的，比如，被保护过的代码被切割成多个小段，前面的一段代码先把后面的代码片段在内存中解密，然后再去执行解密之后的代码，如此一块块的迭代执行。</p>
<p><strong>下面我们以加密方案进行解析</strong></p>
<h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><h3 id="apk的文件结构"><a href="#apk的文件结构" class="headerlink" title="apk的文件结构"></a>apk的文件结构</h3><p><img src="/images/android_dex_shell_apk_structure.png" alt="image-20210701211429600"></p>
<p>文件及文件夹的作用如下表所示。</p>
<table>
<thead>
<tr>
<th>文件或目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>assets文件夹</td>
<td>存放资源文件的目录</td>
</tr>
<tr>
<td>lib文件夹</td>
<td>存放ndk编译出来的so文件</td>
</tr>
<tr>
<td>META-INF文件夹</td>
<td>1.该目录下存放的是签名信息，用来保证apk包的完整性和系统的安全性 2.CERT.RS   保存着该应用程序的证书和授权信息 3.CERT.SF  保存着SHA-1信息资源列表  4.MANIFEST.MF  清单信息</td>
</tr>
<tr>
<td>res文件夹</td>
<td>存放资源文件的目录</td>
</tr>
<tr>
<td>AndroidManifest.xml</td>
<td>一个清单文件，它描述了应用的名字、版本、权限、注册的服务等信息。</td>
</tr>
<tr>
<td>classes.dex</td>
<td>java源码编译经过编译后生成的dalvik字节码文件，主要在Dalvik虚拟机上运行的主要代码部分</td>
</tr>
<tr>
<td>resources.arsc</td>
<td>编译后的二进制资源文件。</td>
</tr>
</tbody></table>
<h3 id="加固流程"><a href="#加固流程" class="headerlink" title="加固流程"></a>加固流程</h3><p><img src="/images/android_dex_shell_flow.png" alt="image-20210701212911231"></p>
<p>加固的过程中需要三个对象：</p>
<p>1、需要加密的Apk(源Apk)</p>
<p>2、壳程序Apk(负责解密Apk工作)</p>
<p>3、加密工具(将源Apk进行加密和壳Dex合并成新的Dex)</p>
<p>主要步骤：</p>
<p>我们拿到需要加密的Apk和自己的壳程序Apk，然后用加密算法对源Apk进行加密在将壳Apk进行合并得到新的Dex文件，最后替换壳程序中的dex文件即可，得到新的Apk,那么这个新的Apk我们也叫作脱壳程序Apk.他已经不是一个完整意义上的Apk程序了，他的主要工作是：负责解密源Apk.然后加载Apk,让其正常运行起来。</p>
<h3 id="DEX文件格式"><a href="#DEX文件格式" class="headerlink" title="DEX文件格式"></a>DEX文件格式</h3><p>Dex是Android系统的可执行文件，包含应用程序的全部操作指令以及运行时数据</p>
<p>由于dalvik是一种针对嵌入式设备而特殊设计的java虚拟机，所以dex文件与标准的class文件在结构设计上有着本质的区别</p>
<p>当java程序编译成class后，还需要使用dx工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，实验表明，dex文件是传统jar文件大小的50%左右</p>
<p><img src="/images/android_dex_shell_dex_structure.png" alt="image-20210701213417909"></p>
<p>这里面，有3个成员我们需要特别关注，这在后面加固里会用到，它们分别是checksum、signature和fileSize。</p>
<p><strong>checksum字段</strong></p>
<p>checksum是校验码字段，占4bytes，主要用来检查从该字段（不包含checksum字段，也就是从12bytes开始算起）开始到文件末尾，这段数据是否完整，也就是完整性校验。它使用alder32算法校验。</p>
<p><strong>signature字段</strong></p>
<p>signature是SHA-1签名字段，占20bytes，作用跟checksum一样，也是做完整性校验。之所以有两个完整性校验字段，是由于先使用checksum字段校验可以先快速检查出错的dex文件，然后才使用第二个计算量更大的校验码进行计算检查。</p>
<p><strong>fileSize字段</strong></p>
<p>占4bytes，保存classes.dex文件总长度。</p>
<p>这3个字段当我们修改dex文件的时候，这3个字段的值是需要更新的，否则在加载到Dalvik虚拟机的时候会报错。</p>
<p>为什么说我们只需要关注这三个字段呢？</p>
<p>因为我们需要将一个文件(加密之后的源Apk)写入到Dex中，那么我们肯定需要修改文件校验码(checksum).因为他是检查文件是否有错误。那么signature也是一样，也是唯一识别文件的算法。还有就是需要修改dex文件的大小。</p>
<p>不过这里还需要一个操作，就是标注一下我们加密的Apk的大小，因为我们在脱壳的时候，需要知道Apk的大小，才能正确的得到Apk。那么这个值放到哪呢？这个值直接放到文件的末尾就可以了。</p>
<h3 id="apk的打包流程"><a href="#apk的打包流程" class="headerlink" title="apk的打包流程"></a>apk的打包流程</h3><p><img src="/images/android_dex_shell_apk_package_flow.png" alt="android_dex_shell_apk_package_flow"></p>
<p>上图中涉及到的工具及其作用如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>aapt</td>
<td>打包资源文件，包括res和assets文件夹下的资源、AndroidManifest.xml文件、Android基础类库</td>
</tr>
<tr>
<td>aidl</td>
<td>将.aidl接口文件转换成.java文件</td>
</tr>
<tr>
<td>javaComiler</td>
<td>编译java文件，生成.class字节码文件</td>
</tr>
<tr>
<td>dex</td>
<td>将所有的第三方libraries和.class文件转换成Dalvik虚拟机支持的.dex文件</td>
</tr>
<tr>
<td>apkbuilder</td>
<td>打包生成apk文件，但未签名</td>
</tr>
<tr>
<td>jarsigner</td>
<td>对未签名的apk文件进行签名</td>
</tr>
<tr>
<td>zipalign</td>
<td>对签名后的apk文件进行对其处理</td>
</tr>
</tbody></table>
<h3 id="加密过程实操"><a href="#加密过程实操" class="headerlink" title="加密过程实操"></a>加密过程实操</h3><p><img src="/images/android_dex_shell_enctype_package.png" alt="image-20210701214455616"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDexMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">byte</span>[] mainDexData; <span class="comment">//存储源apk中的源dex文件 </span></span><br><span class="line">    	<span class="keyword">byte</span>[] aarData;     <span class="comment">// 存储壳中的壳dex文件</span></span><br><span class="line">    	<span class="keyword">byte</span>[] mergeDex;    <span class="comment">// 存储壳dex 和源dex 的合并的新dex文件</span></span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">    	File tempFileApk = <span class="keyword">new</span> File(<span class="string">&quot;source/apk/temp&quot;</span>);</span><br><span class="line">    	<span class="keyword">if</span> (tempFileApk.exists()) &#123;</span><br><span class="line">        File[]files = tempFileApk.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File file: files)&#123;</span><br><span class="line">          <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">			&#125;</span><br><span class="line">    	</span><br><span class="line">    	File tempFileAar = <span class="keyword">new</span> File(<span class="string">&quot;source/aar/temp&quot;</span>);</span><br><span class="line">    	<span class="keyword">if</span> (tempFileAar.exists()) &#123;</span><br><span class="line">        File[]files = tempFileAar.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File file: files)&#123;</span><br><span class="line">          <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一步 处理原始apk 加密dex</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        AES.init(AES.DEFAULT_PWD);</span><br><span class="line">        <span class="comment">//解压apk</span></span><br><span class="line">        File apkFile = <span class="keyword">new</span> File(<span class="string">&quot;source/apk/app-debug.apk&quot;</span>);</span><br><span class="line">        File newApkFile = <span class="keyword">new</span> File(apkFile.getParent() + File.separator + <span class="string">&quot;temp&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!newApkFile.exists()) &#123;</span><br><span class="line">        	newApkFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        File mainDexFile = AES.encryptAPKFile(apkFile,newApkFile);</span><br><span class="line">        <span class="keyword">if</span> (newApkFile.isDirectory()) &#123;</span><br><span class="line">        File[] listFiles = newApkFile.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : listFiles) &#123;</span><br><span class="line">          <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;.dex&quot;</span>)) &#123;</span><br><span class="line">              String name = file.getName();</span><br><span class="line">              System.out.println(<span class="string">&quot;rename step1:&quot;</span>+name);</span><br><span class="line">              <span class="keyword">int</span> cursor = name.indexOf(<span class="string">&quot;.dex&quot;</span>);</span><br><span class="line">              String newName = file.getParent()+ File.separator + name.substring(<span class="number">0</span>, cursor) + <span class="string">&quot;_&quot;</span> + <span class="string">&quot;.dex&quot;</span>;</span><br><span class="line">              System.out.println(<span class="string">&quot;rename step2:&quot;</span>+newName);</span><br><span class="line">              file.renameTo(<span class="keyword">new</span> File(newName));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二步 处理aar 获得壳dex</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    		File aarFile = <span class="keyword">new</span> File(<span class="string">&quot;source/aar/mylibrary-debug.aar&quot;</span>);</span><br><span class="line">        File aarDex  = Dx.jar2Dex(aarFile);</span><br><span class="line"><span class="comment">//        aarData = Utils.getBytes(aarDex);   //将dex文件读到byte 数组</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        File tempMainDex = <span class="keyword">new</span> File(newApkFile.getPath() + File.separator + <span class="string">&quot;classes.dex&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!tempMainDex.exists()) &#123;</span><br><span class="line">          tempMainDex.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;MyMain&quot; + tempMainDex.getAbsolutePath());</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(tempMainDex);</span><br><span class="line">        <span class="keyword">byte</span>[] fbytes = Utils.getBytes(aarDex);</span><br><span class="line">        fos.write(fbytes);</span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第3步 打包签名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        File unsignedApk = <span class="keyword">new</span> File(<span class="string">&quot;result/apk-unsigned.apk&quot;</span>);</span><br><span class="line">        unsignedApk.getParentFile().mkdirs();</span><br><span class="line"><span class="comment">//        File disFile = new File(apkFile.getAbsolutePath() + File.separator+ &quot;temp&quot;);</span></span><br><span class="line">        Zip.zip(newApkFile, unsignedApk);</span><br><span class="line">        <span class="comment">//不用插件就不能自动使用原apk的签名...</span></span><br><span class="line">        File signedApk = <span class="keyword">new</span> File(<span class="string">&quot;result/apk-signed.apk&quot;</span>);</span><br><span class="line">        Signature.signature(unsignedApk, signedApk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> File <span class="title">getMainDexFile</span><span class="params">(File apkFile)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		File disFile = <span class="keyword">new</span> File(apkFile.getAbsolutePath() + <span class="string">&quot;unzip&quot;</span>);</span><br><span class="line">		Zip.unZip(apkFile, disFile);</span><br><span class="line">		File[] files = disFile.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.dex&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">for</span> (File file: files) &#123;</span><br><span class="line">			<span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;classes.dex&quot;</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> file;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加密阶段"><a href="#加密阶段" class="headerlink" title="加密阶段"></a>加密阶段</h4><p>加密阶段主要是讲把原apk文件中提取出来的classes.dex文件通过加密程序进行加密。加密的时候如果使用des对称加密算法，则需要注意处理好密钥的问题。同样的，如果采用非对称加密，也同样存在公钥保存的问题。</p>
<h4 id="合成新的dex文件"><a href="#合成新的dex文件" class="headerlink" title="合成新的dex文件"></a>合成新的dex文件</h4><p>这一阶段主要是讲上一步生成的加密的dex文件和我们的壳dex文件合并，将加密的dex文件追加在壳dex文件后面，并在文件末尾追加加密dex文件的大小数值</p>
<p>在壳程序里面，有个重要的类：ProxyApplication类，该类继承Application类，也是应用程序最先运行的类。所以，我们就是在这个类里面，在原程序运行之前，进行一些解密dex文件和加载原dex文件的操作。</p>
<h4 id="修改原apk文件并重新打包签名"><a href="#修改原apk文件并重新打包签名" class="headerlink" title="修改原apk文件并重新打包签名"></a>修改原apk文件并重新打包签名</h4><p>在这一阶段，我们首先将apk解压，会看到如下图的6个文件和目录。其中，我们需要修改的只有2个文件，分别是classes.dex和AndroidManifest.xml文件，其他文件和文件加都不需要改动。</p>
<p>首先，我们把解压后apk目录下原来的classes.dex文件替换成我们在0x02上一步合成的新的classes.dex文件。然后，由于我们程序运行的时候，首先加载的其实是壳程序里的ProxyApplication类。所以，我们需要修改AndroidManifest.xml文件，指定application为ProxyApplication，这样才能正常找到识别ProxyApplication类并运行壳程序。</p>
<h4 id="运行壳程序并加载原dex文件"><a href="#运行壳程序并加载原dex文件" class="headerlink" title="运行壳程序并加载原dex文件"></a>运行壳程序并加载原dex文件</h4><p>Dalvik虚拟机会加载我们经过修改的新的classes.dex文件，并最先运行ProxyApplication类。在这个类里面，有2个关键的方法：attachBaseContext和onCreate方法。ProxyApplication显示运行attachBaseContext再运行onCreate方法。</p>
<p>在attachBaseContext方法里，主要做两个工作：</p>
<ol>
<li>读取classes.dex文件末尾记录加密dex文件大小的数值，则加密dex文件在新classes.dex文件中的位置为：len(新classes.dex文件) – len(加密dex文件大小)。然后将加密的dex文件读取出来，加密并保存到资源目录下</li>
<li>然后使用自定义的DexClassLoader加载解密后的原dex文件</li>
</ol>
<p>在onCreate方法中，主要做两个工作：</p>
<ol>
<li>通过反射修改ActivityThread类，并将Application指向原dex文件中的Application</li>
<li>创建原Application对象，并调用原Application的onCreate方法启动原程序</li>
</ol>
<p><img src="/images/android_dex_shell_dex_load.png" alt="android_dex_shell_dex_load"></p>
<p>源码地址：<a href="https://github.com/jiajunhui/DexShell">https://github.com/jiajunhui/DexShell</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>应用安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Android进程间通信Binder机制原理</title>
    <url>/2019/06/01/android_binder/</url>
    <content><![CDATA[<p>为了系统的安全与稳定，Linux系统是存在进程隔离的：两个不同的进程，如应用App进程和ActivityManagerService服务所在的system_server系统进程，是无法直接通过内存地址访问到对方内部的函数或者变量的。所以两个进程如果需要相互访问就涉及到一个跨进程通信的概念即IPC(Inter-process communication，进程间通讯)。</p>
<span id="more"></span>

<p>本质上是借助于不同进程的内核空间都是共享的原理，两个不同的进程都去访问内核空间，从而达到“间接”访问对方的目的。Binder就是Android系统中大量使用的IPC机制，无论是应用程序对系统服务的请求（例如应用调用系统核心服务AMS的startActivity接口去实现应用启动），还是应用程序自身提供对外服务，都需要使用到Binder。因此，Binder机制在Android系统中的地位非常重要，可以说，<strong>理解Binder是理解Android系统的前提</strong>。</p>
<p>其实在Unix/Linux系统中，存在很多传统的IPC机制。如管道、消息队列、共享内存、Socket、信号量等。但是Android系统虽然是基于Linux系统但是却很少会使用这些这些传统的IPC机制，而是大部分场景下都是使用Binder。主要原因是，<strong>相对于传统的IPC机制，Binder有如下三点优势：</strong></p>
<ol>
<li><strong>性能上的优势</strong>：管道，消息队列，Socket的通讯都需要两次数据拷贝，而<strong>Binder由于使用了内存映射所以只需要一次拷贝</strong>。要知道，对于系统底层的IPC形式，少一次数据拷贝，对整体性能的影响是非常之大的。</li>
<li><strong>稳定性上的优势</strong>：Binder本身是C/S架构的，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制复杂，难以使用。从稳定性的角度讲，Binder机制是优于内存共享的。</li>
<li><strong>安全性上的优势</strong>：传统IPC形式，无法得到对方的身份标识（UID/PID)，而在使用Binder IPC时，这些身份标示是跟随调用过程而自动传递的。Server端很容易就可以知道Client端的身份，非常便于做安全检查，这一点对移动操作系统非常重要。</li>
</ol>
<h1 id="Binder整体架构"><a href="#Binder整体架构" class="headerlink" title="Binder整体架构"></a>Binder整体架构</h1><p>借用一张经典的架构图来描述binder的整体架构全貌，如下所示： </p>
<p><img src="/images/android_binder_framework_struct.png" alt="img"></p>
<p>从图中可以看出。这个Binder机制从架构上大致可以分为三层：</p>
<ol>
<li><strong>驱动层</strong>，我们知道Android系统是基于Linux内核的，Binder驱动层则位于Linux内核中。Binder 驱动会将自己注册为一个misc device，并向上层提供一个dev/binder节点（此Binder节点并不会对应真实的硬件设备）。Binder驱动运行在内核态，提供了最底层的数据传递，对象标识，线程管理，调用过程控制等功能，<strong>是Binder实现跨进程通信的核心</strong>。</li>
<li><strong>Framework C++层</strong>，以驱动层为基础，Binder机制C++的封装实现。</li>
<li><strong>Framework Java层</strong>，Binder机制的Java层的封装实现，采用JNI调用复用C++层的实现。</li>
</ol>
<p><strong>Binder通信架构是典型的C/S架构</strong>，由Client、Server、ServiceManager、Binder Driver四大组件组成。Client、Server、ServiceManager、Binder Driver这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder Driver）之间的关系。<strong>其相互配合完成一次Binder通信的大概过程如下</strong>：</p>
<ol>
<li>首先在系统开机启动时，一个进程通过Binder驱动将自己注册成ServiceManager，其地址固定为0；</li>
<li><strong>Server通过驱动向ServiceManager中注册Binder（Server中的Binder实体），表明可以对外提供服务</strong>。驱动为这个Binder创建位于内核中的实体节点以及ServiceManager对实体的引用，将名字以及新建的引用打包传给ServiceManager，ServiceManger将其填入查找表；</li>
<li>Client通过名字，在Binder驱动的帮助下从ServiceManager中获取到对Binder实体的引用，通过这个引用就能实现和Server进程的通信。</li>
</ol>
<p>整个过程如下图所示： </p>
<p><img src="/images/android_binder_driver_c_s_flow.png" alt="img"></p>
<h1 id="Binder驱动与协议"><a href="#Binder驱动与协议" class="headerlink" title="Binder驱动与协议"></a>Binder驱动与协议</h1><p>这部分源码位置在Linux内核中：</p>
<blockquote>
<p>/kernel/drivers/android/binder.c</p>
</blockquote>
<blockquote>
<p>/kernel/include/uapi/linux/android/binder.h</p>
</blockquote>
<h2 id="Binder驱动设备初始化"><a href="#Binder驱动设备初始化" class="headerlink" title="Binder驱动设备初始化"></a>Binder驱动设备初始化</h2><p><strong>Binder驱动设备在初始化时主要完成如下几件事情</strong>：</p>
<ol>
<li>通过misc_register()将自己注册为misc device类型的驱动设备；</li>
<li>填写file_operations函数指针结构体以标识用户空间在使用Binder驱动时所支持的文件操作；</li>
<li>指定Binder设备的名称是“binder”，这样用户空间便可以通过对/dev/binder文件进行操作来使用Binder。如下代码所示：</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*kernel/drivers/android/binder.c*/</span></span><br><span class="line"><span class="keyword">static</span> int __init init_binder_device(<span class="keyword">const</span> <span class="built_in">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span></span> *binder_device;</span><br><span class="line">    binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!binder_device)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    binder_device-&gt;miscdev.fops = &amp;binder_fops;<span class="comment">// 1.Binder驱动支持的文件操作</span></span><br><span class="line">    binder_device-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;<span class="comment">//动态分配次设备号</span></span><br><span class="line">    binder_device-&gt;miscdev.name = name;<span class="comment">//2.驱动名称设置，一般就是“binder”</span></span><br><span class="line">    binder_device-&gt;context.binder_context_mgr_uid = INVALID_UID;</span><br><span class="line">    binder_device-&gt;context.name = name;</span><br><span class="line">    mutex_init(&amp;binder_device-&gt;context.context_mgr_node_lock);</span><br><span class="line">    ret = misc_register(&amp;binder_device-&gt;miscdev);<span class="comment">// 3.注册Binder驱动</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        kfree(binder_device);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span></span> binder_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,<span class="comment">// binder_ioctl</span></span><br><span class="line">    .compat_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,<span class="comment">// binder_mmap</span></span><br><span class="line">    .open = binder_open,<span class="comment">// binder_open</span></span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由此可见，Binder驱动为上层应用提供了6个接口——其中使用最多的就是binder_ioctl、binder_mmap和binder_open。这是因为：<strong>需要使用Binder的进程，几乎总是先通过binder_open打开Binder设备，然后通过binder_mmap进行内存映射，最后再通过binder_ioctl来进行实际的操作</strong>。Client对于Server端的请求，以及Server对于Client请求结果的返回，都是通过ioctl完成的。</p>
<h2 id="打开Binder驱动——binder-open"><a href="#打开Binder驱动——binder-open" class="headerlink" title="打开Binder驱动——binder open"></a>打开Binder驱动——binder open</h2><p>上层用户空间的进程在访问Binder驱动时，<strong>首先需要通过open(“dev/binder”)打开Binder驱动设备</strong>，这个操作最终对应的实现是在binder_open()中。如下所示：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*kernel/drivers/android/binder.c*/</span></span><br><span class="line"><span class="keyword">static</span> int binder_open(<span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span> *nodp, <span class="class"><span class="keyword">struct</span> <span class="title">file</span></span> *filp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span></span> *proc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span></span> *binder_dev;</span><br><span class="line">    binder_debug(BINDER_DEBUG_OPEN_CLOSE, <span class="string">&quot;%s: %d:%d\n&quot;</span>, __func__,</span><br><span class="line">             current-&gt;group_leader-&gt;pid, current-&gt;pid);</span><br><span class="line">    proc = kzalloc(sizeof(*proc), GFP_KERNEL);<span class="comment">//1.创建进程对应的binder_proc对象</span></span><br><span class="line">    <span class="keyword">if</span> (proc == NULL)</span><br><span class="line">           <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    spin_lock_init(&amp;proc-&gt;inner_lock);</span><br><span class="line">    spin_lock_init(&amp;proc-&gt;outer_lock);</span><br><span class="line">    get_task_struct(current-&gt;group_leader);</span><br><span class="line">    proc-&gt;tsk = current-&gt;group_leader;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br><span class="line">    <span class="comment">/* binderfs stashes devices in i_private */</span></span><br><span class="line">    <span class="keyword">if</span> (is_binderfs_device(nodp))</span><br><span class="line">        binder_dev = nodp-&gt;i_private;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        binder_dev = container_of(filp-&gt;private_data,</span><br><span class="line">                      <span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span></span>, miscdev);</span><br><span class="line">    proc-&gt;context = &amp;binder_dev-&gt;context;</span><br><span class="line">    binder_alloc_init(&amp;proc-&gt;alloc);</span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">        <span class="comment">// 2.初始化binder_proc</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;waiting_threads);</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line">    mutex_lock(&amp;binder_procs_lock);<span class="comment">// 获取锁</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);<span class="comment">// 3.添加到全局列表binder_procs中</span></span><br><span class="line">    mutex_unlock(&amp;binder_procs_lock);</span><br><span class="line">    <span class="keyword">if</span> (binder_debugfs_dir_entry_proc) &#123;</span><br><span class="line">        <span class="built_in">char</span> strbuf[<span class="number">11</span>];</span><br><span class="line">        snprintf(strbuf, sizeof(strbuf), <span class="string">&quot;%u&quot;</span>, proc-&gt;pid);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * proc debug entries are shared between contexts, so</span></span><br><span class="line"><span class="comment">         * this will fail if the process tries to open the driver</span></span><br><span class="line"><span class="comment">         * again with a different context. The priting code will</span></span><br><span class="line"><span class="comment">         * anyway print all contexts that a given PID has, so this</span></span><br><span class="line"><span class="comment">         * is not a problem.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        proc-&gt;debugfs_entry = debugfs_create_file(strbuf, <span class="number">0444</span>,</span><br><span class="line">            binder_debugfs_dir_entry_proc,</span><br><span class="line">            (void *)(unsigned long)proc-&gt;pid,</span><br><span class="line">            &amp;proc_fops);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Binder驱动中，通过binder_procs集合记录了所有使用Binder的进程。每个初次打开Binder设备的进程都会创建一个binder_proc结构体对象，用来描述使用Binder的进程，然后被添加到这个列表中的。</p>
<h2 id="内存映射——binder-mmap"><a href="#内存映射——binder-mmap" class="headerlink" title="内存映射——binder_mmap"></a>内存映射——binder_mmap</h2><p>在打开Binder设备之后，上层进程就要通过mmap进行内存映射。mmap的作用有如下两个：</p>
<ul>
<li>申请一块内存空间，用来接收Binder通信过程中的数据</li>
<li>对这块内存进行地址映射，以便将来访问</li>
</ul>
<p>mmap在内核对应的就是binder_mmap()函数：在这个函数中，会申请一块物理内存，然后将用户空间和内核空间虚拟地址同时对应到这块物理内存上。在这之后，当有Client要发送数据给Server的时候，<strong>只需一次copy_from_user动作，将Client发送过来的数据拷贝到Server端的内核空间指定的内存地址即可（从而实现前文说的Binder通信机制只需要一次内存拷贝的效果）</strong>，由于这个内存地址在服务端已经同时映射到用户空间，因此无需再做一次复制，Server即可直接访问，整个过程如下图所示： </p>
<p><img src="/images/android_binder_mmap_c_s_flow.png" alt="img"></p>
<p>mmap_and_transaction.png</p>
<p>这幅图的说明如下：</p>
<ol>
<li>Server在启动之后，调用对/dev/binder设备调用mmap；</li>
<li>内核中的binder_mmap函数进行对应的处理：<strong>申请一块物理内存，然后在用户空间和内核空间同时进行映射</strong>；</li>
<li>Client通过BINDER_WRITE_READ命令发送请求，这个请求将先到驱动中，同时需要将数据从Client进程的用户空间拷贝到内核空间；</li>
<li>驱动通过BR_TRANSACTION通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问。</li>
</ol>
<h2 id="Binder驱动控制协议——binder-ioctl"><a href="#Binder驱动控制协议——binder-ioctl" class="headerlink" title="Binder驱动控制协议——binder_ioctl"></a>Binder驱动控制协议——binder_ioctl</h2><p>binder_ioctl()实现了上层应用进程与Binder驱动之间的交互命令，可以说承载了Binder驱动的大部分业务，也是我们学习的重中之重。下面表格中列出binder_ioctl支持的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>BINDER_WRITE_READ</td>
<td>读写操作，可以用此命令向Binder读取或写入数据</td>
</tr>
<tr>
<td>BINDER_SET_MAX_THREADS</td>
<td>设置支持的最大线程数。因为客户端可以并发向服务器端发送请求，如果Binder驱动发现当前线程数已经超过设定值，就会告知Binder Server停止启动新的线程</td>
</tr>
<tr>
<td>BINDER_SET_CONTEXT_MGR</td>
<td>Service Manager专用，将自己设置为“Binder大管家”。系统中只能有一个SM存在</td>
</tr>
<tr>
<td>BINDER_THREAD_EXIT</td>
<td>通知Binder线程退出。每个线程退出时都应该告知Binder驱动、才能释放相关资源；否则会造成内存泄漏</td>
</tr>
<tr>
<td>BINDER_VERSION</td>
<td>获取Binder版本号</td>
</tr>
</tbody></table>
<p>其中BINDER_WRITE_READ这个命令是重点，又分为若干子命令，如下表所示：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BC_TRANSACTION</strong></td>
<td>Binder事务，即：Client对于Server的请求</td>
</tr>
<tr>
<td><strong>BC_REPLY</strong></td>
<td>事务的应答，即：Server对于Client的回复</td>
</tr>
<tr>
<td>BC_ENTER_LOOPER</td>
<td>通知驱动主线程ready</td>
</tr>
<tr>
<td>BC_REGISTER_LOOPER</td>
<td>通知驱动子线程ready</td>
</tr>
<tr>
<td>BR_REPLY</td>
<td>通知进程收到Binder请求的回复（Client）</td>
</tr>
<tr>
<td>BR_TRANSACTION_COMPLETE</td>
<td>驱动对于接受请求的确认回复</td>
</tr>
<tr>
<td>BR_TRANSACTION</td>
<td>通知进程收到一次Binder请求（Server端）</td>
</tr>
<tr>
<td>BR_DEAD_BINDER</td>
<td>发送死亡通知</td>
</tr>
<tr>
<td><strong>BR_SPAWN_LOOPER</strong></td>
<td>通知Binder进程创建一个新的线程</td>
</tr>
</tbody></table>
<p>其中BC_TRANSACTION和BC_REPLAY是最关键的两个命令，Binder机制中Client与Server交互基本靠它们完成。</p>
<p>单独看上面的协议可能很难理解，这里我们以一次Binder请求过程来详细看一下Binder协议是如何通信的，就比较好理解了。 </p>
<p><img src="/images/android_binder_c_s_flow.png" alt="img"></p>
<p>binder_request_sequence.png</p>
<p>这幅图的说明如下：</p>
<ul>
<li>Binder是C/S架构的，通信过程牵涉到：Client，Server以及Binder驱动三个角色</li>
<li>Client对于Server的请求以及Server对于Client回复都需要通过Binder驱动来中转数据</li>
<li>BC_XXX命令是进程发送给驱动的命令</li>
<li>BR_XXX命令是驱动发送给进程的命令</li>
<li>整个通信过程由Binder驱动控制</li>
</ul>
<h1 id="Binder-Framework-C-层"><a href="#Binder-Framework-C-层" class="headerlink" title="Binder Framework C++层"></a>Binder Framework C++层</h1><p>Binder Framework的C++部分：<strong>主要功能是实现向下与Binder驱动的对接交互，并封装复杂的内部实现，对外提供使用接口</strong>。头文件定义位于：/frameworks/native/include/binder/，实现位于这个路径：/frameworks/native/libs/binder/ 。<strong>Binder库最终会编译成一个动态链接库libbinder.so，供其他进程链接使用</strong>。为了便于说明，下文中我们将Binder Framework 的C++部分称为libbinder。</p>
<h2 id="主要类结构"><a href="#主要类结构" class="headerlink" title="主要类结构"></a>主要类结构</h2><p>先用一张类图描述libbinder中的主要类结构之间的关系：</p>
<p><img src="/images/android_binder_libbinder_struct.png" alt="img"></p>
<p>对照上面这张libbinder的设计类图，我们来理一下各个核心类的功能与职责：</p>
<ul>
<li><strong>基类</strong></li>
</ul>
<ol>
<li><strong>IBinder</strong>：Binder对象的基类，这个类描述了所有在Binder上传递的对象，它既是Binder服务端对象BBinder的父类，也是Binder客户端对象BpBinder的父类；<strong>主要定义的方法有</strong>：a.transact ———进行一次Binder操作；b.queryLocalInterface——尝试获取本地Binder对象；c.<strong>getInterfaceDescriptor ——</strong>获取Binder的服务接口唯一的描述****；d.isBinderAlive——查询Binder服务是否还活着等；</li>
<li><strong>IInterface</strong>：<strong>Binder服务接口的基类</strong>，Binder服务通常需要同时提供客户端接口和服务端接口。每个Binder服务都是为了某个功能而实现的，因此其本身会定义一套接口集来描述自己提供的所有功能。而Binder服务既有自身实现服务的类，也要有给客户端进程调用的类。为了便于开发，这两中类里面的服务接口应当是一致的。因此为了实现方便，本地实现类和远程接口类需要有一个公共的描述服务接口的基类（即上图中的IXXXService）来继承。而这个基类通常是IInterface的子类。</li>
</ol>
<ul>
<li><strong>客户端类</strong></li>
</ul>
<ol>
<li><strong>BpBinder</strong> ：BpBinder的实例代表了客户端Binder，这个类的对象将被客户端调用。这个类最重要就是<strong>提供了transact方法</strong>，这个方法会将客户端调用的参数封装好通过IPCThreadState逻辑封装后发送给Binder驱动。</li>
<li><strong>BpInterface</strong>：客户端接口的基类，远程接口是供客户端调用的接口集。<strong>BpInterface是个模板类</strong>，它们在继承自INTERFACE的基础上还继承了BpRefBase，通过这个类的remote方法可以获取到指向服务实现方的句柄。</li>
</ol>
<ul>
<li><strong>服务端类</strong></li>
</ul>
<ol>
<li><strong>BBinder</strong>：BBinder的实例代表了服务端Binder，它描述了服务的提供方，所有Binder服务的实现者都要继承这个类（的子类），在继承类中，最重要的就是实现<strong>onTransact方法</strong>，因为这个方法是所有请求的入口。因此，这个方法是和BpBinder中的transact方法对应的，这个方法同样也有一个uint32_t code参数（统一在IBinder中定义），在这个方法的实现中，由服务提供者通过code对请求的接口进行区分，然后调用具体实现服务的方法。</li>
<li><strong>BnInterface</strong>：服务端接口的基类，是需要服务端服务中真正实现的接口集。<strong>BnInterface是个模板类</strong>，它们在继承自INTERFACE(Binder服务接口的基类，继承自IInterface)的基础上还继承了BBinder，<strong>由此可以通过复写onTransact方法来提供实现</strong>。</li>
</ol>
<ul>
<li><strong>与驱动通信的类</strong></li>
</ul>
<ol>
<li><strong>ProcessState</strong> : <strong>代表使用Binder的进程</strong>。在讲解Binder驱动的时候我们就提到：任何使用Binder机制的进程都必须要对/dev/binder设备进行open以及mmap之后才能使用，这部分逻辑是所有使用Binder机制进程共同的。对于这种共同逻辑的封装便是Framework层的职责之一。libbinder中，ProcessState类封装了这个逻辑，从而<strong>负责进程Binder的初始化</strong>。</li>
<li><strong>IPCThreadState</strong> ：<strong>代表了进程中使用Binder的线程</strong>，这个类中封装了<strong>与Binder驱动通信的具体实现逻辑</strong>。</li>
</ol>
<p><strong>在客户端接口的实现类中，每个接口在组装好参数之后，都会调用remote()-&gt;transact来发送请求，而这里其实就是调用的BpBinder的transact方法，这样请求便通过Binder到达了服务实现方的onTransact中。这个过程如下图所示</strong>：</p>
<p><img src="/images/android_binder_bp_bb_transact.png" alt="img"></p>
<h2 id="进程的Binder初始化（ProcessState）"><a href="#进程的Binder初始化（ProcessState）" class="headerlink" title="进程的Binder初始化（ProcessState）"></a>进程的Binder初始化（ProcessState）</h2><p>之前讲解Binder驱动的时候讲过，需要使用Binder的进程，需要先通过binder_open打开Binder设备，然后通过binder_mmap进行内存映射。由于这部分逻辑是所有使用Binder的进程共有的，所以libbinder中使用ProcessState类统一封装了这个逻辑，具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/binder/ProcessState.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) <span class="comment">// 1M - 8k</span></span></span><br><span class="line"></span><br><span class="line">ProcessState::<span class="built_in">ProcessState</span>(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span><br><span class="line">    : <span class="built_in">mDriverName</span>(<span class="built_in">String8</span>(driver))</span><br><span class="line">    , <span class="built_in">mDriverFD</span>(<span class="built_in">open_driver</span>(driver))<span class="comment">// 1.调用open_driver打开binder驱动设备</span></span><br><span class="line">    , <span class="built_in">mVMStart</span>(MAP_FAILED)</span><br><span class="line">    , <span class="built_in">mThreadCountLock</span>(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mThreadCountDecrement</span>(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , <span class="built_in">mExecutingThreadsCount</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mMaxThreads</span>(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , <span class="built_in">mStarvationStartTimeMs</span>(<span class="number">0</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextCheckFunc</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mBinderContextUserData</span>(<span class="literal">nullptr</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolStarted</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">mThreadPoolSeq</span>(<span class="number">1</span>)</span><br><span class="line">    , <span class="built_in">mCallRestriction</span>(CallRestriction::NONE)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO(b/139016109): enforce in build system</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID_APEX__)</span></span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;Cannot use libbinder in APEX (only system.img libbinder) since it is not stable.&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.mmap执行内存映射动作</span></span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Using %s failed: unable to mmap transaction memory.\n&quot;</span>, mDriverName.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="built_in">close</span>(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">            mDriverName.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这是ProcessState构造函数，Binder的初始化工作都是在这个函数中完成的</strong>。在这个函数中，初始化mDriverFD的时候调用了open_driver方法打开binder设备，然后又在函数体中，通过mmap进行内存映射。<strong>这里需要注意的是mmap函数的参数中有个BINDER_VM_SIZE，这个就是指定在内核上开辟的内存空间的大小，也是一次Binder通信传递的最大数据量，目前默认定义大小是1016个字节（1M-8K）</strong>。这个其实也就解释了我们平常开发过程中遇到的一个问题，就是通过Intent传递过大的对象时会报TransactionTooLargeException异常的原因。open_driver动作具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/binder/ProcessState.cpp*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MAX_BINDER_THREADS 15</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(driver, O_RDWR | O_CLOEXEC);<span class="comment">// 1.通过open系统调用打开了dev/binder设备</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2.通过ioctl获取Binder实现的版本号，并检查是否匹配</span></span><br><span class="line">        <span class="keyword">status_t</span> result = <span class="built_in">ioctl</span>(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to obtain version failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">          <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d&quot;</span>,</span><br><span class="line">                vers, BINDER_CURRENT_PROTOCOL_VERSION, result);</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        <span class="comment">// 3.通过ioctl设置进程支持的最大Binder线程数</span></span><br><span class="line">        result = <span class="built_in">ioctl</span>(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Binder ioctl to set max threads failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;Opening &#x27;%s&#x27; failed: %s\n&quot;</span>, driver, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>open_driver函数中除了实现通过open系统调用打开了dev/binder设备外。<strong>还会通过ioctl调用的BINDER_SET_MAX_THREADS命令设置进程支持的最大Binder线程数，目前定义的一般进程默认最大Binder线程数是15</strong>。这个也解释了我们在开发过程中遇到一类性能问题：就是进程的Binder线程耗尽，此时进程中已经开启了15个Binder线程用于处理binder请求且都处于工作或阻塞状态，此时如果有新的binder请求时就无法继续处理了，从而导致阻塞卡主；</p>
<h2 id="与Binder驱动的通信-IPCThreadState"><a href="#与Binder驱动的通信-IPCThreadState" class="headerlink" title="与Binder驱动的通信(IPCThreadState)"></a>与Binder驱动的通信(IPCThreadState)</h2><p>IPCThreadState是一个单例类，进程中的每个Binder线程存在一个实例，负责了与驱动通信的细节处理。这个类中的关键几个方法说明如下：</p>
<p><img src="/images/android_binder_ipc_thread_state.png" alt="img"></p>
<p>IPCThreadState.PNG</p>
<p>以其中最主要的是transact方法为例，该方法会完成一次Binder数据传输动作，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/binder/IPCThreadState.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::transact</span><span class="params">(<span class="keyword">int32_t</span> handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.通过writeTransactionData完成数据组装写入</span></span><br><span class="line">    err = <span class="built_in">writeTransactionData</span>(BC_TRANSACTION, flags, handle, code, data, <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2.判断是否为TF_ONE_WAY异步单向请求，如果是线程不需要阻塞等待返回值，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 3.通过waitForResponse将数据传输到驱动并等待返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = <span class="built_in">waitForResponse</span>(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = <span class="built_in">waitForResponse</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，<strong>通过Binder驱动完成一次Binder数据传输的主要流程是</strong>：</p>
<ol>
<li>先通过writeTransactionData函数完成传输数据binder_transaction_data的组装填充；</li>
<li>通过waitForResponse函数真正完成传输数据写入驱动并等待返回数据，具体实现会调用talkWithDriver函数，<strong>通过ioctl命令BINDER_WRITE_READ与Binder驱动通信</strong>，完成数据的传输写入，并读取返回数据。</li>
</ol>
<p>详细代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/binder/IPCThreadState.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::writeTransactionData</span><span class="params">(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 组装binder_transaction_data</span></span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don&#x27;t pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.<span class="built_in">errorCheck</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.<span class="built_in">ipcDataSize</span>();</span><br><span class="line">        tr.data.ptr.buffer = data.<span class="built_in">ipcData</span>();</span><br><span class="line">        tr.offsets_size = data.<span class="built_in">ipcObjectsCount</span>()*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.<span class="built_in">ipcObjects</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.<span class="built_in">writeInt32</span>(cmd);</span><br><span class="line">    mOut.<span class="built_in">write</span>(&amp;tr, <span class="built_in"><span class="keyword">sizeof</span></span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::waitForResponse</span><span class="params">(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用talkWithDriver真正完成传输数据写入驱动并等待返回数据</span></span><br><span class="line">        <span class="keyword">if</span> ((err=<span class="built_in">talkWithDriver</span>()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">IPCThreadState::talkWithDriver</span><span class="params">(<span class="keyword">bool</span> doReceive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">IF_LOG_COMMANDS</span>() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">&quot;About to read/write, write size = &quot;</span> &lt;&lt; mOut.<span class="built_in">dataSize</span>() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ANDROID__)</span></span><br><span class="line">        <span class="comment">// 通过ioctl命令BINDER_WRITE_READ与Binder驱动通信</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Binder服务实现举例"><a href="#C-Binder服务实现举例" class="headerlink" title="C++ Binder服务实现举例"></a>C++ Binder服务实现举例</h2><p>上面的理论知识可能比较枯燥和抽象，下面以Android系统中的一个系统Binder服务为例，结合上面的理论具体分析一下。 我们以实现系统图像合成显示的核心进程服务SurfaceFlinger为例，来分析C++的Binder服务如何实现。下图是SurfaceFlinger C++ Binder服务实现类图：</p>
<p><img src="/images/android_binder_sufrafce_flinger.png" alt="img"></p>
<p>ISurfaceComposer定义了SurfaceFlinger对外提供的功能接口，其子类都继承了这些接口。</p>
<ul>
<li>BpSurfaceComposer是提供给客户端调用的远程接口，先通过remote方法获取到指向服务实现方的句柄，然后通过transact方法发送具体请求。</li>
<li>BnSurfaceComposer中只有一个onTransact方法，该方法根据请求的code来对接每个请求，并直接调用SurfaceFlinger中对应的方法。</li>
<li>SurfaceFlinger是服务接口功能真正的实现。</li>
</ul>
<h3 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h3><p>主要包括BnSurfaceComposer和SurfaceFlinger两个类，SurfaceFlinger是BnSurfaceComposer的子类，因此在BnSurfaceComposer中调用自身的virtual方法其实都是在子类SurfaceFlinger类中实现的。BnSurfaceComposer类要做的就是复写onTransact方法，这个方法的职责是：<strong>根据请求的code区分具体调用的是那个接口，然后按顺序从Parcel中读出打包好的参数，接着调用留待子类实现的虚函数</strong>。我们看一下BnSurfaceComposer::onTransact中的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/libs/gui/ISurfaceComposer.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BnSurfaceComposer::onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span>(code) &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">case</span> CREATE_DISPLAY: &#123;</span><br><span class="line">            <span class="built_in">CHECK_INTERFACE</span>(ISurfaceComposer, data, reply);</span><br><span class="line">            String8 displayName = data.<span class="built_in">readString8</span>();</span><br><span class="line">            <span class="keyword">bool</span> secure = <span class="built_in"><span class="keyword">bool</span></span>(data.<span class="built_in">readInt32</span>());</span><br><span class="line">            <span class="function">sp&lt;IBinder&gt; <span class="title">display</span><span class="params">(createDisplay(displayName, secure))</span></span>;</span><br><span class="line">            reply-&gt;<span class="built_in">writeStrongBinder</span>(display);</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中我们看到了实现中是如何根据code区分接口，并通过Parcel读出调用参数，然后调用具体服务方的。而SurfaceFlinger这个类中的createDisplay方法才是真正实现创建显示设备的逻辑，详细代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/services/surfaceflinger/SurfaceFlinger.cpp*/</span></span><br><span class="line">sp&lt;IBinder&gt; SurfaceFlinger::createDisplay(<span class="keyword">const</span> String8&amp; displayName, bool secure) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DisplayToken</span> : <span class="type">public BBinder &#123;</span></span></span><br><span class="line">        sp&lt;SurfaceFlinger&gt; flinger;</span><br><span class="line">        virtual ~DisplayToken() &#123;</span><br><span class="line">             <span class="comment">// no more references, this display must be terminated</span></span><br><span class="line">             Mutex::Autolock _l(flinger-&gt;mStateLock);</span><br><span class="line">             flinger-&gt;mCurrentState.displays.removeItem(<span class="keyword">this</span>);</span><br><span class="line">             flinger-&gt;setTransactionFlags(eDisplayTransactionNeeded);</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        explicit DisplayToken(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span><br><span class="line">            : flinger(flinger) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;BBinder&gt; token = new DisplayToken(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="comment">// Display ID is assigned when virtual display is allocated by HWC.</span></span><br><span class="line">    DisplayDeviceState state;</span><br><span class="line">    state.isSecure = secure;</span><br><span class="line">    state.displayName = displayName;</span><br><span class="line">    mCurrentState.displays.add(token, state);</span><br><span class="line">    mInterceptor-&gt;saveDisplayCreation(state);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>服务实现完成之后，并不是立即就能让别人使用的。而是需要先通过Binder驱动向ServiceManager中注册服务，表明可以对外提供服务。下面我们看看SurfaceFlinger服务注册发布的具体代码实现：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/services/surfaceflinger/main_surfaceflinger.cpp*/</span></span><br><span class="line">int main(int, <span class="built_in">char</span>**) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// When SF is launched in its own process, limit the number of</span></span><br><span class="line">    <span class="comment">// binder threads to 4.</span></span><br><span class="line">    ProcessState::<span class="keyword">self</span>()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.启动Binder线程池</span></span><br><span class="line">    <span class="comment">// start the thread pool</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps(ProcessState::<span class="keyword">self</span>());</span><br><span class="line">    ps-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instantiate surfaceflinger</span></span><br><span class="line">    sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::createSurfaceFlinger();</span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize before clients can connect</span></span><br><span class="line">    flinger-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.通过IServiceManager::addService在ServiceManager中注册服务，此处服务的名称为“SurfaceFlinger”</span></span><br><span class="line">    <span class="comment">// publish surface flinger</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>,</span><br><span class="line">                   IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run surface flinger in this thread</span></span><br><span class="line">    flinger-&gt;run();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，<strong>发布Binder服务需要先启动Binder线程池，然后通过IServiceManager::addService在ServiceManager中进行服务的注册。</strong></p>
<h3 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h3><p>BpSurfaceComposer需要实现ISurfaceComposer中的所有接口。我们以上文提到的createDisplay接口为例，来看看BpSurfaceComposer::createDisplay方法代码是如何实现的：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/gui/ISurfaceComposer.cpp*/</span></span><br><span class="line">virtual sp&lt;IBinder&gt; createDisplay(<span class="keyword">const</span> String8&amp; displayName, bool secure)</span><br><span class="line">&#123;</span><br><span class="line">    Parcel <span class="keyword">data</span>, reply;</span><br><span class="line">    <span class="comment">// 1.填写服务接口的唯一描述信息descriptor</span></span><br><span class="line">    <span class="keyword">data</span>.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">    <span class="comment">// 2.通过Parcel写入发送参数</span></span><br><span class="line">    <span class="keyword">data</span>.writeString8(displayName);</span><br><span class="line">    <span class="keyword">data</span>.writeInt32(secure ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3\. 调用remote()-&gt;transact将请求发送出去</span></span><br><span class="line">    remote()-&gt;transact(BnSurfaceComposer::CREATE_DISPLAY, <span class="keyword">data</span>, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> reply.readStrongBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很简单，逻辑就是：<strong>通过Parcel写入调用参数进行打包，然后调用remote()-&gt;transact将请求发送出去。</strong></p>
<h3 id="获取服务"><a href="#获取服务" class="headerlink" title="获取服务"></a>获取服务</h3><p><strong>客户端在使用服务端的服务之前，需要先根据服务的名称向ServiceManager中查询获取到访问服务的句柄</strong>，才能通过BpSurfaceComposer::remote()函数拿到远端服务的代理后调用transact方法完成一次Binder数据发送。详细代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framworks/native/libs/gui/SurfaceComposerClient.cpp*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComposerService::connectLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1\. 需要查找的远端Binder服务名称为&quot;SurfaceFlinger&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> String16 <span class="title">name</span><span class="params">(<span class="string">&quot;SurfaceFlinger&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 2 .调用IServiceManager::getService封装接口获取远端服务代理并封装到BpSurfaceComposer中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getService</span>(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">250000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/native/include/binder/IServiceManager.h*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">getService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, sp&lt;INTERFACE&gt;* outService)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// 1\. 获取到ServiceManager的代理以访问ServiceManager</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IServiceManager&gt; sm = <span class="built_in">defaultServiceManager</span>();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 2\. 通过getService获取具体的服务句柄，并使用interface_cast转换获取到BpSurfaceComposer对象</span></span><br><span class="line">        *outService = interface_cast&lt;INTERFACE&gt;(sm-&gt;<span class="built_in">getService</span>(name));</span><br><span class="line">        <span class="keyword">if</span> ((*outService) != <span class="literal">nullptr</span>) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NAME_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/native/libs/binder/IServiceManager.cpp*/</span></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(gSmOnce, []() &#123;</span><br><span class="line">        sp&lt;AidlServiceManager&gt; sm = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//ProcessState::getContextObject(nullptr)获取到ServiceManager的访问句柄</span></span><br><span class="line">            sm = interface_cast&lt;AidlServiceManager&gt;(ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">nullptr</span>));</span><br><span class="line">            ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/native/libs/binder/ProcessState.cpp*/</span></span><br><span class="line"><span class="function">sp&lt;IBinder&gt; <span class="title">ProcessState::getContextObject</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="comment">// 此处的参数“0”代表查找的是ServiceManager服务，这个是个特殊的地址，用于标识ServiceManager</span></span><br><span class="line">    sp&lt;IBinder&gt; context = <span class="built_in">getStrongProxyForHandle</span>(<span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过interface_cast这个方法来获取服务的接口对象，由这个方法本身根据是否是在同一个进程，来自动确定返回一个本地Binder还是远程Binder</strong>。interface_cast是一个模板方法，其源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/binder/include/binder/IInterface.h*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; <span class="title">interface_cast</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::<span class="built_in">asInterface</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于ISurfaceComposer来说，其实就是ISurfaceComposer::asInterface(obj)，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/binder/include/binder/IInterface.h*/</span></span><br><span class="line"> ::android::sp&lt;I##INTERFACE&gt; I##INTERFACE::<span class="built_in">asInterface</span>(              \</span><br><span class="line">         <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)               \</span><br><span class="line"> &#123;                                                                   \</span><br><span class="line">     ::android::sp&lt;I##INTERFACE&gt; intr;                               \</span><br><span class="line">     <span class="keyword">if</span> (obj != <span class="literal">nullptr</span>) &#123;                                           \</span><br><span class="line">         <span class="comment">//1.先使用queryLocalInterface尝试获取本地同一进程中的Binder对象</span></span><br><span class="line">         intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">             obj-&gt;<span class="built_in">queryLocalInterface</span>(                               \</span><br><span class="line">                     I##INTERFACE::descriptor).<span class="built_in">get</span>());               \</span><br><span class="line">         <span class="comment">//2.失败则创建并返回远端Binder对象，封装成BpSurfaceComposer</span></span><br><span class="line">         <span class="keyword">if</span> (intr == <span class="literal">nullptr</span>) &#123;                                      \</span><br><span class="line">             intr = <span class="keyword">new</span> Bp##<span class="built_in">INTERFACE</span>(obj);                          \</span><br><span class="line">         &#125;                                                           \</span><br><span class="line">     &#125;                                                               \</span><br><span class="line">     <span class="keyword">return</span> intr;                                                    \</span><br><span class="line"> &#125;   </span><br></pre></td></tr></table></figure>

<p>由于都是模板定义，所以在理解的时候，将“##”替换成SurfaceComposer即可。</p>
<h1 id="ServiceManager——Binder服务“大管家”"><a href="#ServiceManager——Binder服务“大管家”" class="headerlink" title="ServiceManager——Binder服务“大管家”"></a>ServiceManager——Binder服务“大管家”</h1><p>ServerManager(简称SM)的功能可以类比互联网中的DNS服务器，“IP地址”为0。<strong>每一个Binder服务都需要有一个唯一的名称，由SM来管理这些服务的注册和查找</strong>。另外，和DNS服务器本身也是服务器一样，SM也是一个标准的Binder Server，且Binder驱动中，也会通过特定handle = 0这个位置来访问ServiceManager。因此，分析SM我们可以完整的看到一个上层应用如何通过Binder驱动来构建一个Binder Server的过程。下面我们分析SM模块的的具体实现。</p>
<h2 id="ServiceManager进程的启动"><a href="#ServiceManager进程的启动" class="headerlink" title="ServiceManager进程的启动"></a>ServiceManager进程的启动</h2><p>SM作为Binder服务的“大管家”，必须要保证在系统所有Binder服务启动之前就已经启动并处于正常工作状态。所以SM是在开机时由init程序解析init.rc加载时直接启动。如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/cmds/servicemanager/servicemanager.rc*/</span></span><br><span class="line">service servicemanager /system/bin/servicemanager<span class="comment">// 1.servicemanager是一个独立可执行文件</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span> <span class="title">animation</span></span></span><br><span class="line">    user system</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote<span class="comment">// 2.servicemanager重启后会导致zygote重启</span></span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger<span class="comment">// 3.servicemanager重启后会导致surfaceflinger重启</span></span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    onrestart restart thermalservice</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>

<p>由上可见，<strong>servicemanager是一个独立可执行文件，由C++编写，是一个独立运行的native进程，在系统开机时有init进程直接拉起</strong>。源码路径如下：</p>
<blockquote>
<p>/framework/native/cmds/servicemanager/*</p>
</blockquote>
<p>其main函数主要逻辑如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/cmds/servicemanager/main.cpp*/</span></span><br><span class="line">int main(int argc, <span class="built_in">char</span>** argv) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">&quot;usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; [binder driver]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">char</span>* driver = argc == <span class="number">2</span> ? argv[<span class="number">1</span>] : <span class="string">&quot;/dev/binder&quot;</span>;</span><br><span class="line">    <span class="comment">//1.通过initWithDriver会完成打开/dev/binder下的binder驱动设备和mmap内存映射动作</span></span><br><span class="line">    sp&lt;ProcessState&gt; ps = ProcessState::initWithDriver(driver);</span><br><span class="line">    ps-&gt;setThreadPoolMaxThreadCount(<span class="number">0</span>);</span><br><span class="line">    ps-&gt;setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY);</span><br><span class="line">    <span class="comment">//2.创建ServiceManager对象，并通过addService接口将自己注册为名为“manager”的Binder Server</span></span><br><span class="line">    sp&lt;ServiceManager&gt; manager = new ServiceManager(std::make_unique&lt;Access&gt;());</span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;addService(<span class="string">&quot;manager&quot;</span>, manager, <span class="literal">false</span> <span class="comment">/*allowIsolated*/</span>, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">&quot;Could not self register servicemanager&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IPCThreadState::<span class="keyword">self</span>()-&gt;setTheContextObject(manager);</span><br><span class="line">    ps-&gt;becomeContextManager(nullptr, nullptr);<span class="comment">// 3.通知binder驱动将自己注册为binder服务大管家</span></span><br><span class="line"></span><br><span class="line">    sp&lt;Looper&gt; looper = Looper::prepare(<span class="literal">false</span> <span class="comment">/*allowNonCallbacks*/</span>);</span><br><span class="line"></span><br><span class="line">    BinderCallback::setupTo(looper);</span><br><span class="line">    ClientCallbackCallback::setupTo(looper, manager);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(-<span class="number">1</span>);<span class="comment">// 4.循环等待其它模块请求服务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should not be reached</span></span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了如下四件事情：</p>
<ol>
<li>通过调用ProcessState的initWithDriver静态接口，这其中会<strong>创建SM进程的ProcessState对象并完成进程的Binder初始化</strong>：先调用open_driver动作打开Binder驱动，然后调用mmap动作通知Binder驱动完成binder_mmap物理内存分配和虚拟内存映射的操作；</li>
<li>创建ServiceManager对象，并通过addService接口将SM自身注册为名为“manager”的Binder Server服务，<strong>也进一步说明SM自身本质上也是一个C++写的Binder Server服务进程</strong>；</li>
<li>调用ProcessState的becomeContextManager接口，<strong>通过binder_ioctl协议命令BINDER_SET_CONTEXT_MGR通知Binder设备驱动，将SM注册为binder服务“大管家”</strong>；</li>
<li>进入循环等待Binder Client进程的客户端进程访问请求。</li>
</ol>
<h2 id="ServiceManager进程Binder服务接口"><a href="#ServiceManager进程Binder服务接口" class="headerlink" title="ServiceManager进程Binder服务接口"></a>ServiceManager进程Binder服务接口</h2><p>我们看看ServiceManager.h接口文件的代码定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/cmds/servicemanager/ServiceManager.h*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceManager</span> :</span> <span class="keyword">public</span> os::BnServiceManager, <span class="keyword">public</span> IBinder::DeathRecipient &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ServiceManager</span>(std::unique_ptr&lt;Access&gt;&amp;&amp; access);</span><br><span class="line">    ~<span class="built_in">ServiceManager</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// getService will try to start any services it cannot find</span></span><br><span class="line">    <span class="comment">// 1.根据名称查询Binder Server服务</span></span><br><span class="line">    <span class="function">binder::Status <span class="title">getService</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">binder::Status <span class="title">checkService</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, sp&lt;IBinder&gt;* outBinder)</span> <span class="keyword">override</span></span>;</span><br><span class="line">     <span class="comment">// 2.注册Binder Server服务</span></span><br><span class="line">    <span class="function">binder::Status <span class="title">addService</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">bool</span> allowIsolated, <span class="keyword">int32_t</span> dumpPriority)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="comment">// 3.遍历列出所有已注册的Binder Server服务</span></span><br><span class="line">    <span class="function">binder::Status <span class="title">listServices</span><span class="params">(<span class="keyword">int32_t</span> dumpPriority, std::vector&lt;std::string&gt;* outList)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据上一节对Binder framework C++层的分析我们可以看到：<strong>ServiceManager继承自BnServiceManager,是一个Binder Server服务端实现。对客户端提供getService查询Service服务、addService注册Service服务以及listServices遍历所有已注册服务等核心功能接口</strong>。 其内部具体的实现是通过一个全局的名为mNameToService的ServiceMap类型（本质上还是一个map类型的集合）的变量记录维护着服务名称和具体的服务代理之间映射关系；以addService注册服务的实现代码为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*framework/native/cmds/servicemanager/ServiceManager.cpp*/</span></span><br><span class="line"><span class="function">Status <span class="title">ServiceManager::addService</span><span class="params">(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">bool</span> allowIsolated, <span class="keyword">int32_t</span> dumpPriority)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">auto</span> entry = mNameToService.<span class="built_in">emplace</span>(name, Service &#123;</span><br><span class="line">        .binder = binder,</span><br><span class="line">        .allowIsolated = allowIsolated,</span><br><span class="line">        .dumpPriority = dumpPriority,</span><br><span class="line">        .debugPid = ctx.debugPid,</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">ok</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="libbinder中对访问ServiceManager接口的封装"><a href="#libbinder中对访问ServiceManager接口的封装" class="headerlink" title="libbinder中对访问ServiceManager接口的封装"></a>libbinder中对访问ServiceManager接口的封装</h2><p>源码路径：</p>
<blockquote>
<p>frameworks/native/include/binder/IServiceManager.h frameworks/native/libs/binder/IServiceManager.cpp</p>
</blockquote>
<p><strong>这块逻辑相当于是Binder framework C++层的libbinder库作为Binder客户端对ServiceManager进程所提供的Binder服务端接口访问的封装。</strong></p>
<p>IServiceManager的C++接口定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/include/binder/IServiceManager.h*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">IServiceManager</span> : <span class="title">public</span> <span class="title">IInterface</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.根据名称查询Binder Server服务</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve an existing service, blocking for a few seconds</span></span><br><span class="line"><span class="comment">     * if it doesn&#x27;t yet exist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt;         <span class="title">getService</span>(<span class="params"> <span class="keyword">const</span> String16&amp; name</span>) <span class="keyword">const</span></span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Retrieve an existing service, non-blocking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt;         <span class="title">checkService</span>(<span class="params"> <span class="keyword">const</span> String16&amp; name</span>) <span class="keyword">const</span></span> = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 2.注册Binder Server服务</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a service.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// NOLINTNEXTLINE(google-default-arguments)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span>(<span class="params"><span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="built_in">bool</span> allowIsolated = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="built_in">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_DEFAULT</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.遍历列出所有已注册的Binder Server服务</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return list of all existing services.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// NOLINTNEXTLINE(google-default-arguments)</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Vector&lt;String16&gt; <span class="title">listServices</span>(<span class="params"><span class="built_in">int</span> dumpsysFlags = DUMP_FLAG_PRIORITY_ALL</span>)</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Efficiently wait for a service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Returns nullptr only for permission problem or fatal error.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> sp&lt;IBinder&gt; <span class="title">waitForService</span>(<span class="params"><span class="keyword">const</span> String16&amp; name</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>普通的Binder服务我们需要通过ServiceManager来获取接口才能调用，那么ServiceManager的接口又该如何获得呢？<strong>在libbinder中，提供了一个defaultServiceManager方法来获取ServiceManager的代理，并且这个方法不需要传入参数</strong>。原因我们在驱动篇中也已经讲过了：Binder的实现中，为ServiceManager留了一个特殊的位置，不需要像普通服务那样通过标识去查找。defaultServiceManager代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/native/libs/binder/IServiceManager.cpp*/</span></span><br><span class="line"><span class="function">sp&lt;IServiceManager&gt; <span class="title">defaultServiceManager</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(gSmOnce, []() &#123;</span><br><span class="line">        sp&lt;AidlServiceManager&gt; sm = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            sm = interface_cast&lt;AidlServiceManager&gt;(ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getContextObject</span>(<span class="literal">nullptr</span>));</span><br><span class="line">            <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">ALOGE</span>(<span class="string">&quot;Waiting 1s on context object on %s.&quot;</span>, ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">getDriverName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gDefaultServiceManager = <span class="keyword">new</span> <span class="built_in">ServiceManagerShim</span>(sm);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Binder-Framework-Java层"><a href="#Binder-Framework-Java层" class="headerlink" title="Binder Framework Java层"></a>Binder Framework Java层</h1><h2 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h2><p>Android应用使用Java语言开发，Binder Framework框架自然也是提供了相关Java接口。<strong>前面我们已经分析了Binder Framework C++层的完整实现。因此Java层完全不用重复实现，而是通过虚拟机提供的JNI机制，直接调用而复用C++层的实现</strong>。下面借用一张图描述Binder Framework Java层到C++层的调用关系。</p>
<p><img src="/images/android_binder_frame_work_java_struct.png" alt="img"></p>
<h2 id="JNI衔接调用"><a href="#JNI衔接调用" class="headerlink" title="JNI衔接调用"></a>JNI衔接调用</h2><p><strong>JNI全称是Java Native Interface，这个是由Java虚拟机提供的机制。这个机制使得native代码可以和Java代码互相通讯</strong>。简单来说就是：我们可以在C/C++端调用Java代码，也可以在Java端调用C/C++代码。实际上，在Android中很多的服务或者机制都是在C/C++层实现的，想要将这些实现复用到Java层，就必须通过JNI进行衔接。其实这里面就是解决两个方向的调用问题：</p>
<ol>
<li><strong>Java端的代码是如何调用的libbinder中的C++方法的？</strong> 以BinderProxy.java中的transact方法为例，其功能是实现Java层的Binder客户端使用服务端的远端代理完成一次Binder数据发送传输，简化代码实现如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/os/BinderProxy.java*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ..</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> transactNative(code, data, reply, flags);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Native implementation of transact() for proxies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">transactNative</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到方法transactNative是用native关键字修饰的，并且没有方法实现体，这些方法其实都是在C++中实现的。在android_util_Binder.cpp文件中的下面这段代码，定义了Java方法与C++方法的对应关系，并定义了真正的实现，简化代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/jni/android_util_Binder.cpp*/</span></span><br><span class="line"><span class="comment">// 集合中定义了Java方法与C++方法的对应关系</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gBinderProxyMethods[] = &#123;</span><br><span class="line">     <span class="comment">/* name, signature, funcPtr */</span></span><br><span class="line">     ...</span><br><span class="line">    &#123;<span class="string">&quot;transactNative&quot;</span>,      <span class="string">&quot;(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z&quot;</span>, (<span class="keyword">void</span>*)android_os_BinderProxy_transact&#125;,</span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">android_os_BinderProxy_transact</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jint code, jobject dataObj, jobject replyObj, jint flags)</span> <span class="comment">// throws RemoteException</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 1.获取BpBinder对象</span></span><br><span class="line">    IBinder* target = <span class="built_in">getBPNativeData</span>(env, obj)-&gt;mObject.<span class="built_in">get</span>();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 2.调用libbinder中的BpBinder的transact接口实现真正的Binder传输</span></span><br><span class="line">    <span class="keyword">status_t</span> err = target-&gt;<span class="built_in">transact</span>(code, *data, reply, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>libbinder如何能够通知调用到Java层呢？</strong> 下面以libbinder中的BBinder::onTransact如何调用到Java中的Binder::onTransact为例进行分析：这段逻辑是在android_util_Binder.cpp中JavaBBinder::onTransact（<strong>JavaBBinder是BBinder子类</strong>）中<strong>借用虚拟机提供的CallBooleanMethod接口实现native方法调用Java Object上的方法实现</strong>。简化代码实现如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/jni/android_util_Binder.cpp*/</span></span><br><span class="line"><span class="comment">// JavaBBinder是BBinder的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBBinder</span> :</span> <span class="keyword">public</span> BBinder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 1\. CallBooleanMethod这个方法是由虚拟机提供的实现native方法来调用一个Java Object上的方法。这一行代码其实是在调用mObject上offset为mExecTransact的方法,</span></span><br><span class="line">        jboolean res = env-&gt;<span class="built_in">CallBooleanMethod</span>(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">            code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kBinderPathName = <span class="string">&quot;android/os/Binder&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">int_register_android_os_Binder</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    jclass clazz = <span class="built_in">FindClassOrDie</span>(env, kBinderPathName);</span><br><span class="line">    <span class="comment">// 2\. 找到android/os/Binder.java中的execTransact方法</span></span><br><span class="line">    gBinderOffsets.mExecTransact = <span class="built_in">GetMethodIDOrDie</span>(env, clazz, <span class="string">&quot;execTransact&quot;</span>, <span class="string">&quot;(IJJI)Z&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RegisterMethodsOrDie</span>(</span><br><span class="line">        env, kBinderPathName,</span><br><span class="line">        gBinderMethods, <span class="built_in">NELEM</span>(gBinderMethods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*frameworks/base/core/java/android/os/Binder.java*/</span></span><br><span class="line"> <span class="comment">// Entry point from android_util_Binder.cpp&#x27;s onTransact</span></span><br><span class="line">    @<span class="function">UnsupportedAppUsage</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> boolean <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">execTransactInternal</span>(code, dataObj, replyObj, flags, callingUid);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            ThreadLocalWorkSource.<span class="built_in">restore</span>(origWorkSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">execTransactInternal</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> callingUid)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> ((flags &amp; FLAG_COLLECT_NOTED_APP_OPS) != <span class="number">0</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用到java层的onTransact实现</span></span><br><span class="line">                res = <span class="built_in">onTransact</span>(code, data, reply, flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span> (RemoteException|RuntimeException e) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-Binder服务实现举例"><a href="#Java-Binder服务实现举例" class="headerlink" title="Java Binder服务实现举例"></a>Java Binder服务实现举例</h2><p>和C++层一样，这里我们还是通过一个具体的实例来看一下Java层的Binder服务是如何实现的。 以系统框架system_server进程的核心服务ActivityManager为例，下面是其实现的类图结构：</p>
<p><img src="/images/android_binder_java_binder_example.png" alt="img"></p>
<p>Binder_ActivityManager.png</p>
<p>IActivityManager接口定义了ActivityManager对外提供的功能接口，其子类都继承了这些接口。</p>
<ul>
<li>IActivityManager.Stub.Proxy是提供给客户端调用的远程接口，<strong>获取到指向服务实现方的句柄BinderProxy，然后通过transact方法发送具体请求</strong>。</li>
<li>IActivityManager.Stub是服务端的实现，<strong>其中只有一个onTransact方法，该方法根据请求的code来对接每个请求，并直接调用ActivityManagerService中对应的方法</strong>。</li>
<li>ActivityManagerService是服务端接口功能真正的实现。</li>
</ul>
<p><strong>可以看到，这种组织架构和4.4.4小结中Binder C++层SurfaceFlinger服务基本是一样的</strong>。对于Android应用程序的开发者来说，系统对这些类进行了封装，所以我们不会直接接触到上图中的几个类，而是使用android.app.ActivityManager中的接口。那ActivityManager中的接口与上图的实现是什么关系呢。我们选取其中的一个方法来看一下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityManager.java*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;RunningAppProcessInfo&gt; <span class="title">getRunningAppProcesses</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getService().getRunningAppProcesses();</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的实现调用了getService()中的方法，因此我们在来看一下getService()返回到到底是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*frameworks/base/core/java/android/app/ActivityManager.java*/</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">            <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 1.通过访问ServiceManager按照服务名“activity”查询获取到远端服务的代理IBinder对象</span></span><br><span class="line">                    <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                    <span class="comment">// 2.调用asInterface将获取到的远端服务代理IBinder对象转换封装成客户端IActivityManager接口对象</span></span><br><span class="line">                    <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                    <span class="keyword">return</span> am;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>

<p>这里其实是先通过IBinder b = ServiceManager.getService(“activity”); 向 ServiceManager查询获取到ActivityManager的远端服务代理Binder对象（<strong>该AMS系统核心服务在系统开机过程中提前在ServiceManager Binder“大管家”进程中注册，且服务名为“activity”</strong>）;接着我们再来看一下asInterface(b)的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*gen/android/app/IActivityManager.java*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> android.app.<span class="function">IActivityManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">      <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> android.app.IActivityManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((android.app.IActivityManager)iin);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> android.app.IActivityManager.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先通过queryLocalInterface确定有没有本地Binder，如果有的话直接返回，否则创建一个android.app.IActivityManager.Stub.Proxy客户端代理对象。</p>
<h2 id="AIDL机制"><a href="#AIDL机制" class="headerlink" title="AIDL机制"></a>AIDL机制</h2><p>Android应用开发者对AIDL机制应该不会陌生，AIDL全称是Android Interface Definition Language，它是Android SDK提供的一种机制。借助这个机制，应用可以提供跨进程的服务供其他应用使用。<strong>aidl文件使用Java语言的语法来定义，每个.aidl文件只能包含一个interface，并且要包含interface的所有方法声明。</strong>。 下面是一个aidl文件的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterface.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.myapplication;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">long</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(in <span class="keyword">int</span>[] numbers)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件中包含了两个接口add和sum。<strong>对于包含.aidl文件的工程，Android IDE在编译项目的时候，会为aidl文件生成对应的Java文件</strong>。针对上面这个aidl文件编译后生成的java文件中包含的结构如下图所示：</p>
<p><img src="/images/android_binder_aidl_my_aidl.png" alt="img"></p>
<p>在这个生成的Java文件中，包括了：</p>
<ol>
<li><strong>公共接口定义</strong>：一个名称为IMyAildInterface的interface，该interface继承自android.os.IInterface并且包含了我们在aidl文件中声明的接口方法add和sum。</li>
<li><strong>Binder服务端实现封装</strong>：IMyAildInterface中包含了一个名称为Stub的静态内部类，这个类是一个抽象类，<strong>它继承自android.os.Binder并且实现了IMyAildInterface接口。这个类中包含了一个onTransact方法</strong>。</li>
<li><strong>Binder客户端实现封装</strong>：Stub内部又包含了一个名称为Proxy的静态内部类，<strong>Proxy类同样实现了IMyAildInterface接口，内部通过持有android.os.IBinder类型的mRemote远程服务代理对象</strong>，调用其transact方法实现Binder访问。</li>
</ol>
<p><strong>从这个过程也可以看出，AIDL是典型的代理设计模式的思想体现，本质上是对Java层Binder逻辑在编译时自动简化封装，省去应用开发者去写公共且繁琐的实现代理模式相关代码。</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我们基本上从下到上完整的分析了整个Binder进程间通信机制的全貌，这可以说是Android系统中最复杂的模块之一了，也是整个系统运行的基石。建议每一位有志于成为Android开发专家的读者都有必要好好研读一下本章节的全部内容。最后借用一张业界大佬绘制的Binder IPC机制整体数据传输架构图来结束本章节的全部内容。</p>
<p><img src="/images/android_binder_end_summary.png" alt="img"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>转载参考链接：<a href="https://www.jianshu.com/p/b47caded149a">https://www.jianshu.com/p/b47caded149a</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Android自定义View</title>
    <url>/2017/03/11/android_custom_view/</url>
    <content><![CDATA[<p>在Android开发中有很多业务场景，原生的控件是无法满足应用，并且经常也会遇到一个UI在多处 重复使用情况，那么就需要通过自定义View的方式来实现这些UI效果。</p>
<p>作为一个Android开发工程师自定义View属于一个必备技能。</p>
<span id="more"></span>

<h1 id="View和ViewGroup体系结构"><a href="#View和ViewGroup体系结构" class="headerlink" title="View和ViewGroup体系结构"></a>View和ViewGroup体系结构</h1><p><img src="/images/android_custom_view01.png" alt="img"></p>
<h1 id="自定义View的几种方式"><a href="#自定义View的几种方式" class="headerlink" title="自定义View的几种方式"></a>自定义View的几种方式</h1><p>自定义View的实现方式有以下几种：</p>
<ul>
<li><p>组合控件</p>
</li>
<li><p>继承控件</p>
</li>
<li><p>自绘控件</p>
</li>
</ul>
<h2 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h2><p>组合控件就是将多个控件组合成一个新的控件，可以重复使用。</p>
<p>应用场景：在项目中经常会遇到一些比较复杂的UI块需要用在多处使用，那么我们就可以通过五大布局 和基本控件组合成一个新的布局View，这样就可以方便的将该UI用在项目的不同页面中，比如一个标题 栏。这种方式比较简单，只要通过布局文件实现相应的UI，然后将该UI加到适合的五大布局中即可。<br>组合控件完整的实现步骤：</p>
<ol>
<li><p>编写布局文件</p>
</li>
<li><p>实现构造方法</p>
</li>
<li><p>初始化UI 4. 提供对外的方法</p>
</li>
<li><p>在布局当中引用该控件</p>
</li>
<li><p>activity中使用</p>
</li>
</ol>
<p><strong>实现一个简易的标题组件</strong></p>
<p>中间是title的文字，左边是返回按钮</p>
<ol>
<li>编写布局文件 view_header.xml</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;#89CEED&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/rl&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;60dp&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/iv_img&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerVertical</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:srcCompat</span>=<span class="string">&quot;@drawable/ic_baseline_arrow_back_24&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;22sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerInParent</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/white&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;微信&quot;</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>实现构造方法</li>
<li>初始化UI</li>
<li>提供对外的方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为我们的布局采用RelativeLayout，所以这里继承RelativeLayout。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderView</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button left_btn;</span><br><span class="line">    <span class="keyword">private</span> TextView title_tv;</span><br><span class="line">    <span class="keyword">private</span> RelativeLayout layout_root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        initView(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化UI，可根据业务需求设置默认值。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.view_header, <span class="keyword">this</span>,</span><br><span class="line">                <span class="keyword">true</span>);</span><br><span class="line">        left_btn = findViewById(R.id.left_btn);</span><br><span class="line">        title_tv = findViewById(R.id.title_tv);</span><br><span class="line">        layout_root = findViewById(R.id.header_root_layout);</span><br><span class="line">        layout_root.setBackgroundColor(Color.BLACK);</span><br><span class="line">        title_tv.setTextColor(Color.WHITE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置标题文字的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(title)) &#123;</span><br><span class="line">            title_tv.setText(title);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对左边按钮设置事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLeftListener</span><span class="params">(OnClickListener onClickListener)</span> </span>&#123;</span><br><span class="line">        left_btn.setOnClickListener(onClickListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在布局当中引用该控件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.hopu.customviewdemo.view.HeaderView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/title_bar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>activity中使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeaderView title_bar;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main2);</span><br><span class="line">        title_bar = findViewById(R.id.title_bar);</span><br><span class="line">        title_bar.setLeftListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity2.<span class="keyword">this</span>, <span class="string">&quot;左侧按钮被点击&quot;</span>,</span><br><span class="line">                        Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承控件"><a href="#继承控件" class="headerlink" title="继承控件"></a>继承控件</h2><p>通过继承系统控件（View子类控件或ViewGroup子类控件）来完成自定义View，一般是希望在原 有系统控件基础上做一些修饰性的修改，而不会做大幅度的改动，如在TextView的文字下方添加下 划线，在LinearLayout布局中加一个蒙板等。这种方式往往都会复用系统控件的onMeasure和onLayout方法，而只需要重写onDraw方法，在其中绘制一些需要的内容。<br><strong>实现TextView文字下方显示红色下划线</strong></p>
<ol>
<li>继承View控件，并重写onDraw方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnderlineTextView</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">androidx</span>.<span class="title">appcompat</span>.<span class="title">widget</span>.<span class="title">AppCompatTextView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnderlineTextView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">        paint.setColor(Color.RED);</span><br><span class="line">        paint.setStrokeWidth(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">int</span> width = getWidth();</span><br><span class="line">        <span class="keyword">int</span> height = getBaseline();</span><br><span class="line">        canvas.drawLine(<span class="number">0</span>, height, width, height, paint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>在布局文件中调用</li>
</ol>
<p>就像使用一个普通TextView一样使用UnderlineTextView。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.hopu.customviewdemo.view.UnderlineTextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="自绘控件"><a href="#自绘控件" class="headerlink" title="自绘控件"></a>自绘控件</h2><p>这种情况一般是出现了通过系统自带组件的各种设置项无法满足需求时，即可采用自行绘制解决。比如我们绘制一个定制图案的Loading组件。</p>
<p><img src="/images/android_custom_view02.png" alt="image-20221205204547298"></p>
<p>主要的实现代码在onDraw中，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Taurus on 2018/1/21.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmileView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_BORDER_WIDTH = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ANIMATION_DURATION = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mWidth, mHeight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCenterX, mCenterY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Paint mBorderPaint;</span><br><span class="line">    <span class="keyword">private</span> Paint mFacePaint;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> borderWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> borderColor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> faceColor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Path mLeftPath;</span><br><span class="line">    <span class="keyword">private</span> Path mRightPath;</span><br><span class="line">    <span class="keyword">private</span> Path mBottomPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左眼坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] leftPoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右眼坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] rightPoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 嘴巴坐标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] bottomPoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左眼控制点范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] leftControlLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右眼控制点范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] rightControlLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 嘴巴控制点范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] bottomControlLimit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> leftControlY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> rightControlY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> bottomControlY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ValueAnimator mValueAnimator01;</span><br><span class="line">    <span class="keyword">private</span> ValueAnimator mValueAnimator02;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasAttach;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnimation01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dValueTop = leftControlLimit[<span class="number">1</span>] - leftControlLimit[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dValueBottom = bottomControlLimit[<span class="number">1</span>] - bottomControlLimit[<span class="number">0</span>];</span><br><span class="line">        mValueAnimator01 = ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        mValueAnimator01.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> value = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">                leftControlY = rightControlY = leftControlLimit[<span class="number">0</span>]  + (dValueTop * value);</span><br><span class="line">                bottomControlY = bottomControlLimit[<span class="number">1</span>] - (dValueBottom * value);</span><br><span class="line">                invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mValueAnimator01.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">                startAnimation02();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mValueAnimator01.setDuration(ANIMATION_DURATION);</span><br><span class="line">        mValueAnimator01.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnimation02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dValueTop = leftControlLimit[<span class="number">1</span>] - leftControlLimit[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dValueBottom = bottomControlLimit[<span class="number">1</span>] - bottomControlLimit[<span class="number">0</span>];</span><br><span class="line">        mValueAnimator02 = ValueAnimator.ofFloat(<span class="number">1.0f</span>, <span class="number">0f</span>);</span><br><span class="line">        mValueAnimator02.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">float</span> value = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">                leftControlY = rightControlY = leftControlLimit[<span class="number">0</span>]  + (dValueTop * value);</span><br><span class="line">                bottomControlY = bottomControlLimit[<span class="number">1</span>] - (dValueBottom * value);</span><br><span class="line">                invalidate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mValueAnimator02.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onAnimationEnd(animation);</span><br><span class="line">                startAnimation01();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mValueAnimator02.setDuration(ANIMATION_DURATION);</span><br><span class="line">        mValueAnimator02.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAnimator01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mValueAnimator01!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            mValueAnimator01.removeAllListeners();</span><br><span class="line">            mValueAnimator01.removeAllUpdateListeners();</span><br><span class="line">            mValueAnimator01.cancel();</span><br><span class="line">            mValueAnimator01 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAnimator02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mValueAnimator02!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            mValueAnimator02.removeAllListeners();</span><br><span class="line">            mValueAnimator02.removeAllUpdateListeners();</span><br><span class="line">            mValueAnimator02.cancel();</span><br><span class="line">            mValueAnimator02 = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmileView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmileView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmileView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        borderWidth = DEFAULT_BORDER_WIDTH;</span><br><span class="line">        borderColor = Color.YELLOW;</span><br><span class="line">        faceColor = borderColor;</span><br><span class="line"></span><br><span class="line">        leftPoint = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">4</span>];</span><br><span class="line">        rightPoint = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">4</span>];</span><br><span class="line">        bottomPoint = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        leftControlLimit = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>];</span><br><span class="line">        rightControlLimit = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>];</span><br><span class="line">        bottomControlLimit = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        mLeftPath = <span class="keyword">new</span> Path();</span><br><span class="line">        mRightPath = <span class="keyword">new</span> Path();</span><br><span class="line">        mBottomPath = <span class="keyword">new</span> Path();</span><br><span class="line"></span><br><span class="line">        mBorderPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mBorderPaint.setColor(borderColor);</span><br><span class="line">        mBorderPaint.setStrokeWidth(borderWidth);</span><br><span class="line">        mBorderPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line"></span><br><span class="line">        mFacePaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        mFacePaint.setColor(faceColor);</span><br><span class="line">        mFacePaint.setStrokeWidth(borderWidth);</span><br><span class="line">        mFacePaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        mWidth = w;</span><br><span class="line">        mHeight = h;</span><br><span class="line">        mCenterX = mWidth/<span class="number">2</span>;</span><br><span class="line">        mCenterY = mHeight/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        mBorderPaint.setShader(<span class="keyword">new</span> LinearGradient(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight, Color.YELLOW, Color.BLUE, Shader.TileMode.MIRROR));</span><br><span class="line">        mFacePaint.setShader(<span class="keyword">new</span> LinearGradient(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight, Color.YELLOW, Color.BLUE, Shader.TileMode.MIRROR));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> dVH = <span class="number">0.2f</span>;</span><br><span class="line">        <span class="keyword">float</span> dVV = <span class="number">0.3f</span>;</span><br><span class="line">        <span class="keyword">float</span> topV1 = <span class="number">0.3f</span>;</span><br><span class="line">        <span class="keyword">float</span> topV2 = <span class="number">1.1f</span>;</span><br><span class="line"></span><br><span class="line">        leftPoint[<span class="number">0</span>] = mCenterX * dVH;</span><br><span class="line">        leftPoint[<span class="number">1</span>] = mCenterY - (mCenterY * dVV);</span><br><span class="line"></span><br><span class="line">        leftPoint[<span class="number">2</span>] = mCenterX - (mCenterX * dVH);</span><br><span class="line">        leftPoint[<span class="number">3</span>] = leftPoint[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        leftControlLimit[<span class="number">0</span>] = rightControlLimit[<span class="number">0</span>] = mCenterY * topV1;</span><br><span class="line">        leftControlLimit[<span class="number">1</span>] = rightControlLimit[<span class="number">1</span>] = mCenterY * topV2;</span><br><span class="line"></span><br><span class="line">        rightPoint[<span class="number">0</span>] = mCenterX + (mCenterX * dVH);</span><br><span class="line">        rightPoint[<span class="number">1</span>] = leftPoint[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        rightPoint[<span class="number">2</span>] = mWidth - (mCenterX * dVH);</span><br><span class="line">        rightPoint[<span class="number">3</span>] = rightPoint[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> dVH1 = <span class="number">0.5f</span>;</span><br><span class="line">        <span class="keyword">float</span> dVV1 = <span class="number">0.4f</span>;</span><br><span class="line">        <span class="keyword">float</span> bottomV1 = <span class="number">0f</span>;</span><br><span class="line">        <span class="keyword">float</span> bottomV2 = <span class="number">0.9f</span>;</span><br><span class="line"></span><br><span class="line">        bottomPoint[<span class="number">0</span>] = mCenterX - (mCenterX * dVH1);</span><br><span class="line">        bottomPoint[<span class="number">1</span>] = mCenterY + (mCenterY * dVV1);</span><br><span class="line"></span><br><span class="line">        bottomPoint[<span class="number">2</span>] = mCenterX + (mCenterY * dVH1);</span><br><span class="line">        bottomPoint[<span class="number">3</span>] = bottomPoint[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        bottomControlLimit[<span class="number">0</span>] = mCenterY + (mCenterY * bottomV1);</span><br><span class="line">        bottomControlLimit[<span class="number">1</span>] = mCenterY + (mCenterY * bottomV2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorderWidth</span><span class="params">(<span class="keyword">int</span> borderWidth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.borderWidth = borderWidth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBorderColor</span><span class="params">(<span class="keyword">int</span> borderColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.borderColor = borderColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFaceColor</span><span class="params">(<span class="keyword">int</span> faceColor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.faceColor = faceColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAttachedToWindow();</span><br><span class="line">        hasAttach = <span class="keyword">true</span>;</span><br><span class="line">        startAnimation01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line">        cancelAnimator01();</span><br><span class="line">        cancelAnimator02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="keyword">if</span>(!hasAttach)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        drawBorder(canvas);</span><br><span class="line">        drawFace(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawBorder</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        canvas.drawRoundRect(<span class="keyword">new</span> RectF(borderWidth/<span class="number">2</span>, borderWidth/<span class="number">2</span>, mWidth - (borderWidth/<span class="number">2</span>), mHeight - (borderWidth/<span class="number">2</span>)), <span class="number">10</span>, <span class="number">10</span>, mBorderPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawFace</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        canvas.drawPoint(mCenterX, mCenterY ,mFacePaint);</span><br><span class="line"></span><br><span class="line">        mLeftPath.reset();</span><br><span class="line">        mRightPath.reset();</span><br><span class="line">        mBottomPath.reset();</span><br><span class="line"></span><br><span class="line">        mLeftPath.moveTo(leftPoint[<span class="number">0</span>], leftPoint[<span class="number">1</span>]);</span><br><span class="line">        mLeftPath.quadTo(mCenterX/<span class="number">2</span>, leftControlY, leftPoint[<span class="number">2</span>], leftPoint[<span class="number">3</span>]);</span><br><span class="line">        canvas.drawPath(mLeftPath, mFacePaint);</span><br><span class="line"></span><br><span class="line">        mRightPath.moveTo(rightPoint[<span class="number">0</span>], rightPoint[<span class="number">1</span>]);</span><br><span class="line">        mRightPath.quadTo(mCenterX + (mCenterX/<span class="number">2</span>), rightControlY, rightPoint[<span class="number">2</span>], rightPoint[<span class="number">3</span>]);</span><br><span class="line">        canvas.drawPath(mRightPath, mFacePaint);</span><br><span class="line"></span><br><span class="line">        mBottomPath.moveTo(bottomPoint[<span class="number">0</span>], bottomPoint[<span class="number">1</span>]);</span><br><span class="line">        mBottomPath.quadTo(mCenterX, bottomControlY, bottomPoint[<span class="number">2</span>], bottomPoint[<span class="number">3</span>]);</span><br><span class="line">        canvas.drawPath(mBottomPath, mFacePaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h1><p>View 的绘制主要有以下一些核心内容：</p>
<ol>
<li><p><strong>三大流程</strong>：View 绘制主要包含如下三大流程：</p>
<ul>
<li><strong>measure</strong>：测量流程，主要负责对 View 进行测量，其核心逻辑位于<code>View#measure(...)</code>，真正的测量处理由<code>View#onMeasure(...)</code>负责。默认的测量规则为：如果 View 的布局参数为<code>LayoutParams.WRAP_CONTENT</code>或<code>LayoutParams.MATCH_PARENT</code>，那么其测量大小为 SpecSize；如果其布局参数为<code>LayoutParams.UNSPECIFIED</code>，那么其测量大小为<code>android:minWidth</code>/<code>android:minHeight</code>和其背景之间的较大值。</li>
</ul>
<p>自定义View 通常覆写<code>onMeasure(...)</code>方法，在其内一般会对<code>WRAP_CONTENT</code>预设一个默认值，区分<code>WARP_CONTENT</code>和<code>MATCH_PARENT</code>效果，最终完成自己的测量宽/高。而<code>ViewGroup</code>在<code>onMeasure(...)</code>方法中，通常都是先测量子View，收集到相应数据后，才能最终测量自己。</p>
<ul>
<li><p><strong>layout</strong>：布局流程，主要完成对 View 的位置放置，其核心逻辑位于<code>View#layout(...)</code>，该方法内部主要通过<code>View#setFrame(...)</code>记录自己的四个顶点坐标（记录与对应成员变量中即可），完成自己的位置放置，最后会回调<code>View#onLayout(...)</code>方法，在其内完成对 子View 的布局放置。</p>
<p><strong>注</strong>：不同于 measure 流程首先对 子View 进行测量，最后才测量自己，layout 流程首先是先定位自己的布局位置，然后才处理放置 子View 的布局位置。</p>
</li>
<li><p><strong>draw</strong>：绘制流程，就是将 View 绘制到屏幕上，其核心逻辑位于<code>View#draw(...)</code>，主要就是对 <strong>背景</strong>、<strong>自身内容（<code>onDraw(...)</code>）</strong>、<strong>子View（<code>dispatchDraw(...)</code>）</strong>、<strong>装饰（滚动条、前景等）</strong> 进行绘制。</p>
<p><strong>注</strong>：通常自定义View 覆写<code>onDraw(...)</code>方法，完成自己的绘制即可，ViewGroup 一般充当容器使用，因此通常无需覆写<code>onDraw(...)</code>。</p>
</li>
</ul>
</li>
<li><p>Activity 的根视图（即<code>DecorView</code>）最终是绑定到<code>ViewRootImpl</code>，具体是由<code>ViewRootImpl#setView(...)</code>进行绑定关联的，后续 View 绘制的三大流程都是均有<code>ViewRootImpl</code>负责执行的。</p>
</li>
<li><p>对 View 的测量流程中，最关键的一步是求取 View 的<code>MeasureSpec</code>，View 的<code>MeasureSpec</code>是在其父容器<code>MeasureSpec</code>的约束下，结合自己的<code>LayoutParams</code>共同测量得到的，具体的测量逻辑由<code>ViewGroup#getChildMeasureSpec(...)</code>负责。<br> <code>DecorView</code>的<code>MeasureSpec</code>取决于自己的<code>LayoutParams</code>和屏幕尺寸，具体的测量逻辑位于<code>ViewRootImpl#getRootMeasureSpec(...)</code>。</p>
</li>
</ol>
<p>最后，稍微总结一下 View 绘制的整个流程：</p>
<ol>
<li><p>首先，当 Activity 启动时，会触发调用到<code>ActivityThread#handleResumeActivity(..)</code>，其内部会经历一系列过程，生成<code>DecorView</code>和<code>ViewRootImpl</code>等实例，最后通过<code>ViewRootImpl#setView(decor,MATCH_PARENT)</code>设置 Activity 根View。</p>
<p><strong>注</strong>：<code>ViewRootImpl#setView(...)</code>内容通过将其成员属性<code>ViewRootImpl#mView</code>指向<code>DecorView</code>，完成两者之间的关联。</p>
</li>
<li><p><code>ViewRootImpl</code>成功关联<code>DecorView</code>后，其内部会设置同步屏障并发送一个<code>CALLBACK_TRAVERSAL</code>异步渲染消息，在下一次 VSYNC 信号到来时，<code>CALLBACK_TRAVERSAL</code>就会得到响应，从而最终触发执行<code>ViewRootImpl#performTraversals(...)</code>，真正开始执行 View 绘制流程。</p>
</li>
<li><p><code>ViewRootImpl#performTraversals(...)</code>内部会依次调用<code>ViewRootImpl#performMeasure(...)</code>、<code>ViewRootImpl#performLayout(...)</code>和<code>ViewRootImpl#performDraw(...)</code>三大绘制流程，其中：</p>
<ul>
<li>**<code>performMeasure(..)</code>**：内部主要就是对<code>DecorView</code>执行测量流程：<code>DecorView#measure(...)</code>。<code>DecorView</code>是一个<code>FrameLayout</code>，其布局特性是层叠布局，所占的空间就是其 子View 占比最大的宽/高，因此其测量逻辑（<code>onMeasure(...)</code>）是先对所有 子View 进行测量，具体是通过<code>ViewGroup#measureChildWithMargins(...)</code>方法对 子View 进行测量，子View 测量完成后，记录最大的宽/高，设置为自己的测量大小（通过<code>View#setMeasuredDimension(...)</code>），如此便完成了<code>DecorView</code>的测量流程。</li>
<li>**<code>performLayout(...)</code>**：内部其实就是调用<code>DecorView#layout(...)</code>，如此便完成了<code>DecorView</code>的布局位置，最后会回调<code>DecorView#onLayout(...)</code>，负责 子View 的布局放置，核心逻辑就是计算出各个 子View 的坐标位置，最后通过<code>child.layout(...)</code>完成 子View 布局。</li>
<li><strong><code>performDraw()</code><strong>：内部最终调用到的是<code>DecorView#draw(...)</code>，该方法内部并未对绘制流程做任何修改，因此最终执行的是<code>View#draw(...)</code>，所以主要就是依次完成对<code>DecorView</code>的 <strong>背景</strong>、</strong>子View（<code>dispatchDraw(...)</code>）</strong> 和 <strong>视图装饰（滚动条、前景等）</strong> 的绘制。</li>
</ul>
</li>
</ol>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://book.douban.com/subject/26599538/">Android开发艺术探索</a></li>
<li><a href="https://www.cnblogs.com/andy-songwei/p/10955062.html">Android自定义View篇之（一）View绘制流程</a></li>
<li><a href="https://www.jianshu.com/p/ee5d3bb5ab90">Android - View 绘制流程</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化-App启动速度优化</title>
    <url>/2019/11/30/android_launch_better_performace/</url>
    <content><![CDATA[<p>随着项目的迭代，App的功能越来越丰富，无可避免的是我们将会引入更多的第三方库及各种SDK，因此App在启动时要做的初始化工作也会更繁重，不当的初始化行为就会拖慢App的启动响应速度，给用户带来糟糕的使用体验。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Android的启动优化主要是加速用户打开App到可交互的时间。在这段时间里面经历的Application的启动创建，SplashActivity、MainActivity的启动创建(有些App没有Splash页面)。</p>
<ul>
<li>Application的创建过程的调用顺序大致如下：</li>
</ul>
<p>AMS、Zygote—&gt;bindApplication—&gt;attachContext—&gt;ContentProvider—&gt;onCreate</p>
<ul>
<li>Activity的创建到第一帧显示过程调用顺序如下：</li>
</ul>
<p>Activity—&gt;onCreate—&gt;onStart—&gt;onResume—&gt;onWindowFoucusChanged</p>
<p>从视觉交互来说，App的启动过程主要显示了3屏：</p>
<ul>
<li>第一屏：在主题中设置<code>android:windowBackground</code>的图片，这个过程在**Application.attachBaseContext()——Splash.onWindowFocusChanged()**之间。</li>
<li>第二屏：Splash绘制的内容，这个过程在**Splash.onWindowFocusChanged()——Main.onWindowFocusChanged()**之间。</li>
<li>第三屏：Main绘制的内容，这个在<strong>Main.onWindowFocusChanged</strong>之后。</li>
</ul>
<p>所以，启动的优化范围一般在**Application. attachBaseContext ()——Main.onWindowFocusChanged()**之间。其中第一屏和第二屏是的耗时是需要重点关注。这里把第一屏的时间叫做Application的启动耗时，第一屏+第二屏的时间Application启动到可交互页面的启动耗时。</p>
<h1 id="启动优化步骤"><a href="#启动优化步骤" class="headerlink" title="启动优化步骤"></a>启动优化步骤</h1><h2 id="评估时间数据"><a href="#评估时间数据" class="headerlink" title="评估时间数据"></a>评估时间数据</h2><p>在启动优化中，并不是自己觉得哪个地方会耗时，就开始做优化，这样可能带来辛辛苦苦做了一顿优化后，总耗时还是没有好的效果，原因可能是我们直觉耗时的地方并不准确。正确的做法是<code>先得到启动过程中每个方法的时间</code>，得到全部时间表后，分析耗时的地方在哪里记录下来。<br> 那怎么获取到每个方法的执行时间呢？，大致如下：<br> <strong>1. 自带的Profiler</strong><br> 配置应用启动时开始profiler监控如下：</p>
<p><img src="/images/android_launch_better_performance01.png" alt="img"></p>
<p><strong>2. Systrace+函数插桩</strong></p>
<h2 id="梳理业务"><a href="#梳理业务" class="headerlink" title="梳理业务"></a>梳理业务</h2><p>在第一步得到时间数据后，下一步就是整理启动过程的业务梳理，避免因优化而影响业务。</p>
<h2 id="优化业务"><a href="#优化业务" class="headerlink" title="优化业务"></a>优化业务</h2><p>优化的思想大致如下：</p>
<ol>
<li>通过上面的两个步骤，看主线程究竟慢哪里</li>
<li>懒加载，包括业务与布局的懒加载</li>
<li>抛到子线程让其自己加载</li>
<li>提前加载，通过多线程提高效率</li>
<li>检查主线程的IO操作</li>
<li>控制线程的数量和GC的次数</li>
</ol>
<p><strong>1. Application.onCreate()</strong><br> 在这个方法中主要是做SDK的初始化和App状态判断，<br> sdk优化主要有三点：<br> 一：sdk的懒加载，再使用到的时候才去初始化，不要全部放到在Application初始化。<br> 二：对于sdk有依赖的关系的，比如sdk2需要sdk1完成加载后开始初始化，可以利用拓扑算法优化实现sdk加载:<a href="https://links.jianshu.com/go?to=https://github.com/idisfkj/android-startup">android-startup</a><br> 三：把sdk放到子线程中自己初始化，不要阻塞主线程的时间，一些必须初始化的sdk，可以通过多线程加载然后通过CountDownLatch进行阻塞和唤醒。</p>
<p>业务代码的优化：<br> 一：尽量不要滥用ContentProvider,因为其是在Application.attachBaseContext就会初始化其ContentProvider.onCreate()方法，会加长启动时间。<br> 二：查看Application主线程耗时的地方，尽量去优化。</p>
<p><strong>2. Activity.onCreate()</strong><br> 要弄清楚哪里耗时了，才着手优化。常见优化有：<br> 一： setContentVIew()的耗时，这时要优化布局，减少布局背景的重复渲染、减少层级、对于不一定显示的布局用ViewStub按需加载。子线程加载布局，或提前子线程加载。<br> 二：initView()初始化View时不要做耗时操作，比如一些IO操作、播放器等做到按需懒加载，也可以通过让其在多线程中加载不阻塞主线程，也可以通过多线程提前加载。<br> 三：主页面的ViewPager+Fragment可以通过懒加载按需加载Fragment</p>
<p><strong>3. Activity.onResume()</strong><br> 不要在onResume()方法中不要做主线程耗时操作，因为这时页面还没渲染出来，其还要通过Vsync信号来临做绘制三大流程，最终交给屏幕渲染出来，回调执行onWindowFocusChanged()方法。</p>
<p><strong>4.检查主线程IO操作</strong><br> 可以在线下通过<code>StrictMode</code>类来检查IO操作，如果在主线程有IO操作会输入日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> fun <span class="title">startStrictMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(</span><br><span class="line">            StrictMode.ThreadPolicy.Builder()</span><br><span class="line">            .detectDiskWrites()</span><br><span class="line">            .detectDiskReads()</span><br><span class="line">            .detectNetwork()</span><br><span class="line">            .penaltyLog()</span><br><span class="line">            .build()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">            StrictMode.setVmPolicy(</span><br><span class="line">            StrictMode.VmPolicy.Builder()</span><br><span class="line">            .detectLeakedClosableObjects()</span><br><span class="line">            .penaltyLog()</span><br><span class="line">            .build()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android启动优化更多的是一种优化思路，因为每个项目都不一样，导致优化的点也不一样，但掌握了优化思路可以以不变应万变。</p>
<ol>
<li>首先分析启动耗时的地方和启动过程相关任务。</li>
<li>知道主线程哪里耗时</li>
<li>SDK初始化按需加载、有依赖关系通过拓扑算法优化</li>
<li>布局优化，子线程加载布局，提前加载布局</li>
<li>一些主线程耗时的任务要么提前子线程加载，要么用到的时候才加载。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>从源码角度理解Android的Handler机制</title>
    <url>/2017/04/18/android_handler/</url>
    <content><![CDATA[<p>说起Handler，我们一般用的最多的就是在子线程通过Handler发Message进行UI更新。当你发了一个Message后到底发生了什么就进入了Handler的handleMessage方法了？接下来我们从源码的角度对Handler一探究竟。</p>
<span id="more"></span>

<p>开局一张图</p>
<p><img src="/images/android_handler_msg_process.png" alt="image-20210709205619320"></p>
<h2 id="源码探秘Message流转过程"><a href="#源码探秘Message流转过程" class="headerlink" title="源码探秘Message流转过程"></a>源码探秘Message流转过程</h2><p>当我们使用Handler时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先进行的是初始化Handler对象，那么我们就先看看Handler在进行初始化时都做了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看代码第11行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mLooper = Looper.myLooper();</span><br></pre></td></tr></table></figure>

<p>此处对mLooper成员变量进行了赋值，突然冒出来个Looper，什么鬼呢？我们顺藤摸瓜，进入Looper内看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment"> * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码我们发现sThreadLocal是在prepare(boolean quitAllowed)中进行设置值操作的。<br>那就有点郁闷了，一般我们使用Handler时，我们没有调用这个方法啊。其实啊，是系统帮我们调用过了。看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application&#x27;s main looper. The main looper for your application</span></span><br><span class="line"><span class="comment"> * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment"> * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看第8行，调用了prepare(false),然后我们再看看代码的注释，大致意思就是这个方法是在application初始化时系统调用的，用户不需要自己去调用这个方法。</p>
<p>然后我们继续看Handler的初始化，看Handler代码块的第15行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mQueue = mLooper.mQueue;</span><br></pre></td></tr></table></figure>

<p>通过源码我们了解到mQueue是MessageQueue类型的，又引入了一个新角色，其实这货就是我们口口相传的消息队列(其实内部是维护了一个Message的链表)。此处是由mLooper中的变量赋值的，进入Looper查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mQueue在Looper构造时进行了初始化。Handler的初始化完成。接下来我们继续沿着Handler的使用进行讲解。</p>
<p>我们使用Handler发消息时调用mHandler.sendMessage(msg),通过层层调用，最终进入了下面的这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment"> * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;The time-base is &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * Time spent in deep sleep will add an additional delay to execution.</span></span><br><span class="line"><span class="comment"> * You will receive it in &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached</span></span><br><span class="line"><span class="comment"> * to this handler.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uptimeMillis The absolute time at which the message should be</span></span><br><span class="line"><span class="comment"> *         delivered, using the</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment"> *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment"> *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment"> *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>看第32行的msg.target = this;既然是在Handler中的this赋值给了msg.target，也就是说target的Handler类型的，别急，下面讲消息的轮询时会用到。</strong><br>最终进入到了MessageQueue的enqueueMessage方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又引入了一个重要的元素Message，也就是我们称之为消息的对象类，该类包含了what、obj、callback等属性，比如我们区分不同的消息时通常是通过msg.what来进行分别处理。通过msg.obj来取出消息中包含的数据。</p>
<p>看上面20-43行，是对msg对象加入了链表序列的操作。</p>
<p>上面讲了这么多，似乎还是没有讲到最终消息是如何回调到handleMessage方法执行的。接下来我们继续看上文中提到的Looper类,看Looper中如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>篇幅有点长，我们只看关键部分，看第15行，一个无限制的for循环，这就是传说中的不断轮训消息队列。通过queue.next();不断的取消息。</p>
<p>看第32行，msg.target.dispatchMessage(msg);还记得上文中提到的msg.target吗？target即是该消息所属的Handler。也就是说dispatchMessage()是在Handler类中执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到了吧，最终调用了<strong>handleMessage</strong>方法。</p>
<p>等等……这个**loop()**方法谁调用的呢？什么时候开始执行轮询的呢？</p>
<p>记得上文中提到的prepareMainLooper()是系统调用的吧，其实loop方法也是由系统调用prepareMainLooper()之后又顺手把loop给调用了。我也找到了这段代码的出处，在ActivityThread中。</p>
<p><strong>ActivityThread</strong>其实就是我们经常说的UI thread，也就是主线程。应用启动时由系统创建。我们都知道主线程可以使用Handler进行异步通信，因为主线程中已经创建了Looper，而这个Looper就是在这里创建的。这些其实我们的上文分析即可得出。如果其他线程需要使用Handler通信，就要自己去创建Looper。</p>
<p>对于主线程的Looper的初始化我们看下ActivityThread的main函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//......some code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	 <span class="comment">//......some code</span></span><br><span class="line">        <span class="comment">// 在这儿调用 Looper.prepareMainLooper, 为应用的主线程创建Looper</span></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="comment">//......some code</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吧，在执行完Looper.prepareMainLooper();后，ActivityThread帮我们调用了loop轮询。所以我们一般在使用Handler时直接初始化一个Handler，然后发消息，之后等着在handleMessage中等待回调就OK了，其实是系统帮我们做了一部分工作了。</p>
<p>对于ActivityThread此处不做过多讲解，有时间在后面的博文中给大家掰扯掰扯应用启动的那些事儿。</p>
<p>以上讲解的都是在应用主线程下使用Handler的，如果我们想在子线程中使用，咋办呢？<br>不如我们直接按原来的写法试试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>一运行，挂了。。。。抛了个异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: Can<span class="string">&#x27;t create handler inside thread that has not called Looper.prepare()</span></span><br></pre></td></tr></table></figure>

<p>咋回事儿呢？看本文上面的那段Handler初始化代码的第11行就明白了。当检测到mLooper为空时就会抛出这段异常。而上文中我们也说到了，mLooper的赋值是在prepare方法中进行的，所以正确的使用方案就有了，就如同应用主线程ActivityThread一样，我们需要先prepare一下，只不过主线程调用的是prepareMainLooper()，我们要调用prepare()，同样我们也需要调用loop()方法开始消息的轮询。</p>
<p>所以在子线程中，正确的使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        Handler handler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>来张图（图片来自网络）<br>[<img src="/images/android_handler.png" alt="img"></p>
<p>我们重新捋一捋：首先由这么几个重要的角色，Handler、Looper、MessageQueue、Message。在主线程下，应用启动时系统帮我们初始化了主线程的MainLooper，并开启了loop循环，我们在UI线程初始化完Handler时，可以直接使用sendMessage方法发各种Message消息，然后我们的Message进入了MessageQueue，loop不断轮询，当从MessageQueue中取到消息时就通过Message的target（即所属的Handler对象）回调到Handler的handleMessage方法，最终我们就可以快乐的在handleMessage方法里面根据不同的msg.what进行消息的区分进行不同的操作。</p>
<h2 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>同步屏障的概念，在Android开发中非常容易被人忽略，因为这个概念在我们普通的开发中太少见了，很容易被忽略。</p>
<p>大家经过上面的学习应该知道，线程的消息都是放到同一个MessageQueue里面，取消息的时候是互斥取消息，而 且 ，而添加消息是按照消息的执行的先后顺序进行的排序，那么问题来了，同一个时间范围内的消 息，如果它是需要立刻执行的，那我们怎么办，按照常规的办法，我们需要等到队列轮询到我自己的时候才能执行 哦，那岂不是黄花菜都凉了。所以，我们需要给紧急需要执行的消息一个绿色通道，这个绿色通道就是同步屏障的概 念。</p>
<p>同步屏障是什么?</p>
<p>屏障的意思即为阻碍，顾名思义，同步屏障就是阻碍同步消息，只让异步消息通过。如何开启同步屏障呢?如下而<br>已:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue#postSyncBarrier()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">      	<span class="comment">//就是这里!!!初始化Message对象的时候，并没有给target赋值，因此 target==null</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">          	<span class="comment">//如果开启同步屏障的时间(假设记为T)T不为0，且当前的同步消息里有时间小于T，则prev也不为null</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//根据prev是不是为null，将 msg 按照时间顺序插入到 消息队列(链表)的合适位置</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Message 对象初始化的时候并没有给<code>target</code>赋值，因此， <code>target == null </code>的 来源就找到了。上面消 息的插入也做了相应的注释。这样，一条<code>target == null</code> 的消息就进入了消息队列。</p>
<p>那么，开启同步屏障后，所谓的异步消息又是如何被处理的呢? 如果对消息机制有所了解的话，应该知道消息的最终处理是在消息轮询器 <code>Looper#loop()</code> 中，而<code>loop()</code>循环中会</p>
<p>调用 <code>MessageQueue#next() </code>从消息队列中进行取消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">          Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">          Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">          Message msg = mMessages;</span><br><span class="line">          <span class="comment">//关键!!! //如果target==null，那么它就是屏障，需要循环遍历，一直往后找到第一个异步的消息</span></span><br><span class="line">          <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">              prevMsg = msg;</span><br><span class="line">              msg = msg.next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果有消息需要处理，先判断时间有没有到，如果没到的话设置一下阻塞时间， //场景如常用的postDelay</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">              <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">              nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// Got a message.</span></span><br><span class="line">              mBlocked = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//链表操作，获取msg并且删除该节点</span></span><br><span class="line">              <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prevMsg.next = msg.next;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMessages = msg.next;</span><br><span class="line">              &#125;</span><br><span class="line">              msg.next = <span class="keyword">null</span>;</span><br><span class="line">              <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">              msg.markInUse();</span><br><span class="line">              <span class="comment">//返回拿到的消息</span></span><br><span class="line">              <span class="keyword">return</span> msg;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No more messages.</span></span><br><span class="line">            nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//....</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，当消息队列开启同步屏障的时候(即标识为msg.target == null)，消息机制在处理消息的时 候，优先处理异步消息。这样，同步屏障就起到了一种过滤和优先级的作用。</p>
<p><img src="/images/android_handler_sync_barrier.png" alt="image-20210709211503392"></p>
<p>如上图所示，在消息队列中有同步消息和异步消息(黄色部分)以及一道墙—-同步屏障(红色部分)。有了同步屏 障的存在，msg_2 和 msg_M 这两个异步消息可以被优先处理，而后面的 msg_3 等同步消息则不会被处理。那么这 些同步消息什么时候可以被处理呢?那就需要先移除这个同步屏障，即调用<code> removeSyncBarrier()</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestApi</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></span><br><span class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The specified message queue synchronization &quot;</span></span><br><span class="line">                    + <span class="string">&quot; barrier token has not been posted or has already been removed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="同步屏障的应用场景"><a href="#同步屏障的应用场景" class="headerlink" title="同步屏障的应用场景"></a>同步屏障的应用场景</h3><p>似乎在日常的应用开发中，很少会用到同步屏障。那么，同步屏障在系统源码中有哪些使用场景呢?Android 系统中</p>
<p>的 UI 更新相关的消息即为异步消息，需要优先处理。<br> 比如，在 View 更新时，draw、requestLayout、invalidate 等很多地方都调用了</p>
<p><code>ViewRootImpl#scheduleTraversals() </code>，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">      	<span class="comment">//开启同步屏障</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">      	<span class="comment">//发送异步消息</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">          Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postCallback() 最终走到了 <code>ChoreographerpostCallbackDelayedInternal() </code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="params"><span class="function">            Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;PostCallback: type=&quot;</span> + callbackType</span><br><span class="line">              + <span class="string">&quot;, action=&quot;</span> + action + <span class="string">&quot;, token=&quot;</span> + token</span><br><span class="line">              + <span class="string">&quot;, delayMillis=&quot;</span> + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">          	scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">          	<span class="comment">//异步消息</span></span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就开启了同步屏障，并发送异步消息，由于 UI 更新相关的消息是优先级最高的，这样系统就会优先处理这些异 步消息。</p>
<p>最后，当要移除同步屏障的时候需要调用 <code>ViewRootImpl#unscheduleTraversals()</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unscheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">      	<span class="comment">//移除同步屏障</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        mChoreographer.removeCallbacks(</span><br><span class="line">          Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步屏障的设置可以方便地处理那些优先级较高的异步消息。当我们调用<br><code>Handler.getLooper().getQueue().postSyncBarrier()</code> 并设置消息的 <code>setAsynchronous(true)</code> 时，target 即 为 null ，也就开启了同步屏障。当在消息轮询器 Looper 在 <code>loop() </code>中循环处理消息时，如若开启了同步屏障，会优 先处理其中的异步消息，而阻碍同步消息。</p>
<h2 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h2><p>Idlehandler源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the message queue has run out of messages and will now</span></span><br><span class="line"><span class="comment">     * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class="line"><span class="comment">     * to have it removed.  This may be called if there are still messages</span></span><br><span class="line"><span class="comment">     * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class="line"><span class="comment">     * after the current time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">	<span class="comment">//记录IdleHandler数量</span></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">    	<span class="comment">//循环执行IdleHandler的queueIdle方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论: Android应用的运行都是靠着一条条Message入队、出队、执行实现，当应用主线程的消息队列空闲的时候（消息队列没有消息或下一次消息执行的时间还未到），就会尝试去执行<code>IdleHandler</code>集合。</p>
<p>其中：<code>IdleHandler</code>的<code>queueIdle</code>方法的返回值如果为false，那么<code>IdleHandler</code>执行完之后就会被移除，也就是说只会被执行一次；如果返回值为true，不会被移除且可以被执行多次。</p>
<h3 id="案例1-执行GC"><a href="#案例1-执行GC" class="headerlink" title="案例1-执行GC"></a>案例1-执行GC</h3><p>大家都知道，不能随便在主线程执行GC，否则很容易造成卡顿，但是我们可以在主线程空闲的时候去执行GC，这个时候就可以利用<code>IdleHandler</code>，Android源码ActivityThread中就有如下使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleGcIdler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mGcIdlerScheduled) &#123;</span><br><span class="line">        mGcIdlerScheduled = <span class="keyword">true</span>;</span><br><span class="line">        Looper.myQueue().addIdleHandler(mGcIdler);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.removeMessages(H.GC_WHEN_IDLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GcIdler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doGcIfNeeded();</span><br><span class="line">        purgePendingResources();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doGcIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    doGcIfNeeded(<span class="string">&quot;bg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doGcIfNeeded</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    mGcIdlerScheduled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">//Slog.i(TAG, &quot;**** WE MIGHT WANT TO GC: then=&quot; + Binder.getLastGcTime()</span></span><br><span class="line">    <span class="comment">//        + &quot;m now=&quot; + now);</span></span><br><span class="line">    <span class="keyword">if</span> ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) &lt; now) &#123;</span><br><span class="line">        <span class="comment">//Slog.i(TAG, &quot;**** WE DO, WE DO WANT TO GC!&quot;);</span></span><br><span class="line">        BinderInternal.forceGc(reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样既可以满足gc回收对象的需要，又不会影响主线程中其他任务的执行。</p>
<h3 id="案例2-粗估Activity界面渲染时间"><a href="#案例2-粗估Activity界面渲染时间" class="headerlink" title="案例2-粗估Activity界面渲染时间"></a>案例2-粗估Activity界面渲染时间</h3><p>我们首先要明确界面渲染流程是发生在Activity的<code>onResume</code>生命周期，往主线程消息队列添加消息屏障（之后添加的Message只能执行异步类型的），然后发送界面渲染异步Message，等到界面渲染完成后才会从消息队列移除屏障消息，这个时候才能正常执行其他Message。</p>
<p>参考下滴滴的DoKit开源库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis(); </span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> MessageQueue.IdleHandler()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdel</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;onRender const:&quot;</span> + (System.currentTimeMillis() - start))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在<code>onResume</code>方法中记录界面开始渲染时间，添加一个<code>IdleHandler</code>，这个会在界面渲染相关Message执行完毕后再执行它，所以就可以简单的估算出界面渲染时长。</p>
<h3 id="案例3-APP大图监测"><a href="#案例3-APP大图监测" class="headerlink" title="案例3-APP大图监测"></a>案例3-APP大图监测</h3><p>常见的大图监控方法都是将ImageView替换成自定义ImageView，然后重写设置图片的方法，比如<code>setImageBitmap()</code>等等，在方法中计算下图片的宽高是否超过ImageView的宽高，是就弹出一个弹窗提醒开发者，一般在<code>Debug</code>环境下执行这种检测。</p>
<p>Debug环境下开启大图检测，一般为了避免影响主线程其他任务执行，都会添加一个<code>IdleHandler</code>等主线程空闲了再去执行大图检测：</p>
<h3 id="案例4-延迟启动初始化任务"><a href="#案例4-延迟启动初始化任务" class="headerlink" title="案例4-延迟启动初始化任务"></a>案例4-延迟启动初始化任务</h3><p>一般我们都在<code>Application</code>的<code>onCreate</code>方法中执行任务（比如第三方SDK）的初始化，可是如果执行的初始化任务过多就会增加启动耗时，给用户带来较差体验。</p>
<p>而且有的任务并不是一定就需要在<code>Application</code>的<code>onCreate</code>就必须要执行，可以延迟初始化，减少应用启动耗时，这个时候就可以把相关延迟任务添加到一个<code>Idlehandler</code>中去执行。</p>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread是Thread的子类，严格意义上来说就是一个线程，只是它在自己的线程里面帮我们创建了Looper HandlerThread 存在的意义如下:</p>
<ol>
<li>方便使用:a. 方便初始化，b，方便获取线程looper </li>
</ol>
<p>2)保证了线程安全</p>
<p>我们一般在Thread里面 线程Looper进行初始化的代码里面，必须要对Looper.prepare(),同时要调用Loop。 loop();</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们要使用子线程中的Looper的方式是怎样的呢?看下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    Looper looper;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//  Log.d(TAG, &quot;click2: &quot; + Thread.currentThread().getName());</span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        looper =Looper.myLooper();</span><br><span class="line">        Looper.loop();</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> looper;</span><br><span class="line">		&#125; </span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//这样获取looper有问题</span></span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(thread.getLooper());</span><br></pre></td></tr></table></figure>

<p>1)在初始化子线程的handler的时候，我们无法将子线程的looper传值给Handler,解决办法有如下办法:</p>
<p>a. 可以将Handler的初始化放到 Thread里面进行</p>
<p>b. 可以创建一个独立的类继承Thread，然后，通过类的对象获取。</p>
<p>这两种办法都可以，但是，这个工作 HandlerThread帮我们完成了</p>
<p>2)依据多线程的工作原理，我们在上面的代码中，调用 thread.getLooper()的时候，此时的looper可能还没有初 始化，此时是不是可能会挂掉呢?</p>
<p>以上问题<br> HandlerThread 已经帮我们完美的解决了，这就是 handlerThread存在的必要性了。</p>
<p>我们再看 HandlerThread源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid();</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">		notifyAll(); <span class="comment">//此时唤醒其他等待的锁，但是 &#125;</span></span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();</span><br><span class="line">    Looper.loop();</span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的优点就在于它的多线程操作，可以帮我们保证使用Thread的handler时一定是安全的。</p>
<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService是Android中提供的后台服务类，我们在外部组件中通过Intent向IntentService发送请求命令，之后IntentService逐个执行命令队列里的命令，接收到首个命令时，IntentService就开始启动并开始一条后台线程执行首个命令，接着队列里的命令将会被顺序执行，最后执行完队列的所有命令后，服务也随即停止并被销毁。</p>
<p><strong>与Service的不同</strong></p>
<ol>
<li>Service中的程序仍然运行于主线程中，而在IntentService中的程序运行在我们的异步后台线程中。在接触到IntentService之前，我在项目中大多是自己写一个Service，在Service中自己写一个后台线程去处理相关事务，而这些工作Android其实早已经帮我们封装的很好。</li>
<li>在Service中当我的后台服务执行完毕之后需要在外部组件中调用stopService方法销毁服务，而IntentService并不需要，它会在工作执行完毕后自动销毁。</li>
</ol>
<h3 id="IntentService的用法"><a href="#IntentService的用法" class="headerlink" title="IntentService的用法"></a>IntentService的用法</h3><p>1.编写自己的Service类继承IntentService，并重写其中的onHandleIntent(Intent)方法，该方法是IntentService的一个抽象方法，用来处理我们通过startService方法开启的服务，传入参数Intent就是开启服务的Intent。在这里我重写了一个MyService类去处理后台事务，每一次调用对count加1，并打印log。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.intentservicetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.IntentService;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MyService.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(TAG);</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="comment">//在这里添加我们要执行的代码，Intent中可以保存我们所需的数据，</span></span><br><span class="line">        <span class="comment">//每一次通过Intent发送的命令将被顺序执行</span></span><br><span class="line">        count ++;</span><br><span class="line">        Log.w(TAG, <span class="string">&quot;count::&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.注册我们的服务：接下来在AndroidManifest文件中的Application标签下添加我们的服务。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.intentservicetest.MyService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.在外部组件中开启服务：在这里我们在Activity中利用Intent循环10次开启服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, MyService.class);</span><br><span class="line">        startService(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.结果输出：</p>
<p><img src="/images/android_handler_intent_service_test_output.jpg" alt="img"></p>
<p>可以看到在MyService中是按照顺序执行我们的请求命令的。</p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>1.生命周期函数：<br>IntentService同样是继承于Service的，它也拥有相同的生命周期函数;</p>
<ul>
<li>onCreate：服务创建时调用；</li>
<li>onStartCommand(Intent, int, int)方法:在Service源码可以看到onStart方法是在该方法中被调用的。每次组件通过startService方法启动服务时调用一次，两个int型参数，一个是组标识符，一个是启动ID，组标识符用来表示当前Intent发送是一次重新发送还是一次从没成功过的发送。每次调用onStartCommand方法时启动ID都不同，启动ID也用来区分不同的命令;</li>
<li>onDestroy方法：在服务停止时调用。</li>
</ul>
<p>2.onCreate方法：首先让我们看看IntentService源码中的onCreate方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;IntentService[&quot;</span> + mName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：在IntentService的onCreate方法中开启了一个异步线程HandlerThread来处理我们的请求，并利用Looper和Handler来管理我们的请求命令队列。</p>
<p>3.如何停止服务<br>看到了onCreate方法我们就可以明白了，IntentService是如何开启异步线程以及如何管理命令队列的，那么我们之前曾提到：当后台服务处理结束后，我们并不需要再调用stopService方法销毁服务，IntentService会自动销毁，它是如何做到的呢？然我们看看ServiceHandler：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Handler中我们处理完每一个命令都会调用stopSelf(int)方法来停止服务：该方法需要来自onStartCommand方法中的启动ID，只有在接收到最新的启动ID时才会停止服务，就是说，我们的IntentService直到命令队列中的所有命令被执行完后才会停止服务。</p>
<p><strong>setIntentRedelivery方法</strong></p>
<p>在源码中我们可以发现，该方法改变了boolean变量mRedelivery的值，而mRedelivery得值关系到onStartCommand的返回变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，mRedelivery不同，会返回两个不同的标志START_REDELIVER_INTENT 和START_NOT_STICKY，那么他们有什么不同呢？<br>区别就在于如果系统在服务完成之前关闭它，则两种类型就表现出不同了：</p>
<ul>
<li>START_NOT_STICKY型服务会直接被关闭，而START_REDELIVER_INTENT 型服务会在可用资源不再吃紧的时候尝试再次启动服务。</li>
<li>由此我们可以发现，当我们的操作不是十分重要的时候，我们可以选择START_NOT_STICKY，这也是IntentService的默认选项，当我们认为操作十分重要时，则应该选择START_REDELIVER_INTENT 型服务。</li>
</ul>
<p><strong>non-sticky服务和sticky服务</strong></p>
<p>non-sticky服务会在自己认为任务完成时停止，若一个Service为non-sticky服务则应该在onStartCommand方法中返回START_REDELIVER_INTENT或START_NOT_STICKY标志。<br>sticky服务会持续存在，直到外部组件调用Context.stopService方法。sticky服务返回标志位START_STICKY。</p>
<p>注意：IntentService不应该处理长时间运行的服务（如音乐播放），长时间运行的服务应该由sticky服务完成。</p>
<h2 id="疑点解惑"><a href="#疑点解惑" class="headerlink" title="疑点解惑"></a>疑点解惑</h2><h3 id="主线程的Looper中的loop-循环为什么不会卡死主线程？"><a href="#主线程的Looper中的loop-循环为什么不会卡死主线程？" class="headerlink" title="主线程的Looper中的loop()循环为什么不会卡死主线程？"></a>主线程的Looper中的loop()循环为什么不会卡死主线程？</h3><p>我们先看一段ActivityThread的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看最后一行代码，抛出一个运行时异常“Main thread loop unexpectedly exited”(主线程异常退出)，也就是说如果loop循环执行完的话系统就判定为应用异常退出了。其实这里涉及到了线程/进程问题。</p>
<p>以下转载自知乎：<a href="https://www.zhihu.com/question/34652589">https://www.zhihu.com/question/34652589</a></p>
<p><strong>进程</strong>：每个app运行时前首先创建一个进程，该进程是由Zygote fork出来的，用于承载App上运行的各种Activity/Service等组件。进程对于上层应用来说是完全透明的，这也是google有意为之，让App程序都是运行在Android Runtime。大多数情况一个App就运行在一个进程中，除非在AndroidManifest.xml中配置Android:process属性，或通过native代码fork进程。</p>
<p><strong>线程</strong>：线程对应用来说非常常见，比如每次new Thread().start都会创建一个新的线程。该线程与App所在进程之间资源共享，从Linux角度来说进程与线程除了是否共享资源外，并没有本质的区别，都是一个task_struct结构体，在CPU看来进程或线程无非就是一段可执行的代码，CPU采用CFS调度算法，保证每个task都尽可能公平的享有CPU时间片。<br>有了这么准备，再说说死循环问题：对于线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。真正会卡死主线程的操作是在回调方法onCreate/onStart/onResume等操作时间过长，会导致掉帧，甚至发生ANR，looper.loop本身不会导致应用卡死。</p>
<p>另外，ActivityThread实际上并非线程，不像HandlerThread类，ActivityThread并没有真正继承Thread类，只是往往运行在主线程，给人以线程的感觉，其实承载ActivityThread的主线程就是由Zygote fork而创建的进程。主线程的死循环一直运行是不是特别消耗CPU资源呢？ 其实不然，这里就涉及到Linux pipe/epoll机制，<strong>简单说就是在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作</strong>。这里采用的epoll机制，是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。 所以说，<strong>主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源</strong>。</p>
<p><strong>Activity的生命周期是怎么实现在死循环体外能够执行起来的？</strong><br>ActivityThread的内部类H继承于Handler，通过handler消息机制，简单说Handler机制用于同一个进程的线程间通信。Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施：在H.handleMessage(msg)方法中，根据接收到不同的msg，执行相应的生命周期。 比如收到msg=H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终会通过反射机制，创建Activity实例，然后再执行Activity.onCreate()等方法； 再比如收到msg=H.PAUSE_ACTIVITY，则调用ActivityThread.handlePauseActivity()方法，最终会执行Activity.onPause()等方法。 上述过程，我只挑核心逻辑讲，真正该过程远比这复杂。</p>
<p>归结如下：</p>
<p>A. Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分组成的。<br>B. Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。<br>C. Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。<br>D. 当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。<br>E. 当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。</p>
<p><strong>结论：</strong>阻塞是有的，但是不会卡住主要原因有2个</p>
<p>1，epoll模型当没有消息的时候会epoll.wait，等待句柄写的时候再唤醒，这个时候其实是阻塞的。<br>2，所有的ui操作都通过handler来发消息操作。比如屏幕刷新16ms一个消息，你的各种点击事件，所以就会有句柄写操作，唤醒上文的wait操作，所以不会被卡死了。</p>
<p>所以当loop真的执行完了说明应用异常退出了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 组件化开发</title>
    <url>/2019/12/01/android_components_develop/</url>
    <content><![CDATA[<p>所谓组件化，就是将整个庞大的项目以业务逻辑进行拆分成多个模块，并且各个模块之间相互独立，相互解耦，每一个模块可以单独进行开发调试，各个模块调试完，以library的形式依赖在壳App中组合成一个完整的项目。</p>
<span id="more"></span>

<h1 id="为什么要进行组件化"><a href="#为什么要进行组件化" class="headerlink" title="为什么要进行组件化"></a>为什么要进行组件化</h1><p>随着APP版本不断的迭代，新功能的不断增加，业务也会变的越来越复杂，APP业务模块的数量有可能还会继续增加，而且每个模块的代码也变的越来越多，这样发展下去单一工程下的APP架构势必会影响开发效率，增加项目的维护成本，每个工程师都要熟悉如此之多的代码，将很难进行多人协作开发，而且Android项目在编译代码的时候电脑会非常卡，又因为单一工程下代码耦合严重，每修改一处代码后都要重新编译打包测试，导致非常耗时，最重要的是这样的代码想要做单元测试根本无从下手，所以必须要有更灵活的架构代替过去单一的工程架构。</p>
<p><img src="/images/android_components_develop01.png" alt="image"></p>
<p>上图是目前比较普遍使用的Android APP技术架构，往往是在一个界面中存在大量的业务逻辑，而业务逻辑中充斥着各种网络请求、数据操作等行为，整个项目中也没有模块的概念，只有简单的以业务逻辑划分的文件夹，并且业务之间也是直接相互调用、高度耦合在一起的；</p>
<p><img src="/images/android_components_develop02.png" alt="image"></p>
<p>上图单一工程模型下的业务关系，总的来说就是：你中有我，我中有你，相互依赖，无法分离。<br>然而随着产品的迭代，业务越来越复杂，随之带来的是项目结构复杂度的极度增加，此时我们会面临如下几个问题：<br>1、实际业务变化非常快，但是单一工程的业务模块耦合度太高，牵一发而动全身；<br>2、对工程所做的任何修改都必须要编译整个工程；<br>3、功能测试和系统测试每次都要进行；<br>4、团队协同开发存在较多的冲突.不得不花费更多的时间去沟通和协调，并且在开发过程中，任何一位成员没办法专注于自己的功能点，影响开发效率；<br>5、不能灵活的对业务模块进行配置和组装；<br>为了满足各个业务模块的迭代而彼此不受影响，更好的解决上面这种让人头疼的依赖关系，就需要整改App的架构。</p>
<h1 id="如何组件化"><a href="#如何组件化" class="headerlink" title="如何组件化"></a>如何组件化</h1><p><img src="/images/android_components_develop03.png" alt="image"></p>
<p>上图是组件化工程模型，为了方便理解这张架构图，下面会列举一些组件<br>化工程中用到的名词的含义：</p>
<table>
<thead>
<tr>
<th>名词</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>集成模式</td>
<td>所有的业务组件被“app壳工程”依赖，组成一个完整的APP；</td>
</tr>
<tr>
<td>组件模式</td>
<td>可以独立开发业务组件，每一个业务组件就是一个APP；</td>
</tr>
<tr>
<td>app壳工程</td>
<td>负责管理各个业务组件，和打包apk，没有具体的业务功能；</td>
</tr>
<tr>
<td>业务组件</td>
<td>根据公司具体业务而独立形成一个的工程；</td>
</tr>
<tr>
<td>功能组件</td>
<td>提供开发APP的某些基础功能，例如打印日志、树状图等；</td>
</tr>
<tr>
<td>Main组件</td>
<td>属于业务组件，指定APP启动页面、主界面；</td>
</tr>
<tr>
<td>Common组件</td>
<td>属于功能组件，支撑业务组件的基础，提供多数业务组件需要的功能，例如提供网络请求功能；</td>
</tr>
</tbody></table>
<p>Android APP组件化架构的目标是告别结构臃肿，让各个业务变得相对独立，业务组件在组件模式下可以独立开发，而在集成模式下又可以变为arr包集成到“app壳工程”中，组成一个完整功能的APP；</p>
<p>从组件化工程模型中可以看到，业务组件之间是独立的，没有关联的，这些业务组件在集成模式下是一个个library，被app壳工程所依赖，组成一个具有完整业务功能的APP应用，但是在组件开发模式下，业务组件又变成了一个个application，它们可以独立开发和调试，由于在组件开发模式下，业务组件们的代码量相比于完整的项目差了很远，因此在运行时可以显著减少编译时间。</p>
<p><img src="/images/android_components_develop04.png" alt="image"></p>
<p>这是组件化工程模型下的业务关系，业务之间将不再直接引用和依赖，而是通过“路由”这样一个中转站间接产生联系，而Android中的路由实际就是对URL Scheme的封装；<br>如此规模大的架构整改需要付出更高的成本，还会涉及一些潜在的风险，但是整改后的架构能够带来很多好处：</p>
<p>1、加快业务迭代速度，各个业务模块组件更加独立，不再出现业务耦合情况；<br>2、稳定的公共模块采用依赖库方式，提供给各个业务线使用，减少重复开发和维护工作量；<br>3、迭代频繁的业务模块采用组件方式，各业务研发可以互不干扰、提升协作效率，并控制产品质量；<br>4、为新业务随时集成提供了基础，所有业务可上可下，灵活多变；<br>5、降低团队成员熟悉项目的成本，降低项目的维护难度；<br>6、加快编译速度，提高开发效率；<br>7、控制代码权限，将代码的权限细分到更小的粒度；</p>
<h1 id="组件化实施流程"><a href="#组件化实施流程" class="headerlink" title="组件化实施流程"></a>组件化实施流程</h1><p>1）组件模式和集成模式的转换<br>Android Studio中的Module主要有两种属性，分别为：<br>1、application属性，可以独立运行的Android程序，也就是我们的APP；</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> ‘com.android.application’</span><br></pre></td></tr></table></figure>

<p>2、library属性，不可以独立运行，一般是Android程序依赖的库文件；</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> ‘com.android.library’</span><br></pre></td></tr></table></figure>

<p>Module的属性是在每个组件的 build.gradle 文件中配置的，当我们在组件模式开发时，业务组件应处于application属性，这时的业务组件就是一个 Android App，可以独立开发和调试；而当我们转换到集成模式开发时，业务组件应该处于 library 属性，这样才能被我们的“app壳工程”所依赖，组成一个具有完整功能的APP；</p>
<p>但是我们如何让组件在这两种模式之间自动转换呢？总不能每次需要转换模式的时候去每个业务组件的 Gralde 文件中去手动把 Application 改成library 吧？如果我们的项目只有两三个组件那么这个办法肯定是可行的，手动去改一遍也用不了多久，但是在大型项目中我们可能会有十几个业务组件，再去手动改一遍必定费时费力，这时候就需要程序员发挥下懒的本质了。</p>
<p>试想，我们经常在写代码的时候定义静态常量，那么定义静态常量的目的什么呢？当一个常量需要被好几处代码引用的时候，把这个常量定义为静态常量的好处是当这个常量的值需要改变时我们只需要改变静态常量的值，其他引用了这个静态常量的地方都会被改变，做到了一次改变，到处生效；根据这个思想，那么我们就可以在我们的代码中的某处定义一个决定业务组件属性的常量，然后让所有业务组件的build.gradle都引用这个常量，这样当我们改变了常量值的时候，所有引用了这个常量值的业务组件就会根据值的变化改变自己的属性；可是问题来了？静态常量是用Java代码定义的，而改变组件属性是需要在Gradle中定义的，Gradle能做到吗？</p>
<p>Gradle自动构建工具有一个重要属性，可以帮助我们完成这个事情。每当我们用AndroidStudio创建一个Android项目后，就会在项目的根目录中生成一个文件 gradle.properties，我们将使用这个文件的一个重要属性：在Android项目中的任何一个build.gradle文件中都可以把gradle.properties中的常量读取出来；那么我们在上面提到解决办法就有了实际行动的方法，首先我们在gradle.properties中定义一个常量值isModule（是否是组件开发模式，true为是，false为否）：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"># 每次更改“isModule”的值后，需要点击 <span class="string">&quot;Sync Project&quot;</span> 按钮</span><br><span class="line">isModule=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>然后我们在业务组件的build.gradle中读取 isModule，但是gradle.properties 还有一个重要属性： gradle.properties 中的数据类型都是String类型，使用其他数据类型需要自行转换；也就是说我们读到isModule 是个String类型的值，而我们需要的是Boolean值，代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isModule.toBoolean()) &#123;</span><br><span class="line">	apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们第一个问题就解决了，当然了 每次改变isModule的值后，都要同步项目才能生效；</p>
<p>2）组件之间AndroidManifest合并问题</p>
<p>在 AndroidStudio 中每一个组件都会有对应的 AndroidManifest.xml，用于声明需要的权限、Application、Activity、Service、Broadcast等，当项目处于组件模式时，业务组件的 AndroidManifest.xml 应该具有一个 Android APP 所具有的的所有属性，尤其是声明 Application 和要launch的Activity，但是当项目处于集成模式的时候，每一个业务组件的AndroidManifest.xml 都要合并到“app壳工程”中，要是每一个业务组件都有自己的 Application 和 launch的Activity，那么合并的时候肯定会冲突，试想一个APP怎么可能会有多个 Application 和 launch 的Activity呢？</p>
<p>但是大家应该注意到这个问题是在组件开发模式和集成开发模式之间转换引起的问题，而在上一节中我们已经解决了组件模式和集成模式转换的问题，另外大家应该都经历过将 Android 项目从 Eclipse 切换到AndroidStudio 的过程，由于 Android 项目在 Eclipse 和 AndroidStudio开发时 AndroidManifest.xml 文件的位置是不一样的，我们需要在build.gradle 中指定下 AndroidManifest.xml 的位置，AndroidStudio才能读取到 AndroidManifest.xml，这样解决办法也就有了，我们可以为组件开发模式下的业务组件再创建一个 AndroidManifest.xml，然后根据isModule指定AndroidManifest.xml的文件路径，让业务组件在集成模式和组件模式下使用不同的AndroidManifest.xml，这样表单冲突的问题就可以规避了。</p>
<p><img src="/images/android_components_develop05.png" alt="image"></p>
<p>上图是组件化项目中一个标准的业务组件目录结构，首先我们在main文件夹下创建一个module文件夹用于存放组件开发模式下业务组件的AndroidManifest.xml，而 AndroidStudio 生成的 AndroidManifest.xml则依然保留，并用于集成开发模式下业务组件的表单；然后我们需要在业务组件的 build.gradle 中指定表单的路径，代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        <span class="keyword">if</span> (isModule.toBoolean()) &#123;</span><br><span class="line">            manifest.srcFile <span class="string">&#x27;src/main/module/AndroidManifest.xml&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            manifest.srcFile <span class="string">&#x27;src/main/AndroidManifest.xml&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在不同的开发模式下就会读取到不同的 AndroidManifest.xml ，然后我们需要修改这两个表单的内容以为我们不同的开发模式服务。</p>
<p>首先是集成开发模式下的 AndroidManifest.xml，前面我们说过集成模式下，业务组件的表单是绝对不能拥有自己的 Application 和 launch 的Activity的，也不能声明APP名称、图标等属性，总之app壳工程有的属性，业务组件都不能有，下面是一份标准的集成开发模式下业务组件的AndroidManifest.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.guiying.girls&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.main.GirlsActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.girl.GirlActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme.NoActionBar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我在这个表单中只声明了应用的主题，而且这个主题还是跟app壳工程中的主题是一致的，都引用了common组件中的资源文件，在这里声明主题是为了方便这个业务组件中有使用默认主题的Activity时就不用再给Activity单独声明theme了。</p>
<p>然后是组件开发模式下的表单文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.guiying.girls&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;debug.GirlsApplication&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/girls_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">&quot;.main.GirlsActivity&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">category</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:name</span>=<span class="string">&quot;.girl.GirlActivity&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:theme</span>=<span class="string">&quot;@style/AppTheme.NoActionBar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>组件模式下的业务组件表单就是一个Android项目普通的AndroidManifest.xml，这里就不在过多介绍了。</p>
<p>3）全局Context的获取及组件数据初始化</p>
<p>当Android程序启动时，Android系统会为每个程序创建一个 Application类的对象，并且只创建一个，application对象的生命周期是整个程序中最长的，它的生命周期就等于这个程序的生命周期。在默认情况下应用系统会自动生成 Application 对象，但是如果我们自定义了 Application，那就需要在 AndroidManifest.xml 中声明告知系统，实例化的时候，是实例化我们自定义的，而非默认的。</p>
<p>但是我们在组件化开发的时候，可能为了数据的问题每一个组件都会自定义一个Application类，如果我们在自己的组件中开发时需要获取 全局的Context，一般都会直接获取 application 对象，但是当所有组件要打包合并在一起的时候就会出现问题，因为最后程序只有一个 Application，我们组件中自己定义的 Application 肯定是没法使用的，因此我们需要想办法再任何一个业务组件中都能获取到全局的 Context，而且这个Context 不管是在组件开发模式还是在集成开发模式都是生效的。</p>
<p>在 组件化工程模型图中，功能组件集合中有一个 Common 组件，Common 有公共、公用、共同的意思，所以这个组件中主要封装了项目中需要的基础功能，并且每一个业务组件都要依赖Common组件，Common 组件就像是万丈高楼的地基，而业务组件就是在 Common 组件这个地基上搭建起来我们的APP的，Common 组件会专门在一个章节中讲解，这里只讲 Common组件中的一个功能，在Common组件中我们封装了项目中用到的各种Base类，这些基类中就有BaseApplication类。</p>
<p>BaseApplication 主要用于各个业务组件和app壳工程中声明的Application 类继承用的，只要各个业务组件和app壳工程中声明的Application类继承了 BaseApplication，当应用启动时 BaseApplication就会被动实例化，这样从 BaseApplication 获取的 Context 就会生效，也就从根本上解决了我们不能直接从各个组件获取全局 Context 的问题；</p>
<p>这时候大家肯定都会有个疑问？不是说了业务组件不能有自己的Application 吗，怎么还让他们继承 BaseApplication 呢？其实我前面说的是业务组件不能在集成模式下拥有自己的 Application，但是这不代表业务组件也不能在组件开发模式下拥有自己的Application，其实业务组件在组件开发模式下必须要有自己的 Application 类，一方面是为了让BaseApplication 被实例化从而获取 Context，还有一个作用是，业务组件自己的 Application 可以在组件开发模式下初始化一些数据，例如在组件开发模式下，A组件没有登录页面也没法登录，因此就无法获取到Token，这样请求网络就无法成功，因此我们需要在A组件这个 APP 启动后就应该已经登录了，这时候组件自己的 Application 类就有了用武之地，我们在组件的 Application的 onCreate 方法中模拟一个登陆接口，在登陆成功后将数据保存到本地，这样就可以处理A组件中的数据业务了；另外我们也可以在组件Application中初始化一些第三方库。</p>
<p>但是，实际上业务组件中的Application在最终的集成项目中是没有什么实际作用的，组件自己的 Application 仅限于在组件模式下发挥功能，因此我们需要在将项目从组件模式转换到集成模式后将组件自己的Application剔除出我们的项目；在 AndroidManifest 合并问题小节中介绍了如何在不同开发模式下让 Gradle 识别组件表单的路径，这个方法也同样适用于Java代码；</p>
<p><img src="/images/android_components_develop06.png" alt="image"></p>
<p>我们在Java文件夹下创建一个 debug 文件夹，用于存放不会在业务组件中引用的类，例如上图中的 NewsApplication ，你甚至<strong>可以在 debug 文件夹中创建一个Activity，然后组件表单中声明启动这个Activity，在这个Activity中不用setContentView，只需要在启动你的目标Activity的时候传递参数就行，这样就就可以解决组件模式下某些Activity需要getIntent数据而没有办法拿到的情况</strong>，代码如下；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LauncherActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        request();</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,TargetActivity.class);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;avcd&quot;</span>);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;syscode&quot;</span>, <span class="string">&quot;023e2e12ed&quot;</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//申请读写权限</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AndPermission.with(<span class="keyword">this</span>)</span><br><span class="line">            .requestCode(<span class="number">110</span>)</span><br><span class="line">            .permission(Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">            Manifest.permission.CAMERA,Manifest.permission.READ_PHONE_STATE)</span><br><span class="line">            .callback(<span class="keyword">this</span>)</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在业务组件的 build.gradle 中，根据 isModule 是否是集成模式将debug 这个 Java代码文件夹排除：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main &#123;</span><br><span class="line">        <span class="keyword">if</span> (isModule.toBoolean()) &#123;</span><br><span class="line">            manifest.srcFile <span class="string">&#x27;src/main/module/AndroidManifest.xml&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            manifest.srcFile <span class="string">&#x27;src/main/AndroidManifest.xml&#x27;</span></span><br><span class="line">            <span class="comment">//集成开发模式下排除debug文件夹中的所有Java文件</span></span><br><span class="line">            java &#123;</span><br><span class="line">                exclude <span class="string">&#x27;debug/**&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）library依赖问题</p>
<p>在介绍这一节的时候，先说一个问题，在组件化工程模型图中，多媒体组件和Common组件都依赖了日志组件，而A业务组件有同时依赖了多媒体组件和Common组件，这时候就会有人问，你这样搞岂不是日志组件要被重复依赖了，而且Common组件也被每一个业务组件依赖了，这样不出问题吗？</p>
<p>其实大家完全没有必要担心这个问题，如果真有重复依赖的问题，在你编译打包的时候就会报错，如果你还是不相信的话可以反编译下最后打包出来的APP，看看里面的代码你就知道了。组件只是我们在代码开发阶段中为了方便叫的一个术语，在组件被打包进APP的时候是没有这个概念的，这些组件最后都会被打包成arr包，然后被app壳工程所依赖，在构建APP的过程中Gradle会自动将重复的arr包排除，APP中也就不会存在相同的代码了；</p>
<p>但是虽然组件是不会重复了，但是我们还是要考虑另一个情况，我们在build.gradle中compile的第三方库，例如AndroidSupport库经常会被一些开源的控件所依赖，而我们自己一定也会compile AndroidSupport库，这就会造成第三方包和我们自己的包存在重复加载，解决办法就是找出那个多出来的库，并将多出来的库给排除掉，而且Gradle也是支持这样做的，分别有两种方式：根据组件名排除或者根据包名排除，下面以排除support-v4库为例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    compile(<span class="string">&quot;com.jude:easyrecyclerview:$rootProject.easyRecyclerVersion&quot;</span>) &#123;</span><br><span class="line">        exclude <span class="attr">module:</span> <span class="string">&#x27;support-v4&#x27;</span><span class="comment">//根据组件名排除</span></span><br><span class="line">        exclude <span class="attr">group:</span> <span class="string">&#x27;android.support.v4&#x27;</span><span class="comment">//根据包名排除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>library重复依赖的问题算是都解决了，但是我们在开发项目的时候会依赖很多开源库，而这些库每个组件都需要用到，要是每个组件都去依赖一遍也是很麻烦的，尤其是给这些库升级的时候，为了方便我们统一管理第三方库，我们将给给整个工程提供统一的依赖第三方库的入口，前面介绍的Common库的作用之一就是统一依赖开源库，因为其他业务组件都依赖了Common库，所以这些业务组件也就间接依赖了Common所依赖的开源库。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    <span class="comment">//Android Support</span></span><br><span class="line">    compile <span class="string">&quot;com.android.support:appcompat-v7:$rootProject.supportLibraryVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.android.support:design:$rootProject.supportLibraryVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.android.support:percent:$rootProject.supportLibraryVersion&quot;</span></span><br><span class="line">    <span class="comment">//网络请求相关</span></span><br><span class="line">    compile <span class="string">&quot;com.squareup.retrofit2:retrofit:$rootProject.retrofitVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.squareup.retrofit2:retrofit-mock:$rootProject.retrofitVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.github.franmontiel:PersistentCookieJar:$rootProject.cookieVersion&quot;</span></span><br><span class="line">    <span class="comment">//稳定的</span></span><br><span class="line">    compile <span class="string">&quot;com.github.bumptech.glide:glide:$rootProject.glideVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.orhanobut:logger:$rootProject.loggerVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;org.greenrobot:eventbus:$rootProject.eventbusVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.google.code.gson:gson:$rootProject.gsonVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.github.chrisbanes:PhotoView:$rootProject.photoViewVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.jude:easyrecyclerview:$rootProject.easyRecyclerVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.github.GrenderG:Toasty:$rootProject.toastyVersion&quot;</span></span><br><span class="line">    <span class="comment">//router</span></span><br><span class="line">    compile <span class="string">&quot;com.github.mzule.activityrouter:activityrouter:$rootProject.routerVersion&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）组件之间调用和通信</p>
<p>在组件化开发的时候，组件之间是没有依赖关系，我们不能在使用显示调用来跳转页面了，因为我们组件化的目的之一就是解决模块间的强依赖问题，假如现在要从A业务组件跳转到业务B组件，并且要携带参数跳转，这时候怎么办呢？而且组件这么多怎么管理也是个问题，这时候就需要引入“路由”的概念了，由本文开始的组件化模型下的业务关系图可知路由就是起到一个转发的作用。</p>
<p>这里我将介绍开源库的“ActivityRouter” ，有兴趣的同学情直接去ActivityRouter的Github主页学习：ActivityRouter，ActivityRouter支持给Activity定义 URL，这样就可以通过 URL 跳转到Activity，并且支持从浏览器以及 APP 中跳入我们的Activity，而且还支持通过 url 调用方法。下面将介绍如何将ActivityRouter集成到组件化项目中以实现组件之间的调用；</p>
<p>1、首先我们需要在 Common 组件中的 build.gradle 将ActivityRouter 依赖进来，方便我们在业务组件中调用：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    <span class="comment">//router</span></span><br><span class="line">    compile <span class="string">&quot;com.github.mzule.activityrouter:activityrouter:$rootProject.routerVersion&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、这一步我们需要先了解 APT这个概念，APT(Annotation Processing Tool)是一种处理注解的工具，它对源代码文件进行检测找出其中的Annotation，使用Annotation进行额外的处理。 Annotation处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定)，APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。在这里我们将在每一个业务组件的 build.gradle 都引入ActivityRouter 的Annotation处理器，我们将会在声明组件和Url的时候使用，annotationProcessor是Android官方提供的Annotation处理器插件，代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    annotationProcessor <span class="string">&quot;com.github.mzule.activityrouter:compiler:$rootProject.annotationProcessor&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、接下来需要在 app壳工程的 AndroidManifest.xml 配置，到这里ActivityRouter配置就算完成了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明整个应用程序的路由协议--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.github.mzule.activityrouter.router.RouterActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@android:style/Theme.NoDisplay&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">        	<span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span></span></span><br><span class="line"><span class="tag">        	<span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span></span></span><br><span class="line"><span class="tag">        	<span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.BROWSABLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span></span></span><br><span class="line"><span class="tag">        	<span class="attr">android:scheme</span>=<span class="string">&quot;@string/global_scheme&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 改成自己的scheme --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--发送崩溃日志界面--&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、接下来我们将声明项目中的业务组件，声明方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module(&quot;girls&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girls</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每一个业务组件的java文件的根目录下创建一个类，用 注解@Module声明这个业务组件；</p>
<p>然后在“app壳工程”的 应用Application 中使用 注解@Modules 管理我们声明的所有业务组件，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Modules(&#123;&quot;main&quot;, &quot;girls&quot;, &quot;news&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">BaseApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里组件化项目中的所有业务组件就被声明和管理起来了，组件之间的也就可以互相调用了，当然前提是要给业务组件中的Activity定义 URL。</p>
<p>5、例如我们给 Girls组件 中的 GirlsActivity 使用 注解@Router 定义一个URL：“news”，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Router(&quot;girls&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlsActivity</span> <span class="keyword">extends</span> <span class="title">BaseActionBarActivity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GirlsView mView;</span><br><span class="line">    <span class="keyword">private</span> GirlsContract.Presenter mPresenter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">setTitleId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> R.string.girls_activity_title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mView = <span class="keyword">new</span> GirlsView(<span class="keyword">this</span>);</span><br><span class="line">        setContentView(mView);</span><br><span class="line">        mPresenter = <span class="keyword">new</span> GirlsPresenter(mView);</span><br><span class="line">        mPresenter.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以在项目中的任何一个地方通过 URL地址 ：module://girls, 调用 GirlsActivity，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Routers.open(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;module://girls&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>组件之间的调用解决后，另外需要解决的就是组件之间的通信，例如A业务组件中有消息列表，而用户在B组件中操作某个事件后会产生一条新消息，需要通知A组件刷新消息列表，这样业务场景需求可以使用Android广播来解决，也可以使用第三方的事件总线来实现，比如EventBus。</strong></p>
<p>6）组件之间资源名冲突</p>
<p>因为我们拆分出了很多业务组件和功能组件，在把这些组件合并到“app壳工程”时候就有可能会出现资源名冲突问题，例如A组件和B组件都有一张叫做“ic_back”的图标，这时候在集成模式下打包APP就会编译出错，解决这个问题最简单的办法就是在项目中约定资源文件命名规约，比如强制使每个资源文件的名称以组件名开始，这个可以根据实际情况和开发人员制定规则。当然了万能的Gradle构建工具也提供了解决方法，通过在在组件的build.gradle中添加如下的代码：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">//设置了resourcePrefix值后，所有的资源名必须以指定的字符串做前缀，否则会报错。</span><br><span class="line">//但是resourcePrefix这个值只能限定xml里面的资源，并不能限定图片资源，所有图片资源仍然需要手动去修改资源名。resourcePrefix &quot;girls<span class="built_in">_</span>&quot;</span><br></pre></td></tr></table></figure>

<p><strong>但是设置了这个属性后有个问题，所有的资源名必须以指定的字符串做前缀，否则会报错，而且resourcePrefix这个值只能限定xml里面的资源，并不能限定图片资源，所有图片资源仍然需要手动去修改资源名；</strong>所以我并不推荐使用这种方法来解决资源名冲突。</p>
<h1 id="组件化项目的工程类型"><a href="#组件化项目的工程类型" class="headerlink" title="组件化项目的工程类型"></a>组件化项目的工程类型</h1><p>在组件化工程模型中主要有：app壳工程、业务组件和功能组件3种类型，而业务组件中的Main组件和功能组件中的Common组件比较特殊，下面将分别介绍。</p>
<p>1）app壳工程<br>app壳工程是从名称来解释就是一个空壳工程，没有任何的业务代码，也不能有Activity，但它又必须被单独划分成一个组件，而不能融合到其他组件中，是因为它有如下几点重要功能：</p>
<p>1、app壳工程中声明了我们Android应用的 Application，这个Application 必须继承自 Common组件中的 BaseApplication（如果你无需实现自己的Application可以直接在表单声明BaseApplication），因为只有这样，在打包应用后才能让BaseApplication中的Context生效，当然你还可以在这个 Application中初始化我们工程中使用到的库文件，还可以在这里解决Android引用方法数不能超过 65535 的限制，对崩溃事件的捕获和发送也可以在这里声明。<br>2、app壳工程的 AndroidManifest.xml 是我Android应用的根表单，应用的名称、图标以及是否支持备份等等属性都是在这份表单中配置的，其他组件中的表单最终在集成开发模式下都被合并到这份AndroidManifest.xml 中。<br>3、app壳工程的 build.gradle 是比较特殊的，app壳不管是在集成开发模式还是组件开发模式，它的属性始终都是：com.android.application，因为最终其他的组件都要被app壳工程所依赖，被打包进app壳工程中，这一点从组件化工程模型图中就能体现出来，所以app壳工程是不需要单独调试单独开发的。另外Android应用的打包签名，以及buildTypes和defaultConfig都需要在这里配置，而它的dependencies则需要根据isModule的值分别依赖不同的组件，在组件开发模式下app壳工程只需要依赖Common组件，或者为了防止报错也可以根据实际情况依赖其他功能组件，而在集成模式下app壳工程必须依赖所有在应用Application中声明的业务组件，并且不需要再依赖任何功能组件。</p>
<p>下面是一份 app壳工程 的 build.gradle文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">def</span> buildTime() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">android &#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            keyAlias <span class="string">&#x27;guiying712&#x27;</span></span><br><span class="line">            keyPassword <span class="string">&#x27;guiying712&#x27;</span></span><br><span class="line">            storeFile file(<span class="string">&#x27;/mykey.jks&#x27;</span>)</span><br><span class="line">            storePassword <span class="string">&#x27;guiying712&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">&quot;com.guiying.androidmodulepattern&quot;</span></span><br><span class="line">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.ext.targetSdkVersion</span><br><span class="line">        versionCode rootProject.ext.versionCode</span><br><span class="line">        versionName rootProject.ext.versionName</span><br><span class="line">        multiDexEnabled <span class="literal">false</span></span><br><span class="line">        <span class="comment">//打包时间</span></span><br><span class="line">        resValue <span class="string">&quot;string&quot;</span>, <span class="string">&quot;build_time&quot;</span>, buildTime()</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">//更改AndroidManifest.xml中预先定义好占位符信息</span></span><br><span class="line">            <span class="comment">//manifestPlaceholders = [app_icon:&quot;@drawable/icon&quot;]</span></span><br><span class="line">            <span class="comment">// 不显示Log</span></span><br><span class="line">            buildConfigField <span class="string">&quot;boolean&quot;</span>, <span class="string">&quot;LEO_DEBUG&quot;</span>, <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="comment">//是否zip对齐</span></span><br><span class="line">            zipAlignEnabled <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 缩减resource文件</span></span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            <span class="comment">//Proguard</span></span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            proguardFiles</span><br><span class="line">            getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">            <span class="comment">//签名</span></span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">//给applicationId添加后缀“.debug”</span></span><br><span class="line">            applicationIdSuffix <span class="string">&quot;.debug&quot;</span></span><br><span class="line">            <span class="comment">//manifestPlaceholders = [app_icon:&quot;@drawable/launch_beta&quot;]</span></span><br><span class="line">            buildConfigField <span class="string">&quot;boolean&quot;</span>, <span class="string">&quot;LOG_DEBUG&quot;</span>, <span class="string">&quot;true&quot;</span></span><br><span class="line">            zipAlignEnabled <span class="literal">false</span></span><br><span class="line">            shrinkResources <span class="literal">false</span></span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            debuggable <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    annotationProcessor <span class="string">&quot;com.github.mzule.activityrouter:compiler:$rootProject.annotationProcessor&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (isModule.toBoolean()) &#123;</span><br><span class="line">    	compile project(<span class="string">&#x27;:lib_common&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        compile project(<span class="string">&#x27;:module_main&#x27;</span>)</span><br><span class="line">        compile project(<span class="string">&#x27;:module_girls&#x27;</span>)</span><br><span class="line">        compile project(<span class="string">&#x27;:module_news&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）功能组件和Common组件<br>功能组件是为了支撑业务组件的某些功能而独立划分出来的组件，功能实质上跟项目中引入的第三方库是一样的，功能组件的特征如下：</p>
<p>1、功能组件的 AndroidManifest.xml 是一张空表，这张表中只有功能组件的包名；<br>2、功能组件不管是在集成开发模式下还是组件开发模式下属性始终是：com.android.library，所以功能组件是不需要读取 gradle.properties 中的 isModule 值的；另外功能组件的 build.gradle 也无需设置 buildTypes，只需要 dependencies 这个功能组件需要的jar包和开源库。下面是一份 普通 的功能组件的 build.gradle文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.ext.targetSdkVersion</span><br><span class="line">        versionCode rootProject.ext.versionCode</span><br><span class="line">        versionName rootProject.ext.versionName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">	compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Common组件除了有功能组件的普遍属性外，还具有其他功能：<br>1、Common组件的 AndroidManifest.xml 不是一张空表，这张表中声明了我们 Android应用用到的所有使用权限 uses-permission 和 uses-feature，放到这里是因为在组件开发模式下，所有业务组件就无需在自己的 AndroidManifest.xm 声明自己要用到的权限了。<br>2、Common组件的 build.gradle 需要统一依赖业务组件中用到的 第三方依赖库和jar包，例如我们用到的ActivityRouter、Okhttp等等。</p>
<p>3、Common组件中封装了Android应用的 Base类和网络请求工具、图片加载工具等等，公用的 widget控件也应该放在Common 组件中；业务组件中都用到的数据也应放于Common组件中，例如保存到SharedPreferences 和 DataBase 中的登陆数据；<br>4、Common组件的资源文件中需要放置项目公用的 Drawable、layout、sting、dimen、color和style 等等，另外项目中的 Activity 主题必须定义在 Common中，方便和 BaseActivity 配合保持整个Android应用的界面风格统一。</p>
<p>下面是一份 Common功能组件的 build.gradle文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.ext.targetSdkVersion</span><br><span class="line">        versionCode rootProject.ext.versionCode</span><br><span class="line">        versionName rootProject.ext.versionName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    <span class="comment">//Android Support</span></span><br><span class="line">    compile <span class="string">&quot;com.android.support:appcompat-v7:$rootProject.supportLibraryVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.android.support:design:$rootProject.supportLibraryVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.android.support:percent:$rootProject.supportLibraryVersion&quot;</span></span><br><span class="line">    <span class="comment">//网络请求相关</span></span><br><span class="line">    compile <span class="string">&quot;com.squareup.retrofit2:retrofit:$rootProject.retrofitVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.squareup.retrofit2:retrofit-mock:$rootProject.retrofitVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.github.franmontiel:PersistentCookieJar:$rootProject.cookieVersion&quot;</span></span><br><span class="line">    <span class="comment">//稳定的</span></span><br><span class="line">    compile <span class="string">&quot;com.github.bumptech.glide:glide:$rootProject.glideVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.orhanobut:logger:$rootProject.loggerVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;org.greenrobot:eventbus:$rootProject.eventbusVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.google.code.gson:gson:$rootProject.gsonVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.github.chrisbanes:PhotoView:$rootProject.photoViewVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.jude:easyrecyclerview:$rootProject.easyRecyclerVersion&quot;</span></span><br><span class="line">    compile <span class="string">&quot;com.github.GrenderG:Toasty:$rootProject.toastyVersion&quot;</span></span><br><span class="line">    <span class="comment">//router</span></span><br><span class="line">    compile <span class="string">&quot;com.github.mzule.activityrouter:activityrouter:$rootProject.routerVersion&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）业务组件和Main组件</p>
<p>业务组件就是根据业务逻辑的不同拆分出来的组件，业务组件的特征如下：<br>1、业务组件中要有两张AndroidManifest.xml，分别对应组件开发模式和集成开发模式，这两张表的区别请查看 组件之间AndroidManifest合并问题 小节。<br>2、业务组件在集成模式下是不能有自己的Application的，但在组件开发模式下又必须实现自己的Application并且要继承自Common组件的BaseApplication，并且这个Application不能被业务组件中的代码引用，因为它的功能就是为了使业务组件从BaseApplication中获取的全局Context生效，还有初始化数据之用。<br>3、业务组件有debug文件夹，这个文件夹在集成模式下会从业务组件的代码中排除掉，所以debug文件夹中的类不能被业务组件强引用，例如组件模式下的 Application 就是置于这个文件夹中，还有组件模式下开发给目标 Activity 传递参数的用的 launch Activity 也应该置于 debug 文件夹中；<br>4、业务组件必须在自己的 Java文件夹中创建业务组件声明类，以使 app壳工程 中的 应用Application能够引用，实现组件跳转，具体请查看 组件之间调用和通信 小节；<br>5、业务组件必须在自己的 build.gradle 中根据 isModule 值的不同改变自己的属性，在组件模式下是：com.android.application，而在集成模式下com.android.library；同时还需要在build.gradle配置资源文件，如指定不同开发模式下的AndroidManifest.xml文件路径，排除debug文件夹等；业务组件还必须在dependencies中依赖Common组件，并且引入ActivityRouter的注解处理器annotationProcessor，以及依赖其他用到的功能组件。</p>
<p>下面是一份普通业务组件的 build.gradle文件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isModule.toBoolean()) &#123;</span><br><span class="line">	apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion rootProject.ext.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.ext.targetSdkVersion</span><br><span class="line">        versionCode rootProject.ext.versionCode</span><br><span class="line">        versionName rootProject.ext.versionName</span><br><span class="line">    &#125;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">        <span class="keyword">if</span> (isModule.toBoolean()) &#123;</span><br><span class="line">            manifest.srcFile <span class="string">&#x27;src/main/module/AndroidManifest.xml&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            manifest.srcFile <span class="string">&#x27;src/main/AndroidManifest.xml&#x27;</span></span><br><span class="line">            <span class="comment">//集成开发模式下排除debug文件夹中的所有Java文件</span></span><br><span class="line">            java &#123;</span><br><span class="line">            	exclude <span class="string">&#x27;debug/**&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置了resourcePrefix值后，所有的资源名必须以指定的字符串做前缀，否则会报错。</span></span><br><span class="line"><span class="comment">//但是resourcePrefix这个值只能限定xml里面的资源，并不能限定图片资源，所有图片资源仍然需要手动去修改资源名。</span></span><br><span class="line"><span class="comment">//resourcePrefix &quot;girls_&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    annotationProcessor <span class="string">&quot;com.github.mzule.activityrouter:compiler:$rootProject.annotationProcessor&quot;</span></span><br><span class="line">    compile project(<span class="string">&#x27;:lib_common&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Main组件除了有业务组件的普遍属性外，还有一项重要功能：</strong></p>
<p>1、Main组件集成模式下的AndroidManifest.xml是跟其他业务组件不一样的，Main组件的表单中声明了我们整个Android应用的launchActivity，这就是Main组件的独特之处；所以我建议SplashActivity、登陆Activity以及主界面都应属于Main组件，也就是说Android应用启动后要调用的页面应置于Main组件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.splash.SplashActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:screenOrientation</span>=<span class="string">&quot;portrait&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/SplashTheme&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">        	<span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span></span></span><br><span class="line"><span class="tag">        	<span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="组件化项目的混淆方案"><a href="#组件化项目的混淆方案" class="headerlink" title="组件化项目的混淆方案"></a>组件化项目的混淆方案</h1><p>组件化项目的Java代码混淆方案采用在集成模式下集中在app壳工程中混淆，各个业务组件不配置混淆文件。集成开发模式下在app壳工程中build.gradle文件的release构建类型中开启混淆属性，其他buildTypes配置方案跟普通项目保持一致，Java混淆配置文件也放置在app壳工程中，各个业务组件的混淆配置规则都应该在app壳工程中的混淆配置文件中添加和修改。</p>
<p>之所以不采用在每个业务组件中开启混淆的方案，是因为 组件在集成模式下都被 Gradle 构建成了 release 类型的arr包，一旦业务组件的代码被混淆，而这时候代码中又出现了bug，将很难根据日志找出导致bug的原因；另外每个业务组件中都保留一份混淆配置文件非常不便于修改和管理，这也是不推荐在业务组件的 build.gradle 文件中配置 buildTypes（构建类型）的原因。</p>
<h1 id="工程的配置信息"><a href="#工程的配置信息" class="headerlink" title="工程的配置信息"></a>工程的配置信息</h1><p>1）组件化工程的build.gradle文件<br>在组件化项目中因为每个组件的 build.gradle 都需要配置compileSdkVersion、buildToolsVersion和defaultConfig 等的版本号，而且每个组件都需要用到 annotationProcessor，为了能够使组件化项目中的所有组件的 build.gradle 中的这些配置都能保持统一，并且也是为了方便修改版本号，我们统一在Android工程根目录下的build.gradle中定义这些版本号，当然为了方便管理Common组件中的第三方开源库的版本号，最好也在这里定义这些开源库的版本号，然后在各个组件的build.gradle中引用Android工程根目录下的build.gradle定义的版本号，组件化工程的 build.gradle 文件代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        <span class="comment">//classpath</span></span><br><span class="line">        <span class="string">&quot;com.android.tools.build:gradle:$localGradlePluginVersion&quot;</span></span><br><span class="line">        <span class="comment">//$localGradlePluginVersion是gradle.properties中的</span></span><br><span class="line">        数据</span><br><span class="line">        classpath <span class="string">&quot;com.android.tools.build:gradle:$localGradlePluginVersion&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        <span class="comment">//Add the JitPack repository</span></span><br><span class="line">        maven &#123; url <span class="string">&quot;https://jitpack.io&quot;</span> &#125;</span><br><span class="line">        <span class="comment">//支持arr包</span></span><br><span class="line">        flatDir &#123;</span><br><span class="line">        	dirs <span class="string">&#x27;libs&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task clean(<span class="attr">type:</span> Delete) &#123;</span><br><span class="line">	delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Define versions in a single place</span></span><br><span class="line"><span class="comment">//时间：2017.2.13；每次修改版本号都要添加修改时间</span></span><br><span class="line">ext &#123;</span><br><span class="line">    <span class="comment">// Sdk and tools</span></span><br><span class="line">    <span class="comment">//localBuildToolsVersion是gradle.properties中的数据</span></span><br><span class="line">    buildToolsVersion = localBuildToolsVersion</span><br><span class="line">    compileSdkVersion = <span class="number">25</span></span><br><span class="line">    minSdkVersion = <span class="number">16</span></span><br><span class="line">    targetSdkVersion = <span class="number">25</span></span><br><span class="line">    versionCode = <span class="number">1</span></span><br><span class="line">    versionName = <span class="string">&quot;1.0&quot;</span></span><br><span class="line">    javaVersion = JavaVersion.VERSION_1_8</span><br><span class="line">    <span class="comment">// App dependencies version</span></span><br><span class="line">    supportLibraryVersion = <span class="string">&quot;25.3.1&quot;</span></span><br><span class="line">    retrofitVersion = <span class="string">&quot;2.1.0&quot;</span></span><br><span class="line">    glideVersion = <span class="string">&quot;3.7.0&quot;</span></span><br><span class="line">    loggerVersion = <span class="string">&quot;1.15&quot;</span></span><br><span class="line">    eventbusVersion = <span class="string">&quot;3.0.0&quot;</span></span><br><span class="line">    gsonVersion = <span class="string">&quot;2.8.0&quot;</span></span><br><span class="line">    photoViewVersion = <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">    <span class="comment">//需检查升级版本</span></span><br><span class="line">    annotationProcessor = <span class="string">&quot;1.1.7&quot;</span></span><br><span class="line">    routerVersion = <span class="string">&quot;1.2.2&quot;</span></span><br><span class="line">    easyRecyclerVersion = <span class="string">&quot;4.4.0&quot;</span></span><br><span class="line">    cookieVersion = <span class="string">&quot;v1.0.1&quot;</span></span><br><span class="line">    toastyVersion = <span class="string">&quot;1.1.3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）组件化工程的gradle.properties文件<br>在组件化实施流程中我们了解到gradle.properties有两个属性对我们非常<br>有用：<br>1、在Android项目中的任何一个build.gradle文件中都可以把gradle.properties中的常量读取出来，不管这个build.gradle是组件的还是整个项目工程的build.gradle；<br>2、gradle.properties中的数据类型都是String类型，使用其他数据类型需要自行转换；</p>
<p>利用gradle.properties的属性不仅可以解决集成开发模式和组件开发模式的转换，而且还可以解决在多人协同开发Android项目的时候，因为开发团队成员的Android开发环境（开发环境指Android SDK和AndroidStudio）不一致而导致频繁改变线上项目的build.gradle配置。</p>
<p>在每个Android组件的 build.gradle 中有一个属性：buildToolsVersion，表示构建工具的版本号，这个属性值对应AndroidSDK 中的 Android SDK Build-tools，正常情况下 build.gradle中的 buildToolsVersion 跟你电脑中 Android SDK Build-tools 的最新版本是一致的，比如现在 Android SDK Build-tools 的最新的版本是：25.0.3，那么我的Android项目中 build.gradle 中的 buildToolsVersion版本号也是 25.0.3，但是一旦一个Android项目是由好几个人同时开发，总会出现每个人的开发环境 Android SDK Build-tools 是都是不一样的，并不是所有人都会经常升级更新 Android SDK，而且代码是保存到线上环境的（例如使用 SVN/Git 等工具），某个开发人员提交代码后线上<br>Android项目中 build.gradle 中的 buildToolsVersion 也会被不断地改变。</p>
<p>另外一个原因是因为Android工程的根目录下的 build.gradle 声明了Android Gradle 构建工具，而这个工具也是有版本号的，而且 GradleBuild Tools 的版本号跟 AndroidStudio 版本号一致的，但是有些开发人员基本很久都不会升级自己的 AndroidStudio 版本，导致团队中每个开发人员的 Gradle Build Tools 的版本号也不一致。</p>
<p>如果每次同步代码后这两个工具的版本号被改变了，开发人员可以自己手动改回来，并且不要把改动工具版本号的代码提交到线上环境，这样还可以勉强继续开发；但是很多公司都会使用持续集成工具（例如Jenkins）用于持续的软件版本发布，而Android出包是需要 Android SDK Build-tools 和 Gradle Build Tools 配合的，一旦提交到线上的版本跟持续集成工具所依赖的Android环境构建工具版本号不一致就会导致Android打包失败。</p>
<p>为了解决上面问题就必须将Android项目中 build.gradle 中的buildToolsVersion 和 GradleBuildTools 版本号从线上代码隔离出来，保证线上代码的 buildToolsVersion 和 Gradle Build Tools 版本号不会被人为改变。</p>
<p>7、组件化项目Router的其他方案-ARouter</p>
<p>在组件化项目中使用到的跨组件跳转库ActivityRouter可以使用阿里巴巴的开源路由项目：阿里巴巴ARouter；</p>
<p>ActivityRouter和ARouter的接入组件化项目的方式是一样的，ActivityRouter提供的功能目前ARouter也全部支持，但是ARouter还支持依赖注入解耦，页面、拦截器、服务等组件均会自动注册到框架。对于大家来说，没有最好的只有最适合的，大家可以根据自己的项目选择合适的Router。</p>
<p><strong>下面将介绍ARouter的基础使用方法，更多功能还需大家去Github自己学习；</strong></p>
<p>1、首先 ARouter 这个框架是需要初始化SDK的，所以你需要在“app壳工程”中的应用Application中加入下面的代码，注意：在 debug 模式下一定要 openDebug：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">    <span class="comment">//一定要在ARouter.init之前调用openDebug</span></span><br><span class="line">    ARouter.openDebug();</span><br><span class="line">    ARouter.openLog();</span><br><span class="line">&#125;</span><br><span class="line">ARouter.init(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>2、首先我们依然需要在 Common 组件中的 build.gradle 将ARouter 依赖进来，方便我们在业务组件中调用：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    <span class="comment">//router</span></span><br><span class="line">    compile <span class="string">&#x27;com.alibaba:arouter-api:1.2.1.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、然后在每一个业务组件的 build.gradle 都引入ARouter 的 Annotation处理器，代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [ <span class="attr">moduleName :</span> project.getName() ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(<span class="attr">dir:</span> <span class="string">&#x27;libs&#x27;</span>, <span class="attr">include:</span> [<span class="string">&#x27;*.jar&#x27;</span>])</span><br><span class="line">    annotationProcessor <span class="string">&#x27;com.alibaba:arouter-compiler:1.0.3&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、<strong>由于ARouter支持自动注册到框架，所以我们不用像ActivityRouter那样在各个组件中声明组件，当然更不需要在Application中管理组件了。 <strong>我们给 Girls组件 中的 GirlsActivity 添加注解：</strong>@Route(path =“/girls/list”)<strong>，需要注意的是</strong>这里的路径至少需要有两级，/xx/xx</strong>，之所以这样是因为<strong>ARouter使用了路径中第一段字符串(/*/)作为分组</strong>，比如像上面的”girls”，而分组这个概念就有点类似于ActivityRouter中的组件声明@Module ，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Route(path = &quot;/girls/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GirlsActivity</span> <span class="keyword">extends</span> <span class="title">BaseActionBarActivity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GirlsView mView;</span><br><span class="line">    <span class="keyword">private</span> GirlsContract.Presenter mPresenter;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">setTitleId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> R.string.girls_activity_title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mView = <span class="keyword">new</span> GirlsView(<span class="keyword">this</span>);</span><br><span class="line">        setContentView(mView);</span><br><span class="line">        mPresenter = <span class="keyword">new</span> GirlsPresenter(mView);</span><br><span class="line">        mPresenter.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以在项目中的任何一个地方通过 URL地址 ： /girls/list, 调用 GirlsActivity，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ARouter.getInstance().build(<span class="string">&quot;/girls/list&quot;</span>).navigation();</span><br></pre></td></tr></table></figure>

<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>组件化相比于单一工程优势是显而易见的：</p>
<ol>
<li>组件模式下可以加快编译速度，提高开发效率；</li>
<li>自由选择开发框架（MVC /MVP / MVVM /）；</li>
<li>方便做单元测试；</li>
<li>代码架构更加清晰，降低项目的维护难度；</li>
<li>适合于团队开发；</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>组件化</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化-内存泄露与内存优化</title>
    <url>/2019/09/17/android_memory_performace/</url>
    <content><![CDATA[<p>在Android中，内存泄露的现象十分常见；而内存泄露导致的后果会使得应用Crash。本文将介绍了内存泄露的本质、原因 &amp; 解决方案，最终提供一些常见的内存泄露分析工具。</p>
<span id="more"></span>

<h1 id="Android的内存管理"><a href="#Android的内存管理" class="headerlink" title="Android的内存管理"></a>Android的内存管理</h1><p><img src="/images/android_memory_performance01.png" alt="image"></p>
<h2 id="针对进程的内存策略"><a href="#针对进程的内存策略" class="headerlink" title="针对进程的内存策略"></a>针对进程的内存策略</h2><p><strong>a. 内存分配策略</strong><br>由 ActivityManagerService 集中管理 所有进程的内存分配</p>
<p><strong>b. 内存回收策略</strong></p>
<ul>
<li>步骤1：Application Framework 决定回收的进程类型<br><strong>Android中的进程 是托管的；当进程空间紧张时，会 按进程优先级低-&gt;&gt;高的顺序 自动回收进程</strong></li>
</ul>
<blockquote>
<p>Android将进程分为5个优先等级，具体如下：</p>
</blockquote>
<p><img src="/images/android_memory_performance02.png" alt="image"></p>
<ul>
<li>步骤2：Linux 内核真正回收具体进程<br>1.ActivityManagerService 对 所有进程进行评分（评分存放在变量adj中）<br>2.更新评分到Linux 内核<br>3.由Linux 内核完成真正的内存回收</li>
</ul>
<blockquote>
<p>此处仅总结流程，这其中的过程复杂，有兴趣的读者可研究系统源码ActivityManagerService.java</p>
</blockquote>
<h2 id="针对对象、变量的内存策略"><a href="#针对对象、变量的内存策略" class="headerlink" title="针对对象、变量的内存策略"></a>针对对象、变量的内存策略</h2><ul>
<li><p>Android的对于对象、变量的内存策略同 Java</p>
</li>
<li><p>内存管理 = 对象 / 变量的内存分配 + 内存释放</p>
</li>
</ul>
<p>下面，将详细讲解内存分配 &amp; 内存释放策略</p>
<p><strong>a. 内存分配策略</strong></p>
<ul>
<li><p>对象 / 变量的内存分配 由程序自动 负责</p>
</li>
<li><p>共有3种：静态分配、栈式分配、 &amp; 堆式分配，分别面向静态变量、局部变量 &amp; 对象实例</p>
</li>
</ul>
<p>具体介绍如下<br><img src="/images/android_memory_performance03.png" alt="image"></p>
<p>用1个实例讲解 内存分配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">    Sample mSample1 = <span class="keyword">new</span> Sample();   </span><br><span class="line"> 	</span><br><span class="line"> 	<span class="comment">// 方法中的局部变量s2、mSample2存放在 栈内存</span></span><br><span class="line"> 	<span class="comment">// 变量mSample2所指向的对象实例存放在 堆内存</span></span><br><span class="line"> 	  <span class="comment">// 该实例的成员变量s1、mSample1也存放在栈中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">        Sample mSample2 = <span class="keyword">new</span> Sample();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 变量mSample3所指向的对象实例存放在堆内存</span></span><br><span class="line">	<span class="comment">// 该实例的成员变量s1、mSample1也存放在栈中</span></span><br><span class="line">    Sample mSample3 = <span class="keyword">new</span> Sample();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b.内存释放策略</strong></p>
<ul>
<li><p>对象 / 变量的内存释放 由Java垃圾回收器（GC） / 帧栈 负责</p>
</li>
<li><p>此处主要讲解对象分配（即堆式分配）的内存释放策略 = Java垃圾回收器（GC）</p>
</li>
</ul>
<blockquote>
<p>由于静态分配不需释放、栈式分配仅 通过帧栈自动出、入栈，较简单，故不详细描述</p>
</blockquote>
<ul>
<li>Java垃圾回收器（GC）的内存释放 = 垃圾回收算法，主要包括：</li>
</ul>
<p><img src="/images/android_memory_performance04.png" alt="image"></p>
<p>具体介绍如下</p>
<p><img src="/images/android_memory_performance05.png" alt="image"></p>
<h1 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h1><p>内存泄露，即ML(Memory Leak)。指 程序在申请内存后，当该内存不需再使用 <strong>但 却无法被释放 &amp; 归还给 程序</strong>的现象。容易使得应用程序发生内存溢出，即 <code>OOM</code></p>
<p><img src="/images/android_memory_performance06.png" alt="image"></p>
<h2 id="发生内存泄露的本质原因"><a href="#发生内存泄露的本质原因" class="headerlink" title="发生内存泄露的本质原因"></a>发生内存泄露的本质原因</h2><p><img src="/images/android_memory_performance07.png" alt="image"></p>
<ul>
<li>特别注意<br>从机制上的角度来说，由于 <code>Java</code>存在垃圾回收机制（<code>GC</code>），理应不存在内存泄露；出现内存泄露的原因仅仅是外部人为原因 = <strong>无意识地持有对象引用，使得 持有引用者的生命周期 &gt; 被引用者的生命周期</strong></li>
</ul>
<h1 id="常见的内存泄露原因-amp-解决方案"><a href="#常见的内存泄露原因-amp-解决方案" class="headerlink" title="常见的内存泄露原因&amp;解决方案"></a>常见的内存泄露原因&amp;解决方案</h1><ul>
<li>常见引发内存泄露原因主要有：<br>1.集合类<br>2.Static关键字修饰的成员变量<br>3.非静态内部类 / 匿名类<br>4.资源对象使用后未关闭</li>
</ul>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><ul>
<li>内存泄露原因<br>集合类 添加元素后，仍引用着 集合元素对象，导致该集合元素对象不可被回收，从而 导致内存泄漏</li>
</ul>
<p>实例演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 循环申请Object 对象 &amp; 将申请的对象逐个放入到集合List</span></span><br><span class="line">List&lt;Object&gt; objectList = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Object o = <span class="keyword">new</span> Object();</span><br><span class="line">            objectList.add(o);</span><br><span class="line">            o = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 虽释放了集合元素引用的本身：o=null）</span></span><br><span class="line"><span class="comment">// 但集合List 仍然引用该对象，故垃圾回收器GC 依然不可回收该对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案<br>集合类 添加集合元素对象 后，在使用后必须从集合中删除</li>
</ul>
<blockquote>
<p>由于1个集合中有许多元素，故最简单的方法 = 清空集合对象 &amp; 设置为<code>null</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 释放objectList</span></span><br><span class="line">objectList.clear();</span><br><span class="line">objectList=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="static关键字修饰的成员变量"><a href="#static关键字修饰的成员变量" class="headerlink" title="static关键字修饰的成员变量"></a>static关键字修饰的成员变量</h2><ul>
<li><p>储备知识<br>被 Static 关键字修饰的成员变量的生命周期 = 应用程序的生命周期</p>
</li>
<li><p>泄露原因<br>若使被 Static 关键字修饰的成员变量 引用耗费资源过多的实例（如Context），则容易出现该成员变量的生命周期 &gt; 引用实例生命周期的情况，当引用实例需结束生命周期销毁时，会因静态变量的持有而无法被回收，从而出现内存泄露</p>
</li>
</ul>
<p>实例讲解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 定义1个静态变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Context mContext;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"><span class="comment">// 引用的是Activity的context</span></span><br><span class="line"> mContext = context; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Activity需销毁时，由于mContext = 静态 &amp; 生命周期 = 应用程序的生命周期，故 Activity无法被回收，从而出现内存泄露</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案</li>
</ul>
<ol>
<li>尽量避免 <code>Static</code> 成员变量引用资源耗费过多的实例（如 <code>Context</code>）</li>
</ol>
<blockquote>
<p>若需引用 <code>Context</code>，则尽量使用<code>Applicaiton</code>的<code>Context</code></p>
</blockquote>
<ol>
<li>使用 弱引用<code>（WeakReference）</code> 代替 强引用 持有实例</li>
</ol>
<p><strong>静态成员变量有个非常典型的例子:单例模式</strong></p>
<ul>
<li>储备知识<br>单例模式 由于其<strong>静态特性</strong>，其生命周期的长度 = 应用程序的生命周期</li>
<li>泄露原因<br>若1个对象已不需再使用 而单例对象还持有该对象的引用，那么该对象将不能被正常回收 从而 导致内存泄漏</li>
</ul>
<p>实例演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建单例时，需传入一个Context</span></span><br><span class="line"><span class="comment">// 若传入的是Activity的Context，此时单例 则持有该Activity的引用</span></span><br><span class="line"><span class="comment">// 由于单例一直持有该Activity的引用（直到整个应用生命周期结束），即使该Activity退出，该Activity的内存也不会被回收</span></span><br><span class="line"><span class="comment">// 特别是一些庞大的Activity，此处非常容易导致OOM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceClass</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstanceClass instance;    </span><br><span class="line">    <span class="keyword">private</span> Context mContext;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstanceClass</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.mContext = context; <span class="comment">// 传递的是Activity的context</span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleInstanceClass <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleInstanceClass(context);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案<br>单例模式引用的对象的生命周期 = 应用的生命周期</li>
</ul>
<blockquote>
<p>如上述实例，应传递<code>Application</code>的<code>Context</code>，因<code>Application</code>的生命周期 = 整个应用的生命周期</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceClass</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstanceClass instance;    </span><br><span class="line">    <span class="keyword">private</span> Context mContext;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstanceClass</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.mContext = context.getApplicationContext(); <span class="comment">// 传递的是Application 的context</span></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleInstanceClass <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleInstanceClass(context);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="非静态内部类-匿名类"><a href="#非静态内部类-匿名类" class="headerlink" title="非静态内部类/匿名类"></a>非静态内部类/匿名类</h2><ul>
<li>储备知识<br>非静态内部类 / 匿名类 默认持有 外部类的引用；而静态内部类则不会</li>
<li>常见情况<br>3种，分别是：非静态内部类的实例 = 静态、多线程、消息传递机制（<code>Handler</code>）</li>
</ul>
<h3 id="非静态内部类的实例-静态"><a href="#非静态内部类的实例-静态" class="headerlink" title="非静态内部类的实例 = 静态"></a>非静态内部类的实例 = 静态</h3><ul>
<li>泄露原因<br>若 非静态内部类所创建的实例 = 静态（其生命周期 = 应用的生命周期），会因 <strong>非静态内部类默认持有外部类的引用</strong> 而导致外部类无法释放，最终 造成内存泄露</li>
</ul>
<blockquote>
<p>即 外部类中 持有 非静态内部类的静态对象</p>
</blockquote>
<p>实例演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背景：</span></span><br><span class="line">   a. 在启动频繁的Activity中，为了避免重复创建相同的数据资源，会在Activity内部创建一个非静态内部类的单例</span><br><span class="line">   b. 每次启动Activity时都会使用该单例的数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非静态内部类的实例的引用</span></span><br><span class="line">    <span class="comment">// 注：设置为静态  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InnerClass innerClass = <span class="keyword">null</span>; </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证非静态内部类的实例只有1个</span></span><br><span class="line">        <span class="keyword">if</span> (innerClass == <span class="keyword">null</span>)</span><br><span class="line">            innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态内部类的定义    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 造成内存泄露的原因：</span></span><br><span class="line">	<span class="comment">// a. 当TestActivity销毁时，因非静态内部类单例的引用（innerClass）的生命周期 = 应用App的生命周期、持有外部类TestActivity的引用</span></span><br><span class="line">	<span class="comment">// b. 故 TestActivity无法被GC回收，从而导致内存泄漏</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案<ol>
<li>将非静态内部类设置为：静态内部类（静态内部类默认不持有外部类的引用）</li>
<li>该内部类抽取出来封装成一个单例</li>
<li>尽量 避免 非静态内部类所创建的实例 = 静态</li>
</ol>
</li>
</ul>
<blockquote>
<p>若需使用<code>Context</code>，建议使用 <code>Application</code> 的 <code>Context</code></p>
</blockquote>
<h3 id="多线程：AsyncTask、实现Runnable接口、继承Thread类"><a href="#多线程：AsyncTask、实现Runnable接口、继承Thread类" class="headerlink" title="多线程：AsyncTask、实现Runnable接口、继承Thread类"></a>多线程：AsyncTask、实现Runnable接口、继承Thread类</h3><ul>
<li>储备知识<br>多线程的使用方法 = 非静态内部类 / 匿名类；即 线程类 属于 非静态内部类 / 匿名类</li>
<li>泄露原因<br>当 工作线程正在处理任务 &amp; 外部类需销毁时， <strong>由于 工作线程实例 持有外部类引用</strong>，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露</li>
</ul>
<blockquote>
<ol>
<li>多线程主要使用的是：<code>AsyncTask</code>、实现<code>Runnable</code>接口 &amp; 继承<code>Thread</code>类</li>
<li>前3者内存泄露的原理相同，此处主要以继承<code>Thread</code>类 为例说明</li>
</ol>
</blockquote>
<p>实例演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式1：新建Thread子类（内部类）</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过创建的内部类 实现多线程</span></span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自定义的Thread子类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式2：匿名Thread内部类</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过匿名内部类 实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 分析：内存泄露原因</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="comment">// 工作线程Thread类属于非静态内部类 / 匿名内部类，运行时默认持有外部类的引用</span></span><br><span class="line">  <span class="comment">// 当工作线程运行时，若外部类MainActivity需销毁</span></span><br><span class="line">  <span class="comment">// 由于此时工作线程类实例持有外部类的引用，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案<br>从上面可看出，造成内存泄露的原因有2个关键条件：</li>
</ul>
<ol>
<li>存在 ”工作线程实例 持有外部类引用“ 的引用关系</li>
<li>工作线程实例的生命周期 &gt; 外部类的生命周期，即工作线程仍在运行 而 外部类需销毁</li>
</ol>
<p><strong>解决方案的思路:使得上述任1条件不成立 即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共有2个解决方案：静态内部类 &amp; 当外部类结束生命周期时，强制结束线程</span></span><br><span class="line"><span class="comment">// 具体描述如下</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解决方式1：静态内部类</span></span><br><span class="line"><span class="comment">     * 原理：静态内部类 不默认持有外部类的引用，从而使得 “工作线程实例 持有 外部类引用” 的引用关系 不复存在</span></span><br><span class="line"><span class="comment">     * 具体实现：将Thread的子类设置成 静态内部类</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过创建的内部类 实现多线程</span></span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分析1：自定义Thread子类</span></span><br><span class="line">        <span class="comment">// 设置为：静态内部类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解决方案2：当外部类结束生命周期时，强制结束线程</span></span><br><span class="line"><span class="comment">     * 原理：使得 工作线程实例的生命周期 与 外部类的生命周期 同步</span></span><br><span class="line"><span class="comment">     * 具体实现：当 外部类（此处以Activity为例） 结束生命周期时（此时系统会调用onDestroy（）），强制结束线程（调用stop（））</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Thread.stop();</span><br><span class="line">        <span class="comment">// 外部类Activity生命周期结束时，强制结束线程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="资源对象使用后未关闭"><a href="#资源对象使用后未关闭" class="headerlink" title="资源对象使用后未关闭"></a>资源对象使用后未关闭</h2><ul>
<li>泄露原因<br>对于资源的使用（如 广播<code>BraodcastReceiver</code>、文件流<code>File</code>、数据库游标<code>Cursor</code>、图片资源<code>Bitmap</code>等），若在<code>Activity</code>销毁时无及时关闭 / 注销这些资源，则这些资源将不会被回收，从而造成内存泄漏</li>
<li>解决方案<br>在<code>Activity</code>销毁时 及时关闭 / 注销资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 广播BraodcastReceiver：注销注册</span></span><br><span class="line">unregisterReceiver()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 文件流File：关闭流</span></span><br><span class="line">InputStream / OutputStream.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于数据库游标cursor：使用后关闭游标</span></span><br><span class="line">cursor.close（）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 图片资源Bitmap：Android分配给图片的内存只有8M，若1个Bitmap对象占内存较多，当它不再被使用时，应调用recycle()回收此对象的像素所占用的内存；最后再赋为null </span></span><br><span class="line">Bitmap.recycle()；</span><br><span class="line">Bitmap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于动画（属性动画）</span></span><br><span class="line"><span class="comment">// 将动画设置成无限循环播放repeatCount = “infinite”后</span></span><br><span class="line"><span class="comment">// 在Activity退出时记得停止动画</span></span><br></pre></td></tr></table></figure>

<h2 id="其他使用"><a href="#其他使用" class="headerlink" title="其他使用"></a>其他使用</h2><ul>
<li>除了上述4种常见情况，还有一些日常的使用会导致内存泄露</li>
<li>主要包括：<code>Context</code>、<code>WebView</code>、<code>Adapter</code>，具体介绍如下</li>
</ul>
<p><img src="/images/android_memory_performance08.png" alt="image"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面，我将用一张图总结<code>Android</code>中内存泄露的原因 &amp; 解决方案</p>
<p><img src="/images/android_memory_performance09.png" alt="image"></p>
<h1 id="内存泄露辅助分析工具"><a href="#内存泄露辅助分析工具" class="headerlink" title="内存泄露辅助分析工具"></a>内存泄露辅助分析工具</h1><ul>
<li>哪怕完全了解 内存泄露的原因，但难免还是会出现内存泄露的现象</li>
<li>下面将简单介绍几个主流的分析内存泄露的工具，分别是<ol>
<li><code>MAT(Memory Analysis Tools)</code></li>
<li><code>Heap Viewer</code></li>
<li><code>Allocation Tracker</code></li>
<li><code>Android Studio 的 Memory Monitor</code></li>
<li><code>LeakCanary</code></li>
</ol>
</li>
</ul>
<h2 id="MAT-Memory-Analysis-Tools"><a href="#MAT-Memory-Analysis-Tools" class="headerlink" title="MAT(Memory Analysis Tools)"></a>MAT(Memory Analysis Tools)</h2><ul>
<li>定义：一个<code>Eclipse</code>的 <code>Java Heap</code> 内存分析工具 -&gt;&gt;<a href="http://www.eclipse.org/mat/">下载地址</a></li>
<li>作用：查看当前内存占用情况</li>
</ul>
<blockquote>
<p>通过分析 <code>Java</code> 进程的内存快照 <code>HPROF</code> 分析，快速计算出在内存中对象占用的大小，查看哪些对象不能被垃圾收集器回收 &amp; 可通过视图直观地查看可能造成这种结果的对象</p>
</blockquote>
<ul>
<li>具体使用：自行查找</li>
</ul>
<h2 id="Heap-Viewer"><a href="#Heap-Viewer" class="headerlink" title="Heap Viewer"></a>Heap Viewer</h2><ul>
<li><p>定义：一个的 Java Heap 内存分析工具</p>
</li>
<li><p>作用：查看当前内存快照</p>
</li>
</ul>
<blockquote>
<p>可查看 分别有哪些类型的数据在堆内存总 &amp; 各种类型数据的占比情况</p>
</blockquote>
<ul>
<li>具体使用：自行查找</li>
</ul>
<h2 id="Allocation-Tracker"><a href="#Allocation-Tracker" class="headerlink" title="Allocation Tracker"></a>Allocation Tracker</h2><ul>
<li><p>简介：一个内存追踪分析工具</p>
</li>
<li><p>作用：追踪内存分配信息，按顺序排列</p>
</li>
<li><p>具体使用：自行查找</p>
</li>
</ul>
<h2 id="Memory-Monitor"><a href="#Memory-Monitor" class="headerlink" title="Memory Monitor"></a>Memory Monitor</h2><ul>
<li><p>简介：一个 Android Studio 自带 的图形化检测内存工具</p>
</li>
<li><p>作用：跟踪系统 / 应用的内存使用情况。核心功能如下</p>
</li>
<li><p>具体使用：自行查找</p>
</li>
</ul>
<h2 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a>LeakCanary</h2><ul>
<li><p>简介：一个square出品的Android开源库 -&gt;&gt;下载地址</p>
</li>
<li><p>作用：检测内存泄露</p>
</li>
<li><p>具体使用：<a href="https://www.liaohuqiu.net/cn/posts/leak-canary/">https://www.liaohuqiu.net/cn/posts/leak-canary/</a></p>
</li>
</ul>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><img src="/images/android_memory_performance10.png" alt="image"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化-安装包优化</title>
    <url>/2019/07/08/android_package_performace/</url>
    <content><![CDATA[<p>Android的安装包APK文件本身就是个压缩文件。把后缀名改成.zip，用解压软件解压后，就能看到安装包的内容。</p>
<span id="more"></span>

<p><img src="/images/android_package_performance01.png" alt="image"></p>
<p>从上图可以看到，安装包内的文件结构是：</p>
<ol>
<li>assets 资源文件</li>
<li>res 资源文件</li>
<li>*.dex Dalvik字节码</li>
<li>META-INF 签名信息</li>
<li>lib so库</li>
</ol>
<p>要减小安装包的体积本质就是要减少包内的文件的大小。接下来我们依次<br>来看如何减少这些文件的大小</p>
<h1 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h1><ol>
<li><p>能用shape就绝不用图片。对于纯色或渐变的图片，能用shape渲染的就优先使用shape。不仅文件体积小，还渲染速度快，也不用考虑适配问题。</p>
</li>
<li><p>图片压缩。一般UI给的资源图都是软件直接导出的PNG图片，体积较大。可以把图片压缩后，再放入项目中。推荐使用tinyPNG ，或者AndroidStudio 插件TinyPic 压缩。</p>
</li>
<li><p>使用webp图片。相同的图片质量下，体积更小。</p>
<ul>
<li><p>webp的无损压缩比PNG文件小45%左右</p>
</li>
<li><p>AndroidStudio 自带转换功能，可以把png转换为webp。</p>
</li>
<li><p>不用考虑Android系统兼容问题，因为目前大部分App的最低支持版本<br>都是4.4.4。</p>
</li>
<li><p>缺点是解码速度相对慢些，在加载网络图片上很有优势。</p>
</li>
</ul>
</li>
<li><p>svg矢量图。其实是图片的描述文件，牺牲CPU的计算能力的，节省空间。适用于简单的图标。</p>
</li>
</ol>
<blockquote>
<p>目前WEBP与JPG相比较，编码速度慢10倍，解码速度慢1.5倍，虽然会增加额外的解码时间，但是由于减少了文件体积，缩短了加载的时间，实际上文件的渲染速度反而变快了。4.2.1+ 对于webp的decode、encode是完全支持的（包含半透明的webp图）对于4.0+ 到 4.2.1 ，只支持完全不透明的decode、encode的webp图<br>4.0 以下，应该是默认不支持webp了</p>
</blockquote>
<h1 id="资源文件混淆"><a href="#资源文件混淆" class="headerlink" title="资源文件混淆"></a>资源文件混淆</h1><p>主要是使用微信开源的AndResGuard资源混淆工具。这是个缩小APK大小的工具，他的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将res/drawable/wechat变为r/d/a。</p>
<p>这个工具不仅可以混淆资源文件，还利用了7z深度压缩，进一步减少安装包大小。如何使用请参考 AndResGuard的使用。</p>
<p>实现的原理是：resource.arsc文件中保存着资源文件夹中各个资源的路径。AndResGuard工具将资源文件重命名(甚至修改文件夹名，将drawable改为a0)后，再生成新的resource.arsc文件，替换源文件打包签名即可。</p>
<p><img src="/images/android_package_performance02.png" alt="混淆之前的资源文件夹"></p>
<p><img src="/images/android_package_performance03.png" alt="混淆之后的资源文件夹"></p>
<h1 id="去除不用so文件"><a href="#去除不用so文件" class="headerlink" title="去除不用so文件"></a>去除不用so文件</h1><p>在使用一些三方库的时候，会集成大量的so文件到项目中，这些so文件都对应着不同的CPU架构。</p>
<p>Android系统目前支持以下七种不同的CPU架构：ARMv5、ARMv7、x86、MIPS、ARMv8、MIPS64、x86_64，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。</p>
<p>目前市面上绝大部分的CPU架构都是 ARMv7/ARMv8，所以可以在gradle中加入配置，只保留v7,v8。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    ndk &#123;</span><br><span class="line">    	abiFilters <span class="string">&#x27;armeabi-v7a&#x27;</span>, <span class="string">&#x27;arm64-v8a&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至只保留 armeabi-v7a ，微信大佬就这么干的！</p>
<h1 id="资源动态加载"><a href="#资源动态加载" class="headerlink" title="资源动态加载"></a>资源动态加载</h1><p>也可以将一些不必要资源放入网络中，等需要时再下载，比如：</p>
<ul>
<li><p>emoji表情</p>
</li>
<li><p>换肤</p>
</li>
<li><p>动态添加插件化模块(插件化框架)</p>
</li>
</ul>
<h1 id="移除无用资源"><a href="#移除无用资源" class="headerlink" title="移除无用资源"></a>移除无用资源</h1><p>可以使用Lint工具检测无用的资源，然后移除掉。</p>
<ol>
<li>点击菜单“Analyze”</li>
<li>选择 “run inspaction by Name …”</li>
<li>在弹出的搜索窗口中输入想执行的检查类型，如“Unused<br> Resources”。</li>
<li>选择检查的范围，一般选择整个项目或模块。</li>
<li>选择好后点ok就开始检查了。然后就可以根据检查结果来去除重复的<br> 资源。</li>
</ol>
<p>如果觉得一个个删除太麻烦，可以开启代码混淆，在打包时排除不需要的资源。</p>
<h1 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h1><p>这个不用多说，大家都知道。</p>
<ol>
<li>可以删除注释和不用的代码。</li>
<li>将java文件名改成短名a.java，b.java</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        buildConfigField <span class="string">&quot;boolean&quot;</span>, <span class="string">&quot;LOG_DEBUG&quot;</span>,<span class="string">&quot;false&quot;</span> <span class="comment">//不显示log</span></span><br><span class="line">        minifyEnabled <span class="literal">true</span> <span class="comment">//开启混淆</span></span><br><span class="line">        shrinkResources <span class="literal">true</span> <span class="comment">//移除无用资源</span></span><br><span class="line">        zipAlignEnabled <span class="literal">true</span> <span class="comment">//Zipalign优化</span></span><br><span class="line">        proguardFiles</span><br><span class="line">        getDefaultProguardFile(<span class="string">&#x27;proguard-android.txt&#x27;</span>),<span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        signingConfig signingConfigs.config</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化-布局与绘制优化</title>
    <url>/2019/08/26/android_layout_draw_performace/</url>
    <content><![CDATA[<p>android开发中，布局的使用和View的绘制是使用频次较高的场景，布局和绘制性能的好坏，对页面的渲染呈现效率有直接影响。</p>
<span id="more"></span>

<h1 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h1><h2 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h2><p>布局影响<code>Android</code>性能的实质：<strong>页面的测量 &amp; 绘制时间</strong></p>
<blockquote>
<p>1个页面通过递归 完成测量 &amp; 绘制过程 = <code>measure</code>、<code>layout</code> 过程</p>
</blockquote>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><ul>
<li>优化方向：布局性能、布局层级、布局复用性 和 测量 &amp; 绘制时间</li>
</ul>
<p>具体如下：</p>
<p><img src="/images/android_layout_draw_performance01.png" alt="image"></p>
<p>针对 <strong>页面布局的性能、层级、测量绘制时间</strong> 进行优化，从而提高 <code>Android</code>应用中的页面显示速度</p>
<h2 id="具体优化方案"><a href="#具体优化方案" class="headerlink" title="具体优化方案"></a>具体优化方案</h2><p><img src="/images/android_layout_draw_performance02.png" alt="image"></p>
<h3 id="选择耗费性能较少的布局"><a href="#选择耗费性能较少的布局" class="headerlink" title="选择耗费性能较少的布局"></a>选择耗费性能较少的布局</h3><ul>
<li>性能耗费低的布局 = 功能简单 = <code>FrameLayout</code>、<code>LinearLayout</code></li>
<li>性能耗费高的布局 = 功能复杂 = <code>RelativeLayout</code></li>
</ul>
<blockquote>
<p>即 布局过程需消耗更多性能（<code>CPU</code>资源 &amp; 时间）</p>
</blockquote>
<blockquote>
<p>注：<br>嵌套所耗费的性能 &gt; 单个布局本身耗费的性能<br>即 完成需求时：宁选择 1个耗费性能高的布局，也不采用嵌套多个耗费性能低的布局</p>
</blockquote>
<h3 id="减少布局的层级（嵌套）"><a href="#减少布局的层级（嵌套）" class="headerlink" title="减少布局的层级（嵌套）"></a>减少布局的层级（嵌套）</h3><ul>
<li>原理：布局层级少 -&gt;&gt; 绘制的工作量少 -&gt;&gt; 绘制速度快 -&gt;&gt; 性能提高</li>
<li>优化方式：使用布局标签<code>&lt;merge&gt;</code> &amp; 合适选择布局类型</li>
</ul>
<h4 id="使用布局标签"><a href="#使用布局标签" class="headerlink" title="使用布局标签"></a>使用布局标签</h4><ul>
<li>作用<br>减少 布局层级</li>
</ul>
<blockquote>
<p>配合<code>&lt;include&gt;</code>标签使用，可优化 加载布局文件时的资源消耗</p>
</blockquote>
<ul>
<li>具体使用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 使用说明：</span><br><span class="line">// 1. <span class="tag">&lt;<span class="name">merge</span>&gt;</span>作为被引用布局A的根标签</span><br><span class="line">// 2. 当其他布局通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引用布局A时，布局A中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）会被去掉，在<span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是布局A中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）的子标签（即子节点），以此减少布局文件的层次</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 实例说明：在上述例子，在布局B中 通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引用布局C</span><br><span class="line"> * 此时：布局层级为 =  RelativeLayout -&gt;&gt; Button </span><br><span class="line"> *                                  —&gt;&gt; RelativeLayout -&gt;&gt; Button</span><br><span class="line"> *                                                     -&gt;&gt; TextView</span><br><span class="line"> * 现在使用<span class="tag">&lt;<span class="name">merge</span>&gt;</span>优化：将 被引用布局C根标签 的RelativeLayout 改为 <span class="tag">&lt;<span class="name">merge</span>&gt;</span></span><br><span class="line"> * 在引用布局C时，布局C中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）会被去掉，在<span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是布局C中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）的子标签（即子节点）</span><br><span class="line"> * 即 <span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是：<span class="tag">&lt;<span class="name">Button</span>&gt;</span>、<span class="tag">&lt;<span class="name">TextView</span>&gt;</span></span><br><span class="line"> * 此时布局层级为 =  RelativeLayout -&gt;&gt; Button </span><br><span class="line"> *                                -&gt;&gt; Button</span><br><span class="line"> *                                -&gt;&gt; TextView</span><br><span class="line"> * 即 已去掉之前无意义、多余的<span class="tag">&lt;<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"> */  </span><br><span class="line"></span><br><span class="line"> // 被引用的公共部分：布局C = layout_c.xml</span><br><span class="line"> <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  // 布局B：layout_b.xml</span><br><span class="line">  <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/layout_c.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="合适选择布局类型"><a href="#合适选择布局类型" class="headerlink" title="合适选择布局类型"></a>合适选择布局类型</h4><ul>
<li>通过合理选择布局类型，从而减少嵌套</li>
<li>即：完成 复杂的<code>UI</code>效果时，<strong>尽可能选择1个功能复杂的布局（如<code>RelativeLayout</code>）完成，而不要选择多个功能简单的布局（如<code>LinerLayout</code>）通过嵌套完成</strong></li>
</ul>
<h3 id="提高布局的复用性"><a href="#提高布局的复用性" class="headerlink" title="提高布局的复用性"></a>提高布局的复用性</h3><ul>
<li>优化原理：提取布局间的公共部分，通过提高布局的复用性从而减少测量 &amp; 绘制时间</li>
<li>优化方案：使用 布局标签 <code>&lt;include&gt;</code>，其作用是实现 <strong>布局模块化</strong>，即 提取布局中的公共部分 供其他布局共用。</li>
<li>使用说明：通过标签引入抽取的公共部分布局C；标签所需属性 = 公共部分的layout属性，作用 = 指定需引入、包含的布局文件</li>
<li>具体使用<br>抽取布局A、B中的公共部分布局C &amp; 放入到布局B中使用.</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 布局B：layout_b.xml</span><br><span class="line"> */  </span><br><span class="line">  <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">      // 通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引入抽取的公共部分布局C</span><br><span class="line">      // <span class="tag">&lt;<span class="name">include</span>&gt;</span>标签所需属性 = 公共部分的layout属性，作用 = 指定需引入、包含的布局文件</span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/layout_c.xml&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 公共部分的布局C：layout_c.xml</span><br><span class="line"> */</span><br><span class="line">   <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="减少初次测量-amp-绘制时间"><a href="#减少初次测量-amp-绘制时间" class="headerlink" title="减少初次测量&amp;绘制时间"></a>减少初次测量&amp;绘制时间</h3><p>主要优化方案：使用 布局标签<code>&lt;ViewStub&gt;</code> &amp; 尽可能少用布局属性 <code>wrap_content</code></p>
<h4 id="使用布局标签-1"><a href="#使用布局标签-1" class="headerlink" title="使用布局标签"></a>使用布局标签</h4><ul>
<li>作用：<strong>按需加载</strong> 外部引入的布局，属 轻量级<code>View</code>、不占用显示 &amp; 位置</li>
<li>应用场景：引入 只在特殊情况下才显示的布局（即 默认不显示），如：进度显示布局、信息出错出现的提示布局等</li>
<li>使用说明<ol>
<li>先设置好预显示的布局</li>
<li>在其他布局通过标签引入外部布局（类似）；注：此时该布局还未被加载显示</li>
<li>只有当ViewStub被设置为可见 / 调用了ViewStub.inflate()时，ViewStub所指向的布局文件才会被inflate 、实例化，最终 显示指向的布局</li>
</ol>
</li>
<li>具体使用：在布局A中引入布局B，只有在特定时刻C中才显示</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 步骤1：先设置好预显示的布局B = layout_b.xml</span><br><span class="line"> <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 步骤2：在布局A通过<span class="tag">&lt;<span class="name">ViewStub</span>&gt;</span>标签引入布局B（类似<span class="tag">&lt;<span class="name">include</span>&gt;</span>）；注：此时该布局还未被加载显示</span><br><span class="line">// 布局A：layout_a.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/Blayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span>=<span class="string">&quot;@layout/layout_b&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 步骤3：只有当ViewStub被设置为可见 / 调用了ViewStub.inflate()时，ViewStub所指向的布局文件才会被inflate 、实例化，最终 显示<span class="tag">&lt;<span class="name">ViewStub</span>&gt;</span>指向的布局</span><br><span class="line">ViewStub stub = (ViewStub) findViewById(R.id.Blayout);   </span><br><span class="line">stub.inflate();</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是：</p>
<ol>
<li>ViewStub中的layout布局不能使用merge标签，否则会报错</li>
<li>ViewStub的inflate只能执行一次，显示了之后，就不能再使用ViewStub控制它了</li>
<li>与View.setVisible(View.Gone)的区别：View 的可见性设置为 gone 后，在inflate 时，该View 及其子View依然会被解析；而使用ViewStub就能避免解析其中指定的布局文件，从而节省布局文件的解析时间 &amp; 内存的占用</li>
</ol>
<h4 id="尽可能的减少用布局属性wrap-content"><a href="#尽可能的减少用布局属性wrap-content" class="headerlink" title="尽可能的减少用布局属性wrap_content"></a>尽可能的减少用布局属性wrap_content</h4><p>布局属性<code>wrap_content</code> 会增加布局测量时计算成本，应尽可能少用；特别是在已知宽高为固定值时，不使用<code>wrap_content</code>。</p>
<h1 id="绘制优化"><a href="#绘制优化" class="headerlink" title="绘制优化"></a>绘制优化</h1><h2 id="对性能的影响-1"><a href="#对性能的影响-1" class="headerlink" title="对性能的影响"></a>对性能的影响</h2><p>绘制性能的好坏 主要影响 ：<code>Android</code>应用中的<strong>页面显示速度</strong></p>
<p>绘制影响<code>Android</code>性能的实质：<strong>页面的绘制时间</strong></p>
<blockquote>
<p>1个页面通过递归 完成测量 &amp; 绘制过程</p>
</blockquote>
<h2 id="优化思路-1"><a href="#优化思路-1" class="headerlink" title="优化思路"></a>优化思路</h2><p>主要优化方向是：</p>
<ol>
<li>降低<code>View.onDraw（）</code>的复杂度</li>
<li>避免过度绘制<code>（Overdraw）</code></li>
</ol>
<h2 id="具体优化方案-1"><a href="#具体优化方案-1" class="headerlink" title="具体优化方案"></a>具体优化方案</h2><p><img src="/images/android_layout_draw_performance03.png" alt="image"></p>
<h3 id="降低View-onDraw（）的复杂度"><a href="#降低View-onDraw（）的复杂度" class="headerlink" title="降低View.onDraw（）的复杂度"></a>降低View.onDraw（）的复杂度</h3><h4 id="onDraw（）中不要创建新的局部对象"><a href="#onDraw（）中不要创建新的局部对象" class="headerlink" title="onDraw（）中不要创建新的局部对象"></a>onDraw（）中不要创建新的局部对象</h4><p><img src="/images/android_layout_draw_performance04.png" alt="image"></p>
<h4 id="避免onDraw（）执行大量-amp-耗时操作"><a href="#避免onDraw（）执行大量-amp-耗时操作" class="headerlink" title="避免onDraw（）执行大量 &amp; 耗时操作"></a>避免onDraw（）执行大量 &amp; 耗时操作</h4><p><img src="/images/android_layout_draw_performance05.png" alt="image"></p>
<h3 id="避免过度绘制"><a href="#避免过度绘制" class="headerlink" title="避免过度绘制"></a>避免过度绘制</h3><h4 id="过度绘制的简介"><a href="#过度绘制的简介" class="headerlink" title="过度绘制的简介"></a>过度绘制的简介</h4><p><img src="/images/android_layout_draw_performance06.png" alt="image"></p>
<h4 id="过度绘制的表现形式"><a href="#过度绘制的表现形式" class="headerlink" title="过度绘制的表现形式"></a>过度绘制的表现形式</h4><p>过度绘制 会导致屏幕显示的色块不同，具体如下</p>
<p><img src="/images/android_layout_draw_performance07.png" alt="image"></p>
<p>示例说明</p>
<p><img src="/images/android_layout_draw_performance08.png" alt="image"></p>
<h4 id="过度绘制的优化原则"><a href="#过度绘制的优化原则" class="headerlink" title="过度绘制的优化原则"></a>过度绘制的优化原则</h4><p>很多 过度绘制是难以避免的，如 上述实例的 文字 &amp; 背景导致的过度绘制；只能尽可能避免过度绘制：</p>
<ol>
<li>尽可能地控制 过度绘制的次数 = <code>2</code> 次（绿色）以下，蓝色最理想</li>
<li>尽可能避免 过度绘制的粉色 &amp; 红色情况</li>
<li>不允许 3 次以上的过度绘制（淡红色）面积 超过 屏幕大小的 1/4</li>
</ol>
<h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><ol>
<li>移除默认的 <code>Window</code> 背景</li>
<li>移除 控件中不必要的背景</li>
<li>减少布局文件的层级（嵌套）</li>
<li>自定义控件View优化：使用 clipRect() 、 quickReject()</li>
</ol>
<h5 id="方案1：移除默认的-Window-背景"><a href="#方案1：移除默认的-Window-背景" class="headerlink" title="方案1：移除默认的 Window 背景"></a>方案1：移除默认的 Window 背景</h5><ul>
<li>背景<br>一般应用程序 默认 继承的主题 = <code>windowBackground</code> ，如默认的 Light 主题：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.Light&quot;</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;isLightTheme&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;windowBackground&quot;</span>&gt;</span>@drawable/screen_background_selector_light<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    ...</span></span><br><span class="line"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>问题<br>一般情况下，该默认的 Window 背景基本用不上：因背景都自定义设置<br>若不移除，则导致所有界面都多 1 次绘制</li>
<li>解决方案<br>移除默认的 Window 背景</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 方式1：在应用的主题中添加如下的一行属性</span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@android:color/transparent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowBackground&quot;</span>&gt;</span>@null<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 方式2：在 BaseActivity 的 onCreate() 方法中使用下面的代码移除</span><br><span class="line">	getWindow().setBackgroundDrawable(null);</span><br><span class="line">	<span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line">	getWindow().setBackgroundDrawableResource(android.R.color.transparent);</span><br></pre></td></tr></table></figure>

<h5 id="方案2：移除-控件中不必要的背景"><a href="#方案2：移除-控件中不必要的背景" class="headerlink" title="方案2：移除 控件中不必要的背景"></a>方案2：移除 控件中不必要的背景</h5><p>如2个常见场景：</p>
<ul>
<li>场景1：<code>ListView</code> 与 <code>Item</code><br>列表页<code>（ListView）</code> 与 其内子控件<code>（Item）</code>的背景相同 = 白色，故可移除子控件<code>（Item）</code>布局中的背景</li>
</ul>
<p><img src="/images/android_layout_draw_performance09.png" alt="image"></p>
<ul>
<li>场景2：<code>ViewPager</code> 与 <code>Fragment</code><br>对于1个<code>ViewPager</code> + 多个 <code>Fragment</code> 组成的首页界面，若每个<br><code>Fragment</code> 都设有背景色，即 ViewPager 则无必要设置，可移除</li>
</ul>
<p><img src="/images/android_layout_draw_performance10.png" alt="image"></p>
<p>关于更多场景，可使用工具 <code>Hierarchy View</code> 查看.</p>
<h5 id="方案3：减少布局文件的层级（减少不必要的嵌套）"><a href="#方案3：减少布局文件的层级（减少不必要的嵌套）" class="headerlink" title="方案3：减少布局文件的层级（减少不必要的嵌套）"></a>方案3：减少布局文件的层级（减少不必要的嵌套）</h5><ul>
<li>原理：减少不必要的嵌套 -&gt;&gt; UI层级少 -&gt;&gt; 过度绘制的可能性低</li>
<li>优化方式：使用布局标签<code>&lt;merge&gt;</code> &amp; 合适选择布局类型</li>
</ul>
<h5 id="方案4：自定义控件View优化：使用-clipRect-、-quickReject"><a href="#方案4：自定义控件View优化：使用-clipRect-、-quickReject" class="headerlink" title="方案4：自定义控件View优化：使用 clipRect() 、 quickReject()"></a>方案4：自定义控件View优化：使用 clipRect() 、 quickReject()</h5><ul>
<li><p>```<br>clipRect()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  1. 作用：给 Canvas 设置一个裁剪区域，只有在该区域内才会被绘制，区域之外的都不绘制</span><br><span class="line">  2. 实例说明：`DrawerLayout` 布局 = 左抽屉布局</span><br><span class="line"></span><br><span class="line">![image](/images/android_layout_draw_performance11.png)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Override</span><br><span class="line">protected boolean drawChild(Canvas canvas, View child, long drawingTim</span><br><span class="line">    // ...仅贴出关键代码</span><br><span class="line"></span><br><span class="line">        // 1. 遍历 DrawerLayout 的 child view，拿到抽屉布局</span><br><span class="line">        for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">            final View v = getChildAt(i);</span><br><span class="line">            if (v == child || v.getVisibility() != VISIBLE</span><br><span class="line">                    || !hasOpaqueBackground(v) || !isDrawerView(v)</span><br><span class="line">                    || v.getHeight() &lt; height) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // a. 若是左抽屉布局</span><br><span class="line">            // 则取抽屉布局的右边界作为裁剪区的左边界、设置原主布局的裁剪区域，如上图裁剪区域</span><br><span class="line">            if (checkDrawerViewAbsoluteGravity(v, Gravity.LEFT)) &#123;</span><br><span class="line">                final int vright = v.getRight();</span><br><span class="line">                if (vright &gt; clipLeft) clipLeft = vright;</span><br><span class="line">            // b. 若是右抽屉布局</span><br><span class="line">            // 则取抽屉布局的左边界作为裁剪区的右边界、设置原主布局的裁剪区域</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                final int vleft = v.getLeft();</span><br><span class="line">                if (vleft &lt; clipRight) clipRight = vleft;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 通过clipRect（）设置原主布局的显示范围 = 裁剪区域，使其仅在上图中的红框区域（即不阻碍抽屉布局的区域）显示</span><br><span class="line">       // 从而避免过度绘制</span><br><span class="line">        canvas.clipRect(clipLeft, 0, clipRight, getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    ......                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><pre><code>quickreject()
</code></pre>
<ol>
<li>作用：判断和某个矩形相交</li>
<li>具体措施：若判断与矩形相交，则可跳过相交的区域，从而减少过度绘制</li>
</ol>
</li>
</ul>
<h3 id="其他优化方案"><a href="#其他优化方案" class="headerlink" title="其他优化方案"></a>其他优化方案</h3><p><img src="/images/android_layout_draw_performance12.png" alt="image"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/android_layout_draw_performance13.png" alt="image"></p>
<h1 id="布局调优工具"><a href="#布局调优工具" class="headerlink" title="布局调优工具"></a>布局调优工具</h1><ul>
<li>背景<br>尽管已经注意到上述的优化策略，但实际开发中难免还是会出现布局性能的问题</li>
<li>解决方案<br>使用 布局调优工具</li>
</ul>
<blockquote>
<p>此处主要介绍 常用的：<code>hierarchy viewer</code>、<code>Profile GPU Rendering</code>、<code>Systrace</code></p>
</blockquote>
<h2 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h2><ul>
<li>简介<br><code>Android Studio</code> 提供的UI性能检测工具。</li>
<li>作用<br>可视化获得UI布局设计结构 &amp; 各种属性信息，帮助我们优化布局设计</li>
</ul>
<blockquote>
<p>即 ：方便查看<code>Activity</code>布局，各个<code>View</code>的属性、布局测量-布局-绘制的时间</p>
</blockquote>
<ul>
<li>具体使用<br><a href="http://developer.android.com/tools/debugging/debugging-ui.html">Hierarchy Viewer 使用指南</a></li>
</ul>
<h2 id="Profile-GPU-Rendering"><a href="#Profile-GPU-Rendering" class="headerlink" title="Profile GPU Rendering"></a>Profile <a href="https://so.csdn.net/so/search?q=GPU&spm=1001.2101.3001.7020">GPU</a> Rendering</h2><ul>
<li>简介<br>一个 图形监测工具</li>
<li>作用<br>渲染、绘制性能追踪</li>
</ul>
<blockquote>
<p>能实时反应当前绘制的耗时</p>
</blockquote>
<ul>
<li>具体使用<br>横轴 = 时间、纵轴 = 每帧的耗时；随着时间推移，从左到右的刷新呈现</li>
</ul>
<blockquote>
<p>提供一个标准的耗时，如果高于标准耗时，就表示当前这一帧丢失</p>
</blockquote>
<p><img src="/images/android_layout_draw_performance14.png" alt="image"></p>
<h2 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h2><ul>
<li>简介<br><code>Android 4.1</code>以上版本提供的性能数据采样 &amp; 分析工具</li>
<li>作用<br>检测 <code>Android</code>系统各个组件随着时间的运行状态 &amp; 提供解决方案</li>
</ul>
<blockquote>
<ol>
<li>收集 等运行信息，从而帮助开发者更直观地分析系统瓶颈，改进性能<br>检测范围包括：<code>Android</code> 关键子系统（如<code>WindowManagerService</code> 等 <code>Framework</code> 部分关键模块）、服务、View系统</li>
<li>功能包括：跟踪系统的<code>I/O</code> 操作、内核工作队列、<code>CPU</code> 负载等，在 UI 显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡等问题上</li>
</ol>
</blockquote>
<ul>
<li>具体使用<br><a href="http://gityuan.com/2016/01/17/systrace/">Systrace 使用指南</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
        <tag>绘制优化</tag>
        <tag>布局优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 热修复方案和原理</title>
    <url>/2019/11/24/android_hot_fix/</url>
    <content><![CDATA[<p>热修复是指，在应用上线后出现 bug 需要及时修复时，不用再发新的安装包，只需要发布补丁包，在客户无感知下修复掉 bug。补丁包需要由开发者生成，由服务器管理并下发补丁包到用户的设备上执行热修复。</p>
<span id="more"></span>

<h1 id="热修复方案"><a href="#热修复方案" class="headerlink" title="热修复方案"></a>热修复方案</h1><p>热修复解决方案对比：</p>
<p><img src="/images/android_hot_fix01.png" alt="热修复对比"></p>
<p>框架都会用到反射 + 类加载技术，只不过使用方式不同呈现的效果也不同。通过类替换实现的热修复方案都不是即时生效的，需要重启应用后才能生效，而非类替换的方案可以做到即时生效，但实现方式有所不同，下面简单看看各方案的实现原理。</p>
<h2 id="AndFix"><a href="#AndFix" class="headerlink" title="AndFix"></a>AndFix</h2><p>AndFix 会在 native 层动态替换 Java 层的方法属性，通过 native 层 hook Java 层的代码。</p>
<p>首先，在补丁包的源文件中要对需要修改的方法打上 @MethodReplace 注解，注明要替换的类名和方法名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodReplace &#123;</span><br><span class="line">	<span class="function">String <span class="title">clazz</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法写好后编译生成 class 再打包成 dex 文件。然后 AndFix 会在 Java 层通过 DexFile 加载这个补丁包中的 dex 文件，遍历其中的 Class：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment"> *            patch file</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment"> *            classloader of class that will be fixed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classes</span></span><br><span class="line"><span class="comment"> *            classes will be fixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fix</span><span class="params">(File file, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="params"><span class="function">		List&lt;String&gt; classes)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		File optfile = <span class="keyword">new</span> File(mOptDir, file.getName());</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加载补丁包 dex 文件</span></span><br><span class="line">		<span class="keyword">final</span> DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),</span><br><span class="line">				optfile.getAbsolutePath(), Context.MODE_PRIVATE);</span><br><span class="line"></span><br><span class="line">		ClassLoader patchClassLoader = <span class="keyword">new</span> ClassLoader(classLoader) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">protected</span> Class&lt;?&gt; findClass(String className)</span><br><span class="line">					<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">				Class&lt;?&gt; clazz = dexFile.loadClass(className, <span class="keyword">this</span>);</span><br><span class="line">				<span class="keyword">if</span> (clazz == <span class="keyword">null</span></span><br><span class="line">						&amp;&amp; className.startsWith(<span class="string">&quot;com.alipay.euler.andfix&quot;</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> Class.forName(className);<span class="comment">// annotation’s class</span></span><br><span class="line">													<span class="comment">// not found</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(className);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> clazz;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 获取 dex 文件中的所有 Class 对象 </span></span><br><span class="line">		Enumeration&lt;String&gt; entrys = dexFile.entries();</span><br><span class="line">		Class&lt;?&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 遍历 dex 中的所有 Class</span></span><br><span class="line">		<span class="keyword">while</span> (entrys.hasMoreElements()) &#123;</span><br><span class="line">			String entry = entrys.nextElement();</span><br><span class="line">			<span class="keyword">if</span> (classes != <span class="keyword">null</span> &amp;&amp; !classes.contains(entry)) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;<span class="comment">// skip, not need fix</span></span><br><span class="line">			&#125;</span><br><span class="line">			clazz = dexFile.loadClass(entry, patchClassLoader);</span><br><span class="line">			<span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 开始执行类内方法的修复</span></span><br><span class="line">				fixClass(clazz, classLoader);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		Log.e(TAG, <span class="string">&quot;pacth&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历类里面声明的所有方法，筛选出被 @MethodReplace 注解标记的方法，从中获得要替换的类名+方法名，以便进行替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixClass</span><span class="params">(Class&lt;?&gt; clazz, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 clazz 内声明的所有方法</span></span><br><span class="line">    Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">    MethodReplace methodReplace;</span><br><span class="line">    String clz;</span><br><span class="line">    String meth;</span><br><span class="line">    <span class="comment">// 遍历 methods，筛选出被 @MethodReplace 注解标记的方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        methodReplace = method.getAnnotation(MethodReplace.class);</span><br><span class="line">        <span class="keyword">if</span> (methodReplace == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 从 @MethodReplace 注解上获取类和方法名</span></span><br><span class="line">        clz = methodReplace.clazz();</span><br><span class="line">        meth = methodReplace.method();</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty(clz) &amp;&amp; !isEmpty(meth)) &#123;</span><br><span class="line">            <span class="comment">// 开始替换</span></span><br><span class="line">            replaceMethod(classLoader, clz, meth, method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>replaceMethod() 会对已经修复过的类做缓存处理，真正执行修复操作的是 addReplaceMethod()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存，&lt;类名@ClassLoader名，Class对象&gt;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Class&lt;?&gt;&gt; mFixedClass = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * replace method</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader classloader</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clz class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> meth name of target method </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method source method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceMethod</span><span class="params">(ClassLoader classLoader, String clz,</span></span></span><br><span class="line"><span class="params"><span class="function">		String meth, Method method)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 缓存的 key 是类名@ClassLoader名</span></span><br><span class="line">		String key = clz + <span class="string">&quot;@&quot;</span> + classLoader.toString();</span><br><span class="line">		<span class="comment">// 先去缓存中找 clazz</span></span><br><span class="line">		Class&lt;?&gt; clazz = mFixedClass.get(key);</span><br><span class="line">		<span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;<span class="comment">// class not load</span></span><br><span class="line">			Class&lt;?&gt; clzz = classLoader.loadClass(clz);</span><br><span class="line">			<span class="comment">// initialize target class</span></span><br><span class="line">			clazz = AndFix.initTargetClass(clzz);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 缓存没找到</span></span><br><span class="line">		<span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;<span class="comment">// initialize class OK</span></span><br><span class="line">			mFixedClass.put(key, clazz);</span><br><span class="line">			Method src = clazz.getDeclaredMethod(meth,</span><br><span class="line">					method.getParameterTypes());</span><br><span class="line">			<span class="comment">// 真正的执行替换</span></span><br><span class="line">			AndFix.addReplaceMethod(src, method);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		Log.e(TAG, <span class="string">&quot;replaceMethod&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 addReplaceMethod() 中会通过一个 native 方法执行方法体的替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * replace method&#x27;s body</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment">	 *            source method</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> dest</span></span><br><span class="line"><span class="comment">	 *            target method</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addReplaceMethod</span><span class="params">(Method src, Method dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        replaceMethod(src, dest);</span><br><span class="line">        initFields(dest.getDeclaringClass());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;addReplaceMethod&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">replaceMethod</span><span class="params">(Method dest, Method src)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ative 的 replaceMethod() 主要是对 ArtMethod 结构体的属性进行替换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replace_4_4</span><span class="params">(JNIEnv* env, jobject src, jobject dest)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 分别获取源方法和目标方法的 ArtMethod 结构体，进行对应属性替换</span></span><br><span class="line">	art::mirror::ArtMethod* smeth =</span><br><span class="line">			(art::mirror::ArtMethod*) env-&gt;<span class="built_in">FromReflectedMethod</span>(src);</span><br><span class="line"></span><br><span class="line">	art::mirror::ArtMethod* dmeth =</span><br><span class="line">			(art::mirror::ArtMethod*) env-&gt;<span class="built_in">FromReflectedMethod</span>(dest);</span><br><span class="line"></span><br><span class="line">	dmeth-&gt;declaring_class_-&gt;class_loader_ =</span><br><span class="line">			smeth-&gt;declaring_class_-&gt;class_loader_; <span class="comment">//for plugin classloader</span></span><br><span class="line">	dmeth-&gt;declaring_class_-&gt;clinit_thread_id_ =</span><br><span class="line">			smeth-&gt;declaring_class_-&gt;clinit_thread_id_;</span><br><span class="line">	dmeth-&gt;declaring_class_-&gt;status_ = smeth-&gt;declaring_class_-&gt;status_<span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//for reflection invoke</span></span><br><span class="line">	<span class="keyword">reinterpret_cast</span>&lt;art::mirror::Class*&gt;(dmeth-&gt;declaring_class_)-&gt;super_class_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	smeth-&gt;declaring_class_ = dmeth-&gt;declaring_class_;</span><br><span class="line">    smeth-&gt;dex_cache_initialized_static_storage_ = dmeth-&gt;dex_cache_initialized_static_storage_;</span><br><span class="line">    smeth-&gt;access_flags_ = dmeth-&gt;access_flags_  | <span class="number">0x0001</span>;</span><br><span class="line">    smeth-&gt;dex_cache_resolved_types_ = dmeth-&gt;dex_cache_resolved_types_;</span><br><span class="line">    smeth-&gt;dex_cache_resolved_methods_ = dmeth-&gt;dex_cache_resolved_methods_;</span><br><span class="line">    smeth-&gt;dex_cache_strings_ = dmeth-&gt;dex_cache_strings_;</span><br><span class="line">    smeth-&gt;code_item_offset_ = dmeth-&gt;code_item_offset_;</span><br><span class="line">    smeth-&gt;core_spill_mask_ = dmeth-&gt;core_spill_mask_;</span><br><span class="line">    smeth-&gt;fp_spill_mask_ = dmeth-&gt;fp_spill_mask_;</span><br><span class="line">    smeth-&gt;method_dex_index_ = dmeth-&gt;method_dex_index_;</span><br><span class="line">    smeth-&gt;mapping_table_ = dmeth-&gt;mapping_table_;</span><br><span class="line">    smeth-&gt;method_index_ = dmeth-&gt;method_index_;</span><br><span class="line">    smeth-&gt;gc_map_ = dmeth-&gt;gc_map_;</span><br><span class="line">    smeth-&gt;frame_size_in_bytes_ = dmeth-&gt;frame_size_in_bytes_;</span><br><span class="line">    smeth-&gt;native_method_ = dmeth-&gt;native_method_;</span><br><span class="line">    smeth-&gt;vmap_table_ = dmeth-&gt;vmap_table_;</span><br><span class="line"></span><br><span class="line">    smeth-&gt;entry_point_from_compiled_code_ = dmeth-&gt;entry_point_from_compiled_code_;</span><br><span class="line">    </span><br><span class="line">    smeth-&gt;entry_point_from_interpreter_ = dmeth-&gt;entry_point_from_interpreter_;</span><br><span class="line">    </span><br><span class="line">    smeth-&gt;method_index_ = dmeth-&gt;method_index_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从 AndFix 的源码中能看出，ART 虚拟机（从 4.4 开始）上的每一个系统版本都需要对 ArtMethod 结构体进行适配，在适配到 7.0 之后 AndFix 便停更了。</p>
<h2 id="Robust"><a href="#Robust" class="headerlink" title="Robust"></a>Robust</h2><p>Robust 也是会即时生效的热修复框架，但是它是在 Java 层实现的，并没有 native 的处理。</p>
<p>Robust 会在编译打包阶段对每个方法自动插入一段代码（字节码插桩），类似于代理，将方法执行的代码重定向到其它方法，这个插入过程对业务开发是完全透明的。</p>
<p>比如说 State.java 的 getIndex() 内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 Robust 处理后变成下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ChangeQuickRedirect changeQuickRedirect;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(changeQuickRedirect != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//PatchProxy中封装了获取当前className和methodName的逻辑，并在其内部最终调用了changeQuickRedirect的对应函数</span></span><br><span class="line">        <span class="keyword">if</span>(PatchProxy.isSupport(<span class="keyword">new</span> Object[<span class="number">0</span>], <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Long)PatchProxy.accessDispatch(<span class="keyword">new</span> Object[<span class="number">0</span>], <span class="keyword">this</span>, changeQuickRedirect, <span class="keyword">false</span>)).longValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Robust 为每个 class 增加了一个类型为 ChangeQuickRedirect 的静态成员，在每个方法前都插入了使用 changeQuickRedirect 相关的逻辑。当 changeQuickRedirect 不为 null 时，可能会执行到 accessDispatch 从而替换掉之前老的逻辑，达到 fix 的目的。</p>
<p>想要修改 getIndex() 的返回值，补丁包中需要包含如下两个源文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchesInfoImpl</span> <span class="keyword">implements</span> <span class="title">PatchesInfo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PatchedClassInfo&gt; <span class="title">getPatchedClassesInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;PatchedClassInfo&gt; patchedClassesInfos = <span class="keyword">new</span> ArrayList&lt;PatchedClassInfo&gt;();</span><br><span class="line">        <span class="comment">// 需要打补丁的类名，com.meituan.sample.d 是混淆后的类名</span></span><br><span class="line">        PatchedClassInfo patchedClass = <span class="keyword">new</span> PatchedClassInfo(<span class="string">&quot;com.meituan.sample.d&quot;</span>, StatePatch.class.getCanonicalName());</span><br><span class="line">        patchedClassesInfos.add(patchedClass);</span><br><span class="line">        <span class="keyword">return</span> patchedClassesInfos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatePatch</span> <span class="keyword">implements</span> <span class="title">ChangeQuickRedirect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">accessDispatch</span><span class="params">(String methodSignature, Object[] paramArrayOfObject)</span> </span>&#123;</span><br><span class="line">        String[] signature = methodSignature.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.equals(signature[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>)) &#123;<span class="comment">//long getIndex() -&gt; a</span></span><br><span class="line">        	<span class="comment">// 修改 getIndex() 的返回值为 106</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">106</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSupport</span><span class="params">(String methodSignature, Object[] paramArrayOfObject)</span> </span>&#123;</span><br><span class="line">        String[] signature = methodSignature.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.equals(signature[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>)) &#123;<span class="comment">//long getIndex() -&gt; a</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打补丁的主要过程为：</p>
<ol>
<li>ClassLoader 加载补丁的 dex 文件，拿到 PatchesInfoImpl.class 并创建一个对应的 Class 对象</li>
<li>反射调用 getPatchedClassesInfo()，拿到需要打补丁的类名，再反射拿到这个类的 Class 对象</li>
<li>反射上一步中 Class 对象的 changeQuickRedirect 字段，并赋值为补丁包 dex 文件中 StatePatch.class new 出来的对象。</li>
</ol>
<p>以上过程没有动系统的 ClassLoader，都是直接使用，兼容性得以保证。</p>
<p>更详细内容可以直接参考美团技术团队对 Robust 的介绍文章链接<a href="https://tech.meituan.com/2016/09/14/android-robust.html">Android热更新方案Robust</a>。</p>
<h2 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a>Tinker</h2><p>Tinker 的补丁包与前两者不同，它是一个差分包而不是完整的 dex 文件。这个差分包是计算了指定的 base apk（一般就是设备正在运行的 apk）的 dex 与修改后 apk 的 dex 的区别的描述，运行时将 base apk 的 dex 与差分包进行合成，重启后加载全新合成的 dex 文件：<br><img src="/images/android_hot_fix02.png" alt="img"></p>
<p>图片来源：<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286384&idx=1&sn=f1aff31d6a567674759be476bcd12549&scene=4#wechat_redirect">微信Tinker的一切都在这里，包括源码(一)</a></p>
<p>Tinker 实现热修复的原理，是将补丁包的 dex 文件存放到系统的 PathClassLoader 的 pathList 字段的 dexElements 数组的前面：</p>
<p><img src="/images/android_hot_fix03.png" alt="img"></p>
<p>由于 ClassLoader 加载 dexElements 数组中的类是按照由先到后的顺序，且加载过的类不会重复加载，所以补丁包的 Key.class 生效，原本 Classes2.dex 中的 Key.class 不会被加载，使得修复生效。参考 Tinker 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tinker/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/SystemClassLoaderAdder.java:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectDexesInternal</span><span class="params">(ClassLoader cl, List&lt;File&gt; dexFiles, File optimizeDir)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 针对不同系统需要做出兼容处理，我们看V23的</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        V23.install(cl, dexFiles, optimizeDir);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        V19.install(cl, dexFiles, optimizeDir);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        V14.install(cl, dexFiles, optimizeDir);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V4.install(cl, dexFiles, optimizeDir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V23</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="params"><span class="function">                                File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">    NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 找到 loader 中的 pathList 字段，并拿到 pathList 对象</span></span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(loader, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        <span class="comment">// expandFieldArray() 会将 makePathElements() 得到的 Element 数组放在 dexPathList 对象 dexElements 的前面</span></span><br><span class="line">        ShareReflectUtil.expandFieldArray(dexPathList, <span class="string">&quot;dexElements&quot;</span>, makePathElements(dexPathList,</span><br><span class="line">                                                                                       <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                                                                                       suppressedExceptions));</span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                ShareTinkerLog.w(TAG, <span class="string">&quot;Exception in makePathElement&quot;</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 反射调用 makePathElements() 或者 makeDexElements()，将补丁包中的 dex 文件转换成 Element 数组。</span></span><br><span class="line"><span class="comment">         * 系统源码在不同版本中使用的方法形式不同，版本由高到低的形式为 makePathElements(List,File,List)、</span></span><br><span class="line"><span class="comment">         * makeDexElements(ArrayList,File,ArrayList)、makeDexElements(List,File,List)。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makePathElements(</span><br><span class="line">        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        Method makePathElements;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">&quot;makePathElements&quot;</span>, List.class, File.class,</span><br><span class="line">                                                           List.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            ShareTinkerLog.e(TAG, <span class="string">&quot;NoSuchMethodException: makePathElements(List,File,List) failure&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                makePathElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">&quot;makePathElements&quot;</span>, ArrayList.class, File.class, ArrayList.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e1) &#123;</span><br><span class="line">                ShareTinkerLog.e(TAG, <span class="string">&quot;NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ShareTinkerLog.e(TAG, <span class="string">&quot;NoSuchMethodException: try use v19 instead&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> V19.makeDexElements(dexPathList, files, optimizedDirectory, suppressedExceptions);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e2) &#123;</span><br><span class="line">                    ShareTinkerLog.e(TAG, <span class="string">&quot;NoSuchMethodException: makeDexElements(List,File,List) failure&quot;</span>);</span><br><span class="line">                    <span class="keyword">throw</span> e2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Object[]) makePathElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="热修复的兼容问题"><a href="#热修复的兼容问题" class="headerlink" title="热修复的兼容问题"></a>热修复的兼容问题</h1><p>从上述热修复框架的介绍中不难发现，热修复对兼容性的要求是很高的，最明显的就是，如果反射了系统源码，就要跟随版本对系统源码的变化做兼容处理。除了源码的变化，系统机制的变化也会对热修复的兼容性产生影响。</p>
<h2 id="Android-N混合编译"><a href="#Android-N混合编译" class="headerlink" title="Android N混合编译"></a>Android N混合编译</h2><p>ART 虚拟机是在 Android KitKat（4.4） 被引入的，并从 Android L（5.0） 开始被设为默认运行环境。</p>
<p>Android N（7.0）之前，ART 在安装 apk 时会采用 AOT（Ahead of time：提前编译、静态编译）预编译为机器码。</p>
<p>而从 Android N 开始，使用混合编译模式，即安装 apk 时不编译，运行时解释字节码，同时在 JIT （Just-In-Time：即时编译）编译热点代码（即频繁执行的代码）并将这些代码信息记录至 Profile 文件，在设备空闲时使用 AOT（All-Of-the-Time compilation：全时段编译）编译生成名为 app_image 的 base.art（类对象映像）文件，该文件会在 apk 下次启动时自动加载（相当于缓存）。</p>
<p>根据 Android 的类加载机制，已经被加载过的类无法被替换，使得无法通过热修复修正这些类（启动 apk 时，在 ActivityThread 创建 PathClassLoader 时就会先加载 app_image 中的类，随后才执行热修复的代码，所以被编译进 app_image 的类无法被热修复）。</p>
<p>Tinker 的解决方案是自己创建一个 PathClassLoader 替换掉系统的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoaderAdder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installDexes</span><span class="params">(Application application, ClassLoader loader, File dexOptDir, List&lt;File&gt; files,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">boolean</span> isProtectedApp, <span class="keyword">boolean</span> useDLC)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">            files = createSortedAdditionalPathEntries(files);</span><br><span class="line">            ClassLoader classLoader = loader;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span> &amp;&amp; !isProtectedApp) &#123;</span><br><span class="line">            	<span class="comment">// 从 7.0 开始要用自己创建的 PathClassLoader 替换掉系统的</span></span><br><span class="line">                classLoader = NewClassLoaderInjector.inject(application, loader, dexOptDir, useDLC, files);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">// 7.0 以下</span></span><br><span class="line">                injectDexesInternal(classLoader, files, dexOptDir);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dalvik-虚拟机的-CLASS-ISPREVERIFIED-标记"><a href="#Dalvik-虚拟机的-CLASS-ISPREVERIFIED-标记" class="headerlink" title="Dalvik 虚拟机的 CLASS_ISPREVERIFIED 标记"></a>Dalvik 虚拟机的 CLASS_ISPREVERIFIED 标记</h2><p>我们仿照 Tinker 写一个热修复 Demo，在 4.4 系统上运行（4.4 默认用的还是 Dalvik 虚拟机）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、获取程序的PathClassLoader对象</span></span><br><span class="line"><span class="comment">     * 2、反射获得PathClassLoader父类BaseDexClassLoader的pathList对象</span></span><br><span class="line"><span class="comment">     * 3、反射获取pathList的dexElements对象 （oldElement）</span></span><br><span class="line"><span class="comment">     * 4、把补丁包变成Element数组：patchElement（反射执行makePathElements）</span></span><br><span class="line"><span class="comment">     * 5、合并patchElement+oldElement = newElement （Array.newInstance）</span></span><br><span class="line"><span class="comment">     * 6、反射把oldElement赋值成newElement</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> application</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installPatch</span><span class="params">(Application application, File patch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、获取程序的PathClassLoader对象</span></span><br><span class="line">    ClassLoader classLoader = application.getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoaderInjector.inject(application, classLoader, patchs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、反射获得PathClassLoader父类BaseDexClassLoader的pathList对象</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(classLoader, <span class="string">&quot;pathList&quot;</span>);</span><br><span class="line">        Object pathList = pathListField.get(classLoader);</span><br><span class="line">        <span class="comment">//3、反射获取pathList的dexElements对象 （oldElement）</span></span><br><span class="line">        Field dexElementsField = ShareReflectUtil.findField(pathList, <span class="string">&quot;dexElements&quot;</span>);</span><br><span class="line">        Object[] oldElements = (Object[]) dexElementsField.get(pathList);</span><br><span class="line">        <span class="comment">//4、把补丁包变成Element数组：patchElement（反射执行makePathElements）</span></span><br><span class="line">        Object[] patchElements = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            Method makePathElements = ShareReflectUtil.findMethod(pathList, <span class="string">&quot;makePathElements&quot;</span>,</span><br><span class="line">                                                                  List.class, File.class,</span><br><span class="line">                                                                  List.class);</span><br><span class="line">            ArrayList&lt;IOException&gt; ioExceptions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            patchElements = (Object[])</span><br><span class="line">                makePathElements.invoke(pathList, patchs, application.getCacheDir(), ioExceptions);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            Method makePathElements = ShareReflectUtil.findMethod(pathList, <span class="string">&quot;makeDexElements&quot;</span>,</span><br><span class="line">                                                                  ArrayList.class, File.class, ArrayList.class);</span><br><span class="line">            ArrayList&lt;IOException&gt; ioExceptions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            patchElements = (Object[])</span><br><span class="line">                makePathElements.invoke(pathList, patchs, application.getCacheDir(), ioExceptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、合并patchElement+oldElement = newElement （Array.newInstance）</span></span><br><span class="line">        <span class="comment">//创建一个新数组，大小 oldElements+patchElements</span></span><br><span class="line">        Object[] newElements = (Object[]) Array.newInstance(oldElements.getClass().getComponentType(),</span><br><span class="line">                                                            oldElements.length + patchElements.length);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(patchElements, <span class="number">0</span>, newElements, <span class="number">0</span>, patchElements.length);</span><br><span class="line">        System.arraycopy(oldElements, <span class="number">0</span>, newElements, patchElements.length, oldElements.length);</span><br><span class="line">        <span class="comment">//6、反射把oldElement赋值成newElement</span></span><br><span class="line">        dexElementsField.set(pathList, newElements);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现抛出如下错误：</p>
<p><img src="/images/android_hot_fix04.png" alt="img"></p>
<p>这是因为，被标记了 CLASS_ISPREVERIFIED 的类，引用了不在同一个 dex 文件中的类。如果一个类只引用了（正向调用，反射不算，因为反射不需要一个类的引用就用获取到该类对象）同一个 dex 文件中的类，那么在打包 dex 文件时，这个类就会被打上 CLASS_ISPREVERIFIED 标记（这个机制属于 Dalvik 虚拟机的一个优化)：<br><img src="/images/android_hot_fix05.png" alt="img"></p>
<p>比如说 MainActivity 只引用了 Utils，且二者在同一个 dex 文件中，那么 MainActivity.class 就会被打上 CLASS_ISPREVERIFIED 标记。</p>
<p>在热修复时，会用 patch.dex 中的 Utils.class 去替换 classes.dex 中的 Utils.class，导致 MainActivity 引用了不同 dex 文件中的类，就会抛出 IllegalAccessError。</p>
<p>如何规避掉这个错误呢？那就尝试让 MainActivity 引用不同 dex 文件中的类，这样它就打不上 CLASS_ISPREVERIFIED 标记，再引用其它 dex 中的类也就不会出错了。具体做法是：</p>
<ol>
<li>在补丁包中创建一个专门被引用的空类 AntiLazyLoad</li>
<li>通过字节码插桩的方式在 MainActivity.class 的构造方法中添加引用 AntiLazyLoad 的代码</li>
<li>将 AntiLazyLoad 这个类添加到负责加载 classes.dex 的那个 ClassLoader 中</li>
</ol>
<p>上述过程可以通过打补丁包的方式实现，做法是：</p>
<p><img src="/images/android_hot_fix06.png" alt="img"></p>
<h1 id="自定义-Gradle-插件打补丁包"><a href="#自定义-Gradle-插件打补丁包" class="headerlink" title="自定义 Gradle 插件打补丁包"></a>自定义 Gradle 插件打补丁包</h1><p>我们写一个通过 Gradle 插件 + ASM 字节码插桩的自动化补丁 Demo 来解决上面的问题。</p>
<p>实现自动化补丁需要有两个前置知识：</p>
<ol>
<li>熟悉 Android Gradle Plugin（AGP）的基础知识（可参考<a href="https://juejin.cn/post/7092367604211253256">为什么说 Gradle 是 Android 进阶绕不去的坎</a>）</li>
<li>知道如何通过 ASM 实现字节码插桩（可参考<a href="https://blog.csdn.net/tmacfrank/article/details/124964043">ASM 字节码插桩入门</a>）</li>
</ol>
<p>此外，由于 AGP 的向后兼容性很弱，所以这里先声明 Demo 中使用的 Gradle 版本是 4.10.1，AGP 版本是 3.3.1（版本确实老了点），如果你所使用的版本高于上述版本，可能部分 API 不兼容（比如说你的 AS 升级到了 AS BumbleBee，其支持最低的 Gradle 版本为 6.1.1，那么本文章中的示例代码就无法运行），但是处理问题的思路应该是大致相同的。关于 Gradle 与 AGP 的版本对照表，可以参考下图：<br><img src="/images/android_hot_fix07.png" alt="img"></p>
<p>此外，下面做 Demo 演示时只会编译 debug 版本，所以涉及到的任务名都是以 debug 为准，比如编译 Java 源文件为 class 文件的任务名，在编译 debug 时为 compileDebugJavaWithJavac，而编译 Release 版本时就为 compileReleaseJavaWithJavac，如果还配置了其它变体，如 Xxx，那么编译该变体的任务就是 compileXxxJavaWithJavac。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>我们的目的是自定义一个 Gradle 任务，自动为两次编译之间发生了变化的 class 文件进行字节码插桩，再通过 dx/d8 命令将 class 文件打包成 dex 文件后放入补丁包。</p>
<p><img src="/images/android_hot_fix08.png" alt="img"></p>
<p>如上图所示，在由 Java 源文件生成 dex 文件的过程中，其实是经过了几个 Gradle 任务处理的：</p>
<ol>
<li>compileDebugJavaWithJavac 将 Java 源文件编译成 class 文件</li>
<li>transformClassesAndResourcesWithProguardForDebug 对 class 文件进行混淆</li>
<li>transformClassesWithDexBuilderForDebug 将混淆后的 class 文件打包进 dex 文件</li>
</ol>
<p>每个任务都有输入和输出，以及 doFirst 和 doLast 两个监听：</p>
<p><img src="/images/android_hot_fix09.png" alt="img"></p>
<p>比如混淆任务 transformClassesAndResourcesWithProguardForDebug 的输入，是所有模块的 compileDebugJavaWithJavac 任务输出的 class 文件，输出就是混淆后的 class，这些 class 就是 transformClassesWithDexBuilderForDebug 任务的输入。</p>
<p>而 doFirst/doLast 可以理解为任务的入口/出口监听，会分别在刚进入任务还没开始执行任务功能、已经执行完任务功能即将结束任务时回调。在 Demo 中常用 doFirst 来获取上一个任务的输出文件，用 doLast 获取当前任务的输出文件，后面结合具体思路以及代码能看的更清楚些。</p>
<p>此外必须要明确的是，对于热修复而言，我们只需要在补丁包中加入相比于正式版本进行过修改的 class 文件，而不是本次编译生成的所有 class 文件，所以我们在每次编译时都应该用一个文件保存 class 文件的 md5 值，如果本次编译与正式版本的 md5 不同，那么该 class 文件才需要放进补丁包。</p>
<p>还有，如果编译开启了混淆，为了保证每次编译时，同一个文件被混淆成相同的名字，需要保存正式版本编译时使用的 mapping.txt 文件，并在后续编译中使用该 mapping。</p>
<p>经过以上论述呢，我们可以理出一个大致的思路：</p>
<ol>
<li>如果开启了混淆，transformClassesAndResourcesWithProguardForDebug 任务进行混淆时需要使用之前备份的 mapping 文件，并且在任务的 doLast 中备份本次混淆的 mapping 作为下次的参考</li>
<li>transformClassesWithDexBuilderForDebug 的输入是混淆后的 class/jar 文件，在将它们打包成 dex 之前，即在 doFirst 中，进行插桩，并通过与之前备份的 md5 值文件对比筛选出修改过的 class/jar，对它们用 dx/d8 命令打包成包含 dex 文件的补丁包</li>
</ol>
<h2 id="创建与使用-AGP-的基本步骤"><a href="#创建与使用-AGP-的基本步骤" class="headerlink" title="创建与使用 AGP 的基本步骤"></a>创建与使用 AGP 的基本步骤</h2><p>还是要简单提一下如何创建与使用一个 Android Plugin 插件，如果前面给出的参考链接中的内容已经掌握，可以跳过本节。</p>
<p>我们想在两个任务执行期间加入字节码插桩、补丁打包等操作，需要自定义一个 AGP 来实现。自定义 AGP 的方式有如下三种：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Build script 脚本</td>
<td>把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该 build.gradle 文件可见</td>
</tr>
<tr>
<td>buildSrc 目录</td>
<td>将插件源代码放在 buildSrc/src/main/ 中，只对该项目中可见</td>
</tr>
<tr>
<td>独立项目</td>
<td>一个独立的 Java 项目/模块，可以将文件包发布到仓库（Jcenter），使其他项目方便引入</td>
</tr>
</tbody></table>
<p>Build script 脚本只能在当前 build.gradle 文件中生效，复用性差；buildSrc 目录对当前项目生效，buildSrc 被作为系统保留的目录，编译时会最先编译该目录下的代码；独立项目的方式复用性最好，可以通过 Maven 实现远程共享。这里我们主要介绍 buildSrc 目录的方式。</p>
<h3 id="确定-Gradle-与-AGP-版本"><a href="#确定-Gradle-与-AGP-版本" class="headerlink" title="确定 Gradle 与 AGP 版本"></a>确定 Gradle 与 AGP 版本</h3><p>首先设置合适的 Gradle 与 Gradle 插件版本，Gradle 版本修改 /gradle/wrapper/gradle-wrapper.properties 文件：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">distributionUrl=https<span class="keyword">\:</span>//services.gradle.org/distributions/gradle-4.10.1-all.zip</span><br></pre></td></tr></table></figure>

<p>Gradle 插件版本修改项目的 build.gradle:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;com.android.tools.build:gradle:3.3.1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-buildSrc-目录"><a href="#创建-buildSrc-目录" class="headerlink" title="创建 buildSrc 目录"></a>创建 buildSrc 目录</h3><p>在项目根目录下创建 buildSrc 目录（注意不是模块），然后新建 build.gradle 文件添加 Gradle 插件依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;java-library&#x27;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 我们需要实现的 Plugin 接口在这个依赖中</span></span><br><span class="line">    implementation <span class="string">&#x27;com.android.tools.build:gradle:3.3.1&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 Java 语言编写自定义插件（其实用 Groovy 更方便一些），新建 PatchPlugin 实现 Plugin 接口来完成自定义插件，目录结构：</p>
<p><img src="/images/android_hot_fix10.png" alt="img"></p>
<p>PatchPlugin 实现 Plugin 接口时需要重写入口方法 apply，我们先只在 apply() 中添加一句 log：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Execute apply() in PatchPlugin.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-AGP-插件"><a href="#使用-AGP-插件" class="headerlink" title="使用 AGP 插件"></a>使用 AGP 插件</h3><p>当其它模块需要使用 AGP 插件时，需要在模块 build.gradle 中通过 apply plugin 声明插件的全类名：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> com.demo.plugin.PatchPlugin</span><br></pre></td></tr></table></figure>

<p>然后编译，在编译的输出信息中可以看到我们在 apply() 中加的 log：</p>
<p><img src="/images/android_hot_fix11.png" alt="img"></p>
<p>导入插件还有另一种形式，就是在 buildSrc 目录下，具体是在 buildSrc/src/main/resources/META-INF/gradle-plugins 目录下新建一个 xxx.properties 文件（xxx 文件名由你自己指定，但是后面在引用的时候要保持一致)，并将 implementation-class 属性指定为插件类的全类名：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">implementation-class=com.demo.plugin.PatchPlugin</span><br></pre></td></tr></table></figure>

<p>然后在 app 模块中就可以通过单引号的方式引入该插件了：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个 xxx 要和 gradle-plugins 目录下定义的 xxx 文件名一致</span></span><br><span class="line">apply <span class="attr">plugin:</span><span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="插件功能实现"><a href="#插件功能实现" class="headerlink" title="插件功能实现"></a>插件功能实现</h2><p>下面正式进入 Demo 的代码。</p>
<h3 id="创建扩展并进行配置"><a href="#创建扩展并进行配置" class="headerlink" title="创建扩展并进行配置"></a>创建扩展并进行配置</h3><p>首先在插件执行的入口方法 apply() 中创建一个名为 patch 的扩展：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 作用在 application 插件上，而不是 library</span></span><br><span class="line">        <span class="keyword">if</span> (!project.getPlugins().hasPlugin(AppPlugin.class)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;本插件需要结合Android Application插件使用！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 patch 扩展，支持的属性定义在 PatchExtension 中，其它模块</span></span><br><span class="line">        <span class="comment">// 在 build.gradle 中引入本插件后，就可以用 patch&#123;&#125; 进行配置</span></span><br><span class="line">        project.getExtensions().create(<span class="string">&quot;patch&quot;</span>, PatchExtension.class);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 project 拿到 ExtensionContainer 并调用 create() 创建一个 patch 闭包，PatchExtension 是一个 JavaBean，定义了 patch 支持的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatchExtension</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否在 debug 模式下开启热修复，默认为 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> debugOn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Application 的全类名。由于热修复一般是在 Application 中执行的，执行热修复代码时 Application</span></span><br><span class="line"><span class="comment">     * 已经被系统 ClassLoader 加载了，无法再替换，所以热修复时要刨除掉 Application 的 class 文件。</span></span><br><span class="line"><span class="comment">     * 虽然 Application 信息可以通过解析插件中的 AndroidManifest 获取，但是通过 Java 实现的插件</span></span><br><span class="line"><span class="comment">     * 解析 xml 很麻烦（Groovy 简单些），因此直接要求作为配置项获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String applicationName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可选项，补丁的输出目录，默认为 app/build/patch</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String output;</span><br><span class="line"></span><br><span class="line">    getters and setters...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样需要打补丁包的模块就可以这样配置其 build.gradle 来使用我们的插件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line"><span class="comment">// 引入我们的自定义插件</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.plugin.patch&#x27;</span></span><br><span class="line"></span><br><span class="line">patch &#123;</span><br><span class="line">	<span class="comment">// debug 模式下开启打补丁包</span></span><br><span class="line">    debugOn <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 本模块使用的 Application 全类名</span></span><br><span class="line">    applicationName <span class="string">&#x27;com.demo.plugin.Application&#x27;</span></span><br><span class="line">    <span class="comment">// 输出路径没配置，使用默认的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取配置信息"><a href="#获取配置信息" class="headerlink" title="获取配置信息"></a>获取配置信息</h3><p>接下来要获取所有配置信息为编译工作做准备了，这些操作要放在 Project 的 afterEvaluate() 回调中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 作用在 application 插件上，而不是 library</span></span><br><span class="line">    <span class="keyword">if</span> (!project.getPlugins().hasPlugin(AppPlugin.class)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">&quot;本插件需要结合Android Application插件使用！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 patch 扩展，支持的属性定义在 PatchExtension 中，其它模块</span></span><br><span class="line">    <span class="comment">// 在 build.gradle 中引入本插件后，就可以用 patch&#123;&#125; 进行配置</span></span><br><span class="line">    project.getExtensions().create(<span class="string">&quot;patch&quot;</span>, PatchExtension.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// afterEvaluate() 在 build.gradle 文件解析完成后回调</span></span><br><span class="line">    project.afterEvaluate(<span class="keyword">new</span> Action&lt;Project&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">            PatchExtension patchExtension = project.getExtensions().findByType(PatchExtension.class);</span><br><span class="line">            <span class="keyword">if</span> (patchExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// debug 模式下是否打补丁包</span></span><br><span class="line">                <span class="keyword">boolean</span> debugOn = patchExtension.isDebugOn();</span><br><span class="line">                project.getLogger().info(<span class="string">&quot;debugOn:&quot;</span> + debugOn + <span class="string">&quot;, ApplicationName:&quot;</span> + patchExtension.getApplicationName());</span><br><span class="line">                <span class="comment">// 获取 android 扩展</span></span><br><span class="line">                AppExtension android = project.getExtensions().getByType(AppExtension.class);</span><br><span class="line">                <span class="comment">// 遍历 android -&gt; buildTypes 下所有的变体，如 debug、release 等</span></span><br><span class="line">                android.getApplicationVariants().all(<span class="keyword">new</span> Action&lt;ApplicationVariant&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ApplicationVariant applicationVariant)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 如果编译的是 debug 版本并且已经配置了 debug 不需要生成补丁包，就不作处理</span></span><br><span class="line">                        <span class="keyword">if</span> (applicationVariant.getName().contains(<span class="string">&quot;debug&quot;</span>) &amp;&amp; !debugOn) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 开始编译配置与生成补丁工作</span></span><br><span class="line">                        configTasks(project, applicationVariant, patchExtension);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不在 afterEvaluate() 中获取配置信息，那么会拿不到 patchExtension 中的属性值。因为使用 PatchPlugin 插件的模块，在其 build.gradle 执行到 apply plugin: ‘com.plugin.patch’ 这句话时就去执行其 apply() 去获取 patch 扩展中配置的 patchExtension 的值，而此时 build.gradle 还没解析，所以拿不到 patch 配置的属性值。</p>
<p>configTasks() 作为接下来一系列工作的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configTasks</span><span class="params">(Project project, ApplicationVariant variant, PatchExtension patchExtension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建补丁文件的输出路径</span></span><br><span class="line">    String variantName = variant.getName();</span><br><span class="line">    File outputDir = Utils.getOrCreateOutputDir(project, variantName, patchExtension);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取 Android 的混淆任务，并配置混淆任务使用的 mapping 文件</span></span><br><span class="line">    String variantCapName = Utils.capitalize(variantName);</span><br><span class="line">    Task proguardTask = project.getTasks().findByName(<span class="string">&quot;transformClassesAndResourcesWithProguardFor&quot;</span></span><br><span class="line">                                                      + variantCapName);</span><br><span class="line">    <span class="keyword">if</span> (proguardTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        configProguardTask(project, proguardTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.配置任务，进行字节码插桩和补丁生成</span></span><br><span class="line">    Task dexTask = getTransformTask(project, patchExtension, outputDir, variantCapName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.创建打补丁的任务 patchDebug/patchRelease，依赖于 dexTask</span></span><br><span class="line">    Task task = project.getTasks().create(<span class="string">&quot;patch&quot;</span> + variantCapName);</span><br><span class="line">    task.setGroup(<span class="string">&quot;patch&quot;</span>);</span><br><span class="line">    task.dependsOn(dexTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释已经标明，任务大致分为 4 步，第 1 步比较简单，就是根据配置创建补丁输出目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getOrCreateOutputDir</span><span class="params">(Project project, String variantName, PatchExtension patchExtension)</span> </span>&#123;</span><br><span class="line">    File outputDir;</span><br><span class="line">    <span class="comment">// 如果 build.gradle 中没有指定 patch -&gt; output 就用默认值 /build/patch/[variantName]</span></span><br><span class="line">    <span class="keyword">if</span> (!Utils.isEmpty(patchExtension.getOutput())) &#123;</span><br><span class="line">        outputDir = <span class="keyword">new</span> File(patchExtension.getOutput(), variantName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outputDir = <span class="keyword">new</span> File(project.getBuildDir(), <span class="string">&quot;patch/&quot;</span> + variantName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    project.getLogger().info(<span class="string">&quot;补丁输出路径：&quot;</span> + outputDir.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    outputDir.mkdirs();</span><br><span class="line">    <span class="keyword">return</span> outputDir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面 3 步下面详解。</p>
<h3 id="处理混淆"><a href="#处理混淆" class="headerlink" title="处理混淆"></a>处理混淆</h3><p>我们需要让混淆任务按照上一次混淆的映射关系 mapping.txt 进行（如果有），并且在本次混淆任务结束之后，保存本次混淆的 mapping 文件以备下次混淆时使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configProguardTask</span><span class="params">(Project project, Task proguardTask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proguardTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有备份的 mapping 文件，那么本次编译还要使用上次的 mapping</span></span><br><span class="line">    File backupMappingFile = <span class="keyword">new</span> File(project.getBuildDir(), <span class="string">&quot;mapping.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (backupMappingFile.exists()) &#123;</span><br><span class="line">        TransformTask task = (TransformTask) proguardTask;</span><br><span class="line">        ProGuardTransform transform = (ProGuardTransform) task.getTransform();</span><br><span class="line">        <span class="comment">// 相当于在 proguard-rules.pro 中配置了 -applymapping mapping.txt</span></span><br><span class="line">        transform.applyTestedMapping(backupMappingFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要开启了混淆，在混淆任务结束后就要把 mapping 文件备份</span></span><br><span class="line">    proguardTask.doLast(<span class="keyword">new</span> Action&lt;Task&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// mapping 文件在 proguardTask 的输出之中</span></span><br><span class="line">            TaskOutputs outputs = proguardTask.getOutputs();</span><br><span class="line">            Set&lt;File&gt; files = outputs.getFiles().getFiles();</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">&quot;mapping.txt&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 找出 mapping.txt 并备份</span></span><br><span class="line">                        FileUtils.copyFile(file, backupMappingFile);</span><br><span class="line">                        project.getLogger().info(<span class="string">&quot;mapping: &quot;</span> + backupMappingFile.getCanonicalPath());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字节码插桩，生成补丁"><a href="#字节码插桩，生成补丁" class="headerlink" title="字节码插桩，生成补丁"></a>字节码插桩，生成补丁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Task <span class="title">getTransformTask</span><span class="params">(Project project, PatchExtension patchExtension, File outputDir, String variantCapName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存 class 文件名及其 md5 值的文件</span></span><br><span class="line">    File hexFile = <span class="keyword">new</span> File(outputDir, <span class="string">&quot;hex.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 需要打补丁的类组成的 jar 包</span></span><br><span class="line">    File patchClassFile = <span class="keyword">new</span> File(outputDir, <span class="string">&quot;patchClass.jar&quot;</span>);</span><br><span class="line">    <span class="comment">// dx 命令打包 patchClassFile 后生成的补丁包，最终产物</span></span><br><span class="line">    File patchFile = <span class="keyword">new</span> File(outputDir, <span class="string">&quot;patch.jar&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取将 class 打包成 dex 的任务</span></span><br><span class="line">    Task dexTask = project.getTasks().findByName(<span class="string">&quot;transformClassesWithDexBuilderFor&quot;</span> + variantCapName);</span><br><span class="line">    <span class="comment">// 在开始打包之前，插桩并记录每个 class 的 md5 哈希值</span></span><br><span class="line">    dexTask.doFirst(<span class="keyword">new</span> Action&lt;Task&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 将 Application 全类名中的 . 替换成平台相关的斜杠，Windows 是 xx\xx\，Linux 是 xx/xx/</span></span><br><span class="line">            String applicationName = patchExtension.getApplicationName();</span><br><span class="line">            applicationName = applicationName.replaceAll(<span class="string">&quot;\\.&quot;</span>, Matcher.quoteReplacement(File.separator));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录类本次编译的 md5 值</span></span><br><span class="line">            Map&lt;String, String&gt; newHexes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 负责生成补丁</span></span><br><span class="line">            PatchGenerator patchGenerator = <span class="keyword">new</span> PatchGenerator(project, patchFile, patchClassFile, hexFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历 dexTask 任务的输入文件，对 class 和 jar 文件进行处理，像 app 中的 MainActivity</span></span><br><span class="line">            <span class="comment">// 的路径是：app\build\intermediates\transforms\proguard\debug\0.jar</span></span><br><span class="line">            Set&lt;File&gt; files = dexTask.getInputs().getFiles().getFiles();</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                String filePath = file.getAbsolutePath();</span><br><span class="line">                <span class="comment">// 插桩，并做 md5 值比较，不一致的放入补丁包</span></span><br><span class="line">                <span class="keyword">if</span> (filePath.endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">                    processClass(project, applicationName, file, newHexes, patchGenerator);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (filePath.endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">                    processJar(project, applicationName, file, newHexes, patchGenerator);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存本次编译的 md5</span></span><br><span class="line">            Utils.writeHex(newHexes, hexFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成补丁文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                patchGenerator.generate();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> dexTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开头三个文件的作用：</p>
<ul>
<li>hexFile 保存每次编译生成的 class 文件，插桩之后的类名及 md5 值，这样才能比较出哪些文件有改动，进而被放入补丁包</li>
<li>patchClassFile 是所有需要被添加进补丁包的 class 文件打成的 jar 包，是一个中间产物，用来生成最终的补丁包</li>
<li>patchFile 是 dx/d8 命令对 patchClassFile 打包生成的 jar 包，也就是最终需要的补丁包</li>
</ul>
<p>在拿到 transformClassesWithDexBuilderForDebug 任务的一开始，先拿到模块的 applicationName 对应的全类名路径，因为热修复不会替换 Application，所以在后面处理时要剔除掉。</p>
<p>PatchGenerator 主要用来比较 md5 值以及执行打包的 dx/d8 命令，初始化时要获取 buildToolsVersion 以便动态获取 dx/d8 命令的执行路径，还要读取上次编译时备份的 hexFile：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PatchGenerator</span><span class="params">(Project project, File patchFile, File jarFile, File hexFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.project = project;</span><br><span class="line">    <span class="keyword">this</span>.patchFile = patchFile;</span><br><span class="line">    <span class="keyword">this</span>.jarFile = jarFile;</span><br><span class="line">    <span class="comment">// 从 android&#123;&#125; 中获取 buildToolsVersion 属性</span></span><br><span class="line">    buildToolsVersion = project.getExtensions().getByType(AppExtension.class).getBuildToolsVersion();</span><br><span class="line">    <span class="comment">// 从备份文件中读取上一次编译生成的 class 文件名和 md5 值</span></span><br><span class="line">    <span class="keyword">if</span> (hexFile.exists()) &#123;</span><br><span class="line">        prevHexes = Utils.readHex(hexFile);</span><br><span class="line">        project.getLogger().info(<span class="string">&quot;从备份文件 &quot;</span> + hexFile.getAbsolutePath() + <span class="string">&quot; 中读取md5值&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果备份文件不存在，可能是首次编译，直接创建备份文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hexFile.createNewFile()) &#123;</span><br><span class="line">                project.getLogger().info(<span class="string">&quot;创建备份文件成功：&quot;</span> + hexFile.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是对所有输入文件进行插桩和 md5 值的比较，由于输入的文件既可能是 class 也可能是 jar 包（没开混淆上一个任务传过来的就是 class，开了混淆传过来的就是 jar 包，具体路径看注释），所以才会用 processClass() 和 processJar() 分别处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 class 文件执行插桩，并记录插装后的 md5，与上一次编译的备份 md5</span></span><br><span class="line"><span class="comment">     * 做比较，如果比较结果不相同，说明文件发生了变化，需要打包进补丁包中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationName Application 全类名对应的路径名，如：com\demo\plugin\Application</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file            待处理的 class 文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHexes        记录 Map&lt;class,String&gt; 类名与对应 md5 值的 Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patchGenerator  生成补丁包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processClass</span><span class="params">(Project project, String applicationName, File file, Map&lt;String, String&gt; newHexes,</span></span></span><br><span class="line"><span class="params"><span class="function">                          PatchGenerator patchGenerator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 截取文件的绝对路径，仅保留包名之后的部分，比如 filePath 为</span></span><br><span class="line">    <span class="comment">// app\build\intermediates\javac\debug\compileDebugJavaWithJavac\classes\com\demo\plugin\Test.class，</span></span><br><span class="line">    <span class="comment">// 那么截取后的 classPath 就是 com\demo\plugin\Test.class</span></span><br><span class="line">    String filePath = file.getAbsolutePath();</span><br><span class="line">    String classPath = filePath.split(<span class="string">&quot;classes&quot;</span>)[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (classPath.startsWith(applicationName) || Utils.isAndroidClass(classPath)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        project.getLogger().info(<span class="string">&quot;开始处理 class 文件：&quot;</span> + filePath);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">        <span class="comment">// 插桩</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = ClassUtils.referHackWhenInit(fis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成这个 class 文件的 16 进制 md5</span></span><br><span class="line">        String hex = Utils.hex(bytes);</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出插桩后的 class 文件</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(filePath);</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将本次的 md5 值存入缓存，并与上一次的 md5 进行对比</span></span><br><span class="line">        newHexes.put(classPath, hex);</span><br><span class="line">        patchGenerator.checkClass(classPath, hex, bytes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 jar 包中的 class 文件执行插桩，并记录插装后的 md5，与上一次编译的备份 md5</span></span><br><span class="line"><span class="comment">     * 做比较，如果比较结果不相同，说明文件发生了变化，需要打包进补丁包中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file            条件限定，这个 file 是个 jar 包</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hexes           保存类名及其 md5 值的 Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patchGenerator  生成补丁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJar</span><span class="params">(Project project, String applicationName, File file, Map&lt;String, String&gt; hexes,</span></span></span><br><span class="line"><span class="params"><span class="function">                        PatchGenerator patchGenerator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        applicationName = applicationName.replaceAll(Matcher.quoteReplacement(File.separator), <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        File backupJar = <span class="keyword">new</span> File(file.getParent(), file.getName() + <span class="string">&quot;.bak&quot;</span>);</span><br><span class="line"></span><br><span class="line">        JarOutputStream jarOutputStream = <span class="keyword">new</span> JarOutputStream(<span class="keyword">new</span> FileOutputStream(backupJar));</span><br><span class="line"></span><br><span class="line">        JarFile jarFile = <span class="keyword">new</span> JarFile(file);</span><br><span class="line">        Enumeration&lt;JarEntry&gt; entries = jarFile.entries();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">            JarEntry jarEntry = entries.nextElement();</span><br><span class="line">            String className = jarEntry.getName();</span><br><span class="line">            jarOutputStream.putNextEntry(<span class="keyword">new</span> JarEntry(className));</span><br><span class="line">            InputStream inputStream = jarFile.getInputStream(jarEntry);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (className.endsWith(<span class="string">&quot;.class&quot;</span>) &amp;&amp; !className.startsWith(applicationName) &amp;&amp;</span><br><span class="line">                !Utils.isAndroidClass(className) &amp;&amp; !className.startsWith(<span class="string">&quot;com/demo/patch&quot;</span>)) &#123;</span><br><span class="line">                project.getLogger().info(<span class="string">&quot;开始处理 jar 包中的 class 文件：&quot;</span> + className);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = ClassUtils.referHackWhenInit(inputStream);</span><br><span class="line">                String hex = Utils.hex(bytes);</span><br><span class="line">                hexes.put(className, hex);</span><br><span class="line">                <span class="comment">// 对比缓存的 md5，不一致则放入补丁</span></span><br><span class="line">                patchGenerator.checkClass(className, hex, bytes);</span><br><span class="line">                jarOutputStream.write(bytes);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 输出到临时文件</span></span><br><span class="line">                jarOutputStream.write(IOUtils.toByteArray(inputStream));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            inputStream.close();</span><br><span class="line">            jarOutputStream.closeEntry();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jarOutputStream.close();</span><br><span class="line">        jarFile.close();</span><br><span class="line">        file.delete();</span><br><span class="line">        backupJar.renameTo(file);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二者的处理思路大致相同，都是先插桩：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtils</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 向  class 文件的构造方法中插入一句 Class cls = AntiLazyLoad.class</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] referHackWhenInit(InputStream inputStream) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ClassReader classReader = <span class="keyword">new</span> ClassReader(inputStream);</span><br><span class="line">        ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">        ClassVisitor classVisitor = <span class="keyword">new</span> ClassVisitor(Opcodes.ASM6, classWriter) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">                MethodVisitor methodVisitor = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">                methodVisitor = <span class="keyword">new</span> MethodVisitor(api, methodVisitor) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;&lt;init&gt;&quot;</span>.equals(name) &amp;&amp; opcode == Opcodes.RETURN) &#123;</span><br><span class="line">                            <span class="comment">// 在构造方法末尾插入 AntiLazyLoad 引用</span></span><br><span class="line">                            <span class="keyword">super</span>.visitLdcInsn(Type.getType(<span class="string">&quot;Lcom/demo/plugin/AntiLazyLoad;&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> methodVisitor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        classReader.accept(classVisitor, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> classWriter.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将插桩后的 md5 值存入 Map&lt;String, String&gt; newHexes 中，再通过 PatchGenerator 把 newHexes 和 hexFile 中的 md5 作比较：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查本次编译的 md5 与上一次的是否相同，如果不同说明文件</span></span><br><span class="line"><span class="comment">     * 有变化，需要打包进补丁包</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className class 文件全类名对应的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHex    新编译后 class 文件的 md5 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes     新编译后 class 文件的字节内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClass</span><span class="params">(String className, String newHex, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Utils.isEmpty(prevHexes)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 newHex 不在缓存中或者与缓存中的值不相等，就要放入补丁包</span></span><br><span class="line">    String oldHex = prevHexes.get(className);</span><br><span class="line">    <span class="keyword">if</span> (oldHex == <span class="keyword">null</span> || !oldHex.equals(newHex)) &#123;</span><br><span class="line">        JarOutputStream jarOutputStream = getJarOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jarOutputStream.putNextEntry(<span class="keyword">new</span> JarEntry(className));</span><br><span class="line">            jarOutputStream.write(bytes);</span><br><span class="line">            jarOutputStream.closeEntry();</span><br><span class="line">            project.getLogger().info(<span class="string">&quot;放入补丁包，文件路径：&quot;</span> + className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>md5 不一致的类会被放入 patchClassFile 中，最后再用 generate() 执行 dx/d8 命令，对 patchClassFile 执行打包，生成最终的补丁包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行 dx 命令将 class/jar 文件打包成 dex 文件，Java Runtime 和</span></span><br><span class="line"><span class="comment">     * Gradle 都提供了运行 Java 命令的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!jarFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关流 jar 包才会去写数据</span></span><br><span class="line">    getJarOutputStream().close();</span><br><span class="line"></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    File localPropFile = project.getRootProject().file(<span class="string">&quot;local.properties&quot;</span>);</span><br><span class="line">    <span class="comment">// dx 命令在 sdk 中，先获取 sdk 路径，再拼接出 dx 命令的绝对路径</span></span><br><span class="line">    String sdkDir;</span><br><span class="line">    <span class="keyword">if</span> (localPropFile.exists()) &#123;</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileInputStream(localPropFile));</span><br><span class="line">        sdkDir = properties.getProperty(<span class="string">&quot;sdk.dir&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sdkDir = System.getenv(<span class="string">&quot;ANDROID_HOME&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Windows 使用 dx.bat 命令，linux/mac 使用 dx 命令</span></span><br><span class="line">    String cmdExt = Os.isFamily(Os.FAMILY_WINDOWS) ? <span class="string">&quot;.bat&quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    String dxPath = sdkDir + <span class="string">&quot;/build-tools/&quot;</span> + buildToolsVersion + <span class="string">&quot;/dx&quot;</span> + cmdExt;</span><br><span class="line">    String patch = <span class="string">&quot;--output=&quot;</span> + patchFile.getAbsolutePath();</span><br><span class="line"></span><br><span class="line">    project.exec(<span class="keyword">new</span> Action&lt;ExecSpec&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ExecSpec execSpec)</span> </span>&#123;</span><br><span class="line">            execSpec.commandLine(dxPath, <span class="string">&quot;--dex&quot;</span>, patch, jarFile.getAbsolutePath());</span><br><span class="line">            project.getLogger().info(<span class="string">&quot;执行了命令：&quot;</span> + (dxPath + <span class="string">&quot; --dex&quot;</span> + patch + jarFile.getAbsolutePath()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 class 组成的 jar 包</span></span><br><span class="line">    jarFile.delete();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*// 使用 Java Runtime 执行 dx 命令</span></span><br><span class="line"><span class="comment">        final String cmd = dxPath + &quot; --dex &quot; + patch + &quot; &quot; + jarFile.getAbsolutePath();</span></span><br><span class="line"><span class="comment">        Process process = Runtime.getRuntime().exec(cmd);</span></span><br><span class="line"><span class="comment">        process.waitFor();</span></span><br><span class="line"><span class="comment">        // 命令执行失败</span></span><br><span class="line"><span class="comment">        if (process.exitValue() != 0) &#123;</span></span><br><span class="line"><span class="comment">            throw new IOException(&quot;generate patch error:&quot; + cmd);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    project.getLogger().info(<span class="string">&quot;\npatch generated in : &quot;</span> + patchFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建新任务"><a href="#创建新任务" class="headerlink" title="创建新任务"></a>创建新任务</h3><p>最后就是创建一个新任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.创建打补丁的任务 patchDebug，依赖于 dex 打包任务</span></span><br><span class="line">Task task = project.getTasks().create(<span class="string">&quot;patch&quot;</span> + variantCapName);</span><br><span class="line">task.setGroup(<span class="string">&quot;patch&quot;</span>);</span><br><span class="line">task.dependsOn(dexTask);</span><br></pre></td></tr></table></figure>

<p>如果编译的是 debug 版本，任务名就是 patchDebug，属于 patch 组别，依赖于将混淆后的 class 打包成 dex 的任务 transformClassesWithDexBuilderForDebug，由于 Gradle 会根据所有任务之间的依赖关系形成一个有向无环图，所以执行 patchDebug 任务，就会按照依赖关系将其前面的编译-&gt;混淆-&gt;插桩-&gt;打补丁包-&gt;生成 dex 这一系列任务都执行，进而得到补丁包了：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> 执行所有模块的 patchDebug</span><br><span class="line">&gt;gradlew patchDebug</span><br><span class="line"><span class="params">#</span> 执行 app 模块的 patchDebug</span><br><span class="line">&gt;gradlew :app:patchDebug</span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>设置 debug 编译也生成补丁包，没有开混淆的情况下，初次编译会生成一个 hex.txt 文件：</p>
<p><img src="/images/android_hot_fix12.png" alt="img"></p>
<p>接着修改 app 模块中的 Test.java 文件，随便增加个测试语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 增加的语句</span></span><br><span class="line">        Class clazz = Test.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次编译，发现 hex.txt 中 Test.class 的 md5 值发生了变化，并且在 patch/debug 下会生成 patch.jar 文件，也就是补丁包：</p>
<p><img src="/images/android_hot_fix13.png" alt="img"></p>
<p>使用 jadx 工具打开 patch.jar，发现里面只有 Test 文件，并且在构造方法的尾部被字节码插桩引入了 AntiLazyLoad.class，证明 Demo 的基本功能还是实现了：</p>
<p><img src="/images/android_hot_fix14.png" alt="img"></p>
<p>如果开启了混淆，那么 app 模块中的类被编译成 class 文件后，还会再被打包进一个 jar 包，再传递给 transformClassesWithDexBuilderForDebug 任务。首次编译的 hex.txt 以及备份的 mapping.txt 如下：</p>
<p><img src="/images/android_hot_fix15.png" alt="img"></p>
<p>对上述文件做出更改，让 MainActivity 调用 Test 中新增的方法 newMethod() 后再次编译，结果如下：</p>
<p><img src="/images/android_hot_fix16.png" alt="img"></p>
<p>查看 patch.jar 的内容也确实是与修改内容相符，并且两个修改的类的构造方法都被插桩引用了 AntiLazyLoad.class：</p>
<p><img src="/images/android_hot_fix17.png" alt="img"></p>
<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><p>主要有二，加 log 和打断点。</p>
<p>Demo 中有很多地方加了类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">project.getLogger().info(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这是添加了 Gradle log，执行任务时会在控制台输出，log 的级别从低到高为：DEBUG、INFO、LIFECYCLE、WARNING、QUITE、ERROR，默认情况下控制台只会输出 LIFECYCLE 以及更高级别的 log，在执行命令时可以通过添加参数来改变 log 的输出级别：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> 输出 INFO 及更高级别的 log，还可以 -q、-d 等，分别对应 QUITE、DEBUG</span><br><span class="line">&gt; gradlew -i patchDebug</span><br></pre></td></tr></table></figure>

<p>除了加 log 我们还可以打断点，先在 Run/Debug Configurations 中点击 + 添加一个 Remote 类型的 Configuration：</p>
<p><img src="/images/android_hot_fix18.png" alt="img"></p>
<p>然后在命令行中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 比如说上图中新建的 Remote 名字为 GradleDebug，那么 TaskName 填 GradleDebug 即可</span><br><span class="line">&gt; gradlew [TaskName] -Dorg.gradle.debug=true --no-daemon</span><br></pre></td></tr></table></figure>

<p>最后点击 debug 按钮就可以进行断点调试了：</p>
<p><img src="/images/android_hot_fix19.png" alt="img"></p>
<p>Demo 代码地址：<a href="https://github.com/tmacfrank/GradlePluginDemo/">GradlePluginDemo</a></p>
<p>参考文章：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a">安卓App热补丁动态修复技术介绍</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286341&idx=1&sn=054d595af6e824cbe4edd79427fc2706&scene=0#wechat_redirect">Android N混合编译与对热补丁影响解析</a><br><a href="https://tech.meituan.com/2016/09/14/android-robust.html">Android热更新方案Robust</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=2649286384&idx=1&sn=f1aff31d6a567674759be476bcd12549&scene=4#wechat_redirect">微信Tinker的一切都在这里，包括源码(一)</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>热修复</tag>
        <tag>HotFix</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 插件化开发</title>
    <url>/2020/01/21/android_plugin_develop/</url>
    <content><![CDATA[<p>插件化技术最初源于免安装运行 <code>Apk</code>的想法，这个免安装的 <code>Apk</code> 就可以理解为插件，而支持插件的 <code>app</code> 我们一般叫 宿主。</p>
<p>想必大家都知道，在 <code>Android</code> 系统中，应用是以 <code>Apk</code> 的形式存在的，应用都需要安装才能使用。但实际上 <code>Android</code> 系统安装应用的方式相当简单，其实就是把应用 <code>Apk</code> 拷贝到系统不同的目录下、然后把 <code>so</code> 解压出来而已。</p>
<span id="more"></span>

<p>常见的应用安装目录有：</p>
<ul>
<li><code>/system/app</code>：系统应用</li>
<li><code>/system/priv-app</code>：系统应用</li>
<li><code>/data/app</code>：用户应用</li>
</ul>
<p>那可能大家会想问，既然安装这个过程如此简单，<code>Android</code> 是怎么运行应用中的代码的呢，我们先看 <code>Apk</code> 的构成，一个常见的 <code>Apk</code> 会包含如下几个部分：</p>
<ul>
<li><code>classes.dex</code>：<code>Java</code> 代码字节码</li>
<li><code>res</code>：资源文件</li>
<li><code>lib</code>：<code>so</code> 文件</li>
<li><code>assets</code>：静态资产文件</li>
<li><code>AndroidManifest.xml</code>：清单文件</li>
</ul>
<p>其实 <code>Android</code> 系统在打开应用之后，也只是开辟进程，然后使用 <code>ClassLoader</code> 加载 <code>classes.dex</code> 至进程中，执行对应的组件而已。</p>
<p>那大家可能会想一个问题，既然 <code>Android</code> 本身也是使用类似反射的形式加载代码执行，凭什么我们不能执行一个 <code>Apk</code> 中的代码呢？</p>
<h1 id="插件化的优点"><a href="#插件化的优点" class="headerlink" title="插件化的优点"></a>插件化的优点</h1><p>插件化让 <code>Apk</code> 中的代码（主要是指 <code>Android</code> 组件）能够免安装运行，这样能够带来很多收益：</p>
<ul>
<li>减少安装<code>Apk</code>的体积、按需下载模块</li>
<li>动态更新插件</li>
<li>宿主和插件分开编译，提升开发效率</li>
<li>解决方法数超过65535的问题</li>
</ul>
<p>想象一下，你的应用拥有 <code>Native</code> 应用一般极高的性能，又能获取诸如 <code>Web</code> 应用一样的收益。</p>
<p>嗯，理想很美好不是嘛？</p>
<h1 id="与组件化的区别"><a href="#与组件化的区别" class="headerlink" title="与组件化的区别"></a>与组件化的区别</h1><ul>
<li><p><strong>组件化</strong>：是将一个<code>App</code>分成多个模块，每个模块都是一个组件（module），开发过程中可以让这些组件相互依赖或独立编译、调试部分组件，但是这些组件最终会合并成一个完整的<code>Apk</code>去发布到应用市场。</p>
</li>
<li><p><strong>插件化</strong>：是将整个App拆分成很多模块，每个模块都是一个Apk（组件化的每个模块是一个lib），最终打包的时候将宿主Apk和插件Apk分开打包，只需发布宿主Apk到应用市场，插件Apk通过动态按需下发到宿主Apk。</p>
</li>
</ul>
<h1 id="插件化的技术难点"><a href="#插件化的技术难点" class="headerlink" title="插件化的技术难点"></a>插件化的技术难点</h1><p>想让插件的Apk真正运行起来，首先要先能找到插件Apk的存放位置，然后我们要能解析加载Apk里面的代码。</p>
<p>​        但是光能执行Java代码是没有意义的，在Android系统中有四大组件是需要在系统中注册的，具体来说是在 <code>Android</code> 系统的 <code>ActivityManagerService (AMS)</code> 和 <code>PackageManagerService (PMS)</code> 中注册的，而四大组件的解析和启动都需要依赖 <code>AMS</code> 和 <code>PMS</code>，如何欺骗系统，让他承认一个未安装的 <code>Apk</code> 中的组件，如何让宿主动态加载执行插件Apk中 <code>Android</code> 组件（即 <code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>、<code>ContentProvider</code>、<code>Fragment</code>）等是插件化最大的难点。</p>
<p>​         另外，应用资源引用（特指 <code>R</code> 中引用的资源，如 <code>layout</code>、<code>values</code> 等）也是一大问题，想象一下你在宿主进程中使用反射加载了一个插件 <code>Apk</code>，代码中的 <code>R</code> 对应的 <code>id</code> 却无法引用到正确的资源，会产生什么后果。</p>
<p>总结一下，其实做到插件化的要点就这几个：</p>
<ul>
<li>如何加载并执行插件 <code>Apk</code> 中的代码（<code>ClassLoader Injection</code>）</li>
<li>让系统能调用插件 <code>Apk</code> 中的组件（<code>Runtime Container</code>）</li>
<li>正确识别插件 <code>Apk</code> 中的资源（<code>Resource Injection</code>）</li>
</ul>
<p>当然还有其他一些小问题，但可能不是所有场景下都会遇到，我们后面再单独说。</p>
<h1 id="ClassLoader-Injection"><a href="#ClassLoader-Injection" class="headerlink" title="ClassLoader Injection"></a>ClassLoader Injection</h1><p>ClassLoader 是插件化中必须要掌握的，因为我们知道<code>Android</code> 应用本身是基于魔改的 <code>Java</code> 虚拟机的，而由于插件是未安装的 apk，系统不会处理其中的类，所以需要使用 <code>ClassLoader</code> 加载 <code>Apk</code>，然后反射里面的代码。</p>
<h2 id="Java中的ClassLoader"><a href="#Java中的ClassLoader" class="headerlink" title="Java中的ClassLoader"></a>Java中的ClassLoader</h2><ul>
<li><p>BootstrapClassLoader 负责加载 JVM 运行时的核心类，比如 JAVA_HOME/lib/rt.jar 等等</p>
</li>
<li><p>ExtensionClassLoader 负责加载 JVM 的扩展类，比如 JAVA_HOME/lib/ext 下面的 jar 包</p>
</li>
<li><p>AppClassLoader 负责加载 classpath 里的 jar 包和目录</p>
</li>
</ul>
<h2 id="Android中的ClassLoader"><a href="#Android中的ClassLoader" class="headerlink" title="Android中的ClassLoader"></a>Android中的ClassLoader</h2><p>在Android系统中<code>ClassLoader</code>是用来加载<code>dex</code>文件的，有包含 dex 的 apk 文件以及 jar 文件，dex 文件是一种对class文件优化的产物，在Android中应用打包时会把所有class文件进行合并、优化（把不同的class文件重复的东西只保留一份），然后生成一个最终的class.dex文件</p>
<ul>
<li>PathClassLoader 用来加载系统类和应用程序类，可以加载已经安装的 apk 目录下的 dex 文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath,</span></span></span><br><span class="line"><span class="params"><span class="function">            ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DexClassLoader 用来加载 dex 文件，可以从存储空间加载 dex 文件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="params"><span class="function">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在插件化中一般使用的是 DexClassLoader。</p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>每一个 ClassLoader 中都有一个 parent 对象，代表的是父类加载器，在加载一个类的时候，会先使用父类加载器去加载，如果在父类加载器中没有找到，自己再进行加载，如果 parent 为空，那么就用系统类加载器来加载。通过这样的机制可以保证系统类都是由系统类加载器加载的。 下面是 ClassLoader 的 loadClass 方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">    Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 先从父类加载器中进行加载</span></span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">            <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有找到，再自己加载</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何加载插件中的类"><a href="#如何加载插件中的类" class="headerlink" title="如何加载插件中的类"></a>如何加载插件中的类</h2><p>要加载插件中的类，我们首先要创建一个 DexClassLoader，先看下 DexClassLoader 的构造函数需要哪些参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数需要四个参数： <strong>dexPath</strong> 是需要加载的 dex / apk / jar 文件路径 <strong>optimizedDirectory</strong> 是 dex 优化后存放的位置，在 ART 上，会执行 oat 对 dex 进行优化，生成机器码，这里就是存放优化后的 odex 文件的位置 <strong>librarySearchPath</strong> 是 native 依赖的位置 <strong>parent</strong> 就是父类加载器，默认会先从 parent 加载对应的类</p>
<p>创建出 DexClassLaoder 实例以后，只要调用其 loadClass(className) 方法就可以加载插件中的类了。具体的实现在下面：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 assets 中拿出插件 apk 放到内部存储空间</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">extractPlugin</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> inputStream = assets.<span class="keyword">open</span>(<span class="string">&quot;plugin.apk&quot;</span>)</span><br><span class="line">        File(filesDir.absolutePath, <span class="string">&quot;plugin.apk&quot;</span>).writeBytes(inputStream.readBytes())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    extractPlugin()</span><br><span class="line">        pluginPath = File(filesDir.absolutePath, <span class="string">&quot;plugin.apk&quot;</span>).absolutePath</span><br><span class="line">        nativeLibDir = File(filesDir, <span class="string">&quot;pluginlib&quot;</span>).absolutePath</span><br><span class="line">        dexOutPath = File(filesDir, <span class="string">&quot;dexout&quot;</span>).absolutePath</span><br><span class="line">        <span class="comment">// 生成 DexClassLoader 用来加载插件类</span></span><br><span class="line">        pluginClassLoader = DexClassLoader(pluginPath, dexOutPath, nativeLibDir, <span class="keyword">this</span>::<span class="keyword">class</span>.java.classLoader)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_plugin_develop01.png" alt="img"></p>
<h2 id="执行插件类的方法"><a href="#执行插件类的方法" class="headerlink" title="执行插件类的方法"></a>执行插件类的方法</h2><p>通过反射来执行类的方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> loadClass = pluginClassLoader.loadClass(activityName)</span><br><span class="line">loadClass.getMethod(<span class="string">&quot;test&quot;</span>,<span class="literal">null</span>).invoke(loadClass)</span><br></pre></td></tr></table></figure>

<p>我们称这个过程叫做 <code>ClassLoader</code> 注入。完成注入后，所有来自宿主的类使用宿主的 <code>ClassLoader</code> 进行加载，所有来自插件 <code>Apk</code> 的类使用插件 <code>ClassLoader</code> 进行加载，而由于 <code>ClassLoader</code> 的双亲委派机制，实际上系统类会不受 <code>ClassLoader</code> 的类隔离机制所影响，这样宿主 <code>Apk</code> 就可以在宿主进程中使用来自于插件的组件类了。</p>
<h1 id="Runtime-Container"><a href="#Runtime-Container" class="headerlink" title="Runtime Container"></a>Runtime Container</h1><p>我们之前说到 Activity 插件化最大的难点是如何欺骗系统，让他承认一个未安装的 <code>Apk</code> 中的组件。 因为插件是动态加载的，所以插件的四大组件不可能注册到宿主的 Manifest 文件中，而没有在 Manifest 中注册的四大组件是不能和系统直接进行交互的。 如果直接把插件的 Activity 注册到宿主 Manifest 里就失去了插件化的动态特性，因为每次插件中新增 Activity 都要修改宿主 Manifest 并且重新打包，那就和直接写在宿主中没什么区别了。</p>
<h2 id="为什么没有注册的-Activity-不能和系统交互"><a href="#为什么没有注册的-Activity-不能和系统交互" class="headerlink" title="为什么没有注册的 Activity 不能和系统交互"></a>为什么没有注册的 Activity 不能和系统交互</h2><p>这里的不能直接交互的含义有两个</p>
<ol>
<li>系统会检测 Activity 是否注册 如果我们启动一个没有在 Manifest 中注册的 Activity，会发现报如下 error：</li>
</ol>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">android.content.ActivityNotFoundException: Unable to find explicit activity class &#123;com.zyg.commontec/com.zyg.plugin.PluginActivity&#125;; have you declared this activity in your AndroidManifest.xml?</span><br></pre></td></tr></table></figure>

<p>这个 log 在 Instrumentation 的 checkStartActivityResult 方法中可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkStartActivityResult</span><span class="params">(<span class="keyword">int</span> res, Object intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ActivityManager.isStartResultFatalError(res)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_INTENT_NOT_RESOLVED:</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">                <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                            <span class="string">&quot;Unable to find explicit activity class &quot;</span></span><br><span class="line">                            + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                            + <span class="string">&quot;; have you declared this activity in your AndroidManifest.xml?&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                        <span class="string">&quot;No Activity found to handle &quot;</span> + intent);</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Activity 的生命周期无法被调用，其实一个 Activity 主要的工作，都是在其生命周期方法中调用了，既然上一步系统检测了 Manifest 注册文件，启动 Activity 被拒绝，那么其生命周期方法也肯定不会被调用了。从而插件 Activity 也就不能正常运行了。</li>
</ol>
<h2 id="运行时容器技术"><a href="#运行时容器技术" class="headerlink" title="运行时容器技术"></a>运行时容器技术</h2><p>由于Android中的组件（Activity，Service，BroadcastReceiver和ContentProvider）是由系统创建的，并且由系统管理生命周期。 仅仅构造出这些类的实例是没用的，还需要管理组件的生命周期。其中以Activity最为复杂，不同框架采用的方法也不尽相同。插件化如何支持组件生命周期的管理。 大致分为两种方式：</p>
<ul>
<li>运行时容器技术（ProxyActivity代理）</li>
<li>预埋StubActivity，hook系统启动Activity的过程</li>
</ul>
<p>我们的解决方案很简单，即运行时容器技术，简单来说就是在宿主 <code>Apk</code> 中预埋一些空的 <code>Android</code> 组件，以 <code>Activity</code> 为例，我预置一个 <code>ContainerActivity extends Activity</code> 在宿主中，并且在 <code>AndroidManifest.xml</code> 中注册它。</p>
<p>它要做的事情很简单，就是帮助我们作为插件 <code>Activity</code> 的容器，它从 <code>Intent</code> 接受几个参数，分别是插件的不同信息，如：</p>
<ul>
<li><code>pluginName</code></li>
<li><code>pluginApkPath</code></li>
<li><code>pluginActivityName</code></li>
</ul>
<p>等，其实最重要的就是 <code>pluginApkPath</code> 和 <code>pluginActivityName</code>，当 <code>ContainerActivity</code> 启动时，我们就加载插件的 <code>ClassLoader</code>、<code>Resource</code>，并反射 <code>pluginActivityName</code> 对应的 <code>Activity</code> 类。当完成加载后，<code>ContainerActivity</code> 要做两件事：</p>
<ul>
<li>转发所有来自系统的生命周期回调至插件 <code>Activity</code></li>
<li>接受 <code>Activity</code> 方法的系统调用，并转发回系统</li>
</ul>
<p>我们可以通过复写 <code>ContainerActivity</code> 的生命周期方法来完成第一步，而第二步我们需要定义一个 <code>PluginActivity</code>，然后在编写插件 <code>Apk</code> 中的 <code>Activity</code> 组件时，不再让其集成 <code>android.app.Activity</code>，而是集成自我们的 <code>PluginActivity</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PluginActivity pluginActivity;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        String pluginActivityName = getIntent().getString(<span class="string">&quot;pluginActivityName&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        pluginActivity = PluginLoader.loadActivity(pluginActivityName, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (pluginActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pluginActivity.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pluginActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onResume();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pluginActivity.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pluginActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onPause();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pluginActivity.onPause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ContainerActivity containerActivity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PluginActivity</span><span class="params">(ContainerActivity containerActivity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.containerActivity = containerActivity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends View&gt; <span class="function">T <span class="title">findViewById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containerActivity.findViewById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件 `Apk` 中真正写的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">PluginActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是感觉有点看懂了，虽然真正搞的时候还有很多小坑，但大概原理就是这么简单，启动插件组件需要依赖容器，容器负责加载插件组件并且完成双向转发，转发来自系统的生命周期回调至插件组件，同时转发来自插件组件的系统调用至系统。</p>
<h2 id="字节码替换"><a href="#字节码替换" class="headerlink" title="字节码替换"></a>字节码替换</h2><p>该方式虽然能够很好的实现启动插件Activity的目的，但是由于开发式侵入性很强，插件中的Activity必须继承PluginActivity，如果想把之前的模块改造成插件需要很多额外的工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">PluginActivity</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>有没有什么办法能让插件组件的编写与原来没有任何差别呢？</p>
<p><code>Shadow</code> 的做法是字节码替换插件，这是一个非常棒的想法，简单来说，<code>Android</code> 提供了一些 <code>Gradle</code> 插件开发套件，其中有一项功能叫 <code>Transform Api</code>，它可以介入项目的构建过程，在字节码生成后、<code>dex</code> 文件生成前，对代码进行某些变换，具体怎么做的不说了，可以自己看文档。</p>
<p>实现的功能嘛，就是用户配置 <code>Gradle</code> 插件后，正常开发，依然编写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后完成编译后，最后的字节码中，显示的却是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">PluginActivity</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>到这里基本的框架就差不多结束了。</p>
<h1 id="Resource-Injection"><a href="#Resource-Injection" class="headerlink" title="Resource Injection"></a>Resource Injection</h1><p>最后要说的是资源注入，其实这一点相当重要，<code>Android</code> 应用的开发其实崇尚的是逻辑与资源分离的理念，所有资源（<code>layout</code>、<code>values</code> 等）都会被打包到 <code>Apk</code> 中，然后生成一个对应的 <code>R</code> 类，其中包含对所有资源的引用 <code>id</code>。</p>
<p>资源的注入并不容易，好在 <code>Android</code> 系统给我们留了一条后路，最重要的是这两个接口：</p>
<ul>
<li><code>PackageManager#getPackageArchiveInfo</code>：根据 <code>Apk</code> 路径解析一个未安装的 <code>Apk</code> 的 <code>PackageInfo</code></li>
<li><code>PackageManager#getResourcesForApplication</code>：根据 <code>ApplicationInfo</code> 创建一个 <code>Resources</code> 实例</li>
</ul>
<p>我们要做的就是在上面 <code>ContainerActivity#onCreate</code> 中加载插件 <code>Apk</code> 的时候，用这两个方法创建出来一份插件资源实例。具体来说就是先用 <code>PackageManager#getPackageArchiveInfo</code> 拿到插件 <code>Apk</code> 的 <code>PackageInfo</code>，有了 <code>PacakgeInfo</code> 之后我们就可以自己组装一份 <code>ApplicationInfo</code>，然后通过 <code>PackageManager#getResourcesForApplication</code> 来创建资源实例，大概代码像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PackageManager packageManager = getPackageManager();</span><br><span class="line">PackageInfo packageArchiveInfo = packageManager.getPackageArchiveInfo(</span><br><span class="line">    pluginApkPath,</span><br><span class="line">    PackageManager.GET_ACTIVITIES</span><br><span class="line">    | PackageManager.GET_META_DATA</span><br><span class="line">    | PackageManager.GET_SERVICES</span><br><span class="line">    | PackageManager.GET_PROVIDERS</span><br><span class="line">    | PackageManager.GET_SIGNATURES</span><br><span class="line">);</span><br><span class="line">packageArchiveInfo.applicationInfo.sourceDir = pluginApkPath;</span><br><span class="line">packageArchiveInfo.applicationInfo.publicSourceDir = pluginApkPath;</span><br><span class="line"></span><br><span class="line">Resources injectResources = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    injectResources = packageManager.getResourcesForApplication(packageArchiveInfo.applicationInfo);</span><br><span class="line">&#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到资源实例后，我们需要将宿主的资源和插件资源 <code>Merge</code> 一下，编写一个新的 <code>Resources</code> 类，用这样的方式完成自动代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginResources</span> <span class="keyword">extends</span> <span class="title">Resources</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resources hostResources;</span><br><span class="line">    <span class="keyword">private</span> Resources injectResources;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PluginResources</span><span class="params">(Resources hostResources, Resources injectResources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(injectResources.getAssets(), injectResources.getDisplayMetrics(), injectResources.getConfiguration());</span><br><span class="line">        <span class="keyword">this</span>.hostResources = hostResources;</span><br><span class="line">        <span class="keyword">this</span>.injectResources = injectResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> id, Object... formatArgs)</span> <span class="keyword">throws</span> NotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> injectResources.getString(id, formatArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> hostResources.getString(id, formatArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在 <code>ContainerActivity</code> 完成插件组件加载后，创建一份 <code>Merge</code> 资源，再复写 <code>ContainerActivity#getResources</code>，将获取到的资源替换掉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resources pluginResources;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        pluginResources = <span class="keyword">new</span> PluginResources(<span class="keyword">super</span>.getResources(), PluginLoader.getResources(pluginApkPath));</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pluginActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getResources();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pluginResources;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了资源的注入。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>插件化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android PKMS核心分析</title>
    <url>/2019/08/29/android_pms/</url>
    <content><![CDATA[<p>PackageManagerService是android系统核心服务之一，它主要负责的工作如下：<br>一.  解析AndroidManifest.xml文件，解析清单文件中的所有节点信息。<br>二.  扫描.apk文件，安装系统应用，本地应用等。<br>三.  管理本地应用，主要有：安装、卸载、应用信息查询等。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Android系统启动时，会启动（应用程序管理服务器PKMS），此服务负责扫描系统中特定的目录，寻找里面的APK格式的文件，并对这些文件进行解析，然后得到应用程序相关信息，最后完成应用程序的安装</p>
<p>PKMS在安装应用过程中, 会全面解析应用程序的AndroidManifest.xml文件,  来得到Activity, Service, BroadcastReceiver, ContextProvider 等信息, 在结合PKMS服务就可以在OS中正常的使用应用程序了</p>
<p>在Android系统中, 系统启动时由SystemServer启动PKMS服务, 启动该服务后会执行应用程序的安装过程</p>
<h1 id="PKMS架构设计"><a href="#PKMS架构设计" class="headerlink" title="PKMS架构设计"></a>PKMS架构设计</h1><h2 id="类图关系"><a href="#类图关系" class="headerlink" title="类图关系"></a>类图关系</h2><p><img src="/images/android_pms_01.png" alt="image"></p>
<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><p><img src="/images/android_pms_02.png" alt="image"></p>
<blockquote>
<p>注意：<br>客户端可通过Context.getPackageManager()获得ApplicationPackageManager对象,<br>而mPM指向的是Proxy代理，当调用到mPM.方法后，将会调用到IPackageManager的Proxy代理方法，<br>然后通过Binder机制中的mRemote与服务端PackageManagerService通信<br>并调用到PackageManagerService的方法；<br>自我总结：PKMS是属于Binder机制的服务端角色</p>
</blockquote>
<h1 id="PKMS启动过程"><a href="#PKMS启动过程" class="headerlink" title="PKMS启动过程"></a>PKMS启动过程</h1><blockquote>
<p>启动过程描述：<br>SystemServer启动PKMS：先是在SystemServer.startBootstrapServices()函数中启动PKMS服务，再调用startOtherServices()函数中对dex优化，磁盘管理功能，让PKMS进入SystemReady状态。</p>
</blockquote>
<p><img src="/images/android_pms_03.png" alt="image"></p>
<h2 id="SystemServer的启动"><a href="#SystemServer的启动" class="headerlink" title="SystemServer的启动"></a>SystemServer的启动</h2><h3 id="SystemServer七部曲"><a href="#SystemServer七部曲" class="headerlink" title="SystemServer七部曲"></a>SystemServer七部曲</h3><p><img src="/images/android_pms_04.png" alt="image"></p>
<h3 id="调用startBootstrapServices-服务"><a href="#调用startBootstrapServices-服务" class="headerlink" title="调用startBootstrapServices()服务"></a>调用startBootstrapServices()服务</h3><blockquote>
<p>SystemServer启动Boot服务</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 启动Installer服务：mSystemServiceManager.startService(Installer.class);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span>) 获取设备是否加密(手机设置密码),如果设备加密了，则只解析<span class="string">&quot;core&quot;</span>应用</span><br><span class="line">String cryptState = VoldProperties.decrypt().orElse(<span class="string">&quot;&quot;</span>); </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">3</span>) 调用PKMS.main()方法初始化PackageManagerService</span><br><span class="line">PackageManagerService.main(mSystemContext,installer,mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);       </span><br><span class="line">PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context, installer, factoryTest, onlyCore); <span class="comment">// 构造PackageManagerService对象</span></span><br><span class="line">ServiceManager.addService(<span class="string">&quot;package&quot;</span>,m); <span class="comment">// 把实例化出来的PKMS丢给ServiceManager进行注册</span></span><br><span class="line"><span class="keyword">final</span> PackageManagerNative pmn = m.<span class="function">new <span class="title">PackageManagerNative</span><span class="params">()</span></span>; <span class="comment">// 构造PackageManagerNative对象</span></span><br><span class="line">ServiceManager.addService(<span class="string">&quot;package_native&quot;</span>, pmn); <span class="comment">// 启动package_native服务</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">4</span>) 如果设备没有加密，操作它。管理A/<span class="function">B OTA dexopting</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(!mOnlyCore)</span>  <span class="comment">// 判断是否只是核心应用</span></span></span><br></pre></td></tr></table></figure>

<p><strong>startBootstrapServices源码</strong></p>
<blockquote>
<p>SystemServer.java startBootstrapServices()<br>说明：startBootstrapServices()首先启动Installer服务，也就是安装器，随后判断当前的设备是否是出于加密状态。如果是出于加密状态则只是解析核心应用，接着调用PackageManagerService的静态方法main来创建PKMS对象。<br>(1) 启动Installer对象<br>(2) 获取设备是否加密(手机设置密码)，如果设备加密了，则只解析”core”应用。<br>(3) 调用PKMS main方法初始化PackageManagerService，其中调用PackageManagerService()构造方法创建了PKMS对象。<br>(4) 如果设备没有加密，操作它。管理A/B OTA dexopting。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// （1）启动Installer服务</span></span><br><span class="line">        <span class="comment">// 阻塞等待installed完成启动，以便有机会创建具有适当权限的关键目录，</span></span><br><span class="line">        <span class="comment">// 如/data/user。我们需要在初始化其他服务之前完成此任务。</span></span><br><span class="line">        Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 初始化AMS</span></span><br><span class="line">        mActivityManagerService = ActivityManagerService.Lifecycle.startService(</span><br><span class="line">                mSystemServiceManager, atm);</span><br><span class="line">        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">        <span class="comment">// 我们需要在初始化其他服务之前完成此任务</span></span><br><span class="line">        mActivityManagerService.setInstaller(installer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Only run &quot;core&quot; apps if we&#x27;re encrypting the device.</span></span><br><span class="line">        <span class="comment">// (2).获取设备是否加密</span></span><br><span class="line">        <span class="comment">// 如果设备加密了，则只解析 &quot;core&quot; 应用</span></span><br><span class="line">        <span class="comment">// mOnlyCore = true，后面会频繁使用该变量进行条件判断</span></span><br><span class="line">        String cryptState = VoldProperties.decrypt().orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Detected encryption in progress - only parsing core apps&quot;</span>);</span><br><span class="line">            mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;Device encrypted - only parsing core apps&quot;</span>);</span><br><span class="line">            mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// (3) 调用PKMS的main方法，初始化PKMS</span></span><br><span class="line">            mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">                    mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// PKMS 是否是第一次启动</span></span><br><span class="line">        mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">        <span class="comment">// 通过context.getPackageManager()来获得PackageManager对象</span></span><br><span class="line">        mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// (4) 如果设备没有加密，操作它。管理A/B OTA dexopting</span></span><br><span class="line">        <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> disableOtaDexopt = SystemProperties.getBoolean(<span class="string">&quot;config.disable_otadexopt&quot;</span>,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (!disableOtaDexopt) &#123;</span><br><span class="line">                t.traceBegin(<span class="string">&quot;StartOtaDexOptService&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Watchdog.getInstance().pauseWatchingCurrentThread(<span class="string">&quot;moveab&quot;</span>);</span><br><span class="line">                    OtaDexoptService.main(mSystemContext, mPackageManagerService);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    reportWtf(<span class="string">&quot;starting OtaDexOptService&quot;</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Watchdog.getInstance().resumeWatchingCurrentThread(<span class="string">&quot;moveab&quot;</span>);</span><br><span class="line">                    t.traceEnd();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用startOtherServices-方法"><a href="#调用startOtherServices-方法" class="headerlink" title="调用startOtherServices()方法"></a>调用startOtherServices()方法</h3><blockquote>
<p>SystemServer启动其他服务，并使一些核心服务处于ready状态</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">5</span>) <span class="comment">// 如果设备没有加密，执行performDexoptUpgrade，完成dexopt优化</span></span><br><span class="line">mPackageManagerService.updatePackagesIfNeeded();   </span><br><span class="line">该方法，作用：检查是否需要去更新Packages并进行dex优化。</span><br><span class="line"></span><br><span class="line">条件：没有OTA升级，没有大版本升级，</span><br><span class="line">          没有清除过dalvik虚拟机的缓存，可以去更新Packages。</span><br><span class="line">更新Packages的优先级：core app &gt; system app &gt; other app,调用performDexOptUpgrade()方法进行更新</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">6</span>) mPackageManagerService.performFstrimIfNeeded(); <span class="comment">// 执行performFstrimIfNeeded(),完成磁盘维护</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">7</span>) mPackageManagerService.systemReady(mActivityManagerService.getAppOpsService());<span class="comment">// PackageManagerNative 准备就绪</span></span><br><span class="line">     DefaultPermissionPolicy.grantDefaultPermissions(userId); <span class="comment">// 启动之前授予默认所有权限</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>startOtherServices源码</strong></p>
<blockquote>
<p>[SystemServer.java] startOtherServices()<br>(5) 执行updatePackageIfNeeded，完成dex优化<br>(6) 执行performFstrimIfNeeded，完成磁盘维护<br>(7) 调用systemReady，准备就绪</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Watchdog.getInstance().pauseWatchingCurrentThread(<span class="string">&quot;dexopt&quot;</span>);</span><br><span class="line">                <span class="comment">// (5) 如果设备没有加密，执行performDexoptUpgrade，完成dexopt优化</span></span><br><span class="line">                mPackageManagerService.updatePackagesIfNeeded();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">&quot;update packages&quot;</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Watchdog.getInstance().resumeWatchingCurrentThread(<span class="string">&quot;dexopt&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// (6) 执行performFstrim，完成磁盘维护</span></span><br><span class="line">            mPackageManagerService.performFstrimIfNeeded();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;performing fstrim&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (7) PackageManagerService准备就绪</span></span><br><span class="line">        mPackageManagerService.systemReady();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="PKMS构造初始化"><a href="#PKMS构造初始化" class="headerlink" title="PKMS构造初始化"></a>PKMS构造初始化</h2><h3 id="PKMS-main"><a href="#PKMS-main" class="headerlink" title="PKMS.main"></a>PKMS.main</h3><p>main函数主要工作：<br>(1) 检查Package编译相关系统属性<br>(2) 调用PackageManagerService构造方法<br>(3) 启用部分应用服务于多用户场景<br>(4) 往ServiceManager中注册 “package” 和 “package_native’。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PackageManagerService <span class="title">main</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Self-check for initial settings.</span></span><br><span class="line">        <span class="comment">// (1) 检查Package编译相关系统属性</span></span><br><span class="line">        PackageManagerServiceCompilerMapping.checkProperties();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// (2) 构造PackageManagerService对象</span></span><br><span class="line">        PackageManagerService m = <span class="keyword">new</span> PackageManagerService(injector, onlyCore, factoryTest);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 基于用户类型，为所有用户安装/卸载系统应用</span></span><br><span class="line">        m.installWhitelistedSystemPackages();</span><br><span class="line">        <span class="comment">// 向ServiceManager注册PKMS(启动package服务)</span></span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;package&quot;</span>, m);</span><br><span class="line">        <span class="comment">// 构造PackageManagerNative对象</span></span><br><span class="line">        <span class="keyword">final</span> PackageManagerNative pmn = m.<span class="function">new <span class="title">PackageManagerNative</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">// 启动package_native服务</span></span><br><span class="line">        ServiceManager.addService(<span class="string">&quot;package_native&quot;</span>, pmn);</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【总结回顾】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建PackageManagerService并向ServiceManager注册</span><br><span class="line">创建PackageManagerNative并向ServiceManager注册</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="PKMS构造"><a href="#PKMS构造" class="headerlink" title="PKMS构造"></a>PKMS构造</h3><blockquote>
<p>PKMS 初始化时的核心部分为PackageManagerService的构造函数的内容，现在我们来看一下该函数。</p>
</blockquote>
<p>此函数由两个重要的锁（mInstallLock和mLock）和五个阶段构成。在Android 11.0源码中是由(mInstallLock和mPackages)两个锁</p>
<p>mInstallLock、mLock：用来保护所有安装apk的访问权限，此操作通常涉及繁重的磁盘数据读写等操作。并且是单线程操作，所以有时候会处理很慢。此锁不会在已经持有了mLock锁的情况下加锁，反之，在已经持有mInstallLock锁的情况下，立即获得mLock是安全的。</p>
<p>mPackages（mLock）：用来解析内存中所有apk的package信息及相关状态。</p>
<p>PKMS服务也是通过Binder进行通信，IPackageManager.aidl由工具转换后自动生成Binder的服务端IPackageManager.Stub和客户端IPackageManager.Stub.Proxy。</p>
<p>Binder服务端：PackageManagerService继承自IPackageManager.Stub</p>
<p>Binder客户端：ApplicationPackageManager(简称APM)的成员变量mPm继承于IPackageManager.Stub.Proxy。本身APM继承与PackageManager对象。</p>
<h3 id="五个阶段"><a href="#五个阶段" class="headerlink" title="五个阶段"></a>五个阶段</h3><p><img src="/images/android_pms_05.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5个阶段构成，下面会详细的来分析这些内容。</span><br><span class="line">    阶段1：BOOT_PROGRESS_PMS_START  开始阶段</span><br><span class="line">    阶段2：BOOT_PROGRESS_PMS_SYSTEM_SCAN_START 系统扫描阶段</span><br><span class="line">    阶段3：BOOT_PROGRESS_PMS_DATA_SCAN_START Data扫描阶段</span><br><span class="line">    阶段4：BOOT_PROGRESS_PMS_SCAN_END 扫描结束</span><br><span class="line">    阶段5：BOOT_PROGRESS_PMS_READY 就绪阶段</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>阶段1，阶段2，阶段3，阶段4，阶段5 的 EventLog</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public PackageManagerService(Context context, Installer installer,</span><br><span class="line">        boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 阶段1：BOOT_PROGRESS_PMS_START</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line"> </span><br><span class="line">        // 阶段2：BOOT_PROGRESS_PMS_SYSTEM_SCAN_START</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,</span><br><span class="line">                    startTime);</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        // 阶段3：BOOT_PROGRESS_PMS_DATA_SCAN_STAR</span><br><span class="line">        if (!mOnlyCore) &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</span><br><span class="line">                        SystemClock.uptimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 阶段4：BOOT_PROGRESS_PMS_SCAN_END</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">        ...</span><br><span class="line">        // 阶段5：BOOT_PROGRESS_PMS_READY</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><blockquote>
<p>BOOT_PROGRESS_PMS_START 开始阶段</p>
</blockquote>
<p>主要工作：<br>(1) 构造 DisplayMetrics，保存分辨率相关信息。<br>(2) 创建Installer对象，与installd交互<br>(3) 创建mPermissionManager对象，进行权限管理<br>(4) 构造Settings类，保存安装包信息，清除路径不存在的孤立应用，主要涉及/data/system/目录的packages.xml,<br>     packages-backup.xml,packages.list,packages-stopped.xml,packages-stopped-backup.xml等文件。<br>(5) 构造PackageDexOptimizer及DexManager类，处理dex优化；<br>(6) 创建SystemConfig实例，获取系统配置信息，配置共享lib库；<br>(7) 创建PackageManager的Handler线程，循环处理外部安装相关消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Injector injector, <span class="keyword">boolean</span> onlyCore, <span class="keyword">boolean</span> factoryTest)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一阶段</span></span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">        <span class="comment">// mSdkVersion是编译的SDK版本</span></span><br><span class="line">        <span class="keyword">if</span> (mSdkVersion &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;**** ro.build.version.sdk not set!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        mFactoryTest = factoryTest;    <span class="comment">// 假设为false，即运行在非工厂模式下</span></span><br><span class="line">        mOnlyCore = onlyCore;<span class="comment">// 假设为false，即运行在普通模式下。标记是否只加载核心服务</span></span><br><span class="line">        <span class="comment">// (1) mMetrics用于存储与显示屏相关的一些属性，例如屏幕的宽高尺寸、分辨率等信息</span></span><br><span class="line">        mMetrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">        <span class="comment">// (2) 构建Installer对象，与installed交互</span></span><br><span class="line">        mInstaller = injector.getInstaller();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 本地服务</span></span><br><span class="line">        LocalServices.addService(PackageManagerInternal.class, mPmInternal);</span><br><span class="line">        <span class="comment">// 构建多用户管理服务</span></span><br><span class="line">        mUserManager = injector.getUserManagerService();</span><br><span class="line">        mComponentResolver = injector.getComponentResolver();</span><br><span class="line">        <span class="comment">// (3) 构建权限管理服务</span></span><br><span class="line">        mPermissionManager = injector.getPermissionManagerServiceInternal();</span><br><span class="line">        <span class="comment">// 创建Settings对象，Settings是一个非常重要的类，用于存储系统运行过程中的一些设置</span></span><br><span class="line">        mSettings = injector.getSettings();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// (4)构造Settings类，保存安装包信息，清除路径不存在的孤立应用，主要涉</span></span><br><span class="line">        <span class="comment">// 及/data/system/目录的packages.xml，packages-backup.xml， packages.list，</span></span><br><span class="line">        <span class="comment">// packages-stopped.xml，packages-stopped-backup.xml等文件。</span></span><br><span class="line">        <span class="comment">// 添加system，phone，log，nfc，bluetooth，shell，se，networkstack这八种shareUserId到settings对象中</span></span><br><span class="line">        mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.system&quot;</span>, Process.SYSTEM_UID,</span><br><span class="line">                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">        mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.phone&quot;</span>, RADIO_UID,</span><br><span class="line">                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">        mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.log&quot;</span>, LOG_UID,</span><br><span class="line">                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">        mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.nfc&quot;</span>, NFC_UID,</span><br><span class="line">                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">        mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.bluetooth&quot;</span>, BLUETOOTH_UID,</span><br><span class="line">                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">        mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.shell&quot;</span>, SHELL_UID,</span><br><span class="line">                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">        mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.se&quot;</span>, SE_UID,</span><br><span class="line">                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">        mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.networkstack&quot;</span>, NETWORKSTACK_UID,</span><br><span class="line">                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// (5)构造PackageDexOptimizer及DexManager类，处理dex优化</span></span><br><span class="line">        mPackageDexOptimizer = <span class="keyword">new</span> PackageDexOptimizer(mInstaller, mInstallLock, mContext,</span><br><span class="line">                <span class="string">&quot;*dexopt*&quot;</span>);</span><br><span class="line">        mDexManager =</span><br><span class="line">                <span class="keyword">new</span> DexManager(mContext, <span class="keyword">this</span>, mPackageDexOptimizer, mInstaller, mInstallLock);</span><br><span class="line">        <span class="comment">// 创建ATR虚拟机管理服务</span></span><br><span class="line">        mArtManagerService = <span class="keyword">new</span> ArtManagerService(mContext, <span class="keyword">this</span>, mInstaller, mInstallLock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取默认分辨率</span></span><br><span class="line">        getDefaultDisplayMetrics(mInjector.getDisplayManager(), mMetrics);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// (6)创建SystemConfig实例，获取系统配置信息，配置共享lib库；</span></span><br><span class="line">        <span class="comment">//拿到SystemConfig()的对象，其中会调用SystemConfig的readPermissions()完成权限的读取</span></span><br><span class="line">        SystemConfig systemConfig = SystemConfig.getInstance();        </span><br><span class="line">        <span class="comment">// CHECKSTYLE:OFF IndentationCheck</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">        <span class="comment">// writer</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">//(7)创建PackageManager的handler线程，循环处理外部安装相关消息</span></span><br><span class="line">            <span class="comment">//启动PackageManager线程，负责apk的安装、卸载</span></span><br><span class="line">            mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG,</span><br><span class="line">                    Process.THREAD_PRIORITY_BACKGROUND, <span class="keyword">true</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">            mHandlerThread.start();</span><br><span class="line">            <span class="comment">// 应用Handler</span></span><br><span class="line">            mHandler = <span class="keyword">new</span> PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">            <span class="comment">// 进程记录handler</span></span><br><span class="line">            mProcessLoggingHandler = <span class="keyword">new</span> ProcessLoggingHandler();</span><br><span class="line">            <span class="comment">// WatchDog监听ServiceThread是否超时：10分钟</span></span><br><span class="line">            Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</span><br><span class="line">            <span class="comment">// Instant应用注册</span></span><br><span class="line">            mInstantAppRegistry = <span class="keyword">new</span> InstantAppRegistry(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 共享lib库配置</span></span><br><span class="line">            ArrayMap&lt;String, SystemConfig.SharedLibraryEntry&gt; libConfig</span><br><span class="line">                    = systemConfig.getSharedLibraries();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> builtInLibCount = libConfig.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; builtInLibCount; i++) &#123;</span><br><span class="line">                String name = libConfig.keyAt(i);</span><br><span class="line">                SystemConfig.SharedLibraryEntry entry = libConfig.valueAt(i);</span><br><span class="line">                addBuiltInSharedLibraryLocked(entry.filename, name);</span><br><span class="line">            &#125;         </span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 读取安装SELinux相关策略</span></span><br><span class="line">            SELinuxMMAC.readInstallPolicy();</span><br><span class="line">            <span class="comment">// 返回栈加载</span></span><br><span class="line">            FallbackCategoryProvider.loadFallbacks();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 这句很重要，解析系统配置文件package.xml</span></span><br><span class="line">            <span class="comment">// 读取并解析/data/system下的XML文件</span></span><br><span class="line">            mFirstBoot = !mSettings.readLPw(mInjector.getUserManagerInternal().getUsers(<span class="keyword">false</span>));</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Clean up orphaned packages for which the code path doesn&#x27;t exist</span></span><br><span class="line">            <span class="comment">// and they are an update to a system app - caused by bug/32321269</span></span><br><span class="line">            <span class="comment">// 清理代码路径不存在的孤立软件包</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> packageSettingCount = mSettings.mPackages.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = packageSettingCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!isExternal(ps) &amp;&amp; (ps.codePath == <span class="keyword">null</span> || !ps.codePath.exists())</span><br><span class="line">                        &amp;&amp; mSettings.getDisabledSystemPkgLPr(ps.name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mSettings.mPackages.removeAt(i);</span><br><span class="line">                    mSettings.enableSystemPackageLPw(ps.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是首次启动，也不是CORE应用，则拷贝预编译的DEX文件</span></span><br><span class="line">            <span class="keyword">if</span> (!mOnlyCore &amp;&amp; mFirstBoot) &#123;</span><br><span class="line">                requestCopyPreoptedFiles();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ......</span><br><span class="line"> </span><br><span class="line">         &#125;    <span class="comment">// synchronized (mPackages) </span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【总结回顾】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里主要是对一些属性和子服务进行了创建或赋值，其中比较重要的有mInstaller、mSettings、mPackageDexOptimizer等。</span><br><span class="line">在之前的有些版本，mSettings等有些属性是在这里直接new的，而现在采用传入Injector的方式来获取。另外、这里还开启了工作线程。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>readLPw()会扫描下面5个文件</p>
<ol>
<li>“/data/system/packages.xml”                                       // 所有安装app信息</li>
<li>“/data/system/packages-backup.xml”                          // 所有安装app信息的备份的信息记录</li>
<li>“/data/system/packages.list”                                        // 所有安装app信息</li>
<li>“/data/system/packages-stopped.xml”                        // 所有强制停止app信息 </li>
<li>“/data/system/packages-stopped-backup.xml”           // 所以强制停止app信息的备份的信息记录</li>
</ol>
<p>5个文件共分为三组，简单的作用描述如下：</p>
<ol>
<li>packages.xml: PKMS扫描完成目标文件夹之后会创建该文件。当系统进行程序安装、卸载和更新等操作时，均会更新该文件。该文件保存了系统中与 package相关的一些信息。</li>
<li>packages.list: 描述系统中存在的所有非系统自带的apk的信息。当这些程序有变动时 PKMS 就会更新该文件。</li>
<li>packages-stopped.xml : 从系统自带的设置程序中进入应用程序页面，然后再选择强制停止(ForceStop) 某个应用时，系统会将该应用的相关信息记录到此文件中。也就是该文件保存系统中被用户强制停止的 package 的信息。</li>
</ol>
<p>这些目录的指向，都在settings中的构造函数中完成，如下所示，得到目录后调用readLpw()进行扫描。</p>
<p>看一下settings的构造函数（package com.android.server.pm）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Settins类的几个重要属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File mSettingsFilename;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File mBackupSettingsFilename;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File mPackageListFilename;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File mStoppedPackagesFilename;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File mBackupStoppedPackagesFilename;</span><br><span class="line"><span class="comment">/** The top level directory in configfs for sdcardfs to push the package-&gt;uid,userId mappings */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File mKernelMappingFilename;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 已经安装的App的信息 */</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;String, PackageSetting&gt; mPackages = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Settings的构造方法</span></span><br><span class="line">Settings(File dataDir, PermissionSettings permission,</span><br><span class="line">            Object lock) &#123;</span><br><span class="line">        mLock = lock;</span><br><span class="line">        mPermissions = permission;</span><br><span class="line">        mRuntimePermissionsPersistence = <span class="keyword">new</span> RuntimePermissionPersistence(mLock);</span><br><span class="line"> </span><br><span class="line">        mSystemDir = <span class="keyword">new</span> File(dataDir, <span class="string">&quot;system&quot;</span>);                <span class="comment">//mSystemDir指向目录&quot;/data/system&quot;</span></span><br><span class="line">        mSystemDir.mkdirs();        <span class="comment">//创建 &quot;/data/system&quot;</span></span><br><span class="line">        <span class="comment">// 设置权限</span></span><br><span class="line">        FileUtils.setPermissions(mSystemDir.toString(),</span><br><span class="line">                FileUtils.S_IRWXU|FileUtils.S_IRWXG</span><br><span class="line">                |FileUtils.S_IROTH|FileUtils.S_IXOTH,</span><br><span class="line">                -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//(1)指向目录&quot;/data/system/packages.xml&quot;</span></span><br><span class="line">        mSettingsFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//(2)指向目录&quot;/data/system/packages-backup.xml&quot;</span></span><br><span class="line">        mBackupSettingsFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages-backup.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//(3)指向目录&quot;/data/system/packages.list&quot;</span></span><br><span class="line">        mPackageListFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages.list&quot;</span>);</span><br><span class="line">        FileUtils.setPermissions(mPackageListFilename, <span class="number">0640</span>, SYSTEM_UID, PACKAGE_INFO_GID);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> File kernelDir = <span class="keyword">new</span> File(<span class="string">&quot;/config/sdcardfs&quot;</span>);</span><br><span class="line">        mKernelMappingFilename = kernelDir.exists() ? kernelDir : <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Deprecated: Needed for migration</span></span><br><span class="line">        <span class="comment">//(4)指向目录&quot;/data/system/packages-stopped.xml&quot;</span></span><br><span class="line">        mStoppedPackagesFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages-stopped.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//(5)指向目录&quot;/data/system/packages-stopped-backup.xml&quot;</span></span><br><span class="line">        mBackupStoppedPackagesFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">&quot;packages-stopped-backup.xml&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析上面这几个xml的内容，建立对应的数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Setting.<span class="function">java</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readLPw</span><span class="params">(<span class="meta">@NonNull</span> List&lt;UserInfo&gt; users)</span> </span>&#123;</span><br><span class="line">        FileInputStream str = <span class="keyword">null</span>;   </span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">           str = <span class="keyword">new</span> FileInputStream(mSettingsFilename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析 &quot;/data/system/packages.xml</span></span><br><span class="line">        XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">        parser.setInput(str, StandardCharsets.UTF_8.name());</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG</span><br><span class="line">                &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            mReadMessages.append(<span class="string">&quot;No start tag found in settings file\n&quot;</span>);</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.WARN,</span><br><span class="line">                   <span class="string">&quot;No start tag found in package manager settings&quot;</span>);</span><br><span class="line">            Slog.wtf(PackageManagerService.TAG,</span><br><span class="line">                    <span class="string">&quot;No start tag found in package manager settings&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">           <span class="comment">// 解析xml</span></span><br><span class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                    &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据xml的各个节点进行各种操作，例如读取权限、shared-user等</span></span><br><span class="line">                String tagName = parser.getName();</span><br><span class="line">                <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;package&quot;</span>)) &#123;</span><br><span class="line">                    readPackageLPw(parser);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;permissions&quot;</span>)) &#123;</span><br><span class="line">                    mPermissions.readPermissions(parser);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;permission-trees&quot;</span>)) &#123;</span><br><span class="line">                    mPermissions.readPermissionTrees(parser);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;shared-user&quot;</span>)) &#123;</span><br><span class="line">                    readSharedUserLPw(parser);</span><br><span class="line">                &#125; .....</span><br><span class="line"> </span><br><span class="line">            str.close();       </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> PackageSetting p = mPendingPackages.get(i);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> sharedUserId = p.getSharedUserId();</span><br><span class="line">            <span class="keyword">final</span> Object idObj = getSettingLPr(sharedUserId);</span><br><span class="line">            <span class="keyword">if</span> (idObj <span class="keyword">instanceof</span> SharedUserSetting) &#123;</span><br><span class="line">                <span class="comment">// 创建SharedUserSetting对象并添加到Settings的成员变量mSharedUsers中，</span></span><br><span class="line">                <span class="comment">// 在Android系统中，多个Package通过设置SharedUserId属性可以运行在同一个进程，共享同一个UID</span></span><br><span class="line">                <span class="keyword">final</span> SharedUserSetting sharedUser = (SharedUserSetting) idObj;</span><br><span class="line">                p.sharedUser = sharedUser;</span><br><span class="line">                p.appId = sharedUser.userId;</span><br><span class="line">                addPackageSettingLPw(p, sharedUser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：创建 SharedUserSetting 对象并添加到 Settings 的成员变量 mSharedUsers 中，在 Android 系统中，<br>多个 package 通过设置 sharedUserId 属性可以运行在同一个进程，共享同一个 UID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mSettings.addSharedUserLPw(<span class="string">&quot;android.uid.system&quot;</span>, <span class="comment">// 字符串</span></span><br><span class="line">                            Process.SYSTEM_UID, <span class="comment">//系统进程使用的用户id，值为1000</span></span><br><span class="line">                            ApplicationInfo.FLAG_SYSTEM, <span class="comment">//标志系统 Package</span></span><br><span class="line">                            ApplicationInfo.PRIVATE_FLAG_PRIVILEGED); <span class="comment">//特权系统应用  </span></span><br><span class="line"> </span><br><span class="line"> <span class="function">SharedUserSetting <span class="title">addSharedUserLPw</span><span class="params">(String name, <span class="keyword">int</span> uid, <span class="keyword">int</span> pkgFlags, <span class="keyword">int</span> pkgPrivateFlags)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// mSharedUsers是一个HashMap，key是字符串，值为 SharedUserSetting对象</span></span><br><span class="line">        SharedUserSetting s = mSharedUsers.get(name);</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.userId == uid) &#123;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            PackageManagerService.reportSettingsProblem(Log.ERROR,</span><br><span class="line">                    <span class="string">&quot;Adding duplicate shared user, keeping first: &quot;</span> + name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个 SharedUserSetting对象，并设置userId为UID</span></span><br><span class="line">        s = <span class="keyword">new</span> SharedUserSetting(name, pkgFlags, pkgPrivateFlags);</span><br><span class="line">        s.userId = uid;</span><br><span class="line">        <span class="keyword">if</span> (registerExistingAppIdLPw(uid, s, name)) &#123;</span><br><span class="line">            mSharedUsers.put(name, s);<span class="comment">// 将name与键值对添加到mSharedUsers中保存</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【总结回顾】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化PMS的各个子组件/子服务以及相关属性</span><br><span class="line">解析package.xml，获取已经安装的App信息，存储到Settings的mPackages中</span><br><span class="line">创建了后台工作线程及其Handler</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><blockquote>
<p>BOOT_PROGRESS_PMS_SYSTEM_SCAN_START 系统扫描阶段</p>
</blockquote>
<p>主要工作：<br>(1) 从init.rc中获取环境变量BOOTCLASSPATH和SYSTEMSERVERCLASSPATH；<br>(2) 对于旧版本升级的情况，将安装时获取权限变更为运行时申请权限；<br>(3) 扫描system/vendor/product/odm/oem等目录的priv-app、app、overlay包；<br>(4) 清除安装时临时文件以及其他不必要的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PackageManagerService</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 记录扫描开始时间</span></span><br><span class="line">           <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line"> </span><br><span class="line">           <span class="comment">// 第二阶段</span></span><br><span class="line">           EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,</span><br><span class="line">                    startTime);</span><br><span class="line">            <span class="comment">// 获取环境变量，init.rc</span></span><br><span class="line">            <span class="keyword">final</span> String bootClassPath = System.getenv(<span class="string">&quot;BOOTCLASSPATH&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> String systemServerClassPath = System.getenv(<span class="string">&quot;SYSTEMSERVERCLASSPATH&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取system/frameworks目录</span></span><br><span class="line">            File frameworkDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">&quot;framework&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取内部版本</span></span><br><span class="line">            <span class="keyword">final</span> VersionInfo ver = mSettings.getInternalVersion();</span><br><span class="line">            <span class="comment">// 判断fingerprint是否更新</span></span><br><span class="line">            mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);           </span><br><span class="line">            <span class="comment">// 对于Android M之前版本升级上来的情况，需要将系统应用程序权限从安装升级到运行时</span></span><br><span class="line">            mPromoteSystemApps =</span><br><span class="line">                    mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对于Android N之前版本升级上来的情况，需要像首次启动一样处理package</span></span><br><span class="line">            mIsPreNUpgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N;</span><br><span class="line"> </span><br><span class="line">            mIsPreNMR1Upgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.N_MR1;</span><br><span class="line">            mIsPreQUpgrade = mIsUpgrade &amp;&amp; ver.sdkVersion &lt; Build.VERSION_CODES.Q;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 在扫描之前保存预先存在的系统Package的名称，这样我们可以确定哪些系统包在升级后是全新的。</span></span><br><span class="line">            <span class="keyword">if</span> (isDeviceUpgrading()) &#123;</span><br><span class="line">                mExistingPackages = <span class="keyword">new</span> ArraySet&lt;&gt;(mSettings.mPackages.size());</span><br><span class="line">                <span class="keyword">for</span> (PackageSetting ps : mSettings.mPackages.values()) &#123;</span><br><span class="line">                    mExistingPackages.add(ps.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 准备解析Package的缓存</span></span><br><span class="line">            mCacheDir = preparePackageParserCache();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Set flag to monitor and not change apk file paths when</span></span><br><span class="line">            <span class="comment">// scanning install directories.</span></span><br><span class="line">            <span class="comment">// 设置Flag，而不在扫描安装时更改文件路径</span></span><br><span class="line">            <span class="keyword">int</span> scanFlags = SCAN_BOOTING | SCAN_INITIAL;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 在Android 11.0 中，此处会扫描以下路径</span></span><br><span class="line">            <span class="comment">//扫描以下路径：/vendor/overlay、/product/overlay、/product_services/overlay、                  </span></span><br><span class="line">            <span class="comment">// /odm/overlay、/oem/overlay、/system/framework、/system/priv-app、</span></span><br><span class="line">            <span class="comment">// /system/app、/vendor/priv-app、/vendor/app、/odm/priv-app、/odm/app、</span></span><br><span class="line">            <span class="comment">// /oem/app、/oem/priv-app、/product/priv-app、/product/app、</span></span><br><span class="line">            <span class="comment">// /product_services/priv-app、/product_services/app、</span></span><br><span class="line">            <span class="comment">// /product_services/priv-app</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mDirsToScanAsSystem.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> ScanPartition partition = mDirsToScanAsSystem.get(i);</span><br><span class="line">                <span class="keyword">if</span> (partition.getOverlayFolder() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 扫描overlay包</span></span><br><span class="line">                scanDirTracedLI(partition.getOverlayFolder(), systemParseFlags,</span><br><span class="line">                        systemScanFlags | partition.scanFlag, <span class="number">0</span>,</span><br><span class="line">                        packageParser, executorService);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            scanDirTracedLI(frameworkDir, systemParseFlags,</span><br><span class="line">                    systemScanFlags | SCAN_NO_DEX | SCAN_AS_PRIVILEGED, <span class="number">0</span>,</span><br><span class="line">                    packageParser, executorService);</span><br><span class="line">            <span class="keyword">if</span> (!mPackages.containsKey(<span class="string">&quot;android&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;Failed to load frameworks package; check log for warnings&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = mDirsToScanAsSystem.size(); i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ScanPartition partition = mDirsToScanAsSystem.get(i);</span><br><span class="line">                <span class="keyword">if</span> (partition.getPrivAppFolder() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 扫描priv-app路径</span></span><br><span class="line">                    scanDirTracedLI(partition.getPrivAppFolder(), systemParseFlags,</span><br><span class="line">                            systemScanFlags | SCAN_AS_PRIVILEGED | partition.scanFlag, <span class="number">0</span>,</span><br><span class="line">                            packageParser, executorService);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 扫描app路径</span></span><br><span class="line">                scanDirTracedLI(partition.getAppFolder(), systemParseFlags,</span><br><span class="line">                        systemScanFlags | partition.scanFlag, <span class="number">0</span>,</span><br><span class="line">                        packageParser, executorService);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 删掉不存在的package</span></span><br><span class="line">            <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">                <span class="comment">// do this first before mucking with mPackages for the &quot;expecting better&quot; case</span></span><br><span class="line">                <span class="keyword">final</span> Iterator&lt;AndroidPackage&gt; pkgIterator = mPackages.values().iterator();</span><br><span class="line">                <span class="comment">// 这里把mSettings.mPackages（也就是packages.xml文件中读取的记录）和mPackages（实时扫描得到的记录）做比较，看看有哪些变化 </span></span><br><span class="line">                 <span class="comment">// 有变化的情况往往是OTA升级</span></span><br><span class="line">                <span class="keyword">while</span> (pkgIterator.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> AndroidPackage pkg = pkgIterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (pkg.isStub()) &#123;</span><br><span class="line">                        stubSystemApps.add(pkg.getPackageName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">final</span> Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</span><br><span class="line">                <span class="keyword">while</span> (psit.hasNext()) &#123;</span><br><span class="line">                    PackageSetting ps = psit.next();</span><br><span class="line">                    <span class="comment">// 非系统App跳过</span></span><br><span class="line">                    <span class="comment">// 如果不是系统应用，则不被允许禁用其他应用</span></span><br><span class="line">                    <span class="keyword">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果应用被扫描，则不允许被擦除</span></span><br><span class="line">                    <span class="keyword">final</span> AndroidPackage scannedPkg = mPackages.get(ps.name);</span><br><span class="line">                    <span class="keyword">if</span> (scannedPkg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       </span><br><span class="line">                        <span class="comment">// 如果系统应用被扫描，且存在于disable应用列表中，那它一定是通过OTA添加的</span></span><br><span class="line">                        <span class="keyword">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                            logCriticalInfo(Log.WARN,</span><br><span class="line">                                    <span class="string">&quot;Expecting better updated system app for &quot;</span> + ps.name</span><br><span class="line">                                    + <span class="string">&quot;; removing system app.  Last known&quot;</span></span><br><span class="line">                                    + <span class="string">&quot; codePath=&quot;</span> + ps.codePathString</span><br><span class="line">                                    + <span class="string">&quot;, versionCode=&quot;</span> + ps.versionCode</span><br><span class="line">                                    + <span class="string">&quot;; scanned versionCode=&quot;</span> + scannedPkg.getLongVersionCode());</span><br><span class="line">                            removePackageLI(scannedPkg, <span class="keyword">true</span>);</span><br><span class="line">                            mExpectingBetter.put(ps.name, ps.codePath);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 删除没有关联应用的共享UID标识</span></span><br><span class="line">            mSettings.pruneSharedUsersLPw();</span><br><span class="line">            </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>分析上面调用的 scanDirTracedLI</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirTracedLI</span><span class="params">(File scanDir, <span class="keyword">final</span> <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">long</span> currentTime, PackageParser2 packageParser, ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;scanDir [&quot;</span> + scanDir.getAbsolutePath() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这个方法几乎没有做其他的事情，除了日志，就是直接调用scanDirLI</span></span><br><span class="line">        scanDirLI(scanDir, parseFlags, scanFlags, currentTime, packageParser, executorService);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirLI</span><span class="params">(File scanDir, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime,</span></span></span><br><span class="line"><span class="params"><span class="function">        PackageParser2 packageParser, ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> File[] files = scanDir.listFiles();</span><br><span class="line">    <span class="comment">// 空文件夹直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (ArrayUtils.isEmpty(files)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;No files in app dir &quot;</span> + scanDir);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Scanning app dir &quot;</span> + scanDir + <span class="string">&quot; scanFlags=&quot;</span> + scanFlags</span><br><span class="line">                + <span class="string">&quot; flags=0x&quot;</span> + Integer.toHexString(parseFlags));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把传进来的PackageParser2对象和线程池封装成ParallelPackageParser对象</span></span><br><span class="line">    ParallelPackageParser parallelPackageParser =</span><br><span class="line">            <span class="keyword">new</span> ParallelPackageParser(packageParser, executorService);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fileCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isPackage = (isApkFile(file) || file.isDirectory())</span><br><span class="line">                &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line">        <span class="keyword">if</span> (!isPackage) &#123;</span><br><span class="line">            <span class="comment">// Ignore entries which are not packages</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析包的关键代码</span></span><br><span class="line">        parallelPackageParser.submit(file, parseFlags);</span><br><span class="line">        fileCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析完成之后，取出结果挨个处理</span></span><br><span class="line">    <span class="keyword">for</span> (; fileCount &gt; <span class="number">0</span>; fileCount--) &#123;</span><br><span class="line">        ParallelPackageParser.ParseResult parseResult = parallelPackageParser.take();</span><br><span class="line">        Throwable throwable = parseResult.throwable;</span><br><span class="line">        <span class="keyword">int</span> errorCode = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// TODO(toddke): move lower in the scan chain</span></span><br><span class="line">            <span class="comment">// Static shared libraries have synthetic package names</span></span><br><span class="line">            <span class="keyword">if</span> (parseResult.parsedPackage.isStaticSharedLibrary()) &#123;</span><br><span class="line">                renameStaticSharedLibraryPackage(parseResult.parsedPackage);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//  addForInitLI --&gt; commitReconciledScanResultLocked --&gt; commitPackageSettings --&gt; </span></span><br><span class="line">               <span class="comment">// 更新mSettings中相关包的数据</span></span><br><span class="line">                <span class="comment">// 把包的信息存储到mPackages里面</span></span><br><span class="line">                addForInitLI(parseResult.parsedPackage, parseFlags, scanFlags,</span><br><span class="line">                        currentTime, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除无效的用户App</span></span><br><span class="line">        <span class="keyword">if</span> ((scanFlags &amp; SCAN_AS_SYSTEM) == <span class="number">0</span></span><br><span class="line">                &amp;&amp; errorCode != PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">            logCriticalInfo(Log.WARN,</span><br><span class="line">                    <span class="string">&quot;Deleting invalid package at &quot;</span> + parseResult.scanFile);</span><br><span class="line">            removeCodePathLI(parseResult.scanFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上函数的【总结回顾】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过ParallelPackageParser解析扫描目录下的包</span><br><span class="line">取出解析结果，执行addForInitLI</span><br><span class="line">删除无效的用户App</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【总结回顾】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扫描各个系统分区的的App</span><br><span class="line">解析系统App信息</span><br><span class="line">把解析结果存储起来，存储在PMS的相关属性和mSettings里</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h4><blockquote>
<p>BOOT_PROGRESS_PMS_DATA_SCAN_START Data扫描阶段<br>扫描/data/app下的App，也就是用户安装的App</p>
</blockquote>
<p>主要工作<br>对于不仅仅解析核心应用的情况下，还处理data目录的应用信息，及时更新，去除不必要的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PackageManagerService.packageManagerService()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">    <span class="comment">// 第三阶段</span></span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</span><br><span class="line">                        SystemClock.uptimeMillis());         </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 扫描用户安装的App，/data/app目录</span></span><br><span class="line">    scanDirTracedLI(sAppInstallDir, <span class="number">0</span>, scanFlags | SCAN_REQUIRE_KNOWN, <span class="number">0</span>,</span><br><span class="line">            packageParser, executorService);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 移除通过OTA删除的更新系统应用程序的禁用package设置</span></span><br><span class="line">    <span class="comment">// 如果更新不存在，则完全删除该应用。否则，撤销其系统权限</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = possiblyDeletedUpdatedSystemApps.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">         <span class="keyword">final</span> String packageName = possiblyDeletedUpdatedSystemApps.get(i);</span><br><span class="line">         <span class="keyword">final</span> AndroidPackage pkg = mPackages.get(packageName);</span><br><span class="line">         <span class="keyword">final</span> String msg;</span><br><span class="line"> </span><br><span class="line">         mSettings.removeDisabledSystemPackageLPw(packageName);</span><br><span class="line">        </span><br><span class="line">         .....</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line">                </span><br><span class="line">     <span class="comment">// 确保期望在userdata分区上显示的所有系统应用程序实际显示了。</span></span><br><span class="line">     <span class="comment">// 如果从未出现过，需要回滚以恢复系统版本</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mExpectingBetter.size(); i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> String packageName = mExpectingBetter.keyAt(i);</span><br><span class="line">         <span class="keyword">if</span> (!mPackages.containsKey(packageName)) &#123;</span><br><span class="line">                        </span><br><span class="line">             mSettings.enableSystemPackageLPw(packageName);</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 扫描APK</span></span><br><span class="line">                  scanPackageTracedLI(scanFile, reparseFlags, rescanFlags, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">                  Slog.e(TAG, <span class="string">&quot;Failed to parse original system package: &quot;</span></span><br><span class="line">                                    + e.getMessage());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 解压缩并安装任何存根系统应用程序。必须最后执行此操作以确保禁用或替换所有存根</span></span><br><span class="line">      installSystemStubPackages(stubSystemApps, scanFlags);</span><br><span class="line">                </span><br><span class="line">      ......</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Resolve the storage manager.</span></span><br><span class="line">      <span class="comment">// 获取Storage manager包名</span></span><br><span class="line">      mStorageManagerPackage = getStorageManagerPackageName();</span><br><span class="line">            </span><br><span class="line">      <span class="comment">// 解决受保护的action过滤器。只允许setup wizard(开机向导)为这些action设置高优先级过滤器</span></span><br><span class="line">      mSetupWizardPackage = getSetupWizardPackageNameImpl();</span><br><span class="line">            </span><br><span class="line">      <span class="comment">// 更新客户端，以确保持有正确的共享库路径</span></span><br><span class="line">      updateAllSharedLibrariesLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, Collections.unmodifiableMap(mPackages));</span><br><span class="line"> </span><br><span class="line">      ......</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 读取并更新要保留的package的上次使用时间</span></span><br><span class="line">      mPackageUsage.read(mSettings.mPackages);</span><br><span class="line">      mCompilerStats.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【总结回顾】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里就是对/data/app进行了扫描，主要工作与扫描系统App目录是一样的，只是细节处理上有些不同。初次之外还做了一些扫尾工作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="阶段四"><a href="#阶段四" class="headerlink" title="阶段四"></a>阶段四</h4><blockquote>
<p>BOOT_PROGRESS_PMS_SCAN_END  扫描结束</p>
</blockquote>
<p>主要工作：<br>(1) sdk版本变更，更新权限；<br>(2) OTA升级后首次启动，清除不必要的缓存数据；<br>(3) 权限等默认项更新完后，清理相关数据；<br>(4) 更新package.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PackageManagerService.packageManager()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第四阶段</span></span><br><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,SystemClock.uptimeMillis());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果SDK版本发生了变化（升级系统），重新对App进行授权</span></span><br><span class="line"><span class="comment">// 如果自上次启动以来，平台SDK已改变，则需要重新授予应用程序权限以捕获出现的任何新权限</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> sdkUpdated = (ver.sdkVersion != mSdkVersion);</span><br><span class="line"><span class="keyword">if</span> (sdkUpdated) &#123;</span><br><span class="line">   </span><br><span class="line">     mPermissionManager.updateAllPermissions(StorageManager.UUID_PRIVATE_INTERNAL, sdkUpdated);</span><br><span class="line">     ver.sdkVersion = mSdkVersion;</span><br><span class="line">            </span><br><span class="line">      <span class="comment">// 如果是首次启动或者从6.0以前的系统升级，初始化用户首选App</span></span><br><span class="line">     <span class="comment">// 如果这是第一次启动或这是来自Android M之前的版本升级，并且它是正常启动，</span></span><br><span class="line">     <span class="comment">// 那需要在所有已定义的用户初始化默认的首选应用程序</span></span><br><span class="line">     <span class="keyword">if</span> (!mOnlyCore &amp;&amp; (mPromoteSystemApps || mFirstBoot)) &#123;</span><br><span class="line">          <span class="keyword">for</span> (UserInfo user : mInjector.getUserManagerInternal().getUsers(<span class="keyword">true</span>)) &#123;</span><br><span class="line">                mSettings.applyDefaultPreferredAppsLPw(user.id);</span><br><span class="line">                primeDomainVerificationsLPw(user.id);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 为系统用户准备存储空间，因为SettingsProvider和SystemUI等核心系统App不可能等用户去启动</span></span><br><span class="line">     <span class="comment">// 在启动期间尽早为系统用户准备存储，因为像SettingsProvider和systemUI这样的核心系统应用程序无法等待用户启动</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> storageFlags;</span><br><span class="line">     <span class="keyword">if</span> (StorageManager.isFileEncryptedNativeOrEmulated()) &#123;</span><br><span class="line">          storageFlags = StorageManager.FLAG_STORAGE_DE;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          storageFlags = StorageManager.FLAG_STORAGE_DE | StorageManager.FLAG_STORAGE_CE;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果是升级后第一次正常启动，需要清除代码缓存，但不是会清除应用的配置文件</span></span><br><span class="line">     <span class="comment">// 如果是在OTA之后首次启动，并且正常启动，那需要清除代码缓存目录，但不清除应用程序配置文件</span></span><br><span class="line">     <span class="keyword">if</span> (mIsUpgrade &amp;&amp; !mOnlyCore) &#123;</span><br><span class="line">         Slog.i(TAG, <span class="string">&quot;Build fingerprint changed; clearing code caches&quot;</span>);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mSettings.mPackages.size(); i++) &#123;</span><br><span class="line">              <span class="keyword">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">              <span class="keyword">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</span><br><span class="line">                  <span class="comment">// No apps are running this early, so no need to freeze</span></span><br><span class="line">                  clearAppDataLIF(ps.pkg, UserHandle.USER_ALL, FLAG_STORAGE_DE | FLAG_STORAGE_CE | FLAG_STORAGE_EXTERNAL | Installer.FLAG_CLEAR_CODE_CACHE_ONLY</span><br><span class="line">| Installer.FLAG_CLEAR_APP_DATA_KEEP_ART_PROFILES);</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">              ver.fingerprint = Build.FINGERPRINT;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 安装Android-Q前的非系统应用程序在Luncher中隐藏他们的图标</span></span><br><span class="line">     <span class="keyword">if</span> (!mOnlyCore &amp;&amp; mIsPreQUpgrade) &#123;</span><br><span class="line">         Slog.i(TAG, <span class="string">&quot;Whitelisting all existing apps to hide their icons&quot;</span>);</span><br><span class="line">         <span class="keyword">int</span> size = mSettings.mPackages.size();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">              <span class="keyword">final</span> PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">              <span class="keyword">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) != <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">                    </span><br><span class="line">              ps.disableComponentLPw(PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME,</span><br><span class="line">                     UserHandle.USER_SYSTEM);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 仅在权限或其他默认配置更新后清除</span></span><br><span class="line">     mPromoteSystemApps = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// All the changes are done during package scanning.</span></span><br><span class="line">     <span class="comment">// 所有变化都在扫描过程中完成</span></span><br><span class="line">     ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 把更新后的mSettings中更新后的相关信息写入packages.xml等对应文件中 </span></span><br><span class="line">    mSettings.writeLPr();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【总结回顾】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果SDK版本发生了变化（升级系统），重新对App进行授权</span><br><span class="line">为系统核心服务准备存储空间</span><br><span class="line">如果是升级后第一次正常启动，需要清除代码缓存，但不是会清除应用的配置文件</span><br><span class="line">把更新后的信息写回对应的xml文件中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="阶段五"><a href="#阶段五" class="headerlink" title="阶段五"></a>阶段五</h4><blockquote>
<p>BOOT_PROGRESS_PMS_READY 就绪阶段</p>
</blockquote>
<p>主要工作：<br>(1)创建PackageInstallerService对象<br>(2)GC回收内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第五阶段</span></span><br><span class="line">EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,</span><br><span class="line">         SystemClock.uptimeMillis());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// PermissionController 包含磨人的授予和角色管理，所以它是一个核心系统的关键部分</span></span><br><span class="line">mRequiredPermissionControllerPackage = getRequiredPermissionControllerLPr();</span><br><span class="line">            </span><br><span class="line">.......</span><br><span class="line"> </span><br><span class="line">updateInstantAppInstallerLocked(<span class="keyword">null</span>);</span><br><span class="line">           </span><br><span class="line"><span class="comment">// 阅读并更新dex文件的用法</span></span><br><span class="line"><span class="comment">// 在 PM init结束时执行此操作，以便所有程序包都已协调其数据目录</span></span><br><span class="line"><span class="comment">// 此时知道了包的代码路径，因此可以验证磁盘文件并构建内部缓存</span></span><br><span class="line"><span class="comment">// 使用文件预计很小，因为与其他活动(例如包扫描)相比，加载和验证它应该花费相当小的时间</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;Integer, List&lt;PackageInfo&gt;&gt; userPackages = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> userId : userIds) &#123;</span><br><span class="line">     userPackages.put(userId, getInstalledPackages(<span class="comment">/*flags*/</span> <span class="number">0</span>, userId).getList());</span><br><span class="line">&#125;</span><br><span class="line">mDexManager.load(userPackages);</span><br><span class="line"><span class="keyword">if</span> (mIsUpgrade) &#123;</span><br><span class="line">    FrameworkStatsLog.write(</span><br><span class="line">    FrameworkStatsLog.BOOT_TIME_EVENT_DURATION_REPORTED,</span><br><span class="line">                 BOOT_TIME_EVENT_DURATION__EVENT__OTA_PACKAGE_MANAGER_INIT_TIME,</span><br><span class="line">                 SystemClock.uptimeMillis() - startTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// synchronized (mLock)</span></span><br><span class="line">&#125; <span class="comment">// synchronized (mInstallLock)</span></span><br><span class="line">        </span><br><span class="line">......        </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 打开应用之后，及时的回收处理</span></span><br><span class="line">Runtime.getRuntime().gc();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【总结回顾】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对一些属性进行了赋值，最重要的是初始化PackageInstallerService。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="五阶段总结"><a href="#五阶段总结" class="headerlink" title="五阶段总结"></a>五阶段总结</h4><p>阶段一：开始阶段：BOOT_PROGRESS_PMS_START。这个阶段的主要工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一件事：初始化PMS的各个子组件/子服务以及相关属性</span><br><span class="line">第二件事：解析package.xml，获取已经安装的App信息，存储到Settings的mPackages中</span><br><span class="line">第三件事：创建了后台工作线程及其Handler</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>阶段二：系统扫描阶段：BOOT_PROGRESS_PMS_SYSTEM_SCAN_START。这个阶段的主要工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一件事：扫描各个系统分区的的App</span><br><span class="line">第二件事：解析系统App信息</span><br><span class="line">第三件事：把解析结果存储起来，存储在PMS的相关属性和mSettings里</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>阶段三：Data扫描阶段：BOOT_PROGRESS_PMS_DATA_SCAN_START。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个阶段对/data/app进行了扫描，主要工作与扫描系统App目录是一样的，</span><br><span class="line">只是细节处理上有些不同。初次之外还做了一些扫尾工作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>阶段四：扫描结束：BOOT_PROGRESS_PMS_SCAN_END。这个阶段主要工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一件事：如果SDK版本发生了变化（升级系统），重新对App进行授权</span><br><span class="line">第二件事：为系统核心服务准备存储空间</span><br><span class="line">第三件事：如果是升级后第一次正常启动，需要清除代码缓存，但不是会清除应用的配置文件</span><br><span class="line">第四讲事：把更新后的信息写回对应的xml文件中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>阶段五：就绪阶段：BOOT_PROGRESS_PMS_READY。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个阶段又对一些属性进行了赋值，最重要的是初始化PackageInstallerService</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="PKMS构建成功之后"><a href="#PKMS构建成功之后" class="headerlink" title="PKMS构建成功之后"></a>PKMS构建成功之后</h2><p>在SystemServer中，PMS构建完成之后，仍然后一些额外的操作(通过查找mPackageManagerService看它在哪些地方用到了)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">(<span class="meta">@NonNull</span> TimingsTraceAndSlog t)</span> </span>&#123;</span><br><span class="line">    t.traceBegin(<span class="string">&quot;startOtherServices&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 优化Dex</span></span><br><span class="line">        mPackageManagerService.updatePackagesIfNeeded();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.traceBegin(<span class="string">&quot;PerformFstrimIfNeeded&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 磁盘清理</span></span><br><span class="line">        mPackageManagerService.performFstrimIfNeeded();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">&quot;performing fstrim&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    t.traceEnd();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    t.traceBegin(<span class="string">&quot;MakePackageManagerServiceReady&quot;</span>);</span><br><span class="line">    <span class="comment">// 通知mPackageManagerService及其子组件系统已就绪</span></span><br><span class="line">    mPackageManagerService.systemReady();</span><br><span class="line">    t.traceEnd();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We now tell the activity manager it is okay to run third party</span></span><br><span class="line">    <span class="comment">// code.  It will call back into us once it has gotten to the state</span></span><br><span class="line">    <span class="comment">// where third party code can really run (but before it has actually</span></span><br><span class="line">    <span class="comment">// started launching the initial applications), for us to complete our</span></span><br><span class="line">    <span class="comment">// initialization.</span></span><br><span class="line">    mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待PMS中为App的启动做好准备工作</span></span><br><span class="line">        mPackageManagerService.waitForAppDataPrepared();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;, t);</span><br><span class="line"></span><br><span class="line">    t.traceEnd(); <span class="comment">// startOtherServices</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【总结回顾】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在startOtherServices中，PKMS做了几件事情：</span><br><span class="line">在需要的情况下进行dex优化</span><br><span class="line">在需要的情况下进行磁盘清理</span><br><span class="line">通知PMS及其子组件系统已就绪</span><br><span class="line">ActivityManagerService启动Launcher之前等待PMS中为App的启动做好准备工作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="简述总结"><a href="#简述总结" class="headerlink" title="简述总结"></a>简述总结</h2><p>总的来说，PMS在SystemServer里面创建，并向ServiceManager注册。<br>其创建过程分为五个阶段，在此过程中会从packages.xml等相关文件中读取上次保存的包列表和实时扫描的列表进行比较和更新，<br>处理升级事宜，最后把更新后的包列表重新持久化。<br>另外，创建完成之后还进行了一些dex优化、磁盘清理等等一些列额外操作。</p>
<h1 id="APK的扫描"><a href="#APK的扫描" class="headerlink" title="APK的扫描"></a>APK的扫描</h1><p>PKMS的构造函数中调用了 <strong>scanDirTracedLI</strong>方法 来扫描某个目录的apk文件。 </p>
<p>APK的扫描，整体描述图：</p>
<p><img src="/images/android_pms_06.png" alt="image"></p>
<p>PKMS.<strong>scanDirTracedLi</strong>：首先加入了一些systtrace的日志追踪，然后调用scanDirLI()进行分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirTracedLI</span><span class="params">(File scanDir, <span class="keyword">final</span> <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;scanDir [&quot;</span> + scanDir.getAbsolutePath() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 【注意】会调用此 scanDirLI函数</span></span><br><span class="line">        scanDirLI(scanDir, parseFlags, scanFlags, currentTime);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>PKMS.<strong>scanDirLI</strong>： 使用了ParallelPackageParser的对象，ParallelPackageParser是一个队列，我们这里手机所有系统的apk，然后从这些队列里面取出apk，再调用<strong>PackageParser</strong> 解析进行解析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirLI</span><span class="params">(File scanDir, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> File[] files = scanDir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (ArrayUtils.isEmpty(files)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;No files in app dir &quot;</span> + scanDir);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Scanning app dir &quot;</span> + scanDir + <span class="string">&quot; scanFlags=&quot;</span> + scanFlags</span><br><span class="line">                + <span class="string">&quot; flags=0x&quot;</span> + Integer.toHexString(parseFlags));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// parallelPackageParser是一个队列，收集系统 apk 文件，</span></span><br><span class="line">    <span class="comment">// 然后从这个队列里面一个个取出 apk ，调用 PackageParser 解析</span></span><br><span class="line">     <span class="keyword">try</span> (ParallelPackageParser parallelPackageParser = <span class="keyword">new</span> ParallelPackageParser(</span><br><span class="line">            mSeparateProcesses, mOnlyCore, mMetrics, mCacheDir,</span><br><span class="line">            mParallelPackageParserCallback)) &#123;</span><br><span class="line">        <span class="comment">// Submit files for parsing in parallel</span></span><br><span class="line">        <span class="keyword">int</span> fileCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">// 是Apk文件，或者是目录</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isPackage = (isApkFile(file) || file.isDirectory())</span><br><span class="line">                    &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line">            过滤掉非　apk　文件，如果不是则跳过继续扫描</span><br><span class="line">            <span class="keyword">if</span> (!isPackage) &#123;</span><br><span class="line">                <span class="comment">// Ignore entries which are not packages</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把APK信息存入parallelPackageParser中的对象mQueue，PackageParser()函数赋给了队列中的pkg成员</span></span><br><span class="line">            <span class="comment">// 【们注意】 这里的 submit 函数 很重要，下面就会分析此函数</span></span><br><span class="line">            parallelPackageParser.submit(file, parseFlags);</span><br><span class="line">            fileCount++;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Process results one by one</span></span><br><span class="line">        <span class="keyword">for</span> (; fileCount &gt; <span class="number">0</span>; fileCount--) &#123;</span><br><span class="line">        <span class="comment">// 从parallelPackageParser中取出队列apk的信息</span></span><br><span class="line">            ParallelPackageParser.ParseResult parseResult = parallelPackageParser.take();</span><br><span class="line">            Throwable throwable = parseResult.throwable;</span><br><span class="line">            <span class="keyword">int</span> errorCode = PackageManager.INSTALL_SUCCEEDED;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// TODO(toddke): move lower in the scan chain</span></span><br><span class="line">                <span class="comment">// Static shared libraries have synthetic package names</span></span><br><span class="line">                <span class="keyword">if</span> (parseResult.pkg.applicationInfo.isStaticSharedLibrary()) &#123;</span><br><span class="line">                    renameStaticSharedLibraryPackage(parseResult.pkg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调用 scanPackageChildLI 方法扫描一个特定的 apk 文件</span></span><br><span class="line">                    <span class="comment">// 该类的实例代表一个 APK 文件，所以它就是和 apk 文件对应的数据结构。</span></span><br><span class="line">                    scanPackageChildLI(parseResult.pkg, parseFlags, scanFlags,</span><br><span class="line">                            currentTime, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">                    errorCode = e.error;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Failed to scan &quot;</span> + parseResult.scanFile + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> PackageParser.PackageParserException) &#123;</span><br><span class="line">                PackageParser.PackageParserException e = (PackageParser.PackageParserException)</span><br><span class="line">                        throwable;</span><br><span class="line">                errorCode = e.error;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Failed to parse &quot;</span> + parseResult.scanFile + <span class="string">&quot;: &quot;</span> + e.getMessage());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected exception occurred while parsing &quot;</span></span><br><span class="line">                        + parseResult.scanFile, throwable);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Delete invalid userdata apps</span></span><br><span class="line">            <span class="comment">//如果是非系统 apk 并且解析失败</span></span><br><span class="line">            <span class="keyword">if</span> ((scanFlags &amp; SCAN_AS_SYSTEM) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    errorCode != PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                logCriticalInfo(Log.WARN,</span><br><span class="line">                        <span class="string">&quot;Deleting invalid package at &quot;</span> + parseResult.scanFile);</span><br><span class="line">                 <span class="comment">// 非系统 Package 扫描失败，删除文件</span></span><br><span class="line">                removeCodePathLI(parseResult.scanFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ParallelPackageParser.<strong>submit</strong> : </p>
<p>把扫描路径中的APK等内容，放入队列mQueue，</p>
<p>并把parsePackage() pp 赋给ParseResult，用于后面的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(File scanFile, <span class="keyword">int</span> parseFlags)</span> </span>&#123;</span><br><span class="line">    mService.submit(() -&gt; &#123;</span><br><span class="line">        ParseResult pr = <span class="keyword">new</span> ParseResult();</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;parallel parsePackage [&quot;</span> + scanFile + <span class="string">&quot;]&quot;</span>); <span class="comment">// 日志打印</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PackageParser pp = <span class="keyword">new</span> PackageParser();</span><br><span class="line">            pp.setSeparateProcesses(mSeparateProcesses);</span><br><span class="line">            pp.setOnlyCoreApps(mOnlyCore);</span><br><span class="line">            pp.setDisplayMetrics(mMetrics);</span><br><span class="line">            pp.setCacheDir(mCacheDir);</span><br><span class="line">            pp.setCallback(mPackageParserCallback);</span><br><span class="line">            pr.scanFile = scanFile;</span><br><span class="line">            <span class="comment">// 并把parsePackage()与pp 赋值ParseResult，用于后面的调用</span></span><br><span class="line">            pr.pkg = parsePackage(pp, scanFile, parseFlags); <span class="comment">// 【注意】parsePackage下面会分析</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            pr.throwable = e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把扫描路径中的APK等内容，放入队列mQueue</span></span><br><span class="line">            mQueue.put(pr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="comment">// Propagate result to callers of take().</span></span><br><span class="line">            <span class="comment">// This is helpful to prevent main thread from getting stuck waiting on</span></span><br><span class="line">            <span class="comment">// ParallelPackageParser to finish in case of interruption</span></span><br><span class="line">            mInterruptedInThread = Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过 PackageParser.<strong>parsePackage</strong> 进行apk解析：</p>
<p>​        如果传入的packageFile是目录，        调用parseClusterPackage()解析</p>
<p>​        如果传入的packageFile是APK文件， 调用parseMonolithicPackage()解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">parsePackage</span><span class="params">(File packageFile, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> useCaches)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">if</span> (packageFile.isDirectory()) &#123;</span><br><span class="line">    <span class="comment">//如果传入的packageFile是目录，调用parseClusterPackage()解析</span></span><br><span class="line">        parsed = parseClusterPackage(packageFile, flags);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果是APK文件，就调用parseMonolithicPackage()解析</span></span><br><span class="line">        parsed = parseMonolithicPackage(packageFile, flags);  <span class="comment">// 【注意】下面我们分析此函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">return</span> parsed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>PackageParser.<strong>parseMonolithicPackage</strong>()，它的作用是解析给定的APK文件，将其作为单个单块包处理，最终调用parseBaseApk()进行解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Package <span class="title">parseMonolithicPackage</span><span class="params">(File apkFile, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PackageLite lite = parseMonolithicPackageLite(apkFile, flags);</span><br><span class="line">    <span class="keyword">if</span> (mOnlyCoreApps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lite.coreApp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED,</span><br><span class="line">                    <span class="string">&quot;Not a coreApp: &quot;</span> + apkFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> SplitAssetLoader assetLoader = <span class="keyword">new</span> DefaultSplitAssetLoader(lite, flags);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 对核心应用解析 【注意】 最终调用parseBaseApk()进行解析，我们下面来分析</span></span><br><span class="line">        <span class="keyword">final</span> Package pkg = parseBaseApk(apkFile, assetLoader.getBaseAssetManager(), flags);</span><br><span class="line">        pkg.setCodePath(apkFile.getCanonicalPath());</span><br><span class="line">        pkg.setUse32bitAbi(lite.use32bitAbi);</span><br><span class="line">        <span class="keyword">return</span> pkg;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PackageParserException(INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION,</span><br><span class="line">                <span class="string">&quot;Failed to get path: &quot;</span> + apkFile, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(assetLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>PackageParser.<strong>parseBaseApk</strong>()主要是对AndroidManifest.xml进行解析，解析后所有的信息放在Package对象中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApk</span><span class="params">(File apkFile, AssetManager assets, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String apkPath = apkFile.getAbsolutePath();</span><br><span class="line"> 	 ...</span><br><span class="line">    XmlResourceParser parser = <span class="keyword">null</span>;</span><br><span class="line">  	...</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cookie = assets.findCookieForPath(apkPath);</span><br><span class="line">        <span class="keyword">if</span> (cookie == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PackageParserException(INSTALL_PARSE_FAILED_BAD_MANIFEST,</span><br><span class="line">                    <span class="string">&quot;Failed adding asset path: &quot;</span> + apkPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得一个 XML 资源解析对象，该对象解析的是 APK 中的 AndroidManifest.xml 文件。</span></span><br><span class="line">        parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</span><br><span class="line">        <span class="keyword">final</span> Resources res = <span class="keyword">new</span> Resources(assets, mMetrics, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> String[] outError = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">     </span><br><span class="line">    	<span class="comment">// 再调用重载函数parseBaseApk()最终到parseBaseApkCommon()，解析AndroidManifest.xml 后得到一个Package对象</span></span><br><span class="line">	    <span class="comment">// 【注意】解析后所有的信息放在Package对象中</span></span><br><span class="line">        <span class="keyword">final</span> Package pkg = parseBaseApk(apkPath, res, parser, flags, outError);</span><br><span class="line">    	...</span><br><span class="line">        pkg.setVolumeUuid(volumeUuid);</span><br><span class="line">        pkg.setApplicationVolumeUuid(volumeUuid);</span><br><span class="line">        pkg.setBaseCodePath(apkPath);</span><br><span class="line">        pkg.setSigningDetails(SigningDetails.UNKNOWN);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> pkg;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>parseBaseApk —–&gt;  <strong>parseBaseApkCommon</strong> ,   parseBaseApk省略了</p>
<p>PackageParser.<strong>parseBaseApkCommon</strong> 从AndroidManifest.xml中获取标签名，解析标签中的各个item的内容，存入Package对象中</p>
<p>例如：获取标签  “application”、”permission”、”package”、”manifest”   ，太多了，省略了哈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApkCommon</span><span class="params">(Package pkg, Set&lt;String&gt; acceptedTags, Resources res,</span></span></span><br><span class="line"><span class="params"><span class="function">        XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException,</span></span><br><span class="line"><span class="function">        IOException </span>&#123;</span><br><span class="line">  TypedArray sa = res.obtainAttributes(parser,</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifest);</span><br><span class="line">  <span class="comment">//拿到AndroidManifest.xml 中的sharedUserId, 一般情况下有“android.uid.system”等信息</span></span><br><span class="line">  String str = sa.getNonConfigurationString(</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifest_sharedUserId, <span class="number">0</span>);</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">    <span class="comment">//从AndroidManifest.xml中获取标签名</span></span><br><span class="line">    String tagName = parser.getName();</span><br><span class="line">    <span class="comment">//如果读到AndroidManifest.xml中的tag是&quot;application&quot;,执行parseBaseApplication()进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (tagName.equals(TAG_APPLICATION)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (foundApp) &#123;</span><br><span class="line">        ...</span><br><span class="line">            &#125;</span><br><span class="line">            foundApp = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">      		<span class="comment">// 解析&quot;application&quot;的信息，赋值给pkg </span></span><br><span class="line">        	<span class="comment">// 【注意】这里解析到的是&quot;application&quot; &lt;application 包含了 四大组件，下面分析此操作</span></span><br><span class="line">            <span class="keyword">if</span> (!parseBaseApplication(pkg, res, parser, flags, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//如果标签是&quot;permission&quot;</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(TAG_PERMISSION)) &#123;</span><br><span class="line">      		<span class="comment">//进行&quot;permission&quot;的解析</span></span><br><span class="line">            <span class="keyword">if</span> (!parsePermission(pkg, res, parser, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">     	 ....</span><br><span class="line">     &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面解析AndroidManifest.xml，会得到 “<strong>application</strong>“、”overlay”、”permission”、”uses-permission” 等信息</p>
<p>我们下面就针对”<strong>application</strong>“进行展开分析一下，进入 PackageParser.<strong>parseBaseApplication</strong>()函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseBaseApplication</span><span class="params">(Package owner, Resources res,</span></span></span><br><span class="line"><span class="params"><span class="function">            XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span></span></span><br><span class="line"><span class="function">  <span class="title">while</span> <span class="params">((type = parser.next()</span>) !</span>= XmlPullParser.END_DOCUMENT</span><br><span class="line">                &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123;</span><br><span class="line">    <span class="comment">// 获取&quot;application&quot;子标签的标签内容</span></span><br><span class="line">    String tagName = parser.getName();</span><br><span class="line">    <span class="comment">// 如果标签是&quot;activity&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;activity&quot;</span>)) &#123; <span class="comment">// 解析Activity的信息，把activity加入Package对象</span></span><br><span class="line">            Activity a = parseActivity(owner, res, parser, flags, outError, cachedArgs, <span class="keyword">false</span>,</span><br><span class="line">                    owner.baseHardwareAccelerated);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            hasActivityOrder |= (a.order != <span class="number">0</span>);</span><br><span class="line">            owner.activities.add(a);</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;receiver&quot;</span>)) &#123; <span class="comment">// 如果标签是&quot;receiver&quot;，获取receiver信息，加入Package对象</span></span><br><span class="line">            Activity a = parseActivity(owner, res, parser, flags, outError, cachedArgs, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            hasReceiverOrder |= (a.order != <span class="number">0</span>);</span><br><span class="line">            owner.receivers.add(a);</span><br><span class="line"> </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;service&quot;</span>)) &#123; <span class="comment">// 如果标签是&quot;service&quot;，获取service信息，加入Package对象</span></span><br><span class="line">            Service s = parseService(owner, res, parser, flags, outError, cachedArgs);</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            hasServiceOrder |= (s.order != <span class="number">0</span>);</span><br><span class="line">            owner.services.add(s);</span><br><span class="line"> </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">&quot;provider&quot;</span>)) &#123; <span class="comment">// 如果标签是&quot;provider&quot;，获取provider信息，加入Package对象</span></span><br><span class="line">            Provider p = parseProvider(owner, res, parser, flags, outError, cachedArgs);</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            owner.providers.add(p);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 PackageParser 扫描完一个 APK 后，此时系统已经根据该 APK 中 AndroidManifest.xml，创建了一个完整的 Package 对象</p>
<p><strong>APK的扫描，自我总结：</strong></p>
<p>第一步：扫描APK，解析AndroidManifest.xml文件，得到清单文件各个标签内容</p>
<p>第二步：解析清单文件到的信息由 Package 保存。从该类的成员变量可看出，和 Android 四大组件相关的信息分别由 activites、receivers、providers、services 保存，由于一个 APK 可声明多个组件，因此 activites 和 receivers等均声明为 ArrayList</p>
<h1 id="APK的安装"><a href="#APK的安装" class="headerlink" title="APK的安装"></a>APK的安装</h1><p>安装步骤一: 把Apk的信息通过IO流的形式写入到PackageInstaller.Session中 </p>
<p>安装步骤二: 调用PackageInstaller.Session的commit方法, 把Apk的信息交给PKMS处理</p>
<p>安装步骤三: 进行Apk的Copy操作, 进行安装</p>
<p><strong>安装的三步走, 整体描述图:</strong></p>
<p><img src="/images/android_pms_07.png" alt="image"></p>
<p>用户点击 xxx.apk 文件进行安装,   从 开始安装 到 完成安装 流程如下:</p>
<p><img src="/images/android_pms_08.png" alt="image"></p>
<p>APK的安装, 整体描述图:</p>
<p><img src="/images/android_pms_09.png" alt="image"></p>
<p>点击一个apk后，会弹出安装界面，点击确定按钮后，会进入<strong>PackageInstallerActivity</strong> 的 <strong>bindUi</strong>() 中的mAlert点击事件, 弹出的安装界面底部显示的是一个diaglog，主要由bindUi构成，上面有 ”<strong>取消</strong>“ 和 ”<strong>安装</strong>“ 两个按钮，点击安装后 调用startInstall()进行安装:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindUi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mAlert.setIcon(mAppSnippet.icon);</span><br><span class="line">    mAlert.setTitle(mAppSnippet.label);</span><br><span class="line">    mAlert.setView(R.layout.install_content_view);</span><br><span class="line">    mAlert.setButton(DialogInterface.BUTTON_POSITIVE, getString(R.string.install),</span><br><span class="line">            (ignored, ignored2) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (mOk.isEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mSessionId != -<span class="number">1</span>) &#123;</span><br><span class="line">                        mInstaller.setPermissionsResult(mSessionId, <span class="keyword">true</span>);</span><br><span class="line">                        finish();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        startInstall();  <span class="comment">// 进行APK安装  [注意] 下面开始分析 startInstall 做的事情</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">null</span>);</span><br><span class="line">    mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel),</span><br><span class="line">            (ignored, ignored2) -&gt; &#123;</span><br><span class="line">                <span class="comment">// Cancel and finish</span></span><br><span class="line">                setResult(RESULT_CANCELED);</span><br><span class="line">                <span class="keyword">if</span> (mSessionId != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果mSessionId存在，执行setPermissionsResult()完成取消安装</span></span><br><span class="line">                    mInstaller.setPermissionsResult(mSessionId, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                finish();</span><br><span class="line">            &#125;, <span class="keyword">null</span>);</span><br><span class="line">    setupAlert();</span><br><span class="line"> </span><br><span class="line">    mOk = mAlert.getButton(DialogInterface.BUTTON_POSITIVE);</span><br><span class="line">    mOk.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> <strong>startInstall</strong>方法组装了一个Intent，并跳转到 InstallInstalling 这个Activity，并关闭掉当前的PackageInstallerActivity。InstallInstalling主要用于向包管理器发送包的信息并处理包管理的回调:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Start subactivity to actually install the application</span></span><br><span class="line">    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">    newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO,</span><br><span class="line">            mPkgInfo.applicationInfo);</span><br><span class="line">    newIntent.setData(mPackageURI);</span><br><span class="line">    <span class="comment">// 设置Intent中的class为 InstallInstalling，用来进行Activity跳转</span></span><br><span class="line">    <span class="comment">// class InstallInstalling extends AlertActivity  [注意] 下面会分析 InstallInstalling Activity</span></span><br><span class="line">    newIntent.setClass(<span class="keyword">this</span>, InstallInstalling.class);</span><br><span class="line">    String installerPackageName = getIntent().getStringExtra(</span><br><span class="line">            Intent.EXTRA_INSTALLER_PACKAGE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (mOriginatingURI != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mReferrerURI != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mOriginatingUid != PackageInstaller.SessionParams.UID_UNKNOWN) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (installerPackageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME,</span><br><span class="line">                installerPackageName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line">    <span class="keyword">if</span>(localLOGV) Log.i(TAG, <span class="string">&quot;downloaded app uri=&quot;</span>+mPackageURI);</span><br><span class="line">    startActivity(newIntent);</span><br><span class="line">    finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>启动 <strong>InstallInstalling</strong>，进入onCreate, 重点是看onCreate函数中的<strong>六步</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"> </span><br><span class="line">    ApplicationInfo appInfo = getIntent()</span><br><span class="line">            .getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO);</span><br><span class="line">    mPackageURI = getIntent().getData();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(mPackageURI.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            getPackageManager().installExistingPackage(appInfo.packageName);</span><br><span class="line">            launchSuccess();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//根据mPackageURI创建一个对应的File</span></span><br><span class="line">        <span class="keyword">final</span> File sourceFile = <span class="keyword">new</span> File(mPackageURI.getPath());</span><br><span class="line">        PackageUtil.AppSnippet as = PackageUtil.getAppSnippet(<span class="keyword">this</span>, appInfo, sourceFile);</span><br><span class="line"> </span><br><span class="line">        mAlert.setIcon(as.icon);</span><br><span class="line">        mAlert.setTitle(as.label);</span><br><span class="line">        mAlert.setView(R.layout.install_content_view);</span><br><span class="line">        mAlert.setButton(DialogInterface.BUTTON_NEGATIVE, getString(R.string.cancel),</span><br><span class="line">                (ignored, ignored2) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mInstallingTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInstallingTask.cancel(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (mSessionId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        getPackageManager().getPackageInstaller().abandonSession(mSessionId);</span><br><span class="line">                        mSessionId = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    setResult(RESULT_CANCELED);</span><br><span class="line">                    finish();</span><br><span class="line">                &#125;, <span class="keyword">null</span>);</span><br><span class="line">        setupAlert();</span><br><span class="line">        requireViewById(R.id.installing).setVisibility(View.VISIBLE);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 第一步.如果savedInstanceState不为null，获取此前保存的mSessionId和mInstallId，其中mSessionId是安装包的会话id，mInstallId是等待的安装事件id</span></span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSessionId = savedInstanceState.getInt(SESSION_ID);</span><br><span class="line">            mInstallId = savedInstanceState.getInt(INSTALL_ID);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// Reregister for result; might instantly call back if result was delivered while</span></span><br><span class="line">            <span class="comment">// activity was destroyed</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 第二步.根据mInstallId向InstallEventReceiver注册一个观察者，launchFinishBasedOnResult会接收到安装事件的回调，</span></span><br><span class="line">                <span class="comment">//无论安装成功或者失败都会关闭当前的Activity(InstallInstalling)。如果savedInstanceState为null，代码的逻辑也是类似的</span></span><br><span class="line">                InstallEventReceiver.addObserver(<span class="keyword">this</span>, mInstallId,</span><br><span class="line">                        <span class="keyword">this</span>::launchFinishBasedOnResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (EventResultPersister.OutOfIdsException e) &#123;</span><br><span class="line">                <span class="comment">// Does not happen</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第三步.创建SessionParams，它用来代表安装会话的参数,组装params</span></span><br><span class="line">            PackageInstaller.SessionParams params = <span class="keyword">new</span> PackageInstaller.SessionParams(</span><br><span class="line">                    PackageInstaller.SessionParams.MODE_FULL_INSTALL);</span><br><span class="line">            params.setInstallAsInstantApp(<span class="keyword">false</span>);</span><br><span class="line">            params.setReferrerUri(getIntent().getParcelableExtra(Intent.EXTRA_REFERRER));</span><br><span class="line">            params.setOriginatingUri(getIntent()</span><br><span class="line">                    .getParcelableExtra(Intent.EXTRA_ORIGINATING_URI));</span><br><span class="line">            params.setOriginatingUid(getIntent().getIntExtra(Intent.EXTRA_ORIGINATING_UID,</span><br><span class="line">                    UID_UNKNOWN));</span><br><span class="line">            params.setInstallerPackageName(getIntent().getStringExtra(</span><br><span class="line">                    Intent.EXTRA_INSTALLER_PACKAGE_NAME));</span><br><span class="line">            params.setInstallReason(PackageManager.INSTALL_REASON_USER);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 第四步.根据mPackageUri对包（APK）进行轻量级的解析，并将解析的参数赋值给SessionParams</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(mPackageURI.getPath());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PackageParser.PackageLite pkg = PackageParser.parsePackageLite(file, <span class="number">0</span>);</span><br><span class="line">                params.setAppPackageName(pkg.packageName);</span><br><span class="line">                params.setInstallLocation(pkg.installLocation);</span><br><span class="line">                params.setSize(</span><br><span class="line">                        PackageHelper.calculateInstalledSize(pkg, <span class="keyword">false</span>, params.abiOverride));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageParser.PackageParserException e) &#123;</span><br><span class="line">                Log.e(LOG_TAG, <span class="string">&quot;Cannot parse package &quot;</span> + file + <span class="string">&quot;. Assuming defaults.&quot;</span>);</span><br><span class="line">                Log.e(LOG_TAG,</span><br><span class="line">                        <span class="string">&quot;Cannot calculate installed size &quot;</span> + file + <span class="string">&quot;. Try only apk size.&quot;</span>);</span><br><span class="line">                params.setSize(file.length());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(LOG_TAG,</span><br><span class="line">                        <span class="string">&quot;Cannot calculate installed size &quot;</span> + file + <span class="string">&quot;. Try only apk size.&quot;</span>);</span><br><span class="line">                params.setSize(file.length());</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 第五步.向InstallEventReceiver注册一个观察者返回一个新的mInstallId，</span></span><br><span class="line">                <span class="comment">//其中InstallEventReceiver继承自BroadcastReceiver，用于接收安装事件并回调给EventResultPersister。</span></span><br><span class="line">                mInstallId = InstallEventReceiver</span><br><span class="line">                        .addObserver(<span class="keyword">this</span>, EventResultPersister.GENERATE_NEW_ID,</span><br><span class="line">                                <span class="keyword">this</span>::launchFinishBasedOnResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (EventResultPersister.OutOfIdsException e) &#123;</span><br><span class="line">                launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 第六步.PackageInstaller的createSession方法内部会通过IPackageInstaller与PackageInstallerService进行进程间通信，</span></span><br><span class="line">                <span class="comment">//最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId</span></span><br><span class="line">                mSessionId = getPackageManager().getPackageInstaller().createSession(params);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        mCancelButton = mAlert.getButton(DialogInterface.BUTTON_NEGATIVE);</span><br><span class="line"> </span><br><span class="line">        mSessionCallback = <span class="keyword">new</span> InstallSessionCallback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: 以上<strong>第六步</strong>是重点 PackageInstaller 的 createSession()内部会通过IPackageInstaller与PackageInstallerService进行进程间通信，最终调用的是PackageInstallerService的createSession方法来创建并返回mSessionId</p>
<p><strong>InstallInstalling.onResume</strong>方法中，调用onPostExecute()方法，将APK的信息通过IO流的形式写入到PackageInstaller.Session中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line">    <span class="comment">// This is the first onResume in a single life of the activity</span></span><br><span class="line">    <span class="keyword">if</span> (mInstallingTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">        PackageInstaller installer = getPackageManager().getPackageInstaller();</span><br><span class="line">        <span class="comment">// 获取sessionInfo</span></span><br><span class="line">        PackageInstaller.SessionInfo sessionInfo = installer.getSessionInfo(mSessionId);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (sessionInfo != <span class="keyword">null</span> &amp;&amp; !sessionInfo.isActive()) &#123;</span><br><span class="line">            <span class="comment">// 【注意】 最终执行onPostExecute() 下面来分析</span></span><br><span class="line">            <span class="comment">// 创建内部类InstallingAsyncTask的对象，调用execute()，最终进入onPostExecute()</span></span><br><span class="line">            mInstallingTask = <span class="keyword">new</span> InstallingAsyncTask();</span><br><span class="line">            mInstallingTask.execute();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// we will receive a broadcast when the install is finished</span></span><br><span class="line">            mCancelButton.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">            setFinishOnTouchOutside(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Installinstalling.<strong>InstallingAsyncTask：</strong> 关注  第一步  和  第二步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallingAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">PackageInstaller</span>.<span class="title">Session</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> isDone;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 第一步： doInBackground()会根据包(APK)的Uri，将APK的信息通过IO流的形式写入到PackageInstaller.Session中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> PackageInstaller.<span class="function">Session <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">        PackageInstaller.Session session;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            session = getPackageManager().getPackageInstaller().openSession(mSessionId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        session.setStagingProgress(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(mPackageURI.getPath());</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(file)) &#123;</span><br><span class="line">                <span class="keyword">long</span> sizeBytes = file.length();</span><br><span class="line">                <span class="keyword">try</span> (OutputStream out = session</span><br><span class="line">                        .openWrite(<span class="string">&quot;PackageInstaller&quot;</span>, <span class="number">0</span>, sizeBytes)) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> numRead = in.read(buffer);</span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">if</span> (numRead == -<span class="number">1</span>) &#123;</span><br><span class="line">                            session.fsync(out);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                            session.close();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将APK的信息通过IO流的形式写入到PackageInstaller.Session中</span></span><br><span class="line">                        out.write(buffer, <span class="number">0</span>, numRead);</span><br><span class="line">                        <span class="keyword">if</span> (sizeBytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">float</span> fraction = ((<span class="keyword">float</span>) numRead / (<span class="keyword">float</span>) sizeBytes);</span><br><span class="line">                            session.addProgress(fraction);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> session;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | SecurityException e) &#123;</span><br><span class="line">            Log.e(LOG_TAG, <span class="string">&quot;Could not write package&quot;</span>, e);</span><br><span class="line"> </span><br><span class="line">            session.close();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                isDone = <span class="keyword">true</span>;</span><br><span class="line">                notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 第二步：最后在onPostExecute()中 调用PackageInstaller.Session的commit方法，进行安装</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(PackageInstaller.Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent broadcastIntent = <span class="keyword">new</span> Intent(BROADCAST_ACTION);</span><br><span class="line">            broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">            broadcastIntent.setPackage(getPackageName());</span><br><span class="line">            broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId);</span><br><span class="line"> </span><br><span class="line">            PendingIntent pendingIntent = PendingIntent.getBroadcast(</span><br><span class="line">                    InstallInstalling.<span class="keyword">this</span>,</span><br><span class="line">                    mInstallId,</span><br><span class="line">                    broadcastIntent,</span><br><span class="line">                    PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 【注意】commit 下面会分析</span></span><br><span class="line">            <span class="comment">// 调用PackageInstaller.Session的commit方法，进行安装</span></span><br><span class="line">            session.commit(pendingIntent.getIntentSender());</span><br><span class="line">            mCancelButton.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">            setFinishOnTouchOutside(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getPackageManager().getPackageInstaller().abandonSession(mSessionId);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">                launchFailure(PackageManager.INSTALL_FAILED_INVALID_APK, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>PackageInstaller的<strong>commit</strong>()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[PackageInstaller.java] <span class="function">commit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="meta">@NonNull</span> IntentSender statusReceiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//  mSession的类型为IPackageInstallerSession，这说明要通过IPackageInstallerSession来进行进程间的通信，最终会调用PackageInstallerSession的commit方法，这样代码逻辑就到了Java框架层的。</span></span><br><span class="line">        <span class="comment">// 调用IPackageInstallerSession的commit方法, 跨进程调用到 PackageInstallerSession.commit()</span></span><br><span class="line">        mSession.commit(statusReceiver, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> PackageInstallerSession.**commit()**中 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[PackageInstallerSession.java] commit()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="meta">@NonNull</span> IntentSender statusReceiver, <span class="keyword">boolean</span> forTransfer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mIsPerfLockAcquired &amp;&amp; mPerfBoostInstall != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPerfBoostInstall.perfLockRelease();</span><br><span class="line">        mIsPerfLockAcquired = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 调用markAsCommitted()</span></span><br><span class="line">    <span class="keyword">if</span> (!markAsCommitted(statusReceiver, forTransfer)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 【注意】向Handler发送一个类型为MSG_COMMIT的消息 ，下面会分析</span></span><br><span class="line">    mHandler.obtainMessage(MSG_COMMIT).sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>MSG_COMMIT</strong>在handler中进行处理，进入handleCommit()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_COMMIT:</span><br><span class="line">            handleCommit();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    List&lt;PackageInstallerSession&gt; childSessions = getChildSessions();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">//最终调用installStage()，进入PKMS</span></span><br><span class="line">            commitNonStagedLocked(childSessions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line">        <span class="keyword">final</span> String completeMsg = ExceptionUtils.getCompleteMessage(e);</span><br><span class="line">        Slog.e(TAG, <span class="string">&quot;Commit of session &quot;</span> + sessionId + <span class="string">&quot; failed: &quot;</span> + completeMsg);</span><br><span class="line">        destroyInternal();</span><br><span class="line">        dispatchSessionFinished(e.error, completeMsg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最终调用 **mPm.installStage()**，进入PKMS 【经过千辛万苦，终于要进入PKMS了】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">commitNonStagedLocked</span><span class="params">(...)</span><span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isMultiPackage()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mPm.installStage(activeChildSessions); <span class="comment">// 【注意】跨越进程 进入 PKMS.installStage了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPm.installStage(committingSession);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>PKMS.installStage</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[PackageManagerService.java] </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installStage</span><span class="params">(ActiveInstallSession activeInstallSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_INSTANT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((activeInstallSession.getSessionParams().installFlags</span><br><span class="line">                &amp; PackageManager.INSTALL_INSTANT_APP) != <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">&quot;Ephemeral install of &quot;</span> + activeInstallSession.getPackageName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一步.创建了类型为INIT_COPY的消息</span></span><br><span class="line">    <span class="keyword">final</span> Message msg = mHandler.obtainMessage(INIT_COPY);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 第二步.创建InstallParams，它对应于包的安装数据</span></span><br><span class="line">    <span class="keyword">final</span> InstallParams params = <span class="keyword">new</span> InstallParams(activeInstallSession);</span><br><span class="line">    params.setTraceMethod(<span class="string">&quot;installStage&quot;</span>).setTraceCookie(System.identityHashCode(params));</span><br><span class="line">    msg.obj = params;</span><br><span class="line"> </span><br><span class="line">    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;installStage&quot;</span>,</span><br><span class="line">            System.identityHashCode(msg.obj));</span><br><span class="line">    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;queueInstall&quot;</span>,</span><br><span class="line">            System.identityHashCode(msg.obj));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 第三步.将InstallParams通过消息发送出去。</span></span><br><span class="line">    mHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">对INIT_COPY的消息的处理</span><br><span class="line">[PackageManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doHandleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INIT_COPY: &#123;</span><br><span class="line">            HandlerParams params = (HandlerParams) msg.obj;</span><br><span class="line">            <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="string">&quot;init_copy: &quot;</span> + params);</span><br><span class="line">                Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;queueInstall&quot;</span>,</span><br><span class="line">                        System.identityHashCode(params));</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="string">&quot;startCopy&quot;</span>);</span><br><span class="line">                <span class="comment">// 【注意】执行APK拷贝动作，这里会执行到  final void startCopy()</span></span><br><span class="line">                params.startCopy();</span><br><span class="line">                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		[PKMS.HandlerParams]</span><br><span class="line">		<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="string">&quot;startCopy &quot;</span> + mUser + <span class="string">&quot;: &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">            handleStartCopy();  </span><br><span class="line">            handleReturnCode();  <span class="comment">// 调用到下面 handleReturnCode</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		[PKMS.MultiPackageInstallParams]</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">handleReturnCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mVerificationCompleted &amp;&amp; mEnableRollbackCompleted) &#123;</span><br><span class="line">                .....</span><br><span class="line">                <span class="keyword">if</span> (mRet == PackageManager.INSTALL_SUCCEEDED) &#123;</span><br><span class="line">                    mRet = mArgs.copyApk(); <span class="comment">// 【注意】 下面会说到 copyApk</span></span><br><span class="line">                &#125;</span><br><span class="line">                .....</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>APK 拷贝 方法调用步骤如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">PKMS </span></span><br><span class="line"><span class="function">	<span class="title">copyApk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="title">doCopyApk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function">				PackageManagerServiceUtils</span></span><br><span class="line"><span class="function">					<span class="title">copyPacakge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">					<span class="title">copyFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// TODO 通过文件流的操作，把APK拷贝到/data/app等目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String sourcePath, File targetDir, String targetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ErrnoException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!FileUtils.isValidExtFilename(targetName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Invalid filename: &quot;</span> + targetName);</span><br><span class="line">    &#125;</span><br><span class="line">    Slog.d(TAG, <span class="string">&quot;Copying &quot;</span> + sourcePath + <span class="string">&quot; to &quot;</span> + targetName);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> File targetFile = <span class="keyword">new</span> File(targetDir, targetName);</span><br><span class="line">    <span class="keyword">final</span> FileDescriptor targetFd = Os.open(targetFile.getAbsolutePath(),</span><br><span class="line">            O_RDWR | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    Os.chmod(targetFile.getAbsolutePath(), <span class="number">0644</span>);</span><br><span class="line">    FileInputStream source = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        source = <span class="keyword">new</span> FileInputStream(sourcePath);</span><br><span class="line">        FileUtils.copy(source.getFD(), targetFd);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>进入 Android 11.0 核心安装环节：</p>
<p><img src="/images/android_pms_10.png" alt="image"></p>
<p>processPendingInstall：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processPendingInstall</span><span class="params">(<span class="keyword">final</span> InstallArgs args, <span class="keyword">final</span> <span class="keyword">int</span> currentStatus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.mMultiPackageInstallParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">        args.mMultiPackageInstallParams.tryProcessInstallRequest(args, currentStatus);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.设置安装参数</span></span><br><span class="line">        PackageInstalledInfo res = createPackageInstalledInfo(currentStatus);</span><br><span class="line">        <span class="comment">//2.创建一个新线程，处理安装参数，进行安装</span></span><br><span class="line">        processInstallRequestsAsync(</span><br><span class="line">                res.returnCode == PackageManager.INSTALL_SUCCEEDED,</span><br><span class="line">                Collections.singletonList(<span class="keyword">new</span> InstallRequest(args, res)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processInstallRequestsAsync</span><span class="params">(<span class="keyword">boolean</span> success,</span></span></span><br><span class="line"><span class="params"><span class="function">        List&lt;InstallRequest&gt; installRequests)</span> </span>&#123;</span><br><span class="line">    mHandler.post(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            <span class="keyword">for</span> (InstallRequest request : installRequests) &#123;</span><br><span class="line">                <span class="comment">//1.如果之前安装失败，清除无用信息</span></span><br><span class="line">                request.args.doPreInstall(request.installResult.returnCode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line">                <span class="comment">//2. installPackagesTracedLI 是安装过程的核心方法，然后调用 installPackagesLI 进行安装。</span></span><br><span class="line">                <span class="comment">// 【注意】下面会分析此函数 installPackagesTracedLI</span></span><br><span class="line">                installPackagesTracedLI(installRequests);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (InstallRequest request : installRequests) &#123;</span><br><span class="line">                <span class="comment">//3.如果之前安装失败，清除无用信息</span></span><br><span class="line">                request.args.doPostInstall(</span><br><span class="line">                        request.installResult.returnCode, request.installResult.uid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (InstallRequest request : installRequests) &#123;</span><br><span class="line">            restoreAndPostInstall(request.args.user.getIdentifier(), request.installResult,</span><br><span class="line">                    <span class="keyword">new</span> PostInstallData(request.args, request.installResult, <span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>installPackagesTracedLI</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installPackagesLI</span><span class="params">(List&lt;InstallRequest&gt; requests)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 环节一.Prepare 准备：分析任何当前安装状态，分析包并对其进行初始验证。</span></span><br><span class="line">    prepareResult = preparePackageLI(request.args, request.installResult);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 环节二.Scan  扫描：考虑到prepare中收集的上下文，询问已分析的包。</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;ScanResult&gt; scanResults = scanPackageTracedLI(</span><br><span class="line">                            prepareResult.packageToScan, prepareResult.parseFlags,</span><br><span class="line">                            prepareResult.scanFlags, System.currentTimeMillis(),</span><br><span class="line">                            request.args.user);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 环节三.Reconcile 调和：在彼此的上下文和当前系统状态中验证扫描的包，以确保安装成功。</span></span><br><span class="line">    ReconcileRequest reconcileRequest = <span class="keyword">new</span> ReconcileRequest(preparedScans, installArgs,</span><br><span class="line">            installResults,</span><br><span class="line">            prepareResults,</span><br><span class="line">            mSharedLibraries,</span><br><span class="line">            Collections.unmodifiableMap(mPackages), versionInfos,</span><br><span class="line">            lastStaticSharedLibSettings);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 环节四.Commit 提交：提交所有扫描的包并更新系统状态。这是安装流中唯一可以修改系统状态的地方，必须在此阶段之前确定所有可预测的错误。</span></span><br><span class="line">    commitPackagesLocked(commitRequest);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 环节五.完成APK的安装【注意：下面会分析这个操作】</span></span><br><span class="line">    executePostCommitSteps(commitRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>executePostCommitSteps</strong> 安装APK,并为新的代码路径准备应用程序配置文件,并再次检查是否需要<strong>dex优化</strong></p>
<p>如果是直接安装新包，会为新的代码路径准备应用程序配置文件</p>
<p>如果是替换安装：其主要过程为更新设置，清除原有的某些APP数据，重新生成相关的app数据目录等步骤，同时要区分系统应用替换和非系统应用替换。而安装新包：则直接更新设置，生成APP数据即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[PackageManagerService.java] executePostCommitSteps()</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executePostCommitSteps</span><span class="params">(CommitRequest commitRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ReconciledPackage reconciledPkg : commitRequest.reconciledPackages.values()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//1)进行安装</span></span><br><span class="line">        prepareAppDataAfterInstallLIF(pkg);</span><br><span class="line">        <span class="comment">//2)如果需要替换安装，则需要清楚原有的APP数据</span></span><br><span class="line">        <span class="keyword">if</span> (reconciledPkg.prepareResult.clearCodeCache) &#123;</span><br><span class="line">            clearAppDataLIF(pkg, UserHandle.USER_ALL, FLAG_STORAGE_DE | FLAG_STORAGE_CE</span><br><span class="line">                    | FLAG_STORAGE_EXTERNAL | Installer.FLAG_CLEAR_CODE_CACHE_ONLY);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//3)为新的代码路径准备应用程序配置文件。这需要在调用dexopt之前完成，以便任何安装时配置文件都可以用于优化。</span></span><br><span class="line">        mArtManagerService.prepareAppProfiles(</span><br><span class="line">                pkg,</span><br><span class="line">                resolveUserIds(reconciledPkg.installArgs.user.getIdentifier()),</span><br><span class="line">                <span class="comment">/* updateReferenceProfileContent= */</span> <span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> performDexopt =</span><br><span class="line">                (!instantApp || Global.getInt(mContext.getContentResolver(),</span><br><span class="line">                Global.INSTANT_APP_DEXOPT_ENABLED, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">                &amp;&amp; ((pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) == <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (performDexopt) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//4)执行dex优化</span></span><br><span class="line">            mPackageDexOptimizer.performDexOpt(pkg,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* instructionSets */</span>,</span><br><span class="line">                    getOrCreateCompilerPackageStats(pkg),</span><br><span class="line">                    mDexManager.getPackageUseInfoOrDefault(packageName),</span><br><span class="line">                    dexoptOptions);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        BackgroundDexOptService.notifyPackageChanged(packageName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>prepareAppDataAfterInstallLIF:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">通过一系列的调用，最终会调用到[Installer.java] createAppData()进行安装，交给installed进程进行APK的安装</span><br><span class="line">调用栈如下：</span><br><span class="line"></span><br><span class="line">prepareAppDataAfterInstallLIF()</span><br><span class="line">      	|</span><br><span class="line">prepareAppDataLIF()</span><br><span class="line">    	|</span><br><span class="line">prepareAppDataLeafLIF()</span><br><span class="line">    	|</span><br><span class="line">[Installer.java]</span><br><span class="line">		createAppData()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAppDataAfterInstallLIF</span><span class="params">(PackageParser.Package pkg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (UserInfo user : um.getUsers()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (ps.getInstalled(user.id)) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> when user data is locked, mark that we&#x27;re still dirty</span></span><br><span class="line">            prepareAppDataLIF(pkg, user.id, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAppDataLIF</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> userId, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">&quot;Package was null!&quot;</span>, <span class="keyword">new</span> Throwable());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prepareAppDataLeafLIF(pkg, userId, flags);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = (pkg.childPackages != <span class="keyword">null</span>) ? pkg.childPackages.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        prepareAppDataLeafLIF(pkg.childPackages.get(i), userId, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareAppDataLeafLIF</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> userId, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用Installd守护进程的入口</span></span><br><span class="line">        ceDataInode = mInstaller.createAppData(volumeUuid, packageName, userId, flags,</span><br><span class="line">                appId, seInfo, app.targetSdkVersion);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstallerException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.isSystemApp()) &#123;</span><br><span class="line">            destroyAppDataLeafLIF(pkg, userId, flags);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ceDataInode = mInstaller.createAppData(volumeUuid, packageName, userId, flags,</span><br><span class="line">                        appId, seInfo, app.targetSdkVersion);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstallerException e2) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Installer.<strong>createAppData</strong> 收尾工作，安装完成后，更新设置，更新安装锁等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[Installer.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">createAppData</span><span class="params">(String uuid, String packageName, <span class="keyword">int</span> userId, <span class="keyword">int</span> flags, <span class="keyword">int</span> appId,</span></span></span><br><span class="line"><span class="params"><span class="function">        String seInfo, <span class="keyword">int</span> targetSdkVersion)</span> <span class="keyword">throws</span> InstallerException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkBeforeRemote()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// mInstalld 为IInstalld的对象，即通过Binder调用到 进程installd，最终调用installd的createAppData()</span></span><br><span class="line">        <span class="comment">// 【注意】 mInstalld是一个aidl文件，通过此aidl文件调用到 Binder机制的服务端，服务端哪里要操控底层....</span></span><br><span class="line">        <span class="keyword">return</span> mInstalld.createAppData(uuid, packageName, userId, flags, appId, seInfo,</span><br><span class="line">                targetSdkVersion);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> InstallerException.from(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：安装的原理：</strong></p>
<p><img src="/images/android_pms_11.png" alt="image"></p>
<h1 id="权限扫描"><a href="#权限扫描" class="headerlink" title="权限扫描"></a>权限扫描</h1><p>PackageManagerService中执行systemReady()后，需求对 /system/etc/permissions中的各种xml进行扫描，进行相应的权限存储，让以后可以使用.</p>
<p>PackageManagerService执行systemReady()时，通过SystemConfig的readPermissionsFromXml()来扫描读取/system/etc/permissions中的xml文件,包括platform.xml和系统支持的各种硬件模块的feature主要工作:</p>
<p>整体图：</p>
<p><img src="/images/android_pms_12.png" alt="image"></p>
<p><strong>SystemConfig 的 readPermissions函数：</strong></p>
<p>此函数目的：（扫描/system/etc/permissions中文件，调用readPermissionsFromXml()进行解析，存入SsytemConfig相应的成员数组变量中）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">readPermissions</span><span class="params">(File libraryDir, <span class="keyword">int</span> permissionFlag)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Iterate over the files in the directory and scan .xml files</span></span><br><span class="line">    File platformFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (File f : libraryDir.listFiles()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f.isFile()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 最后读取platform.xml</span></span><br><span class="line">        <span class="keyword">if</span> (f.getPath().endsWith(<span class="string">&quot;etc/permissions/platform.xml&quot;</span>)) &#123;</span><br><span class="line">            platformFile = f;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        readPermissionsFromXml(f, permissionFlag);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Read platform permissions last so it will take precedence</span></span><br><span class="line">    <span class="keyword">if</span> (platformFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        readPermissionsFromXml(platformFile, permissionFlag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>解析xml的标签节点，存入mGlobalGids、mPermissions、mSystemPermissions等成员变量中，供其他进行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readPermissionsFromXml</span><span class="params">(File permFile, <span class="keyword">int</span> permissionFlag)</span> </span>&#123;</span><br><span class="line">    FileReader permReader = <span class="keyword">null</span>;</span><br><span class="line">    permReader = <span class="keyword">new</span> FileReader(permFile);</span><br><span class="line">    ...</span><br><span class="line">    XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">    parser.setInput(permReader);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        String name = parser.getName();</span><br><span class="line">         <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">             <span class="comment">//解析 group 标签，前面介绍的 XML 文件中没有单独使用该标签的地方</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line">                String gidStr = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;gid&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (gidStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> gid = android.os.Process.getGidForName(gidStr);</span><br><span class="line">                    <span class="comment">//转换 XML 中的 gid字符串为整型，并保存到 mGlobalGids 中</span></span><br><span class="line">                    mGlobalGids = appendInt(mGlobalGids, gid);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;&lt;&quot;</span> + name + <span class="string">&quot;&gt; without gid in &quot;</span> + permFile + <span class="string">&quot; at &quot;</span>  + parser.getPositionDescription());</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;permission&quot;</span>: &#123; <span class="comment">//解析 permission 标签</span></span><br><span class="line">                <span class="keyword">if</span> (allowPermissions) &#123;</span><br><span class="line">                    String perm = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (perm == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;&lt;&quot;</span> + name + <span class="string">&quot;&gt; without name in &quot;</span> + permFile + <span class="string">&quot; at &quot;</span> + parser.getPositionDescription());</span><br><span class="line">                        XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    perm = perm.intern();</span><br><span class="line">                    readPermission(parser, perm); <span class="comment">//调用 readPermission 处理,存入mPermissions</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logNotAllowedInPartition(name, permFile, parser);</span><br><span class="line">                    XmlUtils.skipCurrentTag(parser);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>查看 XML文件：</p>
<p>adb devices</p>
<p>adb shell</p>
<p><img src="/images/android_pms_13.png" alt="image"></p>
<p>然后在导出去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb pull /system/etc/permissions</span><br></pre></td></tr></table></figure>



<p>/system/etc/permissions中会存在很多的xml文件，例如我们看下 android.software.webview.xml的文件，内容如下：</p>
<p>里面只只有一个feature “android.software.webview”,大部分的xml都是类似的定义方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permissions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">feature</span> <span class="attr">name</span>=<span class="string">&quot;android.software.webview&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">permissions</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>让我们来简单的看下/system/etc/permissions/platform.xml的内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">permissions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.BLUETOOTH_ADMIN&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">group</span> <span class="attr">gid</span>=<span class="string">&quot;net_bt_admin&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">permission</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">group</span> <span class="attr">gid</span>=<span class="string">&quot;inet&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">permission</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.READ_LOGS&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">group</span> <span class="attr">gid</span>=<span class="string">&quot;log&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">permission</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">assign-permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.MODIFY_AUDIO_SETTINGS&quot;</span> <span class="attr">uid</span>=<span class="string">&quot;media&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assign-permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.ACCESS_SURFACE_FLINGER&quot;</span> <span class="attr">uid</span>=<span class="string">&quot;media&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assign-permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.WAKE_LOCK&quot;</span> <span class="attr">uid</span>=<span class="string">&quot;media&quot;</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line">   <span class="tag">&lt;<span class="name">split-permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.ACCESS_FINE_LOCATION&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">new-permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.ACCESS_COARSE_LOCATION&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">split-permission</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">split-permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">new-permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">split-permission</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">split-permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.READ_CONTACTS&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">targetSdk</span>=<span class="string">&quot;16&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">new-permission</span> <span class="attr">name</span>=<span class="string">&quot;android.permission.READ_CALL_LOG&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">split-permission</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">library</span> <span class="attr">name</span>=<span class="string">&quot;android.test.base&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">file</span>=<span class="string">&quot;/system/framework/android.test.base.jar&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">library</span> <span class="attr">name</span>=<span class="string">&quot;android.test.mock&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">file</span>=<span class="string">&quot;/system/framework/android.test.mock.jar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">dependency</span>=<span class="string">&quot;android.test.base&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">library</span> <span class="attr">name</span>=<span class="string">&quot;android.test.runner&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">file</span>=<span class="string">&quot;/system/framework/android.test.runner.jar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">dependency</span>=<span class="string">&quot;android.test.base:android.test.mock&quot;</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- In BOOT_JARS historically, and now added to legacy applications. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">library</span> <span class="attr">name</span>=<span class="string">&quot;android.hidl.base-V1.0-java&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">file</span>=<span class="string">&quot;/system/framework/android.hidl.base-V1.0-java.jar&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">library</span> <span class="attr">name</span>=<span class="string">&quot;android.hidl.manager-V1.0-java&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">file</span>=<span class="string">&quot;/system/framework/android.hidl.manager-V1.0-java.jar&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">dependency</span>=<span class="string">&quot;android.hidl.base-V1.0-java&quot;</span> /&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">permissions</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上platform.xml中出现的标签种类则较为多样，它们的含义分别是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">platform.xml中出现的标签种类则较为多样，它们的含义分别是：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span>:根据name获取gid</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span> &gt;</span>标签：把属性name所描述的权限赋予给<span class="tag">&lt;<span class="name">group</span>&gt;</span>标签中属性gid所表示的用户组，一个权限可以有一个或多个group对象，当一个APK授权于这个这个权限时，它同时属于这几个组</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">assign-permission</span>&gt;</span>标签：把属性name所描述的权限赋予给uid属性所表示的用户</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">split-permission</span>&gt;</span>标签：一个权限可以扩展出一个新的权限</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">library</span>&gt;</span>标签：除framework中动态库以外的，所有系统会自动加载的动态库</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span>&gt;</span>标签：硬件支持的一些feature</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">oem-permission</span>&gt;</span>标签：oem厂商自己定义的一些权限</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">privapp-permission</span>&gt;</span>标签：来自system、vendor、product、system_ext的privapp权限分别存储，这是防止供应商分区中的xml授权于系统分区中的私有应用权限</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">最后将上面xml解析出来的数据做如下存储：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span>标签gid属性的值会存放在mGlobalGids数组中;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">permission</span>&gt;</span>标签,解析得到的值会存放在mPermissions集合中;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">assign-permission</span>&gt;</span>标签解析得到的值会存放在mSystemPermissions中;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">split-permission</span>&gt;</span>存储在mSplitPermissions</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">library</span>&gt;</span>标签解析得到的值会存放在mSharedLibraries中;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span>&gt;</span>存储在mAvaliableFeatures</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">oem-permission</span>&gt;</span>存储在mOemPermissions</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">privapp-permission</span>&gt;</span>会根据不同的存储路径，分别存储在mVendorPrivAppPermissions、mProductPrivAppPermissions、mSystemExtPrivAppPermissions、mPrivAppPermissions</span><br></pre></td></tr></table></figure>



<p><strong>总结：权限扫描，扫描/system/etc/permissions中的xml，存入相应的结构体中，供之后权限管理使用</strong></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>PKMS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android源码分析-View是如何绘制到屏幕上的</title>
    <url>/2017/12/20/android_source_setcontentview/</url>
    <content><![CDATA[<p>在Android中如果要显示一个页面，那么只需要在Activity的onCreate()方法中，把我们写好的页面布局layout传入到setContentView()方法中即可，这样Activity就会完成接下来的工作，通过一系列的操作把我们想要的布局页面显示出来，不需要我们再做任何的处理，所以最初的时候一直以为是Activity将layout布局中的控件绘制出来的，但事实究竟是怎样的呢，我们来一探究竟。</p>
<span id="more"></span>

<p>首先，我们都知道在onCreate()方法中调用setContentView()函数，Activity并不会立刻将页面显示出来，而是在执行到Activity的onResume()生命周期之后才会将Activity显示出来。所以针对于这个问题 “View是如何绘制到屏幕上的？” ，可以从以下两个方面来进行思考。</p>
<ul>
<li><p>调用setContentView之后都做了哪些事？</p>
</li>
<li><p>在onResume这个生命周期里也就是Activity被显示之前做了哪些事？</p>
</li>
</ul>
<h1 id="Activity-setContentView"><a href="#Activity-setContentView" class="headerlink" title="Activity#setContentView"></a>Activity#setContentView</h1><p>看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the activity content from a layout resource.  The resource will be</span></span><br><span class="line"><span class="comment"> * inflated, adding all top-level views to the activity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> layoutResID Resource ID to be inflated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContentView(android.view.View)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContentView(android.view.View, android.view.ViewGroup.LayoutParams)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, .....)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在Activity的setContentView()方法中，调用了getWindow()的setContentView()，Activity在第一时间就将它交到了getWindow()的手里，getWindow()返回了一个Window的对象，Window是一个抽象类，PhoneWindow是它唯一的实现类，并且从代码中我们可以得知mWindow这个对象是在Activity的attach()方法中进行创建的。（attach()这个方法很重要，很多跟Activity相关的重要信息都是在这个方法中进行初始化的，尤其是初始化了和显示相关的信息，是我们需要重点关注的）此时我们的布局如下：<br><img src="/images/android_source_setcontentview01.png" alt="image"></p>
<h1 id="PhoneWindow-setContentView"><a href="#PhoneWindow-setContentView" class="headerlink" title="PhoneWindow#setContentView"></a>PhoneWindow#setContentView</h1><p>接下来看一下PhoneWindow中的setContentView方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">    <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">    <span class="comment">// before this happens.</span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在phoneWindow的setContentView()中，主要做了两件事:</p>
<ul>
<li><p>installDecor：如果mContentParent为null，就会在这个方法中创建DecorView和ContentParent。</p>
</li>
<li><p>inflate：通过inflate的方式将我们在Activity中传入的xml布局文件也就是R.layout.activity_main，转换成了树形结构的View，并且把ContentParent作为父节点。</p>
</li>
</ul>
<p>接下来看installDecor方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System process doesn&#x27;t have application context and in that case we need to directly use</span></span><br><span class="line">    <span class="comment">// the context we have. Otherwise we want the application context, so we don&#x27;t cling to the</span></span><br><span class="line">    <span class="comment">// activity.</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">	<span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Embedded, so no decoration is needed.</span></span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;Simple!&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mDecor.startChanging();</span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>见上面代码，首先在installDecor()方法中，通过generateDecor()创建出了DecorView，以及通过generateLayout()创建出了ContentParent。</p>
<ul>
<li>generateDecor：创建DecorView，DecorView继承自FrameLayout，此时为我们的布局中创建出了DecorView，布局如下：</li>
</ul>
<p><img src="/images/android_source_setcontentview02.png" alt="image"></p>
<ul>
<li>generateLayout：创建ContentParent，在创建的过程中会根据不同的feature创建不同的系统布局。<br>这里我们主要来了解一下ContentParent的创建过程，首先会根据不同的的feature创建不同的系统布局，这里的feature较多，我们挑一个最简单也是最普遍的R.layout.screen_simple为例，xml文件代码如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout</span> <span class="attr">height</span>=<span class="string">&quot;match parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">&quot;a+id/action mode bar stub&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:inflatedId</span>=<span class="string">&quot;a+id/action mode bar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span>=<span class="string">&quot;alayout/action mode bar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span> <span class="attr">width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span> <span class="attr">height</span>=<span class="string">&quot;wrap content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;?attr/actionBarTheme&quot;</span>/&gt;</span></span><br><span class="line">          	<span class="tag">&lt;<span class="name">Framelavout</span></span></span><br><span class="line"><span class="tag">            	<span class="attr">android:id</span>=<span class="string">&quot;aandroid:id/content&quot;</span></span></span><br><span class="line"><span class="tag">            	<span class="attr">android:layout_width</span>=<span class="string">&quot;match parent&quot;</span></span></span><br><span class="line"><span class="tag">            	<span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            	<span class="attr">android:foregroundInsidePadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">android:foregroundGravity</span>=<span class="string">&quot;fill_horizontalltop&quot;</span></span></span><br><span class="line"><span class="tag">    			<span class="attr">android:foreground</span>=<span class="string">&quot;?android:attr/windowContentOverlay&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>R.layout.screen_simple中是由ViewStub和FrameLayout两个部分组成，进入ViewStub的layout布局能够发现其实就是一个ActionBar；这里注意下FrameLayout的id为content，后面会用到。</p>
<h1 id="DecorView-onResourcesLoaded"><a href="#DecorView-onResourcesLoaded" class="headerlink" title="DecorView#onResourcesLoaded"></a>DecorView#onResourcesLoaded</h1><p>了解了screen_simple中的内容后，接下来我们看mDecor.onResourcesLoaded(mLayoutInflater, layoutResource)这行代码，在onResourcesLoaded()中先是将布局id转换成View，然后再通过addView将此View添加到DecorView中。onResourcesLoaded()代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="keyword">int</span> layoutResource)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">    <span class="keyword">final</span> View root = inflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecorCaptionView.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addView(mDecorCaptionView,</span><br><span class="line">                    <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        &#125;</span><br><span class="line">        mDecorCaptionView.addView(root,</span><br><span class="line">                <span class="keyword">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Put it below the color views.</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在onResourcesloaded()之后呢又通过findViewById(ID_ANDROID_CONTENT)查找到了ContentParent，并且将ContentParent返回，这个ID_ANDROID_CONTENT就是 com.android.internal.R.id.content，也就是我们上面提到的R.layout.screen_simple布局文件中id为content的FrameLayout，所以最终将screen_simple中的布局控件添加到DecorView中之后，此时的布局如下：<br><img src="/images/android_source_setcontentview03.png" alt="image"></p>
<p>此时onResourcesloaded()方法就结束了，我们再次返回到PhoneWindow的setContentView()方法中的第②部分，可以看到通过inflate的方式将我们从Activity中传入的布局R.layout.activity_main加载到了mContentParent，而这个mContentParent就是我们上一步通过generateLayout()创建出来的ContentParent。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mLayoutInflater.inflate(layoutResID, mContentParent);</span><br></pre></td></tr></table></figure>

<p>所以将<code>activity_main</code>添加到<code>ContentParent</code>之后的布局如下：</p>
<p><img src="/images/android_source_setcontentview04.png" alt="image"></p>
<p>至此，<code>Activity</code>需要显示的内容已经被初始化完成了，但是此时<code>Activity</code>并不是可见的，直到<code>Activity</code>的<code>onResume()</code>阶段才会将<code>PhoneWindow</code>中的<code>DecorView</code>真正的绘制到屏幕上。</p>
<p><strong>总结：</strong><br>在Activity实例创建好并且执行attach()方法的时候，会为Activity创建一个PhoneWindow，接下来就到了onCreate()的生命周期，在调用setContentView()的时候，如果还没有初始化ContentParent，说明是第一次进行setContentView()，那么就会初始化DecorView，还会给DecorView添加一个系统页面样式的子View(R.layout.screen_simple)，那么在系统样式的ViewGroup中，就可以通过id找到用来加载自定义布局的ContentParent，再通过inflate就可以将我们自己写的xml文件(R.layout.main)转化为一颗ViewTree了，这颗ViewTree就在ContentParent里面。</p>
<p>所以setContentView()的作用最终可以总结为：</p>
<ul>
<li><p>创建DecorView</p>
</li>
<li><p>创建ContentParent</p>
</li>
<li><p>自定义布局转化为ViewTree，放在ContentParent中</p>
</li>
</ul>
<h1 id="Activity-onResume"><a href="#Activity-onResume" class="headerlink" title="Activity#onResume"></a>Activity#onResume</h1><p><code>Activity</code>的<code>onResume()</code>生命周期是在<code>ActivityThread</code>中的<code>handleResumeActivity()</code>方法中执行的，在这个方法中通过<code>performResumeActivity()</code>触发了<code>onResume()</code>的回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finalStateRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">boolean</span> isForward, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">    <span class="comment">// skip below steps for double-resume and r.mFinish = true case.</span></span><br><span class="line">    <span class="keyword">if</span> (!performResumeActivity(r, finalStateRequest, reason)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到触发onResume()回调之后，在Activity未关闭并且即将要显示的条件下，先是获取了Activity的DecorView，然后又获取了WindowManager，最后呢再调用了WindowManger的addView()方法将DecorView添加到WindowManager中，我们来看下这个WindowManager是在Activity的attach()中通过setWindowManager创建出来的WindowManagerImpl对象，每一个Activity都会对应一个WindowManager对象，一层一层的进入addView()最终代码来到了WindowMangerGlobal的addView()，如下图所示：</p>
<p><strong>Activity#attach</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context,//...)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(mWindowControllerCallback);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>WindowManagerImpl#addView</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span></span>&#123; </span><br><span class="line">	applyDefaultToken(params);</span><br><span class="line">	mGlobal.addView(view,params,mContext.getDisplayNoVerify(),mParentWindow,mContext.getUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>WindowManagerGlobal#addView</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	root = <span class="keyword">new</span> ViewRootImpl(view.getContext (), display)</span><br><span class="line">	view.setLayoutParams(wparams);</span><br><span class="line">	mViews.add(view);</span><br><span class="line">	mRoots. add(root);</span><br><span class="line">	root.setView(view, wparams, panelParentView, userId);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WindowManagerGlobal</code>是一个单例，在它的<code>addView()</code>方法中如果是首次添加的话就会创建了一个<code>ViewRootImpl</code>，然后将<code>DecorView</code>添加到<code>ViewRootImpl</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//DecorView对象</span></span><br><span class="line">            mView = view;</span><br><span class="line">           	<span class="comment">//......</span></span><br><span class="line">            <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">            <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">            <span class="comment">// any other events from the system.</span></span><br><span class="line">            <span class="comment">//触发布局绘制</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="comment">//通知WMS添加窗口</span></span><br><span class="line">            res = mWindowSession.addToDisplayAsUser(mWindow, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(), userId,</span><br><span class="line">                            mInsetsController.getRequestedVisibilities(), inputChannel, mTempInsets,</span><br><span class="line">                            mTempControls);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            setFrame(mTmpFrames.frame);</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">            <span class="comment">//DecorView的parent设置为ViewRootImpl</span></span><br><span class="line">            view.assignParent(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ViewRootImpl的setView()中，首先会调用requestLayout()触发布局的绘制流程，我们熟悉的measure，layout，draw的绘制流程就是从这里开始的，这一步可以确保View被添加到屏幕上之前已经完成了测量和绘制操作。然后会调用mWindowSession的addToDisplayAsUser()通知WMS添加窗口， 这里就涉及到了跨进程通信，方法的最后把decor的parent设置为了ViewRootImpl，这样做的目的就是让ViewRootImpl能够管理整个ViewTree。 接下来我们就来看一下mWindowSession这个对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Emulate the legacy behavior.  The global instance of InputMethodManager</span></span><br><span class="line">                <span class="comment">// was instantiated here.</span></span><br><span class="line">                <span class="comment">// TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage</span></span><br><span class="line">                InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();</span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                <span class="comment">//获取WMS进程中的session对象</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mWindowSession是WindowManagerGlobal中的一个单例对象，它是IWindowSession类型并且继承自IBinder，它的实现类是System进程中的Session，可以看到它是通过WMS进程的openSession来获取的，至此剩下的工作就交由WMS进程来进行后续的添加工作了。<br><strong>总结：</strong><br>在onResume()中会调用WindowManager中的addView()添加DecorView，当WindowManager管理ViewTree的时候会给ViewTree分配一个ViewRootImpl，ViewRootImpl的第一个作用就是管理ViewTree的绘制工作，包括显示、测量，同步刷新以及事件分发等等，第二个作用就是负责与其他的服务进行通信。在同时存在多个Activity的情况下，每个Activity都有自己的PhoneWindow、DecorView以及WindowManagerImpl，WindowManagerGlobal持有每个Activity的RootView，mWindowSession和mWindow是用来和WMS进行双向通信的。</p>
<h1 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h1><p><img src="/images/android_source_setcontentview05.png" alt="image"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 屏幕适配</title>
    <url>/2019/11/24/android_screen_adjust/</url>
    <content><![CDATA[<p>由于 Android设备存在有不同的屏幕尺寸，屏幕分辨率，像素密度，Android应用在开发的过程必须要考虑到屏幕尺寸适配的问题，以保证在不同尺寸的Android设备上都能够正常运行。<br>我们需要利用适配这一个过程把同一张原型图设计的样式尽可能以同样地视觉效果呈现在不同地屏幕上。</p>
<span id="more"></span>

<h1 id="适配基础知识"><a href="#适配基础知识" class="headerlink" title="适配基础知识"></a>适配基础知识</h1><p><strong>由于Android系统的开放性，任何用户、开发者、OEM厂商、运营商都可以对Android进行定制，于是导致：</strong></p>
<ul>
<li>Android系统碎片化：小米定制的MIUI、魅族定制的flyme、华为定制的EMUI等等,当然其都是基于Google原生系统定制的</li>
<li>Android机型屏幕尺寸碎片化：5寸、5.5寸、6寸等等</li>
<li>Android屏幕分辨率碎片化：320x480、480x800、720x1280、1080x1920</li>
</ul>
<blockquote>
<p>据友盟指数显示，统计至2015年12月，支持Android的设备共有27796种</p>
</blockquote>
<p>当Android系统、屏幕尺寸、屏幕密度出现碎片化的时候，就很容易出现同一元素在不同手机上显示不同的问题。</p>
<blockquote>
<p>试想一下这么一个场景：<br> 为4.3寸屏幕准备的UI设计图，运行在5.0寸的屏幕上，很可能在右侧和下侧存在大量的空白；而5.0寸的UI设计图运行到4.3寸的设备上，很可能显示不下。</p>
</blockquote>
<p><strong>首先介绍一下Android屏幕中用到的一些相关重要概念：</strong></p>
<h2 id="屏幕尺寸"><a href="#屏幕尺寸" class="headerlink" title="屏幕尺寸"></a>屏幕尺寸</h2><p>含义：手机对角线的物理尺寸</p>
<p>单位：英寸（inch），1英寸=2.54cm</p>
<p>Android手机常见的尺寸有5寸、5.5寸、6寸等等</p>
<h2 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h2><p> 含义：手机在横向、纵向上的像素点数总和</p>
<ol>
<li>一般描述成屏幕的”宽x高”=AxB</li>
<li>含义：屏幕在横向方向（宽度）上有A个像素点，在纵向方向（高）有B个像素点</li>
</ol>
<p>例子：1080x1920，即宽度方向上有1080个像素点，在高度方向上有1920个像素点</p>
<ul>
<li>单位：px（pixel），1px=1个像素点</li>
</ul>
<blockquote>
<p>UI设计师的设计图会以px作为统一的计量单位</p>
</blockquote>
<ul>
<li>Android手机常见的分辨率：320x480、480x800、720x1280、1080x1920、 1080x2340</li>
</ul>
<h2 id="屏幕像素密度"><a href="#屏幕像素密度" class="headerlink" title="屏幕像素密度"></a>屏幕像素密度</h2><ul>
<li>含义：每英寸的像素点数</li>
<li>单位：dpi(dots per ich)</li>
</ul>
<blockquote>
<p>假设设备内每英寸有160个像素，那么该设备的屏幕像素密度=160dpi</p>
</blockquote>
<ul>
<li>安卓手机对于每类手机屏幕大小都有一个相应的屏幕像素密度：</li>
</ul>
<table>
<thead>
<tr>
<th>密度类型</th>
<th>代表的分辨率（px）</th>
<th>屏幕密度（dpi）</th>
</tr>
</thead>
<tbody><tr>
<td>低密度（ldpi）</td>
<td>240x320</td>
<td>120</td>
</tr>
<tr>
<td>中密度（mdpi）</td>
<td>320x480</td>
<td>160</td>
</tr>
<tr>
<td>高密度（hdpi）</td>
<td>480x800</td>
<td>240</td>
</tr>
<tr>
<td>超高密度（xhdpi）</td>
<td>720x1280</td>
<td>320</td>
</tr>
<tr>
<td>超超高密度（xxhdpi）</td>
<td>1080x1920</td>
<td>480</td>
</tr>
</tbody></table>
<h2 id="屏幕尺寸、分辨率、像素密度三者关系"><a href="#屏幕尺寸、分辨率、像素密度三者关系" class="headerlink" title="屏幕尺寸、分辨率、像素密度三者关系"></a>屏幕尺寸、分辨率、像素密度三者关系</h2><p>一部手机的分辨率是宽*高，屏幕大小是以寸为单位，那么三者的关系是：</p>
<p><img src="/images/android_screen_adjust01.png" alt="img"><br><strong>不懂没关系，在这里举个例子</strong><br> 假设一部手机的分辨率是1080x1920（px)，屏幕大小是5寸，问密度是多少？<br><strong>解</strong>：请直接套公式</p>
<p><img src="/images/android_screen_adjust02.png" alt="img"></p>
<h2 id="密度无关像素"><a href="#密度无关像素" class="headerlink" title="密度无关像素"></a>密度无关像素</h2><ul>
<li>含义：density-independent pixel，叫dp或dip，与终端上的实际物理像素点无关。</li>
<li>单位：dp，可以保证在不同屏幕像素密度的设备上显示相同的效果</li>
</ul>
<blockquote>
<ol>
<li>Android开发时用dp而不是px单位设置图片大小，是Android特有的单位</li>
<li>场景：假如同样都是画一条长度是屏幕一半的线，如果使用px作为计量单位，那么在480x800分辨率手机上设置应为240px；在320x480的手机上应设置为160px，二者设置就不同了；如果使用dp为单位，在这两种分辨率下，160dp都显示为屏幕一半的长度。</li>
</ol>
</blockquote>
<ul>
<li>dp与px的转换<br> 因为ui设计师给你的设计图是以px为单位的，Android开发则是使用dp作为单位的，那么我们需要进行转换：</li>
</ul>
<table>
<thead>
<tr>
<th>密度类型</th>
<th>代表的分辨率（px）</th>
<th>屏幕密度（dpi）</th>
<th>换算（px/dp）</th>
</tr>
</thead>
<tbody><tr>
<td>低密度（ldpi）</td>
<td>240x320</td>
<td>120</td>
<td>1dp=0.75px</td>
</tr>
<tr>
<td>中密度（mdpi）</td>
<td>320x480</td>
<td>160</td>
<td>1dp=1px</td>
</tr>
<tr>
<td>高密度（hdpi）</td>
<td>480x800</td>
<td>240</td>
<td>1dp=1.5px</td>
</tr>
<tr>
<td>超高密度（xhdpi）</td>
<td>720x1280</td>
<td>320</td>
<td>1dp=2px</td>
</tr>
<tr>
<td>超超高密度（xxhdpi）</td>
<td>1080x1920</td>
<td>480</td>
<td>1dp=3px</td>
</tr>
</tbody></table>
<p>在Android中，规定以160dpi（即屏幕分辨率为320x480）为基准：1dp=1px</p>
<h2 id="独立比例像素"><a href="#独立比例像素" class="headerlink" title="独立比例像素"></a>独立比例像素</h2><ul>
<li>含义：scale-independent pixel，叫sp或sip</li>
<li>单位：sp</li>
</ul>
<blockquote>
<p>Android开发时用此单位设置文字大小，可根据字体大小首选项进行缩放<br> 推荐使用12sp、14sp、18sp、22sp作为字体设置的大小，不推荐使用奇数和小数，容易造成精度的丢失问题；小于12sp的字体会太小导致用户看不清</p>
</blockquote>
<p>请把上面的概念记住，因为下面讲解都会用到！</p>
<h1 id="适配方案比较"><a href="#适配方案比较" class="headerlink" title="适配方案比较"></a>适配方案比较</h1><h2 id="dp原生方案"><a href="#dp原生方案" class="headerlink" title="dp原生方案"></a>dp原生方案</h2><p>这是最原始的android适配方案，Android屏幕适配由来已久，关键在于屏幕尺寸与屏幕分辨率的变化巨大，而很多UI工程师为了兼容iOS和Android的适配，这样导致设计出来的UI稿是以px单位标注的。在成千上百种机型面前，px单位已难以适应。</p>
<blockquote>
<p>1.同样尺寸，不同分辨率：<br> 1080px的宽度上显示100px 比例是100/1080<br> 720px的宽度上显示100px 比例是100/720<br> 2.同分辨率，不同尺寸：<br> 1080px在4.7寸上显示100px<br> 1080px在6.1寸上显示100px<br> 如果使用多套px文件方案来适配，<strong>市面上少说上百种寸，需要的文件太多了</strong>。</p>
</blockquote>
<p><strong>不同分辨率的屏幕该如何适配</strong></p>
<p>这时候就需要用到dp方案来解决了,所以<strong>dp究竟解决了什么问题?</strong></p>
<p>以下公式表示了，同样尺寸上不同分辨率（不同density）的设备，每1dp所代表的像素数量是不一样的。</p>
<blockquote>
<p>480 dpi上 1dp = 1 * 3 =     3px<br> 320 dpi上 1dp = 1 * 2 =     2px<br> 240 dpi上 1dp = 1 * 1.5 =   1.5px<br> 160 dpi上 1dp = 1 * 1 =     1px<br> 120 dpi上 1dp = 1 * 0.75 =  0.75px</p>
</blockquote>
<p>但是所表示的物理长度（160dp=1in）是一样的。</p>
<blockquote>
<p>160 dp在density=3上表示480px，物理长度为1 in<br> 160 dp在density=2上表示320px，物理长度为1 in<br> 160 dp在density=1.5上表示240px，物理长度为1 in<br> 160 dp在density=1上表示160px，物理长度为1 in<br> 160 dp在density=0.75上表示120px，物理长度为1 in</p>
</blockquote>
<p>由上可知，dp单位的使用就意味着你在这些同样尺寸但是不同分辨率的设备上看到的大小一样，此时各设备上显示的比例也就一致了。</p>
<p><strong>dp方案没有解决什么问题</strong></p>
<p>举个例子：</p>
<blockquote>
<p>屏幕分辨率为：1920*1080，屏幕尺寸为5吋的话，那么dpi为440。假设我们UI设计图是按屏幕宽度为360dp来设计的，那这样会存在什么问题呢？</p>
<p>在上述设备上，屏幕宽度其实为1080/(440/160)=392.7dp，也就是屏幕是比设计图要宽的。这种情况下， 即使使用dp也是无法在不同设备上显示为同样效果的。 同时还存在部分设备屏幕宽度不足360dp，这时就会导致按360dp宽度来开发实际显示不全的情况。</p>
</blockquote>
<p>而且上述屏幕尺寸、分辨率和像素密度的关系，很多设备并没有按此规则来实现， 因此dpi的值非常乱，没有规律可循，从而导致使用dp适配效果差强人意。</p>
<h2 id="dimens基于px的适配（宽高限定符适配）"><a href="#dimens基于px的适配（宽高限定符适配）" class="headerlink" title="dimens基于px的适配（宽高限定符适配）"></a>dimens基于px的适配（宽高限定符适配）</h2><p><strong>原理：</strong></p>
<blockquote>
<p>根据市面上手机分辨率的占比分析，我们选定一个占比例值大的（比如1280<em>720）设定为一个基准，然后其他分辨率根据这个基准做适配。<br> 基准的意思（比如320</em>480的分辨率为基准）是：<br> 宽为320，将任何分辨率的宽度分为320份，取值为x1到x320<br> 长为480，将任何分辨率的高度分为480份，取值为y1到y480</p>
</blockquote>
<p>例如对于800 * 480的分辨率设备来讲，需要在项目中values-800x480目录下的dimens.xml文件中的如下设置（当然了，可以通过工具自动生成）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;x1&quot;</span>&gt;</span>1.5px<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;x2&quot;</span>&gt;</span>3.0px<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;x3&quot;</span>&gt;</span>4.5px<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;x4&quot;</span>&gt;</span>6.0px<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;x5&quot;</span>&gt;</span>7.5px<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到x1 = 480 / 基准 = 480 / 320 = 1.5 ;它的意思就是同样的1px，在320/480分辨率的手机上是1px，在480/800的分辨率的手机上就是1*1.5px，px会根据我们指定的不同values文件夹自动适配为合适的大小。</p>
<p><img src="/images/android_screen_adjust03.png" alt="img"></p>
<p><img src="/images/android_screen_adjust04.png" alt="img"></p>
<p><strong>验证方案：</strong><br> 简单通过计算验证下这种方案是否能达到适配的效果，例如设计图上有一个宽187dp的View。</p>
<p><strong>分辨率为480 * 800</strong></p>
<blockquote>
<ul>
<li>设计图占宽比: 187dp / 375dp = 0.498</li>
<li>实际在480 800占宽比 = 187 1.28px / 480 = 0.498</li>
</ul>
</blockquote>
<p><strong>分辨率为1080 * 1920</strong></p>
<blockquote>
<ul>
<li>设计图占宽比: 187dp / 375dp = 0.498</li>
<li>实际在1080 1920占宽比 = 187 2.88px / 1080 = 0.498</li>
<li>计算高同理</li>
</ul>
</blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<ul>
<li><p>侵入性强</p>
</li>
<li><p>需要精准命中资源文件才能适配，比如1920x1080的手机就一定要找到1920x1080的限定符，否则就只能用统一的默认的dimens文件了。而使用默认的尺寸的话，UI就很可能变形，简单说，就是容错机制很差。</p>
</li>
<li><p>Android不同分辨率的手机实在太多了，可能你说主流就可以，的确小公司主流就可以，淘宝这种App肯定不能只适配主流手机。控件在设计图上显示的大小以及控件之间的间隙在小分辨率和大分辨率手机上天壤之别，你会发现大屏幕手机上控件超级大。可能你会觉得正常，毕竟分辨率不同。但实际效果大的有些夸张。</p>
</li>
<li><p>占据资源大：好几百KB，甚至多达1M或跟多。</p>
</li>
</ul>
</blockquote>
<h2 id="dimens基于dp的适配（smallWidth适配）"><a href="#dimens基于dp的适配（smallWidth适配）" class="headerlink" title="dimens基于dp的适配（smallWidth适配）"></a>dimens基于dp的适配（smallWidth适配）</h2><p><strong>原理:</strong></p>
<blockquote>
<p>这种适配依据的是最小宽度限定符。指的是Android会识别屏幕可用高度和宽度的最小尺寸的dp值（其实就是手机的宽度值），然后根据识别到的结果去资源文件中寻找对应限定符的文件夹下的资源文件。这种机制和上文提到的宽高限定符适配原理上是一样的，都是系统通过特定的规则来选择对应的文件。</p>
</blockquote>
<p>举个例子，小米5的dpi是480,横向像素是1080px，根据px=dp(dpi/160)，横向的dp值是1080/(480/160),也就是360dp,系统就会去寻找是否存在value-sw360dp的文件夹以及对应的资源文件。</p>
<p><img src="/images/android_screen_adjust05.png" alt="img"></p>
<p><img src="/images/android_screen_adjust06.png" alt="img"></p>
<p>smallestWidth限定符适配和宽高限定符适配最大的区别在于，有很好的容错机制，<strong>如果没有value-sw360dp文件夹，系统会向下寻找，比如离360dp最近的只有value-sw350dp，那么Android就会选择value-sw350dp文件夹下面的资源文件</strong>。这个特性就完美的解决了上文提到的宽高限定符的容错问题。</p>
<p><strong>缺点:</strong></p>
<blockquote>
<ul>
<li>侵入性强</li>
<li>Android 私人订制的原因，宽度方面参差不齐，不可能适配所有的手机。</li>
<li>项目中增加了N个文件夹，上拉下拉查看文件非常不方便：想看string或者color资源文件需要拉很多再能到达。</li>
<li>通过宽度限定符就近查找的原理，可以看出来匹配出来的大小不够准确。</li>
<li>是在Android 3.2 以后引入的，Google的本意是用它来适配平板的布局文件（但是实际上显然用于diemns适配的效果更好），不过目前SPX所有的项目应该最低支持版本应该都是5.1了，所以这问题其实也不重要了。</li>
</ul>
</blockquote>
<h2 id="今日头条适配（修改手机的设备密度density）"><a href="#今日头条适配（修改手机的设备密度density）" class="headerlink" title="今日头条适配（修改手机的设备密度density）"></a>今日头条适配（修改手机的设备密度density）</h2><h3 id="梳理需求："><a href="#梳理需求：" class="headerlink" title="梳理需求："></a>梳理需求：</h3><p>首先来梳理下我们的需求，一般我们设计图都是以固定的尺寸来设计的。比如以分辨率1920px * 1080px来设计，以density为3来标注，也就是屏幕其实是640dp * 360dp。如果我们想在所有设备上显示完全一致，其实是不现实的，因为屏幕高宽比不是固定的，16:9、4:3甚至其他宽高比层出不穷，宽高比不同，显示完全一致就不可能了。但是通常下，我们只需要以宽或高一个维度去适配，比如我们Feed是上下滑动的，只需要保证在所有设备中宽的维度上显示一致即可，再比如一个不支持上下滑动的页面，那么需要保证在高这个维度上都显示一致，尤其不能存在某些设备上显示不全的情况。同时考虑到现在基本都是以dp为单位去做的适配，如果新的方案不支持dp，那么迁移成本也非常高。</p>
<p><strong>因此，总结下大致需求如下：</strong></p>
<blockquote>
<ul>
<li>支持以宽或者高一个维度去适配，保持该维度上和设计图一致；</li>
<li>支持dp和sp单位，控制迁移成本到最小。</li>
</ul>
</blockquote>
<h3 id="找方案兼容突破口"><a href="#找方案兼容突破口" class="headerlink" title="找方案兼容突破口"></a>找方案兼容突破口</h3><p>从dp和px的转换公式 ：</p>
<blockquote>
<p><img src="https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bpx%20=%20dp%20*%20density%7D" alt="\color{red}{px = dp * density}"></p>
</blockquote>
<p>可以看出，如果设计图宽为360dp，想要保证在所有设备计算得出的px值都正好是屏幕宽度的话，我们只能修改 density 的值。通过阅读源码，我们可以得知，density 是 DisplayMetrics 中的成员变量，而 DisplayMetrics 实例通过 Resources#getDisplayMetrics 可以获得，而Resouces通过Activity或者Application的Context获得。</p>
<p>先来熟悉下 DisplayMetrics 中和适配相关的几个变量：</p>
<blockquote>
<ul>
<li>DisplayMetrics#density 就是上述的density</li>
<li>DisplayMetrics#densityDpi 就是上述的dpi</li>
<li>DisplayMetrics#scaledDensity 字体的缩放因子，正常情况下和density相等，但是调节系统字体大小后会改变这个值</li>
</ul>
</blockquote>
<h3 id="是不是Android中所有的dp和px的换算都是通过-DisplayMetrics-中相关的值来计算的呢？"><a href="#是不是Android中所有的dp和px的换算都是通过-DisplayMetrics-中相关的值来计算的呢？" class="headerlink" title="是不是Android中所有的dp和px的换算都是通过 DisplayMetrics 中相关的值来计算的呢？"></a>是不是Android中所有的dp和px的换算都是通过 DisplayMetrics 中相关的值来计算的呢？</h3><ul>
<li>首先来看看布局文件中的dp转化，最终都是调用<strong>TypedValue#applyDimension</strong>来进行住转化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">applyDimension</span><span class="params">(<span class="keyword">int</span> unit, <span class="keyword">float</span> value, DisplayMetrics metrics)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(uint)&#123;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_PX:</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_DIP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.density;</span><br><span class="line">        <span class="keyword">case</span> COMPLEX_UNIT_SP:</span><br><span class="line">            <span class="keyword">return</span> value * metrics.scaleDensity;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>图片的decode，<strong>BitmapFactory#decodeResourceStream方法:</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeResourceStream</span><span class="params">(Resource res, TypedValue value, InputStream is, Rect pad, Options opts)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span>(opts.inTargetDensity == <span class="number">0</span> &amp;&amp; res != <span class="keyword">null</span>)&#123;</span><br><span class="line">        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decodeStream(is, pad, opts);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还有些其他dp转换的场景，基本都是通过 DisplayMetrics 来计算的，这里不再详述。因此，想要满足上述需求，我们只需要修改<strong>DisplayMetrics 中和 dp</strong> 转换相关的变量即可。</p>
<h3 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h3><p>下面假设设计图宽度是360dp，以宽维度来适配。</p>
<p>那么适配后 自定义density = 设备真实宽(单位px) / 360，接下来只需要把我们计算好的 density 在系统中修改下即可，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配：修改设备密度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sNoncompatDensity;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">float</span> sNoncompatScaledDensity;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCustomDensity</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> <span class="keyword">final</span> Application application)</span> </span>&#123;</span><br><span class="line">    DisplayMetrics appDisplayMetrics = application.getResources().getDisplayMetrics();</span><br><span class="line">    <span class="keyword">if</span> (sNoncompatDensity == <span class="number">0</span>) &#123;</span><br><span class="line">        sNoncompatDensity = appDisplayMetrics.density;</span><br><span class="line">        sNoncompatScaledDensity = appDisplayMetrics.scaledDensity;</span><br><span class="line">        <span class="comment">// 防止系统切换后不起作用</span></span><br><span class="line">        application.registerComponentCallbacks(<span class="keyword">new</span> ComponentCallbacks() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (newConfig != <span class="keyword">null</span> &amp;&amp; newConfig.fontScale &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> targetDensity = appDisplayMetrics.widthPixels / <span class="number">360</span>;</span><br><span class="line">    <span class="comment">// 防止字体变小</span></span><br><span class="line">    <span class="keyword">float</span> targetScaleDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity);</span><br><span class="line">    <span class="keyword">int</span> targetDensityDpi = (<span class="keyword">int</span>) (<span class="number">160</span> * targetDensity);</span><br><span class="line"></span><br><span class="line">    appDisplayMetrics.density = targetDensity;</span><br><span class="line">    appDisplayMetrics.scaledDensity = targetScaleDensity;</span><br><span class="line">    appDisplayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> DisplayMetrics activityDisplayMetrics = activity.getResources().getDisplayMetrics();</span><br><span class="line">    activityDisplayMetrics.density = targetDensity;</span><br><span class="line">    activityDisplayMetrics.scaledDensity = targetScaleDensity;</span><br><span class="line">    activityDisplayMetrics.densityDpi = targetDensityDpi;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在 Activity#onCreate 方法中调用下。代码比较简单，也没有涉及到系统非公开api的调用，因此理论上不会影响app稳定性。</p>
<p><strong>缺点:</strong></p>
<blockquote>
<ul>
<li>只能支持以高或宽中的一个作为基准进行适配。</li>
<li>只需要修改一次 density，项目中的所有地方都会自动适配，这个看似解放了双手，减少了很多操作，但是实际上反应了一个缺点，那就是只能一刀切的将整个项目进行适配，但适配范围是不可控的。项目中如果采用了系统控件、三方库控件、等不是我们项目自身设计的控件，这时就会出现和我们项目自身的设计图尺寸差距非常大的问题。</li>
</ul>
</blockquote>
<h1 id="相关的问题探讨"><a href="#相关的问题探讨" class="headerlink" title="相关的问题探讨"></a>相关的问题探讨</h1><h2 id="drawable-xhdpi中的图片放到xxhdpi的手机上，内存是如何变化的"><a href="#drawable-xhdpi中的图片放到xxhdpi的手机上，内存是如何变化的" class="headerlink" title="drawable-xhdpi中的图片放到xxhdpi的手机上，内存是如何变化的"></a>drawable-xhdpi中的图片放到xxhdpi的手机上，内存是如何变化的</h2><h3 id="图片所占内存是如何计算的？"><a href="#图片所占内存是如何计算的？" class="headerlink" title="图片所占内存是如何计算的？"></a>图片所占内存是如何计算的？</h3><p>现在有一张图片： 宽度 = 450像素，高度 = 300像素</p>
<ol>
<li>如果在与手机屏幕密度相同的文件夹下存在此资源，那么内存=图片的宽度（像素）图片的高度（像素） 色彩格式所占的字节数；<br>比方说 你的手机分辨率 是 xxhdpi，你有一张图片放在 drawable-xxhdpi文件夹中，图片的色彩格式为 ARGB-8888，即每个像素站4个字节；</li>
</ol>
<p>图片占用的内存 = 450 * 300 *4 = 540_000 字节= 527 kb</p>
<ol start="2">
<li>如果手机屏幕密度相同的文件夹下不存在此文件，而在大于手机屏幕密度的文件夹下存在此资源， 会进行缩小相应的倍数的平方。<br>xx-hdpi 的密度值是 480， xxx-hdpi 的密度值是640</li>
</ol>
<p>比方说 你的手机还是 xxhdpi ，此时你的图片放在 drawable-xxxhdpi文件夹下；</p>
<p>图片占用的内存 = 450 / (640/480) * 300 / (640/480) * 4 = 303_750 字节 = 297kb</p>
<ol start="3">
<li>若在大于手机屏幕密度的文件夹下没找到此资源，则会向小于手机屏幕密度的文件夹下查找，如果存在，则会进行放大相应的倍数的平方。<br>比方说 你的手机还是 xxhdpi ，此时你的图片放在 drawable-xhdpi文件夹下；</li>
</ol>
<p>xx-hdpi 的密度值是 480， x-hdpi 的密度值是320</p>
<p>图片占用的内存 = 400 * (480 / 320) * 350 * (480 / 320) * 4 = 1215_000 字节 =1187 kb</p>
<h3 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h3><p>验证的手机为 华为P40：<br>分辨率为 ：2340 * 1080<br>屏幕尺寸：6.1<br>可以算出来，屏幕密度为 422，即 xx-hdpi。</p>
<p>图片大小：450*300</p>
<p><img src="/images/android_screen_adjust07.png" alt="image"></p>
<p>验证1：手机屏幕密度与图片所在的文件夹分辨率相同</p>
<p>即 图片也放在 xx-hdpi 目录下：</p>
<p><img src="/images/android_screen_adjust08.png" alt="image"></p>
<p>计算图片的宽度和高度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bitmap bm = BitmapFactory.decodeResource(getResources(), R.drawable.a1);</span><br><span class="line"><span class="keyword">int</span> width = bm.getWidth();</span><br><span class="line"><span class="keyword">int</span> height = bm.getHeight();</span><br><span class="line"></span><br><span class="line">Log.e(<span class="string">&quot;ARouterMainActivity&quot;</span>, <span class="string">&quot;width = &quot;</span> + width + <span class="string">&quot;, height = &quot;</span> + height);</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_screen_adjust09.png" alt="image"></p>
<p>可以验证上面的情况1啦。</p>
<p>验证情况2：如果手机屏幕密度相同的文件夹下不存在此文件，而在大于手机屏幕密度的文件夹下存在此资源：</p>
<p><img src="/images/android_screen_adjust10.png" alt="image"></p>
<p>即 宽度 = 图片宽度 450 / (640/480) = 337.5。<br>高度 = 图片宽度 300 / (640/480) = 225。<br>此时的内存= 337.5 * 225 * 4 = 303_750 字节</p>
<p>即情况2也满足， 情况3就不验证了，感兴趣的可以自己验证下。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li>将图片放在比手机分辨率小的目录，图片所占的内存会 <strong>放大</strong> 手机密度/图片对应目录的密度的平方倍。</li>
<li>将图片放在比手机分辨率大的目录，图片所占的内存会 <strong>缩小</strong> 图片对应目录的密度 <strong>/</strong> 手机密度的平方倍。</li>
<li>相等情况下： 等于 图片的宽度 * 图片的高度 * 色彩格式对应的字节数</li>
</ol>
<h2 id="资源文件加载规则。比如说图片存放在drawable-hdpi和drawable-xxhdpi下，xhdpi的手机会加载哪张？"><a href="#资源文件加载规则。比如说图片存放在drawable-hdpi和drawable-xxhdpi下，xhdpi的手机会加载哪张？" class="headerlink" title="资源文件加载规则。比如说图片存放在drawable-hdpi和drawable-xxhdpi下，xhdpi的手机会加载哪张？"></a>资源文件加载规则。比如说图片存放在drawable-hdpi和drawable-xxhdpi下，xhdpi的手机会加载哪张？</h2><p>当App在特定设备上运行时对应dpi目录下没有找到某个资源时，遵循“<strong>先高再低</strong>”原则，然后按比例缩放图片。比如，当前为xhdpi设备，并且只有以下几个目录，则drawable的寻找顺序为：</p>
<p>xhdpi-&gt;xxhdpi-&gt;xxxhdpi(如果没有更高的了)-&gt;nodpi(如果有的话)-&gt;hdpi-&gt;mdpi，如果在xxhdpi中找到目标图片，则压缩2/3来使用，如果在mdpi中找到图片，则放大2倍来使用。</p>
<p>这很好理解，如果我们按规则放置两张图片，mdpi中为48x48，xxhdpi中为144x144，那么不管我们最后从哪个目录拿到图片，在xhdpi设备上显示的像素大小都是96x96，只是一个被拉伸而来，一个被压缩而来。由于xhdpi定义了96个像素点的物理尺寸，那么这张图的物理尺寸实际就被定下来了。同样的，mdpi中48个像素点的物理尺寸与xhdpi中96个像素点的物理尺寸是相同的，这就保证了该图片在任何设备上显示出的视觉大小一致。</p>
<p>那么，一个结论就是，对于期望保持视觉大小一致的那部分图片而言，如果你也能接受android为你拉伸/压缩图片导致一定程度的模糊或者锐化，那么这些图片是不需要在每个drawable目录下都制作一份的。以现在主流设备来说一般可能在drawable-xxhdpi放置一份即可，这样可以尽量避免Android为我们放大图片所导致的OOM。</p>
<p>当然，在某些情况下，我们会主观希望打破android提供的“视觉大小一致”这种机制，此时我们就可以建立另外的drawable目录来放置需要变化的图片了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title>Android RecyclerView性能优化与对比</title>
    <url>/2018/09/21/android_recycler_view_performance/</url>
    <content><![CDATA[<p>RecyclerView的优化是面试中经常提及的知识点，细节有很多，但可以分为几大类。</p>
<span id="more"></span>

<h1 id="RecyclerView性能优化"><a href="#RecyclerView性能优化" class="headerlink" title="RecyclerView性能优化"></a>RecyclerView性能优化</h1><h2 id="数据处理和视图加载分离"><a href="#数据处理和视图加载分离" class="headerlink" title="数据处理和视图加载分离"></a>数据处理和视图加载分离</h2><p>我们知道，从远端拉取数据肯定是要放在异步的，在我们拉取下来数据之后可能就匆匆把数据丢给了 VH 处理，其实，数据的处理逻辑我们也应该放在异步处理，这样 Adapter 在 notify change 后，ViewHolder 就可以简单无压力地做数据与视图的绑定逻辑，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mTextView.setText(Html.fromHtml(data).toString());</span><br></pre></td></tr></table></figure>

<p>这里的 Html.fromHtml(data) 方法可能就是比较耗时的，存在多个TextView 的话耗时会更为严重，这样便会引发掉帧、卡顿，而如果把这一步与网络异步线程放在一起，站在用户角度，最多就是网络刷新时间稍长一点。</p>
<h2 id="数据优化"><a href="#数据优化" class="headerlink" title="数据优化"></a>数据优化</h2><p>分页拉取远端数据，对拉取下来的远端数据进行缓存，提升二次加载速度；对于新增或者删除数据通过 DiffUtil 进行局部刷新数据，而不是一味地全局刷新数据。</p>
<h2 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h2><h3 id="减少过渡绘制"><a href="#减少过渡绘制" class="headerlink" title="减少过渡绘制"></a>减少过渡绘制</h3><p>减少布局层级，可以考虑使用自定义 View 来减少层级，或者更合理地设置布局来减少层级。总之，减少布局层级深度。</p>
<h3 id="减少-xml-文件-inflate-时间"><a href="#减少-xml-文件-inflate-时间" class="headerlink" title="减少 xml 文件 inflate 时间"></a>减少 xml 文件 inflate 时间</h3><p>这里的 xml 文件不仅包括 layout 的 xml，还包括 drawable 的 xml，xml文件 inflate 出 ItemView 是通过耗时的 IO操作，尤其当 Item 的复用几率很低的情况下，随着 Type 的增多，这种 inflate 带来的损耗是相当大的，此时我可以用代码去生成布局，即 new View() 的方式，只要搞清楚 xml 中每个节点的属性对应的 API 即可。</p>
<h3 id="减少-View-对象的创建"><a href="#减少-View-对象的创建" class="headerlink" title="减少 View 对象的创建"></a>减少 View 对象的创建</h3><p>一个稍微复杂的 Item 会包含大量的 View，而大量的 View 的创建也会消耗大量时间，所以要尽可能简化ItemView；设计 ItemType 时，对多ViewType 能够共用的部分尽量设计成自定义 View，减少 View 的构造和嵌套。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他并不代表不重要，而是我不能把他们进行分类哈，其中可能某些操作会对你的 RecyclerView 有很大的优化。</p>
<p>升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能，可参考RecyclerView 数据预取。</p>
<ul>
<li><p>如果 Item 高度是固定的话，可以使用RecyclerView.setHasFixedSize(true); 来避免 requestLayout浪费资源；</p>
</li>
<li><p>设置 RecyclerView.addOnScrollListener(listener); 来对滑动过程中停止加载的操作。</p>
</li>
<li><p>如果不要求动画，可以通过 ((SimpleItemAnimator)rv.getItemAnimator()).setSupportsChangeAnimations(false);把默认动画关闭来提神效率。</p>
</li>
<li><p>对 TextView 使用 String.toUpperCase 来替代android:textAllCaps=”true”。</p>
</li>
<li><p>对 TextView 使用 StaticLayout 或者 DynamicLayout 的自定义View 来代替它。</p>
</li>
<li><p>通过重写 RecyclerView.onViewRecycled(holder) 来回收资源。</p>
</li>
<li><p>通过 RecycleView.setItemViewCacheSize(size); 来加大RecyclerView 的缓存，用空间换时间来提高滚动的流畅性。</p>
</li>
<li><p>如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的RecyclerView 中存在一样的 Adapter，可以通过设置RecyclerView.setRecycledViewPool(pool); 来共用一个RecycledViewPool。</p>
</li>
<li><p>对 ItemView 设置监听器，不要对每个 Item 都调用addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗。</p>
</li>
<li><p>通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显<br>示范围之外，应该额外缓存的空间），如下所示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getExtraLayoutSpace</span><span class="params">(RecyclerView.State state)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="RecyclerView与ListView-对比浅析"><a href="#RecyclerView与ListView-对比浅析" class="headerlink" title="RecyclerView与ListView 对比浅析"></a>RecyclerView与ListView 对比浅析</h1><p>ListView与RecyclerView缓存机制原理大致相似，如下图所示：</p>
<p><img src="/images/android_recycler_view_performance01.png" alt="image-20221223152710518"></p>
<p>滑动过程中，离屏的ItemView即被回收至缓存，入屏的ItemView则会优先从缓存中获取，只是ListView与RecyclerView的实现细节有差异.（这只是缓存使用的其中一个场景，还有如刷新等）</p>
<h2 id="缓存机制对比"><a href="#缓存机制对比" class="headerlink" title="缓存机制对比"></a>缓存机制对比</h2><h3 id="层级不同："><a href="#层级不同：" class="headerlink" title="层级不同："></a>层级不同：</h3><p>RecyclerView比ListView多两级缓存，支持多个离ItemView缓存，支持开发者自定义缓存处理逻辑，支持所有RecyclerView共用同一个RecyclerViewPool(缓存池)。<br>具体来说：<br>ListView(两级缓存)：</p>
<p><img src="/images/android_recycler_view_performance02.png" alt="image-20221223152935922"></p>
<p>RecyclerView(四级缓存)：</p>
<p><img src="/images/android_recycler_view_performance03.png" alt="image-20221223153010279"></p>
<p>ListView和RecyclerView缓存机制基本一致：<br>1). mActiveViews和mAttachedScrap功能相似，意义在于快速重用屏幕上可见的列表项ItemView，而不需要重新createView和bindView；<br>2). mScrapView和mCachedViews + mReyclerViewPool功能相似，意义在于缓存离开屏幕的ItemView，目的是让即将进入屏幕的ItemView重用.<br>3). RecyclerView的优势在于<br>a.mCacheViews的使用，可以做到屏幕外的列表项ItemView进入屏幕内时也无须bindView快速重用；<br>b.mRecyclerPool可以供多个RecyclerView共同使用，在特定场景下，如viewpaper+多个列表页下有优势.客观来说，RecyclerView在特定场景下对ListView的缓存机制做了补强和完善。</p>
<h3 id="缓存不同"><a href="#缓存不同" class="headerlink" title="缓存不同"></a>缓存不同</h3><p>1). RecyclerView缓存RecyclerView.ViewHolder，抽象可理解为：View + ViewHolder(避免每次createView时调用findViewById) + flag(标识状态)；<br>2). ListView缓存View。缓存不同，二者在缓存的使用上也略有差别，具体来说：<br>ListView获取缓存的流程：</p>
<p><img src="/images/android_recycler_view_performance04.png" alt="image-20221223153337582"></p>
<p>RecyclerView获取缓存的流程：</p>
<p><img src="/images/android_recycler_view_performance05.png" alt="image-20221223153414820"></p>
<p>1). RecyclerView中mCacheViews(屏幕外)获取缓存时，是通过匹配pos获取目标位置的缓存，这样做的好处是，当数据源数据不变的情况下，无须重新bindView：</p>
<p><img src="/images/android_recycler_view_performance06.png" alt="image-20221223153515347"></p>
<p>而同样是离屏缓存，ListView从mScrapViews根据pos获取相应的缓存，但是并没有直接使用，而是重新getView（即必定会重新bindView），相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbsListView源码：line2345</span></span><br><span class="line"><span class="comment">//通过匹配pos从mScrapView中获取缓存</span></span><br><span class="line"><span class="keyword">final</span> View scrapView = mRecycler.getScrapView(position);</span><br><span class="line"><span class="comment">//无论是否成功都直接调用getView,导致必定会调用createView</span></span><br><span class="line"><span class="keyword">final</span> View child = mAdapter.getView(position, scrapView,<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (scrapView != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child != scrapView) &#123;</span><br><span class="line">    	mRecycler.addScrapView(scrapView, position);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2). ListView中通过pos获取的是view，即pos–&gt;view；RecyclerView中通过pos获取的是viewholder，即pos –&gt; (view，viewHolder，flag)；<br>从流程图中可以看出，标志flag的作用是判断view是否需要重新bindView，这也是RecyclerView实现局部刷新的一个核心。</p>
<h2 id="局部刷新"><a href="#局部刷新" class="headerlink" title="局部刷新"></a>局部刷新</h2><p>由上文可知，RecyclerView的缓存机制确实更加完善，但还不算质的变化，RecyclerView更大的亮点在于提供了局部刷新的接口，通过局部刷新，就能避免调用许多无用的bindView。</p>
<p><img src="/images/android_recycler_view_performance07.png" alt="image-20221223153818589"></p>
<p>(RecyclerView和ListView添加，移除Item效果对比)<br>结合RecyclerView的缓存机制，看看局部刷新是如何实现的：以RecyclerView中notifyItemRemoved(1)为例，最终会调用requestLayout()，使整个RecyclerView重新绘制，过程为：onMeasure()–&gt;onLayout()–&gt;onDraw()</p>
<p>其中，onLayout()为重点，分为三步：<br>dispathLayoutStep1()：记录RecyclerView刷新前列表项ItemView的各种信息，如Top,Left,Bottom,Right，用于动画的相关计算；<br>dispathLayoutStep2()：真正测量布局大小，位置，核心函数为layoutChildren()；<br>dispathLayoutStep3()：计算布局前后各个ItemView的状态，如Remove，Add，Move，Update等，如有必要执行相应的动画.<br>其中，layoutChildren()流程图：</p>
<p><img src="/images/android_recycler_view_performance08.png" alt="image-20221223153938716"></p>
<p><img src="/images/android_recycler_view_performance09.png" alt="image-20221223154013675"></p>
<p>当调用notifyItemRemoved时，会对屏幕内ItemView做预处理，修改ItemView相应的pos以及flag(流程图中红色部分)：</p>
<p><img src="/images/android_recycler_view_performance10.png" alt="image-20221223154052503"></p>
<p>当调用fill()中RecyclerView.getViewForPosition(pos)时，RecyclerView通过对pos和flag的预处理，使得bindview只调用一次.<br>需要指出，ListView和RecyclerView最大的区别在于数据源改变时的缓存的处理逻辑，ListView是”一锅端”，将所有的mActiveViews都移入了二级缓存mScrapViews，而RecyclerView则是更加灵活地对每个View修改标志位，区分是否重新bindView。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、在一些场景下，如界面初始化，滑动等，ListView和RecyclerView都能很好地工作，两者并没有很大的差异：<br>于是便抛出了这样一个问题，微信Android客户端卡券模块，大部分UI都是以列表页的形式展示，实现方式为ListView，是否有必要将其替换成RecyclerView呢？</p>
<p><img src="/images/android_recycler_view_performance11.png" alt="image-20221223154244016"></p>
<p>答案是否定的，从性能上看，RecyclerView并没有带来显著的提升，不需要频繁更新，暂不支持用动画，意味着RecyclerView优势也不太明显，没有太大的吸引力，ListView已经能很好地满足业务需求。</p>
<p>2、数据源频繁更新的场景，如弹幕等，RecyclerView的优势会非常明显；<br>进一步来讲，结论是：列表页展示界面，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其它情况(如微信卡包列表页)两者都OK，但ListView在使用上会更加方便，快捷。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>Android图形系统-Surface和SurfaceView</title>
    <url>/2018/03/19/android_surface_surfaceview/</url>
    <content><![CDATA[<p>Surface和SurfaceView是android图形系统java层中较为重要的角色。</p>
<span id="more"></span>

<h1 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h1><p>简单的说Surface对应了一块屏幕缓冲区，每个window对应一个Surface，任何View都要画在Surface上。传统的view共享一块屏幕缓冲区，所有的绘制必须在UI线程中进行。<br>     在SDK的文档中，对Surface的描述是这样的：“Handle onto a raw buffer that is being managed by the screen compositor”，翻译成中文就是“由屏幕显示内容合成器(screen compositor)所管理的原始缓冲区的句柄”，这句话包括下面两个意思：</p>
<p>​     1、通过Surface（因为Surface是句柄）就可以获得原生缓冲器以及其中的内容。就像在C++语言中，可以通过一个文件的句柄，就可以获得文件的内容一样。<br>​     2、 原始缓冲区（a raw buffer）是用于保存当前窗口的像素数据的。<br>​     引伸地，可以认为Android中的Surface就是一个用来画图形（graphics）或图像（image）的地方。</p>
<p>​     根据Java方面的常规知识，我们知道通常画图是在一个Canvas对象上面进行的，由此，可以推知一个Surface对象中应该包含有一个Canvas（画布）对象。因此，在前面提及的两个意思的基础上，可以再加上一条：<br>​     3、Surface中有一个Canvas成员，专门用于画图的。</p>
<p>​     由以上的概括，我们总结如下：Surface中的Canvas成员，是专门用于供程序员画图的场所，就像黑板一样；其中的原始缓冲区是用来保存数据的地方；Surface本身的作用类似一个句柄，得到了这个句柄就可以得到其中的Canvas、原始缓冲区以及其它方面的内容。<br>​    Surface是用来管理数据的。（句柄）</p>
<h1 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h1><p>说SurfaceView是一个View也许不够严谨，然而从定义中pubilc classSurfaceView extends View{…..}显示SurfaceView确实是派生自View，但是SurfaceView却有自己的Surface，请看SurfaceView的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mWindow == <span class="keyword">null</span>) &#123;  </span><br><span class="line">    mWindow = <span class="keyword">new</span> MyWindow(<span class="keyword">this</span>);  </span><br><span class="line">    mLayout.type = mWindowType;  </span><br><span class="line">    mLayout.gravity = Gravity.LEFT|Gravity.TOP;  </span><br><span class="line">    mSession.addWithoutInputChannel(mWindow, mWindow.mSeq, mLayout,  </span><br><span class="line">                                    mVisible ? VISIBLE : GONE, mContentInsets); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，每个SurfaceView创建的时候都会创建一个MyWindow，new MyWindow(this)中的this正是SurfaceView自身，因此将SurfaceView和window绑定在一起，由第一部分我们知道，一个window对应一个Surface，因此SurfaceView也就内嵌了一个自己的Surface，可以认为SurfaceView是用来控制Surface中View的位置和尺寸的。 </p>
<p>​      SurfaceView就是展示Surface中数据的地方，同时可以认为SurfaceView是用来控制Surface中View的位置和尺寸的。</p>
<p>​     大家都知道，传统View及其派生类的更新只能在UI线程，然而UI线程还同时处理其他交互逻辑，这就无法保证View更新的速度和帧率了，而SurfaceView可以用独立的线程进行绘制，因此可以提供更高的帧率，例如游戏，摄像头取景等场景就比较适合SurfaceView来实现。</p>
<h2 id="SurfaceView双缓冲机制"><a href="#SurfaceView双缓冲机制" class="headerlink" title="SurfaceView双缓冲机制"></a>SurfaceView双缓冲机制</h2><p>SurfaceView跟大部分视频应用一样，把视频流解析成一帧帧的图像然后显示。如果把视频解析过程放到一个线程中完成，可能在上一帧图像已经显示过后，下一帧图像还没有来得及解析，这样会导致画面的不流畅或者声音和视频不同步的问题。所以SurfaceView和大部分视频应用一样，通过双缓冲的机制来显示帧图像。那么什么是双缓冲呢？双缓冲可以理解为有两个线程轮番去解析视频流的帧图像，当一个线程解析完帧图像后，把图像渲染到界面中，同时另一线程开始解析下一帧图像，使得两个线程轮番配合去解析视频流，以达到流畅播放的效果。</p>
<p><img src="/images/android_surface_surfaceview01.png" alt="img"></p>
<h1 id="SurfaceHolder"><a href="#SurfaceHolder" class="headerlink" title="SurfaceHolder"></a>SurfaceHolder</h1><p>SurfaceHolder是一个接口，其作用就像一个关于Surface的监听器，提供访问和控制SurfaceView内嵌的Surface 相关的方法。它通过三个回调方法，让我们可以感知到Surface的创建、销毁或者改变。</p>
<p>​     在SurfaceView中有一个方法getHolder，可以很方便地获得SurfaceView内嵌的Surface所对应的监听器接口SurfaceHolder（有点拗口吧）。</p>
<p>​     除下面将要提到的SurfaceHolder.Callback外，SurfaceHolder还提供了很多重要的方法，其中最重要的就是：</p>
<p>​    1、abstract void addCallback(SurfaceHolder.Callbackcallback)：为SurfaceHolder添加一个SurfaceHolder.Callback回调接口。<br>​    2、abstract CanvaslockCanvas()：获取一个Canvas对象，并锁定之。所得到的Canvas对象，其实就是Surface中一个成员。<br>​    3、abstract CanvaslockCanvas(Rect dirty)：同上。但只锁定dirty所指定的矩形区域，因此效率更高。<br>​    4、abstract void unlockCanvasAndPost(Canvas canvas)：当修改Surface中的数据完成后，释放同步锁，并提交改变，然后将新的数据进行展示，同时Surface中相关数据会被丢失。</p>
<p>​     2、3、4中的同步锁机制的目的，就是为了在绘制的过程中，Surface中的数据不会被改变。lockCanvas是为了防止同一时刻多个线程对同一canvas写入。</p>
<p>总结：从设计模式的高度来看，Surface、SurfaceView和SurfaceHolder实质上就是广为人知的MVC，即Model-View-Controller。Model就是模型的意思，或者说是数据模型，或者更简单地说就是数据，也就是这里的Surface；View即视图，代表用户交互界面，也就是这里的SurfaceView；SurfaceHolder很明显可以理解为MVC中的Controller（控制器）。</p>
<h1 id="SurfaceHolder-Callback"><a href="#SurfaceHolder-Callback" class="headerlink" title="SurfaceHolder.Callback"></a>SurfaceHolder.Callback</h1><p>SurfaceView内部实现了双缓冲的机制，但是实现这个功能是非常消耗系统内存的。因为移动设备的局限性，Android在设计的时候规定，SurfaceView如果为用户可见的时候，创建SurfaceView的SurfaceHolder用于显示视频流解析的帧图片，如果发现SurfaceView变为用户不可见的时候，则立即销毁SurfaceView的SurfaceHolder，以达到节约系统资源的目的。</p>
<p>如果开发人员不对SurfaceHolder进行维护，会出现最小化程序后，再打开应用的时候，视频的声音在继续播放，但是不显示画面了的情况，这就是因为当SurfaceView不被用户可见的时候，之前的SurfaceHolder已经被销毁了，再次进入的时候，界面上的SurfaceHolder已经是新的SurfaceHolder了。所以SurfaceHolder需要我们开发人员去编码维护，维护SurfaceHolder需要用到它的一个回调，SurfaceHolder.Callback()，它需要实现如下三个方法：</p>
<p>SurfaceHolder.Callback主要是当底层的Surface被创建、销毁或者改变时提供回调通知，由于绘制必须在Surface被创建后才能进行，因此SurfaceHolder.Callback中的surfaceCreated 和surfaceDestroyed 就成了绘图处理代码的边界。</p>
<p>​     SurfaceHolder.Callback中定义了三个接口方法：<br>​     1、abstract void surfaceChanged(SurfaceHolder holder, int format, int width, int height)：当surface发生任何结构性的变化时（格式或者大小），该方法就会被立即调用。<br>​     2、abstract void surfaceCreated(SurfaceHolder holder)：当surface对象创建后，该方法就会被立即调用。<br>​     3、abstract void surfaceDestroyed(SurfaceHolder holder)：当surface对象在将要销毁前，该方法会被立即调用。</p>
<h1 id="SurfaceView与普通View的区别"><a href="#SurfaceView与普通View的区别" class="headerlink" title="SurfaceView与普通View的区别"></a>SurfaceView与普通View的区别</h1><p>SurfaceView，它拥有独立的绘图表面，即它不与其宿主窗口共享同一个绘图表面。由于拥有独立的绘图表面，因此SurfaceView的UI就可以在一个独立的线程中进行绘制。又由于不会占用主线程资源，SurfaceView一方面可以实现复杂而高效的UI，另一方面又不会导致用户输入得不到及时响应。</p>
<p>普通的Android控件，例如TextView、Button等，都是将自己的UI绘制在宿主窗口的绘图表面之上，这意味着它们的UI是在应用程序的主线程中进行绘制的。由于应用程序的主线程除了要绘制UI之外，还需要及时地响应用户输入，否则的话，系统就会认为应用程序没有响应了，因此就会弹出一个ANR对话框出来。对于一些游戏画面，或者摄像头预览、视频播放来说，它们的UI都比较复杂，而且要求能够进行高效的绘制，因此，它们的UI就不适合在应用程序的主线程中进行绘制。这时候就必须要给那些需要复杂而高效UI的视图生成一个独立的绘图表面，以及使用一个独立的线程来绘制这些视图的UI。</p>
<p>一般来说，每一个窗口在SurfaceFlinger服务中都对应有一个Layer，用来描述它的绘图表面。对于那些具有SurfaceView的窗口来说，每一个SurfaceView在SurfaceFlinger服务中还对应有一个独立的Layer或者LayerBuffer，用来单独描述它的绘图表面，以区别于它的宿主窗口的绘图表面。SurfaceFlinger服务负责绘制Android应用程序的UI。SurfaceFlinger服务运行在Android系统的System进程中，它负责管理Android系统的帧缓冲区（Frame Buffer）。</p>
<h2 id="SurfaceView原理"><a href="#SurfaceView原理" class="headerlink" title="SurfaceView原理"></a>SurfaceView原理</h2><p>官方文档：</p>
<p>SurfaceView：Provides a dedicated drawing surface embedded inside of a view hierarchy. The surface is Z ordered so that it is behind the window holding its SurfaceView; the SurfaceView punches a hole in its window to allow its surface to be displayed.</p>
<p>翻译解释：</p>
<p>SurfaceView提供一个嵌入视图层级的专用的绘图表面。绘图表面是在Z轴上有序的，SurfaceView在宿主窗体的后面。SurfaceView在宿主窗体上“挖”了一个洞，以此来显示自己的表面。实际上，SurfaceView在其宿主Activity窗口上所挖的“洞”只不过是在其宿主Activity窗口上设置了一块透明区域，以显示自己内容</p>
<h1 id="SurfaceView的绘图表面的创建"><a href="#SurfaceView的绘图表面的创建" class="headerlink" title="SurfaceView的绘图表面的创建"></a>SurfaceView的绘图表面的创建</h1><p>我们知道，Activity、Window、View三者紧密联系在一起。我们在Activity中设置setContentView()，最终会调用PhoneWindow的setContentView()。经过WindowManagerImpl#addView，WindowManagerGlobal#addView，ViewRootImpl#setView方法，最顶层视图DecorView被添加到Window上。最后通过WMS调用ViewRootImpl#performTraverals方法开始View的测量、布局、绘制流程。</p>
<p>ViewRootImpl类的成员函数performTraversals在执行的过程中，如果发现当前窗口的绘图表面还没有创建，或者发现当前窗口的绘图表面已经失效了，那么就会请求WindowManagerService服务创建一个新的绘图表面，同时，它还会通过一系列的回调函数来让嵌入在窗口里面的SurfaceView有机会创建自己的绘图表面。</p>
<p>虽然SurfaceView不与它的宿主窗口共享同一个绘图表面，但是它仍然是属于宿主窗口的视图结构的一个结点的，也就是说，SurfaceView仍然是会参与到宿主窗口的某些执行流程中去。</p>
<h2 id="SurfaceView-onAttachedToWindow"><a href="#SurfaceView-onAttachedToWindow" class="headerlink" title="SurfaceView.onAttachedToWindow"></a><strong>SurfaceView.onAttachedToWindow</strong></h2><p><img src="/images/android_surface_surfaceview02.png" alt="img"></p>
<p>说明：SurfaceView在Z轴上位置是小于其宿主窗口的Z轴位置的。为了保证SurfaceView的UI是可见的，SurfaceView就需要在其宿主窗口的上面打一个孔出来，实际上就是在其宿主窗口的绘图表面上设置一块透明区域，以便可以将自己显示出来。SurfaceView类的成员函数onAttachedToWindow调用mParent.requestTransparentRegion(SurfaceView.this)去通知父View，当前正在处理的SurfaceView需要在宿主窗口的绘图表面上打一个孔，即需要在宿主窗口的绘图表面上设置一块透明区域。</p>
<h2 id="SurfaceView-onWindowVisibilityChanged"><a href="#SurfaceView-onWindowVisibilityChanged" class="headerlink" title="SurfaceView.onWindowVisibilityChanged"></a>SurfaceView.onWindowVisibilityChanged</h2><p><img src="/images/android_surface_surfaceview03.png" alt="img"></p>
<p>说明：类SurfaceView调用updateSurface来更新当前正在处理的SurfaceView。在更新的过程中，如果发现当前正在处理的SurfaceView还没有创建绘图表面，那么就会请求WindowManagerService服务为它创建一个。</p>
<h2 id="SurfaceView-updateRequestedVisibility"><a href="#SurfaceView-updateRequestedVisibility" class="headerlink" title="SurfaceView.updateRequestedVisibility"></a>SurfaceView.updateRequestedVisibility</h2><p><img src="/images/android_surface_surfaceview04.png" alt="img"></p>
<p>说明：mWindowVisibility表示SurfaceView的宿主窗口的可见性，mViewVisibility表示SurfaceView自身的可见性。只有当mWindowVisibility和mViewVisibility的值均等于true，且宿主窗口没有停止，mRequestedVisible的值才为true，表示SurfaceView是可见的。</p>
<h2 id="SurfaceView-updateSurface"><a href="#SurfaceView-updateSurface" class="headerlink" title="SurfaceView.updateSurface"></a>SurfaceView.updateSurface</h2><p>mSurface：这个Surface对象描述的是SurfaceView专有的绘图表面，在SurfaceView对象创建时就会被实例化。updateSurface方法根据实际条件判断创建或更新mSurface。</p>
<h2 id="如何在一个绘图表面上进行UI绘制？"><a href="#如何在一个绘图表面上进行UI绘制？" class="headerlink" title="如何在一个绘图表面上进行UI绘制？"></a>如何在一个绘图表面上进行UI绘制？</h2><p>1.在绘图表面的基础上建立一块画布，即获得一个Canvas对象<br>2.利用Canvas类提供的绘图方法在前面获得的画布上绘制任意的UI<br>3.最后通过SurfaceFlinger服务将它合成到屏幕上去</p>
<h2 id="SurfaceView如何绘制？"><a href="#SurfaceView如何绘制？" class="headerlink" title="SurfaceView如何绘制？"></a>SurfaceView如何绘制？</h2><p>1.通过SurfaceView的getHolder方法获得SurfaceHolder<br> 2.通过SurfaceHolder的lockCanvas方法获得Canvas<br> 3.上面会走到Surface的lockCanvas方法获得Canvas<br> 4.在Canvas上绘制UI<br> 5.通过SurfaceHolder的unlockCanvasAndPost将绘制好的canvas投递到surface上<br> 6.上面会走到Surface的unlockCanvasAndPost方法</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>图形系统</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频基础知识整理</title>
    <url>/2018/09/02/av_base_info/</url>
    <content><![CDATA[<p>视频是包含了画面和声音的一个整体，是采用了一些复杂的算法将画面和声音数字信号进行编码存储，并通过解码算法再进行画面和声音的还原播放。</p>
<span id="more"></span>

<h2 id="视频文件格式"><a href="#视频文件格式" class="headerlink" title="视频文件格式"></a>视频文件格式</h2><p>文件格式其实就是为了让系统中的应用程序识别并关联这些文件，让相应的文件由相应的应用程序打开。比如你双击一个.mp4文件，就会打开播放器并播放该文件。</p>
<p>所以我们常见到的.avi .mp4 .rmvb .mkv等都是视频的文件格式。它由   系统中得播放器程序关联。你可以随意改扩展名，但是视频本身的内容不会变，只是关联启动的应用程序可能会变。并不是说将一个.avi的视频后缀改为.mp4他就变成MP4格式的了。</p>
<h2 id="视频封装格式"><a href="#视频封装格式" class="headerlink" title="视频封装格式"></a>视频封装格式</h2><p>封装格式（也叫容器），就是将已经编码压缩好的视频轨和音频轨按照一定的格式放到一个文件中，也就是说仅仅是一个外壳，或者把它当成一个放视频轨和音频轨的文件夹也可以。</p>
<p>同样，封装格式一样不影响视频画质。它只负责把内部的视频轨和音频轨集成在一起，只起到一个文件夹（或者压缩包）的作用，并没有对视频轨和音频轨造成影响。</p>
<h5 id="几种常见的封装格"><a href="#几种常见的封装格" class="headerlink" title="几种常见的封装格"></a>几种常见的封装格</h5><p><img src="/images/video_packing_type.png" alt="image-20210607112412856"></p>
<h2 id="视频编码格式"><a href="#视频编码格式" class="headerlink" title="视频编码格式"></a>视频编码格式</h2><p>所谓视频编码方式就是指能够对数字视频进行压缩或者解压缩（视频解码）的程序或者设备。也可以指通过过特定的压缩技术，将某个视频格式转换成另一种视频格式。</p>
<h5 id="常见的编码格式"><a href="#常见的编码格式" class="headerlink" title="常见的编码格式"></a>常见的编码格式</h5><p>1，MPEG系列（由ISO[国际标准组织机构]下属的MPEG[运动图象专家组]开发 ）视频编码方面主要有：</p>
<ol>
<li><p>MPEG-1第二部分（MPEG-1第二部分主要使用在VCD上，有些在线视频也使用这种格式。该编解码器的质量大致上和原有的VHS录像带相当。）2) MPEG-2第二部分（MPEG-2第二部分等同于H.262，使用在DVD、SVCD和大多数数字视频广播系统和有线分布系统（cable distribution systems）中。）</p>
</li>
<li><p>MPEG-4第二部分（MPEG-4第二部分标准可以使用在网络传输、广播和媒体存储上。比起MPEG-2和第一版的H.263，它的压缩性能有所提高。）4) MPEG-4第十部分（MPEG-4第十部分技术上和ITU-T H.264是相同的标准，有时候也被叫做“AVC”）最后这两个编码组织合作，诞生了H.264/AVC标准。ITU-T给这个标准命名为H.264，而ISO/IEC称它为MPEG-4 高级视频编码（Advanced Video Coding，AVC）。</p>
</li>
</ol>
<p>2，H.26X系列 （由ITU[国际电传视讯联盟]主导）包括H.261、H.262、H.263、H.264、H.265。</p>
<ol>
<li><p>H.261：主要在老的视频会议和视频电话产品中使用。</p>
</li>
<li><p>H.263：主要用在视频会议、视频电话和网络视频上。</p>
</li>
<li><p>H.264：H.264/MPEG-4第十部分，或称AVC（Advanced Video Coding，高级视频编码），是一种视频压缩标准，一种被广泛使用的高精度视频的录制、压缩和发布格式。</p>
</li>
<li><p>H.265：高效率视频编码（High Efficiency Video Coding，简称HEVC）是一种视频压缩标准，H.264/MPEG-4 AVC的继任者。HEVC被认为不仅提升图像质量，同时也能达到H.264/MPEG-4 AVC两倍之压缩率（等同于同样画面质量下比特率减少了50%），可支持4K分辨率甚至到超高画质电视，最高分辨率可达到8192×4320（8K分辨率），这是目前发展的趋势。</p>
</li>
</ol>
<p>其他系列：AMV · AVS · Bink · CineForm · Cinepak · Dirac · DV · Indeo · Video · Pixlet · RealVideo · RTVideo · SheerVideo · Smacker · Sorenson Video · Theora · VC-1 · VP3 · VP6 · VP7 · VP8 · VP9 · WMV。因为以上编码方式不常用，不再介绍。</p>
<h2 id="视频为什么要进行编码？"><a href="#视频为什么要进行编码？" class="headerlink" title="视频为什么要进行编码？"></a>视频为什么要进行编码？</h2><p>视频是连续的图像序列，由连续的帧构成，一帧即为一幅图像。<br>由于人眼的视觉暂留效应，当帧序列以一定的速率播放时，我们看到的就是动作连续的视频。<br>这么多连续的图像数据如果不经过编码的数据量太大了。</p>
<h5 id="看一组数据"><a href="#看一组数据" class="headerlink" title="看一组数据"></a>看一组数据</h5><p>1）一部全高清1080P 2小时的大片，原始数据量大约为4171G</p>
<p>2）假设图像分辨率为4CIF（704*576），帧频为25f/s.如果不进行压缩，大概需要多大的带宽呢？</p>
<p>如果原始图像为4:2:0的YUV格式数据（这个格式已经为原始数据的最小），</p>
<p>每幅画面的大小为：704<em>576</em>1.5*8 bit = 4.64M，也就是说每一帧为4.64M。</p>
<p>如果想看流畅的视频画面，大概每秒需要传输25帧，也即需要4.64*25M = 116M的带宽。</p>
<p>CIF（352*288）格式也需要116/4=29M 的带宽。也就是说如果不压缩，20M的接入带宽，</p>
<p>连QQ聊天都做不了。</p>
<p>以上的计算，只是想说明一个问题，原始视频的数据量相当大，不可能直接进行实时网络传输，甚至连存储的代价都相当大。</p>
<p>这就需要做视频压缩，也就是说去除掉原始数据中的一些冗余，然后再进行传输或者存储，来减少对带宽和存储空间的需求。</p>
<p>大家现在可以在2-4M的带宽上享受高清实时视频服务，可以在一张4G的蓝光DVD里面存储高清视频，这是因为这些传输或者存在的视频信号已经经过了压缩。</p>
<h2 id="数据的压缩"><a href="#数据的压缩" class="headerlink" title="数据的压缩"></a>数据的压缩</h2><p>数据压缩是指在不丢失有用信息的前提下，缩减数据量以减少存储空间，提高其传输、存储和处理效率，或按照一定的算法对数据进行重新组织，减少数据的冗余和存储的空间的一种技术方法。</p>
<p>数据压缩能够实现是因为多数现实世界的数据都有统计冗余。例如，字母“e”在英语中比字母“z”更加常用，字母“q”后面是“z”的可能性非常小。无损压缩算法通常利用了统计冗余，这样就能更加简练地、但仍然是完整地表示发送方的数据。</p>
<p>一些机制是可逆的，这样就可以恢复原始的数据，这种机制称为<strong>无损数据压缩</strong>；另外一些机制为了实现更高的压缩率允许一定程度的数据损失，这种机制称为<strong>有损数据压缩</strong>。</p>
<h2 id="视频的压缩"><a href="#视频的压缩" class="headerlink" title="视频的压缩"></a>视频的压缩</h2><p>视频图像数据有极强的相关性，也就是说有大量的冗余信息。其中冗余信息可分为<strong>空域冗余信息</strong>和<strong>时域冗余信息</strong>。</p>
<p>压缩技术就是将数据中的冗余信息去掉（去除数据之间的相关性），压缩技术包含帧内图像数据压缩技术、帧间图像数据压缩技术和熵编码压缩技术。</p>
<h5 id="去时域压缩"><a href="#去时域压缩" class="headerlink" title="去时域压缩"></a>去时域压缩</h5><p>使用帧间编码技术可去除时域冗余信息，它包括以下三部分：</p>
<p>•－ 运动补偿</p>
<p>​     运动补偿是通过先前的局部图像来预测、补偿当前的局部图像，它是减少帧序列冗余信息的有效方法。</p>
<p>•－ 运动表示</p>
<p>​     不同区域的图像需要使用不同的运动矢量来描述运动信息。运动矢量通过熵编码进行压缩。</p>
<p>•－运动估计</p>
<p>​     运动估计是从视频序列中抽取运动信息的一整套技术。</p>
<p>•注：通用的压缩标准都使用基于块的运动估计和运动补偿。</p>
<h5 id="去空域压缩"><a href="#去空域压缩" class="headerlink" title="去空域压缩"></a>去空域压缩</h5><p>主要使用帧内编码技术和熵编码技术：</p>
<p>•－变换编码</p>
<p>​     帧内图像和预测差分信号都有很高的空域冗余信息。变换编码将空域信号变换到另一正交矢量空间，使其相关性下降，数据冗余度减小。</p>
<p>•－ 量化编码</p>
<p>​     经过变换编码后，产生一批变换系数，对这些系数进行量化，使编码器的输出达到一定的位率。这一过程导致精度的降低。</p>
<p>•－熵编码</p>
<p>​     熵编码是无损编码。它对变换、量化后得到的系数和运动信息，进行进一步的压缩。</p>
<p><img src="/images/space_more_zip.png" alt="image-20210607113147211"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空域冗余</span><br><span class="line"></span><br><span class="line">单帧画面内有很多像素点是一样的，如果存储时一个点一个点的存储，这将带来很大的存储空间的浪费。</span><br></pre></td></tr></table></figure>

<p><img src="/images/time_more_zip1.png" alt="image-20210607113251252"></p>
<p><img src="/images/time_more_zip2.png" alt="image-20210607113314716"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">帧与帧之间的冗余成为时域冗余</span><br><span class="line"></span><br><span class="line">帧1与帧2有很大一部分是一样的，画面内只有部分物体发生了位移或动作变化。随属于不同的画面帧，但存储时如果能共用相同的画面元素，能节省很大一部分存储空间。</span><br></pre></td></tr></table></figure>

<h5 id="视觉冗余"><a href="#视觉冗余" class="headerlink" title="视觉冗余"></a>视觉冗余</h5><p>视觉冗余:是指人眼不能感知或不敏感的那部分图像信息。</p>
<h5 id="信息熵冗余-熵编码-哈夫曼算法"><a href="#信息熵冗余-熵编码-哈夫曼算法" class="headerlink" title="信息熵冗余 == 熵编码-哈夫曼算法"></a>信息熵冗余 <strong>==</strong> <strong>熵编码</strong>-<strong>哈夫曼算法</strong></h5><p>信息熵冗余:也称编码冗余，人们用于表达某一信息所需要的比特数总比理论上表示该信息所需要的最少比特<br>数要大，它们之间的差距就是信息熵冗余，或称编码冗余。</p>
<h5 id="知识冗余"><a href="#知识冗余" class="headerlink" title="知识冗余"></a>知识冗余</h5><p>人类(头 身体 腿)，汽车，房子 不需要记录</p>
<p>知识冗余:是指在有些图像中还包含与某些验证知识有关的信息。</p>
<h5 id="视音频完整的录制编码流程"><a href="#视音频完整的录制编码流程" class="headerlink" title="视音频完整的录制编码流程"></a>视音频完整的录制编码流程</h5><p><img src="/images/encode_decode_info.png" alt="encode_decode_info"></p>
<p>编码的目的，就是为了压缩。各种视频编码方式，都是为了让视频变得体积更小，有利于存储和传输。编码的<br>核心思想就是去除冗余信息。</p>
<h2 id="图像组（GOP）压缩"><a href="#图像组（GOP）压缩" class="headerlink" title="图像组（GOP）压缩"></a>图像组（GOP）压缩</h2><p>•GOP（Group of Picture）</p>
<p>   在视频编码序列中，GOP就称为一个图像组。</p>
<p>•GOP中的编码帧</p>
<p>   在视频中，每帧代表一幅静止的图像，而压缩是要采取各种压缩算法减少数据的容量。</p>
<p>   在视频编码序列中，主要有三种编码帧：I帧、P帧、B帧</p>
<p><strong>I****帧</strong>即Intra-coded picture（帧内编码图像帧），也<strong>称关键帧</strong>不参考其他图像帧，只利用本帧的信息进行编码，是一幅完整的画面。</p>
<p><strong>P****帧</strong>即Predictive-coded Picture（预测编码图像帧），利用之前的I帧或P帧，采用运动预测的方式进行帧间预测编码，表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是<strong>差别帧</strong>，P帧没有完整画面数据，只有与前一帧的画面差别的数据）。</p>
<p><strong>B****帧</strong>即Bidirectionally predicted picture（双向预测编码图像帧)，提供最高的压缩比，它既需要之前的图像帧(I帧或P帧)，也需要后来的图像帧(P帧)，采用运动预测的方式进行帧间双向预测编码，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高</p>
<h5 id="I帧"><a href="#I帧" class="headerlink" title="I帧"></a>I帧</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I帧特点： （关键帧）</span><br><span class="line">1.它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;        </span><br><span class="line">2.解码时仅用I帧的数据就可重构完整图像;        </span><br><span class="line">3.I帧描述了图像背景和运动主体的详情;        </span><br><span class="line">4.I帧不需要参考其他画面而生成;        </span><br><span class="line">5.I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);        </span><br><span class="line">6.I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;        </span><br><span class="line">7.I帧不需要考虑运动矢量;       </span><br><span class="line">8.I帧所占数据的信息量比较大。    </span><br><span class="line"></span><br><span class="line">I帧编码流程：       </span><br><span class="line">1.进行帧内预测，决定所采用的帧内预测模式。        </span><br><span class="line">2.像素值减去预测值，得到残差。        </span><br><span class="line">3.对残差进行变换和量化。        </span><br><span class="line">4.变长编码和算术编码。       </span><br><span class="line">5.重构图像并滤波，得到的图像作为其它帧的参考帧。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="P帧"><a href="#P帧" class="headerlink" title="P帧"></a>P帧</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P帧特点</span><br><span class="line"></span><br><span class="line">1.P帧是I帧后面相隔1-2帧的编码帧。         </span><br><span class="line">2.P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量（预测误差）。         </span><br><span class="line">3.解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像。         </span><br><span class="line">4.P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧。          </span><br><span class="line">5.P帧可以是其后面P帧的参考帧，也可以是其前后的B帧的参考帧。        </span><br><span class="line">6.由于P帧是参考帧，它可能造成解码错误的扩散。         </span><br><span class="line">7.由于是差值传送，P帧的压缩比较高。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="B帧"><a href="#B帧" class="headerlink" title="B帧"></a>B帧</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B帧特点</span><br><span class="line"></span><br><span class="line">1.B帧是由前面的I或P帧和后面的P帧来进行预测的;        </span><br><span class="line">2.B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;        </span><br><span class="line">3.B帧是双向预测编码帧;        </span><br><span class="line">4.B帧压缩比最高,因为它只反映2参考帧间运动主体的变化情况,预测比较准确;        </span><br><span class="line">5.B帧不是参考帧,不会造成解码错误的扩散。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="GOP的值"><a href="#GOP的值" class="headerlink" title="GOP的值"></a>GOP的值</h5><p>•GOP的值指的就是两个I帧之间的距离（两个I帧之间的图像帧数）。</p>
<p>   在这个组内只有I帧是一幅完整的画面帧，而P帧和B帧都属于预测编码帧，一个I帧所占用的字节数大于一个P帧，一个P帧所占用的字节数大于一个B帧（如下图所示）。</p>
<p><img src="/images/gop_desc1.png" alt="image-20210607114220152"></p>
<p>•两个P帧之间的距离叫一个参考周期（Reference）。</p>
<h5 id="I、B、P示意图"><a href="#I、B、P示意图" class="headerlink" title="I、B、P示意图"></a>I、B、P示意图</h5><p><img src="/images/IBP_info.png" alt="image-20210606220037253"></p>
<p>•根据I、P、B帧的定义，I帧属于帧内编码，自己完成就行了。而P帧需要参考前面的帧，B帧前后帧都可以作为参考帧。</p>
<p>•P 帧和 B 帧编码的基本流程为：    </p>
<p>(1)进行运动估计，计算采用帧间编码模式的率失真函数(节)值。P 帧 只参考前面的帧，B 帧可参考后面的帧。    </p>
<p>(2)进行帧内预测，选取率失真函数值最小的帧内模式与帧间模式比较，确定采用哪种编码模式。    </p>
<p>(3)计算实际值和预测值的差值。    </p>
<p>(4)对残差进行变换和量化。    </p>
<p>(5)若编码，如果是帧间编码模式，编码运动矢量。</p>
<p>注:I、B、P各帧是根据压缩算法的需要,是人为定义的,它们都是实实在在的物理帧,至于图像中的哪一帧是I帧,是随机的,一但确定了I帧,以后的各帧就严格按规定顺序排列。</p>
<p><img src="/images/gop_desc2.png" alt="image-20210607114550043"></p>
<h5 id="GOP的影响"><a href="#GOP的影响" class="headerlink" title="GOP的影响"></a>GOP的影响</h5><p>•在码率不变的前提下，GOP值越大，P、B帧的数量会越多，平均每个I、P、B帧所占用的字节数就越多，也就更容易获取较好的图像质量；Reference越大，B帧的数量越多，同理也更容易获得较好的图像质量。</p>
<p>•需要说明的是，通过提高GOP值来提高图像质量是有限度的，在遇到场景切换的情况时，H.264编码器会自动强制插入一个I帧，此时实际的GOP值被缩短了。另一方面，在一个GOP中，P、B帧是由I帧预测得到的，当I帧的图像质量比较差时，会影响到一个GOP中后续P、B帧的图像质量，直到下一个GOP开始才有可能得以恢复，所以GOP值也不宜设置过大。</p>
<p>•同时，由于P、B帧的复杂度大于I帧，所以过多的P、B帧会影响编码效率，使编码效率降低。另外，过长的GOP还会影响Seek操作的响应速度，由于P、B帧是由前面的I或P帧预测得到的，所以Seek操作需要直接定位，解码某一个P或B帧时，需要先解码得到本GOP内的I帧及之前的N个预测帧才可以，GOP值越长，需要解码的预测帧就越多，seek响应的时间也越长。</p>
<h5 id="编码带来的优点和问题"><a href="#编码带来的优点和问题" class="headerlink" title="编码带来的优点和问题"></a>编码带来的优点和问题</h5><p>•优点</p>
<p>​    1.视频码率大幅度下降。</p>
<p>​    2.码率降低的同时清晰度依然很好。</p>
<p>​    3.同等清晰度下视频的传输有效的节约带宽。</p>
<p>​    3.码率的降低将直接带来广泛的应用，如实时高清视频直播。2K、4K超清视频。</p>
<p>•</p>
<p>•问题</p>
<p>   1.编码带来的直接问题就是解码。而高压缩率下的编码带来的就是对硬件解码性能的挑战，可能引起硬件负载一直处于高位运行状态。手持设备最直接的感官就是发热。</p>
<p>   2.播放器所面临的问题就是对众多不同编码格式的视频进行解码。</p>
<h5 id="最常用的编码标准H-264"><a href="#最常用的编码标准H-264" class="headerlink" title="最常用的编码标准H.264"></a>最常用的编码标准H.264</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H.264 == MPEG-4 - AVC</span><br><span class="line">HEVC == H.265 [H.264基础上 加入了更多的算法 == 压缩的更小]</span><br></pre></td></tr></table></figure>

<p><img src="/images/encode_h264.png" alt="image-20210606220153237"></p>
<h5 id="H-264分层结构（VCL与NAL）"><a href="#H-264分层结构（VCL与NAL）" class="headerlink" title="H.264分层结构（VCL与NAL）"></a>H.264分层结构（VCL与NAL）</h5><p>VCL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VCL(Video Coding Layer，视频编码层):负责高效的视频内容表示， VCL数据即编码处理的输出，它表示被压缩编码后的视频数据序列。</span><br></pre></td></tr></table></figure>

<p>NAL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAL(Network Abstraction Layer，网络提取层):负责以网络所要求的恰当的方式对数据进行打包和 传送，</span><br><span class="line">是传输层。不管在本地播放还是网络播放，都要通过这一层来传输。</span><br></pre></td></tr></table></figure>

<p>VCL就是被压缩编码后原始数据，在VCL数据封装到NAL单元中之后，才可以用于传输或存储。</p>
<p><img src="/images/vcl_nal.png" alt="image-20210606220350442"></p>
<h5 id="NAL（片（宏块））"><a href="#NAL（片（宏块））" class="headerlink" title="NAL（片（宏块））"></a>NAL（片（宏块））</h5><p>一帧图片经过 H.264 编码器之后，NAL单元就是装载着这些片(被编码为一个或多个片 slice), 每片包 含整数个宏块(至少一个宏块，最多包含整个图像宏块)。</p>
<p><img src="/images/nal_desc.png" alt="image-20210606220447005"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般H.264编码器的默认输出为:起始码+NALU(Nal单元)。起始码为:0x00000001或者0x000001。 一个NALU(PPS, I帧，B帧，P帧)</span><br><span class="line">为什么需求起始码，0x00000001或者0x000001 ? 答:因为每一个NALU都需要分隔，要分隔帧操作，就相对于写文章断句一样</span><br><span class="line">为什么 0x00000001或者0x000001。 两种起始码 ?</span><br><span class="line">答:0x00000001 起始码代表:一个NALU里面有很多片。</span><br><span class="line">0x000001 起始码代表: 一个NALU里面一个片可以搞定。 反正你必须明白，遇到0x00000001或者0x000001，就是NALU的起始码来了</span><br><span class="line">每个NALU 包含(起始码 与 1个字节的Nal Header 与 若干整数字节的负荷数据EBSP构成)</span><br></pre></td></tr></table></figure>

<p>NAL类型查找表</p>
<p><img src="/images/nal_tyle_list.png" alt="image-20210606220547391"></p>
<h5 id="PTS与DTS"><a href="#PTS与DTS" class="headerlink" title="PTS与DTS"></a>PTS与DTS</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DTS表示解码时间戳，在什么时候解码这一帧的数据 ; PTS表示显示时间戳 ，在什么时候显示这一帧。 在没有B帧的情况下，DTS和PTS的输出顺序是一样的。</span><br><span class="line">因为B帧打乱了解码和显示的顺序(要解码B帧需要先解码后面的P帧)，所以一旦存在B帧，PTS和DTS就会不 同。</span><br></pre></td></tr></table></figure>

<p><img src="/images/pts_dts.png" alt="image-20210606220700402"></p>
<p>I帧 p b p b p b b p I帧 == GOP</p>
<p>I帧之前分为一组</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>播放器</tag>
      </tags>
  </entry>
  <entry>
    <title>Tencent插件化框架Shadow</title>
    <url>/2020/03/17/android_tencent_shadow_introduction/</url>
    <content><![CDATA[<p>Android的插件化开发经过这么多年的发展，已经比较成熟，也诞生了很多优秀的插件框架，比如VirtualApk、RePlugin、Shadow等。其实所有支持四大组件的插件框架，都在解决一个问题，就是绕过Manifest注册表校验。传统的做法就是通过Hook技术，欺骗Android系统，注册表插桩，让系统认为启动的是插桩的四大组件，实际loadclass插件的类。</p>
<span id="more"></span>

<h1 id="Shadow介绍"><a href="#Shadow介绍" class="headerlink" title="Shadow介绍"></a>Shadow介绍</h1><p>Shadow可以说算是另辟蹊径，开源之初，对外宣传的是零Hook，可关键其实源码里是有一处Hook点的，对此官方也解释了，并非必须。那么Shadow是如何“骗”系统的呢？这其实也就是Shadow设计的巧妙之处，后文会进行分析。</p>
<p>关于Shadow在分析前，有几个点我觉得有必要搞清楚：</p>
<p>1、Shadow是跨进程的，插件运行在插件进程，通过Binder机制通信，所以不了解Binder的，建议提前熟悉一下，否则看着会比较绕。</p>
<p>2、Shadow的宿主和业务插件之间还有一层中间层，中间层也是以插件的形式加载，同时可以升级，有较强的灵活性。</p>
<p>3、插件里写一个页面，比如继承自Activity，我们可以正常写，但是在编译期会修改继承关系，将其父类改为ShadowActivity，ShadowActivity实际上不是一个Activity，他持有HostActivity的代理对象，依赖此完成生命周期的回调。</p>
<p>这个操作是靠修改字节码实现的，自定义gradle脚本，通过javassist或者asm都可以实现，不再赘述。</p>
<p>4、我纯属因为感兴趣所有阅读了源码，实际上并没有应用在生产环境，毕竟推进公司框架层面的修改不是那么容易，而且也不一定合适。各位在选择的时候，也要考虑全面，适合自己公司业务的解决方案才是最好的。</p>
<p><strong>思考：</strong></p>
<p>虽然Shadow与传统插件框架的实现方式不同，但有一些基本流程还是一致的。比如插件的下载、安装、更新、卸载。解析插件apk，插件四大组件的信息解析及缓存，插件的ClassLoader、Resource的处理等。</p>
<p>Shadow不一样的点前言已经介绍，所以可以想到，第一次加载业务插件，首先会加载中间层插件。要想代理Activity（ProxyActivity）和插件Activity(PluginActivity)关联，同时ProxyActivity的生命周期方法能调用到PluginActivity，那么ProxyActivity必然会持有PluginActivity实例话对象的引用。PluginActivity里有具体的业务实现，同时需要回调ProxyActivity的生命周期方法，那么PluginActivity也会有一个有此能力的代理对象。</p>
<p>再次强调，PluginActivity并不是一个真实的Activity，不要被Demo里的源码所欺骗，之所以要在编译期修改继承关系，好处就是在开发阶段，我们可以按照一个真实的Activity的写法去开发，剩下的事儿由框架处理；另外插件也是可以独立运行的。</p>
<p>可能放两张图可以表达的更清楚：</p>
<p><img src="/images/android_tencent_shadow_introduction01.png" alt="img"></p>
<p>下面是我反编译插件apk得到的代码</p>
<p><img src="/images/android_tencent_shadow_introduction03.png" alt="img"></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>Shadow源码较多，我们只分析一下插件Activity是如何启动及运行的。</p>
<p>可以先看一下打包出来的apk的结构</p>
<p><img src="/images/android_tencent_shadow_introduction02.png" alt="img"></p>
<p>我的理解pluginmanager.apk loader.apk runtime.apk是中间层</p>
<p>config.json 是发版信息，主要用于检查更新，其中的uuid即为当前版本的唯一标示</p>
<p>HostApplication的onCreate方法会有一些初始化的工作，主要是把asset目录下的插件复制到指定目录，还有runtime插件的状态恢复，非核心流程，不再详述。</p>
<p>我们直接看启动插件的逻辑，很容易就找到加载插件的缺省页PluginLoadActivity，只有一个startPlugin方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PluginHelper.getInstance().singlePool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 方法名虽然叫loadPluginManager，实际上并没有真正安装manager插件，</span></span><br><span class="line">                <span class="comment">// 只是将插件路径包装成FixedPathPmUpdater，作为构造函数的参数，创建一个DynamicPluginManager保存在Application中</span></span><br><span class="line">                HostApplication.getApp().loadPluginManager(PluginHelper.getInstance().pluginManagerFile);</span><br><span class="line">                Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">                <span class="comment">//插件的安装路径</span></span><br><span class="line">                bundle.putString(Constant.KEY_PLUGIN_ZIP_PATH, PluginHelper.getInstance().pluginZipFile.getAbsolutePath());</span><br><span class="line">                <span class="comment">//当前值是：sample-plugin-app</span></span><br><span class="line">                bundle.putString(Constant.KEY_PLUGIN_PART_KEY, getIntent().getStringExtra(Constant.KEY_PLUGIN_PART_KEY));</span><br><span class="line">                <span class="comment">//要启动的插件中的Activity路径 com.tencent.shadow.sample.plugin.app.lib.gallery.splash.SplashActivity</span></span><br><span class="line">                bundle.putString(Constant.KEY_ACTIVITY_CLASSNAME, getIntent().getStringExtra(Constant.KEY_ACTIVITY_CLASSNAME));</span><br><span class="line">                <span class="comment">//EnterCallback主要是用于处理插件加载过程中的过度状态</span></span><br><span class="line">                HostApplication.getApp().getPluginManager()</span><br><span class="line">                        .enter(PluginLoadActivity.<span class="keyword">this</span>, Constant.FROM_ID_START_ACTIVITY, bundle, <span class="keyword">new</span> EnterCallback() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowLoadingView</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>&#123;</span><br><span class="line">                                mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                        mViewGroup.addView(view);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCloseLoadingView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                finish();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEnterComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>懒的长篇大论，相关逻辑已经写在注释里，会执行到DynamicPluginManager的enter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Context context, <span class="keyword">long</span> fromId, Bundle bundle, EnterCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mLogger.isInfoEnabled()) &#123;</span><br><span class="line">            mLogger.info(<span class="string">&quot;enter fromId:&quot;</span> + fromId + <span class="string">&quot; callback:&quot;</span> + callback);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态管理插件的更新逻辑</span></span><br><span class="line">        updateManagerImpl(context);</span><br><span class="line">        <span class="comment">//mManagerImpl的类型是SamplePluginManager</span></span><br><span class="line">        mManagerImpl.enter(context, fromId, bundle, callback);</span><br><span class="line">        mUpdater.update();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>mManagerImpl是一个接口，上面的代码其真实实例是SamplePluginManager，updateManagerImpl方法会安装pluginmanager.apk插件，同时通过反射创建一个SamplePluginManager实例，也就是上面的mManagerImpl，同时支持pluginmanager.apk插件的更新逻辑。</p>
<p>所以进入SamplePluginManager的enter-&gt;onStartActivity，代码逻辑比较简单，没什么可说的，需要注意一点是会启动一个线程，去加载zip包下的几个插件（runtime、loader、业务插件），而后会调用到其父类FastPluginManager的startPluginActivity方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPluginActivity</span><span class="params">(Context context, InstalledPlugin installedPlugin, String partKey, Intent pluginIntent)</span> <span class="keyword">throws</span> RemoteException, TimeoutException, FailedException </span>&#123;</span><br><span class="line">        Intent intent = convertActivityIntent(installedPlugin, partKey, pluginIntent);</span><br><span class="line">        <span class="keyword">if</span> (!(context <span class="keyword">instanceof</span> Activity)) &#123;</span><br><span class="line">            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终启动的是com.tencent.shadow.sample.plugin.runtime.PluginDefaultProxyActivity</span></span><br><span class="line">        <span class="comment">//PluginDefaultProxyActivity 在宿主manifest中有注册</span></span><br><span class="line">        context.startActivity(intent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>核心流程就在<strong>convertActivityIntent</strong>里，从命名就可以看出来，最终会把我们要启动的插件Activity，映射成一个在Manifest里注册的真实Activity，也就是注释中标注的PluginDefaultProxyActivity。</p>
<p>可以回看一下上文“思考”中的内容，即为Shadow第一次使用插件的主要流程，convertActivityIntent的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">convertActivityIntent</span><span class="params">(InstalledPlugin installedPlugin, String partKey, Intent pluginIntent)</span> <span class="keyword">throws</span> RemoteException, TimeoutException, FailedException </span>&#123;</span><br><span class="line">        <span class="comment">//这个partKey的真实值是&quot;sample-plugin-app&quot;</span></span><br><span class="line">        loadPlugin(installedPlugin.UUID, partKey);</span><br><span class="line">        Map map = mPluginLoader.getLoadedPlugin();</span><br><span class="line">        Boolean isCall = (Boolean) map.get(partKey);</span><br><span class="line">        <span class="keyword">if</span> (isCall == <span class="keyword">null</span> || !isCall) &#123;</span><br><span class="line">            <span class="comment">//其持有的是PluginLoaderBinder的引用</span></span><br><span class="line">            <span class="comment">//这里又是一次跨进程通信</span></span><br><span class="line">            mPluginLoader.callApplicationOnCreate(partKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mPluginLoader.convertActivityIntent(pluginIntent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>loadPlugin：先安装中间层插件再安装业务插件，当然如果已安装，直接跳过</p>
<p>mPluginLoader：是一个比较关键的变量，具体他是什么初始化的，下面会具体分析</p>
<p>后续的代码执行逻辑可自行看源码，首先会执行loadPluginLoaderAndRuntime方法，这个方法里会初始化插件进程的服务，同时将插件进程的binder对象赋值给mPpsController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadPluginLoaderAndRuntime</span><span class="params">(String uuid, String partKey)</span> <span class="keyword">throws</span> RemoteException, TimeoutException, FailedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mPpsController == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//partKey是启动插件的时候在PluginLoadActivity中赋值</span></span><br><span class="line">            <span class="comment">//getPluginProcessServiceName 获取插件进程服务的名字</span></span><br><span class="line">            <span class="comment">//bindPluginProcessService启动插件进程服务 由此可见，shadow宿主和插件的信息传递是进程间通信的过程</span></span><br><span class="line">            bindPluginProcessService(getPluginProcessServiceName(partKey));</span><br><span class="line">            <span class="comment">//等待链接超时时间</span></span><br><span class="line">            waitServiceConnected(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        loadRunTime(uuid);</span><br><span class="line">        loadPluginLoader(uuid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动PluginProcessService</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName 注册在宿主中的插件进程管理service完整名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindPluginProcessService</span><span class="params">(<span class="keyword">final</span> String serviceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mServiceConnecting.get()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mLogger.isInfoEnabled()) &#123;</span><br><span class="line">                mLogger.info(<span class="string">&quot;pps service connecting&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mLogger.isInfoEnabled()) &#123;</span><br><span class="line">            mLogger.info(<span class="string">&quot;bindPluginProcessService &quot;</span> + serviceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mConnectCountDownLatch.set(<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        mServiceConnecting.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//CountDownLatch是一个同步工具，协调多个线程之间的同步</span></span><br><span class="line">        <span class="comment">//可以看下这篇文章 https://www.cnblogs.com/Lee_xy_z/p/10470181.html</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startBindingLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span>[] asyncResult = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//从onStartActivity方法可知，当前线程并不是UI线程</span></span><br><span class="line">        mUiHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">                <span class="comment">//serviceName的值是com.tencent.shadow.sample.host.PluginProcessPPS</span></span><br><span class="line">                intent.setComponent(<span class="keyword">new</span> ComponentName(mHostContext, serviceName));</span><br><span class="line">                <span class="keyword">boolean</span> binding = mHostContext.bindService(intent, <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;<span class="comment">//service对应的是PluginProcessService中的mPpsControllerBinder</span></span><br><span class="line">                        <span class="keyword">if</span> (mLogger.isInfoEnabled()) &#123;</span><br><span class="line">                            mLogger.info(<span class="string">&quot;onServiceConnected connectCountDownLatch:&quot;</span> + mConnectCountDownLatch);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mServiceConnecting.set(<span class="keyword">false</span>);</span><br><span class="line">                        mPpsController = PluginProcessService.wrapBinder(service);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//跨进程执行PluginProcessService的setUuidManager方法</span></span><br><span class="line">                            <span class="comment">//UuidManagerBinder内部封装了三个方法，可以让插件进程拿到loader、runtime及指定其他业务插件的相关信息</span></span><br><span class="line">                            mPpsController.setUuidManager(<span class="keyword">new</span> UuidManagerBinder(PluginManagerThatUseDynamicLoader.<span class="keyword">this</span>));</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mLogger.isErrorEnabled()) &#123;</span><br><span class="line">                                mLogger.error(<span class="string">&quot;onServiceConnected RemoteException:&quot;</span> + e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (e.getClass().getSimpleName().equals(<span class="string">&quot;TransactionTooLargeException&quot;</span>)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (mLogger.isErrorEnabled()) &#123;</span><br><span class="line">                                    mLogger.error(<span class="string">&quot;onServiceConnected TransactionTooLargeException:&quot;</span> + e);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//第一次拿到的是一个null</span></span><br><span class="line">                            IBinder iBinder = mPpsController.getPluginLoader();</span><br><span class="line">                            <span class="keyword">if</span> (iBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPluginLoader = <span class="keyword">new</span> BinderPluginLoader(iBinder);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException ignored) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mLogger.isErrorEnabled()) &#123;</span><br><span class="line">                                mLogger.error(<span class="string">&quot;onServiceConnected mPpsController getPluginLoader:&quot;</span>, ignored);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mConnectCountDownLatch.get().countDown();</span><br><span class="line">                        <span class="keyword">if</span> (mLogger.isInfoEnabled()) &#123;</span><br><span class="line">                            mLogger.info(<span class="string">&quot;onServiceConnected countDown:&quot;</span> + mConnectCountDownLatch);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (mLogger.isInfoEnabled()) &#123;</span><br><span class="line">                            mLogger.info(<span class="string">&quot;onServiceDisconnected&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mServiceConnecting.set(<span class="keyword">false</span>);</span><br><span class="line">                        mPpsController = <span class="keyword">null</span>;</span><br><span class="line">                        mPluginLoader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, BIND_AUTO_CREATE);</span><br><span class="line">                asyncResult[<span class="number">0</span>] = binding;</span><br><span class="line">                startBindingLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//当前线程会最多等待10s，startBindingLatch的线程计数为0之前，当前线程会处在中断状态</span></span><br><span class="line">            startBindingLatch.await(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!asyncResult[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;无法绑定PPS:&quot;</span> + serviceName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上文说过，整个流程是运行在子线程，所以启动服务要post到UI线程</p>
<p>后续执行的loadRunTime(uuid);loadPluginLoader(uuid);方法即为启动中间层插件的逻辑，大同小异，只分析loadPluginLoader的执行逻辑，因为要解释关键变量mPluginLoader是怎么来的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loadPluginLoader</span><span class="params">(String uuid)</span> <span class="keyword">throws</span> RemoteException, FailedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mLogger.isInfoEnabled()) &#123;</span><br><span class="line">            mLogger.info(<span class="string">&quot;loadPluginLoader mPluginLoader:&quot;</span> + mPluginLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mPluginLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            PpsStatus ppsStatus = mPpsController.getPpsStatus();</span><br><span class="line">            <span class="keyword">if</span> (!ppsStatus.loaderLoaded) &#123;</span><br><span class="line">                <span class="comment">//动态加载sample-loader-debug.apk此插件 在插件进程创建了PluginLoaderBinder的实体</span></span><br><span class="line">                mPpsController.loadPluginLoader(uuid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//拿到PluginLoaderBinder的引用</span></span><br><span class="line">            IBinder iBinder = mPpsController.getPluginLoader();</span><br><span class="line">            mPluginLoader = <span class="keyword">new</span> BinderPluginLoader(iBinder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>PpsStatus：只是一个状态bean，唯一作用就是保存插件的安装状态</p>
<p>mPpsController：怎么来的上文已经说过，所以他所调用的方法的具体实现，都是插件进程Service里，即PluginProcessService</p>
<p>mPpsController.loadPluginLoader方法，即为安装loader插件，具体不再分析，可以自行查看Shadow源码</p>
<p>PluginProcessService的loadPluginLoader方法调用，有个关键点要注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadPluginLoader</span><span class="params">(String uuid)</span> <span class="keyword">throws</span> FailedException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//pluginLoader类型：PluginLoaderBinder</span></span><br><span class="line">            <span class="comment">//pluginLoader持有DynamicPluginLoader的对象 封装了一系列插件运行的方法</span></span><br><span class="line">            PluginLoaderImpl pluginLoader = <span class="keyword">new</span> LoaderImplLoader().load(installedApk, uuid, getApplicationContext());</span><br><span class="line">            pluginLoader.setUuidManager(mUuidManager);</span><br><span class="line">            mPluginLoader = pluginLoader;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上文中提到，第一次启动插件服务的时候mPluginLoader是null，他的初始化就是在这里，反射创建了一个PluginLoaderBinder对象，也就是mPluginLoader。但是真正干活的是其持有的DynamicPluginLoader对象。具体可以看一下com.tencent.shadow.dynamic.loader.impl.LoaderFactoryImpl类</p>
<p>不要忘了这是跨进程的，所以要这样封装，mPluginLoader也是一个binder对象。</p>
<p>再回到FastPluginManager的loadPlugin方法</p>
<p>中间层插件已处理完，那就到了业务插件，会调用mPluginLoader.getLoadedPlugin()，会返回已安装的插件信息，这个方法的具体实现，从上文分析可知，是在DynamicPluginLoader里。如果要加载的插件没有安装，会调用mPluginLoader.loadPlugin(partKey);安装指定插件。</p>
<p>后续的插件安装逻辑直接看源码吧，相信大家都能看懂，会调到ShadowPluginLoader的loadPlugin方法。</p>
<p>再回到<strong>convertActivityIntent</strong>方法</p>
<p>如果插件是第一次启动，那么会调用mPluginLoader.callApplicationOnCreate(partKey);</p>
<p>mPluginLoader是谁已经说了很多次，不再强调。这个方法会初始化插件的contentprovider以及broadcastreceiver</p>
<p>我们直接看mPluginLoader.convertActivityIntent(pluginIntent)，一连串的方法调用连，最终会调用到ComponentManager类的方法:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用前必须先调用isPluginComponent判断Intent确实一个插件内的组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> Intent.<span class="title">toActivityContainerIntent</span><span class="params">()</span></span>: Intent &#123;</span><br><span class="line">        <span class="keyword">val</span> bundleForPluginLoader = Bundle()</span><br><span class="line">        <span class="keyword">val</span> pluginComponentInfo = pluginComponentInfoMap[component]!!</span><br><span class="line">        bundleForPluginLoader.putParcelable(CM_ACTIVITY_INFO_KEY, pluginComponentInfo)</span><br><span class="line">        <span class="keyword">return</span> toContainerIntent(bundleForPluginLoader)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其实很好理解，这里就是将插件Activity映射到我们注册在宿主的Activity，同时将映射关系以及一些必要的数据传递。</p>
<p>在demo里最终映射的Activity是com.tencent.shadow.sample.plugin.runtime.PluginDefaultProxyActivity</p>
<p>这是一个真实的Activity，可以正常启动。其主要逻辑都在父类PluginContainerActivity中。</p>
<p>先看PluginContainerActivity的初始化方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HostActivityDelegate hostActivityDelegate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PluginContainerActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HostActivityDelegate delegate;</span><br><span class="line">    DelegateProvider delegateProvider = DelegateProviderHolder.getDelegateProvider();</span><br><span class="line">    <span class="keyword">if</span> (delegateProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        delegate = delegateProvider.getHostActivityDelegate(<span class="keyword">this</span>.getClass());</span><br><span class="line">        delegate.setDelegator(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;PluginContainerActivity: DelegateProviderHolder没有初始化&quot;</span>);</span><br><span class="line">        delegate = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hostActivityDelegate = delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hostActivityDelegate：看命名就知道，这是宿主Activity的代理类，我猜应该是给插件Activity使用的，你们觉得呢？</p>
<p>我们来看一下hostActivityDelegate到底是什么：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getHostActivityDelegate</span><span class="params">(aClass: <span class="type">Class</span>&lt;<span class="type">out</span> <span class="type">HostActivityDelegator</span>&gt;)</span></span>: HostActivityDelegate &#123;</span><br><span class="line">        <span class="keyword">return</span> ShadowActivityDelegate(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>回到PluginContainerActivity，以onCreate方法为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (hostActivityDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">           hostActivityDelegate.onCreate(savedInstanceState);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用hostActivityDelegate的onCreate，也就是ShadowActivityDelegate类的onCreate方法:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * com.tencent.shadow.core.loader.delegates.ShadowActivityDelegate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> aClass = mPluginClassLoader.loadClass(pluginActivityClassName)</span><br><span class="line">            <span class="keyword">val</span> pluginActivity = PluginActivity::<span class="keyword">class</span>.java.cast(aClass.newInstance())</span><br><span class="line">            initPluginActivity(pluginActivity)</span><br><span class="line">            mPluginActivity = pluginActivity</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            pluginActivity.onCreate(pluginSavedInstanceState)</span><br><span class="line">            mPluginActivityCreated = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initPluginActivity</span><span class="params">(pluginActivity: <span class="type">PluginActivity</span>)</span></span> &#123;</span><br><span class="line">        pluginActivity.setHostActivityDelegator(mHostActivityDelegator)</span><br><span class="line">        pluginActivity.setPluginResources(mPluginResources)</span><br><span class="line">        pluginActivity.setHostContextAsBase(mHostActivityDelegator.hostActivity <span class="keyword">as</span> Context)</span><br><span class="line">        pluginActivity.setPluginClassLoader(mPluginClassLoader)</span><br><span class="line">        pluginActivity.setPluginComponentLauncher(mComponentManager)</span><br><span class="line">        pluginActivity.setPluginApplication(mPluginApplication)</span><br><span class="line">        pluginActivity.setShadowApplication(mPluginApplication)</span><br><span class="line">        pluginActivity.applicationInfo = mPluginApplication.applicationInfo</span><br><span class="line">        pluginActivity.setBusinessName(mBusinessName)</span><br><span class="line">        pluginActivity.setPluginPartKey(mPartKey)</span><br><span class="line">        pluginActivity.remoteViewCreatorProvider = mRemoteViewCreatorProvider</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>省略掉一些常规代码</p>
<p>val aClass = mPluginClassLoader.loadClass(pluginActivityClassName)</p>
<p>pluginActivityClassName：我们要启动的插件Activity的类路径即为SplashActivity</p>
<p>反射实例化保存在mPluginActivity，用于调用插件Activity的生命周期等系统方法</p>
<p>那么插件Activity要调用super方法，比如onCreate的super方法怎么办呢？</p>
<p>在initPluginActivity方法中会将mHostActivityDelegator 传递给插件activity使用：</p>
<p>pluginActivity.setHostActivityDelegator(mHostActivityDelegator)</p>
<p>本文最开始说过，插件Activity会在编译期修改其继承关系为ShadowActivity，ShadowActivity继承自PluginActivity：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginActivity</span> <span class="keyword">extends</span> <span class="title">ShadowContext</span> <span class="keyword">implements</span> <span class="title">Window</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    HostActivityDelegator mHostActivityDelegator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        mHostActivityDelegator.superOnCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>宿主调用插件onCrate方法，插件会通过mHostActivityDelegator回调到宿主的super，即mHostActivityDelegator.superOnCreate(savedInstanceState);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">superOnCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到这整个流程就跑通了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>插件化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android WMS核心分析</title>
    <url>/2019/09/01/android_wms/</url>
    <content><![CDATA[<p>WMS（WindowManagerService）窗口管理服务，是系统核心服务。简单来讲，它是窗口管理员。窗口是一个抽象的概念，从用户的角度来讲，它是一个界面。从SufaceFlinger的角度来讲，它是一个Layer,承载着和界面有关的数据和属性。所以它是一个WindowState，用于管理和界面有关的状态。</p>
<p>WMS也是系统服务，由SystemServer启动。直到关机时才会退出。发生异常时必须重启。</p>
<span id="more"></span>

<h1 id="WMS主体描述"><a href="#WMS主体描述" class="headerlink" title="WMS主体描述"></a>WMS主体描述</h1><p><strong>Window</strong>：在Android视图体系中Window就是一个窗口的概念。Android中所有的视图都是依赖于Window显示的。</p>
<p><strong>WindowManager</strong>：对Window的管理，包括新增、更新和删除等。</p>
<p><strong>WMS</strong>：窗口的最终管理者，它负责窗口的启动、添加和删除，另外窗口的大小和层级也是由WMS进行管理。</p>
<p><img src="/images/android_wms_window_manager_wms.png" alt="Window_WindowManager_WMS"></p>
<h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><h2 id="常见的window"><a href="#常见的window" class="headerlink" title="常见的window"></a>常见的window</h2><p><img src="/images/android_wms_example_window.png" alt="example_window"></p>
<h2 id="Window的分类"><a href="#Window的分类" class="headerlink" title="Window的分类"></a>Window的分类</h2><p><img src="/images/android_wms_window_types.png" alt="wms_window_types"></p>
<p><strong>Application Window</strong>：Activity就是一个典型的应用程序窗口。</p>
<p><strong>Sub Window</strong>：子窗口，顾名思义，它不能独立存在，需要附着在其他窗口才可以，PopupWindow就属于子窗口。</p>
<p><strong>System Window</strong>：输入法窗口、系统音量条窗口、系统错误窗口都属于系统窗口。</p>
<h3 id="Application-Window"><a href="#Application-Window" class="headerlink" title="Application Window"></a>Application Window</h3><p><img src="/images/android_wms_application_window.png" alt="wms_application_window"></p>
<p>如代码中的以下类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_APPLICATION_WINDOW = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_BASE_APPLICATION   = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION        = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_STARTING = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_DRAWN_APPLICATION = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_APPLICATION_WINDOW = <span class="number">99</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Sub-Window"><a href="#Sub-Window" class="headerlink" title="Sub Window"></a>Sub Window</h3><p>什么是子窗口？</p>
<p>在 PhoneWindow 与 WindowManagerImpl 创建好了以后，我们自己也可以调用 <code>WindowManagerImpl#addView</code> 来添加一个 View 树，也叫添加窗口。</p>
<p>当它的窗口类型处于 WindowManager.LayoutParams.FIRST_SUB_WINDOW 与 WindowManager.LayoutParams.LAST_SUB_WINDOW 之间时，我们称这个直接添加的窗口为子窗口。</p>
<p>那这些直接通过 <code>WindowManagerImpl#addView</code> 创建的窗口，共用同一个 PhoneWindow 以及 WindowManagerImpl 对象，窗口类型不同决定了它们在 WMS 上的一个 z-order 顺序。</p>
<p>典型的子窗口PopupWindow</p>
<p><img src="/images/android_wms_subwindow_popupwindow.png" alt="wms_subwindow_popupwindow"></p>
<p>如代码中的以下类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SUB_WINDOW = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">2</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_MEDIA_OVERLAY  = FIRST_SUB_WINDOW + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SUB_WINDOW = <span class="number">1999</span>;</span><br></pre></td></tr></table></figure>

<p>接下来让我们看看子窗口是如何添加的，以 PopupWindow 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//: PopupWindow.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mWindowLayoutType = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAtLocation</span><span class="params">(View parent, <span class="keyword">int</span> gravity, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  mParentRootView = <span class="keyword">new</span> WeakReference&lt;&gt;(parent.getRootView());</span><br><span class="line">  <span class="comment">//这个getWindowToken返回的就是ViewRootImpl里的mWindow对象</span></span><br><span class="line">  showAtLocation(parent.getWindowToken(), gravity, x, y);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAtLocation</span><span class="params">(IBinder token, <span class="keyword">int</span> gravity, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isShowing() || mContentView == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  detachFromAnchor();</span><br><span class="line"> </span><br><span class="line">  mIsShowing = <span class="keyword">true</span>;</span><br><span class="line">  mIsDropdown = <span class="keyword">false</span>;</span><br><span class="line">  mGravity = gravity;</span><br><span class="line">  <span class="comment">//创建窗口属性，配置窗口类型</span></span><br><span class="line">  <span class="keyword">final</span> WindowManager.LayoutParams p = createPopupLayoutParams(token);</span><br><span class="line">  preparePopup(p);</span><br><span class="line"> </span><br><span class="line">  p.x = x;</span><br><span class="line">  p.y = y;</span><br><span class="line"> </span><br><span class="line">  invokePopup(p);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> WindowManager.<span class="function">LayoutParams <span class="title">createPopupLayoutParams</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> WindowManager.LayoutParams p = <span class="keyword">new</span> WindowManager.LayoutParams();</span><br><span class="line">  p.gravity = computeGravity();</span><br><span class="line">  p.flags = computeFlags(p.flags);</span><br><span class="line">  p.type = mWindowLayoutType;</span><br><span class="line">  p.token = token;</span><br><span class="line">  p.softInputMode = mSoftInputMode;</span><br><span class="line">  p.windowAnimations = computeAnimationResource();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加窗口</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokePopup</span><span class="params">(WindowManager.LayoutParams p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    p.packageName = mContext.getPackageName();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> PopupDecorView decorView = mDecorView;</span><br><span class="line">  decorView.setFitsSystemWindows(mLayoutInsetDecor);</span><br><span class="line"> </span><br><span class="line">  setLayoutDirectionFromAnchor();</span><br><span class="line">  <span class="comment">//添加窗口</span></span><br><span class="line">  mWindowManager.addView(decorView, p);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mEnterTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">    decorView.requestEnterTransition(mEnterTransition);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以看到 PopupWindow 通过 WindowManagerImpl 直接添加了一个类型为 WindowManager.LayoutParams.TYPE_APPLICATION_PANEL 类型的窗口。<br>这个 mWindowManager 就是 Activity 的 WindowManager, 也就是 Activity 内 PhoneWindow 的 WindowManagerImpl。所以，这个窗口要依附于 Activity。Application 没有 WindowManager 所以不能被依附。<br>另一方面, 这个窗口类型恰好是一个 FIRST_SUB_WINDOW 类型，所以 PopupWindow 是一个真正的子窗口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//: WindowManager.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW;</span><br></pre></td></tr></table></figure>

<p>那么问题来了，Dialog是子窗口吗？</p>
<p>接下来看看Dialog的部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//: Dialog.java</span></span><br><span class="line"> </span><br><span class="line">Dialog(<span class="meta">@NonNull</span> Context context, <span class="meta">@StyleRes</span> <span class="keyword">int</span> themeResId, <span class="keyword">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">  mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">  <span class="comment">//创建PhoneWindow</span></span><br><span class="line">  <span class="keyword">final</span> Window w = <span class="keyword">new</span> PhoneWindow(mContext);</span><br><span class="line">  mWindow = w;</span><br><span class="line">  w.setCallback(<span class="keyword">this</span>);</span><br><span class="line">  w.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">  w.setOnWindowSwipeDismissedCallback(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCancelable) &#123;</span><br><span class="line">      cancel();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  w.setWindowManager(mWindowManager, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  w.setGravity(Gravity.CENTER);</span><br><span class="line"> </span><br><span class="line">  mListenersHandler = <span class="keyword">new</span> ListenersHandler(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mShowing) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">          mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">      &#125;</span><br><span class="line">      mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  onStart();</span><br><span class="line">  mDecor = mWindow.getDecorView();</span><br><span class="line"> </span><br><span class="line">  WindowManager.LayoutParams l = mWindow.getAttributes();</span><br><span class="line">  <span class="comment">//添加窗口</span></span><br><span class="line">  mWindowManager.addView(mDecor, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，Dialog 与 PopupWindow 不同，它有自己的 PhoneWindow 对象，同时 Dialog 的窗口类型为 TYPE_APPLICATION，所以Dialog不能视为一个子窗口。</p>
<h3 id="System-Window"><a href="#System-Window" class="headerlink" title="System Window"></a>System Window</h3><p><img src="/images/android_wms_system_window.png" alt="wms_system_window"></p>
<p>如代码中的以下类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FIRST_SYSTEM_WINDOW     = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_STATUS_BAR         = FIRST_SYSTEM_WINDOW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SEARCH_BAR         = FIRST_SYSTEM_WINDOW+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_PHONE              = FIRST_SYSTEM_WINDOW+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_SYSTEM_ALERT       = FIRST_SYSTEM_WINDOW+<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_KEYGUARD           = FIRST_SYSTEM_WINDOW+<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_TOAST              = FIRST_SYSTEM_WINDOW+<span class="number">5</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LAST_SYSTEM_WINDOW      = <span class="number">2999</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Window的次序"><a href="#Window的次序" class="headerlink" title="Window的次序"></a>Window的次序</h2><p><img src="/images/android_wms_window_zorder.png" alt="wms_window_zorder"></p>
<h2 id="Window-Flag"><a href="#Window-Flag" class="headerlink" title="Window Flag"></a>Window Flag</h2><p>Window的Flag是跟随Window的显示并控制了一些特征与属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当 Window 可见时允许锁屏  FLAG_ALLOW_LOCK_WHILE_SCREEN_ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Window 不能获得输入焦点，即不接受任何按键或按钮事件，例如该 Window 上 有 EditView，点击 EditView 是 不会弹出软键盘的</span></span><br><span class="line"><span class="comment">// Window 范围外的事件依旧为原窗口处理；例如点击该窗口外的view，依然会有响应。另外只要设置了此Flag，都将会启用FLAG_NOT_TOUCH_MODAL</span></span><br><span class="line"> FLAG_NOT_FOCUSABLE = <span class="number">0x00000008</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window 处理, 而自己只会处理 Window 区域内的触摸事件</span></span><br><span class="line"><span class="comment">// Window 之外的 view 也是可以响应 touch 事件。</span></span><br><span class="line"> FLAG_NOT_TOUCH_MODAL  = <span class="number">0x00000020</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置了该Flag，表示该 Window 将不会接受任何 touch 事件，例如点击该 Window 不会有响应，只会传给下面有聚焦的窗口。 FLAG_NOT_TOUCHABLE ;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要 Window 可见时屏幕就会一直亮着 FLAG_KEEP_SCREEN_ON</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许 Window 超过屏幕之外 FLAG_LAYOUT_NO_LIMITS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户的脸贴近屏幕时（比如打电话），不会去响应此事件  FLAG_IGNORE_CHEEK_PRESSES ;</span></span><br><span class="line"><span class="comment">// 窗口可以在锁屏的 Window 之上显示, 使用 Activity#setShowWhenLocked(boolean) 方法代替</span></span><br><span class="line"> FLAG_SHOW_WHEN_LOCKED = <span class="number">0x00080000</span>;</span><br></pre></td></tr></table></figure>

<h1 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h1><p><img src="/images/android_wms_window_maanger.png" alt="wms_window_maanger"></p>
<h2 id="Activity与-PhoneWindow与DecorView关系"><a href="#Activity与-PhoneWindow与DecorView关系" class="headerlink" title="Activity与 PhoneWindow与DecorView关系"></a>Activity与 PhoneWindow与DecorView关系</h2><p>Activity是系统可视化交互组件，四大组件都由AMS统一管理生命周期，事实上它的职责只是生命周期的管理，由设计模式的单一职责的原则，那势必需要将Activity和其上的视图View进行解耦，那么就引入Window的概念，它是个抽象类，对于Activity来说，它的具体实现类是PhoneWindow，在Activity执行attach的时候，会创建一个PhoneWindow对象。PhoneWindow作为装载根视图DecorView的顶级容器，Activity通过setContentView实际上是调用PhoneWindow来创建DecorView，并解析xml布局加载到DecorView的contentView部分。</p>
<p>DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图</p>
<p><img src="/images/android_wms_activity_phonewindow_decorview.png" alt="activity_phonewindow_decorview"></p>
<p><img src="/images/android_wms_activity_phonewindow_decorview01.png" alt="activity_phonewindow_decorview01"></p>
<h2 id="WindowManager、WindowManagerImpl、WindowManagerGlobal"><a href="#WindowManager、WindowManagerImpl、WindowManagerGlobal" class="headerlink" title="WindowManager、WindowManagerImpl、WindowManagerGlobal"></a>WindowManager、WindowManagerImpl、WindowManagerGlobal</h2><p>WindowManager是一个接口类，继承自接口ViewManager，负责窗口的管理(增、删、改)。它的实现类是WindowManagerImpl，而具体操作实际上又会交给WindowManagerGlobal来处理，它是个单例，进程唯一。WindowManagerGlobal执行addView的方法中会传入DecorView, 还会初始化一个ViewRootImpl。WindowManagerGlobal因为是单例的，它内部会有两个List来分别保存这两个对象，来统一管理。</p>
<p><img src="/images/android_wms_wm_wmimpl_wmglobal.png" alt="wms_wm_wmimpl_wmglobal"></p>
<p><img src="/images/android_wms_wm_wmimpl_wmglobal01.png" alt="wms_wm_wmimpl_wmglobal01"></p>
<h2 id="ViewRootImpl与WindowManagerService"><a href="#ViewRootImpl与WindowManagerService" class="headerlink" title="ViewRootImpl与WindowManagerService"></a>ViewRootImpl与WindowManagerService</h2><p>ViewRootImpl是View树的树根并管理View树，触发View的测量、布局和绘制，输入响应的中转站，负责与WMS进行进程间通信。</p>
<p>WindowManagerGlobal负责对DecorView和对应的ViewRootImpl进行统一管理，而具体功能是由ViewRootImpl来处理。<br>以addView为例，具体window是由WMS统一管理的，所以这里会进行binder IPC。<br>IWindowSession: 应用程序通过Session与WMS通信，并且每个应用程序进程都会对应一个Session。<br>IWindow: 作为WMS主动与应用程序通信的client端，因为不同的Window是不同的client，因此它也被作为识别window的key。</p>
<p><img src="/images/android_wms_viewrootimpl_wms.png" alt="wms_viewrootimpl_wms"></p>
<h2 id="Activity与Window关联分析"><a href="#Activity与Window关联分析" class="headerlink" title="Activity与Window关联分析"></a>Activity与Window关联分析</h2><p>Activity与Window联系是非常紧密，很多显示相关操作需要两者密切配合，那么如何保证他们的一致性呢？Android通过token来保证两者的一致性校验：<br>token流向简单归纳如下：<br>1）new ActivityRecord的时候会new一个token与之对应。<br>2）ApplicationThread scheduleLaunchActivity的时候，ActivityClientRecord 接收这个token。<br>3）activity.attach传入该token。<br>4）setWindowManager的时候传入该token,最终由Window的AppToken接收。<br>5）在WindowManagerGlobal的addView方法中，执行adjustLayoutParamsForSubWindow，将WindowManager.LayoutParams wp,wp.token赋值appToken,并在之后的流程中，WindowManager.LayoutParams wp作为参数传入WMS的addWindow方法对应attrs.token。<br>6）WMS中通过WindowToken与之对应。<br>那么其实，Activity的token，Window中的token，连传入addWindow的attrs.token，都是同一个token，都是ActivityRecord构造函数中创建的Token对象。这样做保证了一致性，主要体现在如下两点：<br>将AMS中创建的ActivityRecord和Window挂钩，当前的window明确知道自己是哪一个Activity创建的。<br>Window和AMS有联系，同时又和WMS有关系，appToken则保证了这种同步机制。</p>
<h1 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h1><p>该系统服务是集窗口管理、窗口动画、输入系统中转站、Surface管理等功能于一体的综合管理。</p>
<p><strong>窗口管理</strong><br>是窗口的管理者，它负责窗口的启动、添加和删除。另外窗口的大小和层级也是由 <strong>WMS</strong> 进行管理的。<br><strong>窗口动画</strong><br>窗口间进行切换时，使用动画可以显得更炫一些，窗口动画由 <strong>WMS</strong> 的动画子系统来负责，动画子系统的管理者为 <strong>WindowAnimator</strong>。<br><strong>输入系统中转站</strong><br>通过对窗口的触摸从而产生触摸事件，<strong>InputManagerService(IMS)</strong> 会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，<strong>WMS</strong> 是窗口的管理者，它作为输入系统的中转站再合适不过了。<br><strong>Surface 管理</strong><br>窗口不具备绘制功能，因此每个窗口都需要有一块 <strong>Surface</strong> 来供自己绘制，为每个窗口分配 <strong>Surface</strong> 是由<strong>WMS</strong> 来完成的。</p>
<p><img src="/images/android_wms_wms01.png" alt="wms"></p>
<p>从上图我们了解到 <strong>WMS</strong> 整个是很复杂的，与它关联的有<strong>窗口管理、窗口动画、输入系统中转站和 Surface</strong> 管理, 它们每一个都是重要且复杂的系统，本章就对窗口管理来进行分析，因为它跟我们应用开发关系真的是太紧密了。<br>整个界面就像由N个演员参与的话剧：<br>ViewRootImpl就是各个演员的<strong>长相</strong>和<strong>表情</strong>，取决于它们各自的条件与努力。<br>WMS就是<strong>导演</strong>，它要负责话剧的舞台效果、演员站位；<br>SurfaceFling是<strong>摄像机</strong>，它只负责客观的捕捉当前的画面，然后真实的呈现给观众；<br>可见，WMS与SurfaceFling的一个重要区别就是——后者只做与“显示”相关的事情，而WMS要处理对输入事件的派发。</p>
<h2 id="WMS的重要成员"><a href="#WMS的重要成员" class="headerlink" title="WMS的重要成员"></a>WMS的重要成员</h2><h3 id="1-mPolicy：WindowManagerPolicy"><a href="#1-mPolicy：WindowManagerPolicy" class="headerlink" title="1. mPolicy：WindowManagerPolicy"></a>1. mPolicy：WindowManagerPolicy</h3><p>WindowManagerPolicy（WMP）类型的变量。WindowManagerPolicy是窗口管理策略的接口类，用来定义一个窗口策略所要遵循的通用规范，并提供了WindowManager所有的特定的UI行为。它的具体实现类为PhoneWindowManager，这个实现类在WMS创建时被创建。WMP允许定制窗口层级和特殊窗口类型以及关键的调度和布局。</p>
<h3 id="2-mSessions：ArraySet-lt-Session-gt"><a href="#2-mSessions：ArraySet-lt-Session-gt" class="headerlink" title="2. mSessions：ArraySet&lt;**Session**&gt;"></a>2. mSessions：ArraySet&lt;**Session**&gt;</h3><p>ArraySet类型的变量，元素类型为Session。它主要用于进程间通信，其他的应用程序进程想要和WMS进程进行通信就需要经过Session，并且每个应用程序进程都会对应一个Session，WMS保存这些Session用来记录所有向WMS提出窗口管理服务的客户端。</p>
<h3 id="3-mWindowMap：WindowHashMap"><a href="#3-mWindowMap：WindowHashMap" class="headerlink" title="3. mWindowMap：WindowHashMap"></a>3. mWindowMap：WindowHashMap</h3><p>WindowHashMap类型的变量，WindowHashMap继承了HashMap，它限制了HashMap的key值的类型为IBinder，value值的类型为WindowState。WindowState用于保存窗口的信息，在WMS中它用来描述一个窗口。综上得出结论，mWindowMap就是用来保存WMS中各种窗口的集合。</p>
<h3 id="4-mFinishedStarting：ArrayList-lt-AppWindowToken-gt"><a href="#4-mFinishedStarting：ArrayList-lt-AppWindowToken-gt" class="headerlink" title="4.mFinishedStarting：ArrayList&lt;**AppWindowToken**&gt;"></a>4.mFinishedStarting：ArrayList&lt;**AppWindowToken**&gt;</h3><p>ArrayList类型的变量，元素类型为AppWindowToken，它是WindowToken的子类。要想理解mFinishedStarting的含义，需要先了解WindowToken是什么。<br><strong>WindowToken</strong>：</p>
<ul>
<li>可以理解为窗口令牌，当应用程序想要向WMS申请新创建一个窗口，则需要向WMS出示有效的WindowToken。AppWindowToken作为WindowToken的子类，主要用来描述应用程序的</li>
<li>WindowToken结构，<br>应用程序中每个Activity都对应一个AppWindowToken。<br>WindowToken会将相同组件（比如Acitivity）的窗口（WindowState）集合在一起，方便管理。<br><strong>WindowState</strong>:<br>WindowState表示一个窗口的所有属性，且存在于WMS端，所以它是WMS中事实上的窗口。APP端一个Window，就会在WMS端就会有一个WindowState。</li>
</ul>
<h3 id="5-mResizingWindows：ArrayList-lt-WindowState-gt"><a href="#5-mResizingWindows：ArrayList-lt-WindowState-gt" class="headerlink" title="5.mResizingWindows：ArrayList&lt;**WindowState**&gt;"></a>5.mResizingWindows：ArrayList&lt;**WindowState**&gt;</h3><p>   ArrayList类型的变量，元素类型为WindowState。<br>   mResizingWindows是用来存储正在调整大小的窗口的列表</p>
<h3 id="6-mInputManager：InputManagerService"><a href="#6-mInputManager：InputManagerService" class="headerlink" title="6.mInputManager：InputManagerService"></a>6.mInputManager：InputManagerService</h3><p>InputManagerService类型的变量，输入系统的管理者。InputManagerService（IMS）会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS是窗口的管理者，因此，WMS“理所应当”的成为了输入系统的中转站，</p>
<h1 id="WindowManagerService的启动"><a href="#WindowManagerService的启动" class="headerlink" title="WindowManagerService的启动"></a>WindowManagerService的启动</h1><p>WMS的知识点非常多，在了解这些知识点前，我们十分有必要知道WMS是如何产生的。WMS是在SyetemServer进程中启动的。</p>
<p><strong>frameworks/base/services/java/com/android/server/SystemServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法中只调用了SystemServer的run方法，如下所示。<br><strong>frameworks/base/services/java/com/android/server/SystemServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);<span class="comment">//1</span></span><br><span class="line">          ...</span><br><span class="line">          mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);<span class="comment">//2</span></span><br><span class="line">          mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);</span><br><span class="line">          LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line">          <span class="comment">// Prepare the thread pool for init tasks that can be parallelized</span></span><br><span class="line">          SystemServerInitThreadPool.get();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          traceEnd();  <span class="comment">// InitBeforeStartServices</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          traceBeginAndSlog(<span class="string">&quot;StartServices&quot;</span>);</span><br><span class="line">          startBootstrapServices();<span class="comment">//3</span></span><br><span class="line">          startCoreServices();<span class="comment">//4</span></span><br><span class="line">          startOtherServices();<span class="comment">//5</span></span><br><span class="line">          SystemServerInitThreadPool.shutdown();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;******************************************&quot;</span>);</span><br><span class="line">          Slog.e(<span class="string">&quot;System&quot;</span>, <span class="string">&quot;************ Failure starting system services&quot;</span>, ex);</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          traceEnd();</span><br><span class="line">      &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>run方法代码很多，这里截取了关键的部分，在注释1处加载了libandroid_servers.so。在注释2处创建SystemServiceManager，它会对系统的服务进行创建、启动和生命周期管理。接下来的代码会启动系统的各种服务，在注释3中的startBootstrapServices方法中用SystemServiceManager启动了ActivityManagerService、PowerManagerService、PackageManagerService等服务。在注释4处的方法中则启动了BatteryService、UsageStatsService和WebViewUpdateService。注释5处的startOtherServices方法中则启动了CameraService、AlarmManagerService、VrManagerService等服务，这些服务的父类为SystemService。从注释3、4、5的方法名称可以看出，官方把大概80多个系统服务分为了三种类型，分别是引导服务、核心服务和其他服务，其中其他服务为一些非紧要和一些不需要立即启动的服务，WMS就是其他服务的一种。<br>我们来查看startOtherServices方法是如何启动WMS的：</p>
<p><strong>frameworks/base/services/java/com/android/server/SystemServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;InitWatchdog&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance();<span class="comment">//1</span></span><br><span class="line">            watchdog.init(context, mActivityManagerService);<span class="comment">//2</span></span><br><span class="line">            traceEnd();</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartInputManagerService&quot;</span>);</span><br><span class="line">            inputManager = <span class="keyword">new</span> InputManagerService(context);<span class="comment">//3</span></span><br><span class="line">            traceEnd();</span><br><span class="line">            traceBeginAndSlog(<span class="string">&quot;StartWindowManagerService&quot;</span>);</span><br><span class="line">            ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">            mSensorServiceStart = <span class="keyword">null</span>;</span><br><span class="line">            wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">                    mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                    !mFirstBoot, mOnlyCore, <span class="keyword">new</span> PhoneWindowManager());<span class="comment">//4</span></span><br><span class="line">            ServiceManager.addService(Context.WINDOW_SERVICE, wm);<span class="comment">//5</span></span><br><span class="line">            ServiceManager.addService(Context.INPUT_SERVICE, inputManager);<span class="comment">//6</span></span><br><span class="line">            traceEnd();   </span><br><span class="line">           ... </span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            wm.displayReady();<span class="comment">//7</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;making display ready&quot;</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">            wm.systemReady();<span class="comment">//8</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            reportWtf(<span class="string">&quot;making Window Manager Service ready&quot;</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">            ...      </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>startOtherServices方法用于启动其他服务，其他服务大概有70多个，上面的代码只列出了WMS以及和它相关的IMS的启动逻辑，剩余的其他服务的启动逻辑也都大同小异。在注释1、2处分别得到Watchdog实例并对它进行初始化，Watchdog用来监控系统的一些关键服务的运行状况，后文会再次提到它。在注释3处创建了IMS，并赋值给IMS类型的inputManager对象。注释4处执行了WMS的main方法，其内部会创建WMS，需要注意的是main方法其中一个传入的参数就是注释1处创建的IMS，WMS是输入事件的中转站，其内部包含了IMS引用并不意外。结合上文，我们可以得知WMS的main方法是运行在SystemServer的run方法中，换句话说就是运行在”system_server”线程”中，后面会再次提到”system_server”线程。注释5和注释6处分别将WMS和IMS注册到ServiceManager中，这样如果某个客户端想要使用WMS，就需要先去ServiceManager中查询信息，然后根据信息与WMS所在的进程建立通信通路，客户端就可以使用WMS了。注释7处用来初始化显示信息，注释8处则用来通知WMS，系统的初始化工作已经完成，其内部调用了WindowManagerPolicy的systemReady方法。我们来查看注释4处WMS的main方法，如下所示。</p>
<p><strong>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> WindowManagerService <span class="title">main</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> InputManagerService im,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">final</span> <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">final</span> <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">final</span> <span class="keyword">boolean</span> onlyCore,</span></span></span><br><span class="line"><span class="params"><span class="function">           WindowManagerPolicy policy)</span> </span>&#123;</span><br><span class="line">       DisplayThread.getHandler().runWithScissors(() -&gt;<span class="comment">//1</span></span><br><span class="line">               sInstance = <span class="keyword">new</span> WindowManagerService(context, im, haveInputMethods, showBootMsgs,</span><br><span class="line">                       onlyCore, policy), <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> sInstance;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处调用了DisplayThread的getHandler方法，用来得到DisplayThread的Handler实例。DisplayThread是一个单例的前台线程，这个线程用来处理需要低延时显示的相关操作，并只能由WindowManager、DisplayManager和InputManager实时执行快速操作。注释1处的runWithScissors方法中使用了Java8中的Lambda表达式，它等价于如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayThread.getHandler().runWithScissors(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         sInstance = <span class="keyword">new</span> WindowManagerService(context, im, haveInputMethods, showBootMsgs,</span><br><span class="line">                    onlyCore, policy);<span class="comment">//2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在注释2处创建了WMS的实例，这个过程运行在Runnable的run方法中，而Runnable则传入到了DisplayThread对应Handler的runWithScissors方法中，说明WMS的创建是运行在“android.display”线程中。需要注意的是，runWithScissors方法的第二个参数传入的是0，后面会提到。来查看Handler的runWithScissors方法里做了什么：<br><strong>frameworks/base/core/java/android/os/Handler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">runWithScissors</span><span class="params">(<span class="keyword">final</span> Runnable r, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;runnable must not be null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout must be non-negative&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (Looper.myLooper() == mLooper) &#123;<span class="comment">//1</span></span><br><span class="line">           r.run();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       BlockingRunnable br = <span class="keyword">new</span> BlockingRunnable(r);</span><br><span class="line">       <span class="keyword">return</span> br.postAndWait(<span class="keyword">this</span>, timeout);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>开头对传入的Runnable和timeout进行了判断，如果Runnable为null或者timeout小于0则抛出异常。注释1处根据每个线程只有一个Looper的原理来判断当前的线程（”system_server”线程）是否是Handler所指向的线程（”android.display”线程），如果是则直接执行Runnable的run方法，如果不是则调用BlockingRunnable的postAndWait方法，并将当前线程的Runnable作为参数传进去 ，BlockingRunnable是Handler的内部类，代码如下所示。<strong>frameworks/base/core/java/android/os/Handler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mTask;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> mDone;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BlockingRunnable</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">            mTask = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mTask.run();<span class="comment">//1</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mDone = <span class="keyword">true</span>;</span><br><span class="line">                    notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postAndWait</span><span class="params">(Handler handler, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!handler.post(<span class="keyword">this</span>)) &#123;<span class="comment">//2</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> expirationTime = SystemClock.uptimeMillis() + timeout;</span><br><span class="line">                    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                        <span class="keyword">long</span> delay = expirationTime - SystemClock.uptimeMillis();</span><br><span class="line">                        <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// timeout</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(delay);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait();<span class="comment">//3</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>注释2处将当前的BlockingRunnable添加到Handler的任务队列中。前面runWithScissors方法的第二个参数为0，因此timeout等于0，这样如果mDone为false的话会一直调用注释3处的wait方法使得当前线程（”system_server”线程）进入等待状态，那么等待的是哪个线程呢？我们往上看，注释1处，执行了传入的Runnable的run方法（运行在”android.display”线程），执行完毕后在finally代码块中将mDone设置为true，并调用notifyAll方法唤醒处于等待状态的线程，这样就不会继续调用注释3处的wait方法。因此得出结论，”system_server”线程线程等待的就是”android.display”线程，一直到”android.display”线程执行完毕再执行”system_server”线程，这是因为”android.display”线程内部执行了WMS的创建，显然WMS的创建优先级更高些。WMS的创建就讲到这，最后我们来查看WMS的构造方法：<br><strong>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService .java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WindowManagerService</span><span class="params">(Context context, InputManagerService inputManager,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       mInputManager = inputManager;<span class="comment">//1</span></span><br><span class="line">       ...</span><br><span class="line">        mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line">        mDisplays = mDisplayManager.getDisplays();<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">for</span> (Display display : mDisplays) &#123;</span><br><span class="line">            createDisplayContentLocked(display);<span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">        mActivityManager = ActivityManagerNative.getDefault();<span class="comment">//4</span></span><br><span class="line">       ...</span><br><span class="line">        mAnimator = <span class="keyword">new</span> WindowAnimator(<span class="keyword">this</span>);<span class="comment">//5</span></span><br><span class="line">        mAllowTheaterModeWakeFromLayout = context.getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_allowTheaterModeWakeFromWindowLayout);</span><br><span class="line">        LocalServices.addService(WindowManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">        initPolicy();<span class="comment">//6</span></span><br><span class="line">        <span class="comment">// Add ourself to the Watchdog monitors.</span></span><br><span class="line">        Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);<span class="comment">//7</span></span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注释1处用来保存传进来的IMS，这样WMS就持有了IMS的引用。注释2处通过DisplayManager的getDisplays方法得到Display数组（每个显示设备都有一个Display实例），接着遍历Display数组，在注释3处的createDisplayContentLocked方法会将Display封装成DisplayContent，DisplayContent用来描述一快屏幕。注释4处得到AMS实例，并赋值给mActivityManager ，这样WMS就持有了AMS的引用。注释5处创建了WindowAnimator，它用于管理所有的窗口动画。注释6处初始化了窗口管理策略的接口类WindowManagerPolicy（WMP），它用来定义一个窗口策略所要遵循的通用规范。注释7处将自身也就是WMS通过addMonitor方法添加到Watchdog中，Watchdog用来监控系统的一些关键服务的运行状况（比如传入的WMS的运行状况），这些被监控的服务都会实现Watchdog.Monitor接口。Watchdog每分钟都会对被监控的系统服务进行检查，如果被监控的系统服务出现了死锁，则会杀死Watchdog所在的进程，也就是SystemServer进程。</p>
<p>查看注释6处的initPolicy方法，如下所示。<strong>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     UiThread.getHandler().runWithScissors(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper());</span><br><span class="line">             mPolicy.init(mContext, WindowManagerService.<span class="keyword">this</span>, WindowManagerService.<span class="keyword">this</span>);<span class="comment">//1</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>initPolicy方法和此前讲的WMS的main方法的实现类似，注释1处执行了WMP的init方法，WMP是一个接口，init方法的具体实现在PhoneWindowManager（PWM）中。PWM的init方法运行在”android.ui”线程中，它的优先级要高于initPolicy方法所在的”android.display”线程，因此”android.display”线程要等PWM的init方法执行完毕后，处于等待状态的”android.display”线程才会被唤醒从而继续执行下面的代码。<br>在本文中共提到了3个线程，分别是”system_server”、”android.display”和”android.ui”，为了便于理解，下面给出这三个线程之间的关系。</p>
<p><img src="/images/android_wms_service_start.png" alt="wms_service_start"></p>
<p>“system_server”线程中会调用WMS的main方法，main方法中会创建WMS，创建WMS的过程运行在”android.display”线程中，它的优先级更高一些，因此要等创建WMS完毕后才会唤醒处于等待状态的”system_server”线程。<br>WMS初始化时会执行initPolicy方法，initPolicy方法会调用PWM的init方法，这个init方法运行在”android.ui”线程，并且优先级更高，因此要先执行完PWM的init方法后，才会唤醒处于等待状态的”android.display”线程。<br>PWM的init方法执行完毕后会接着执行运行在”system_server”线程的代码，比如本文前部分提到WMS的<br>systemReady方法。</p>
<h1 id="Window的添加与删除"><a href="#Window的添加与删除" class="headerlink" title="Window的添加与删除"></a>Window的添加与删除</h1><h2 id="Window的添加"><a href="#Window的添加" class="headerlink" title="Window的添加"></a>Window的添加</h2><p>WMS#addWindow方法返回的是addWindow的各种状态，比如添加Window成功，无效的Display等，这些状态被定义在WindowManagerGlobal中。在方法里面主要做了四个事情，如果所示：<br><img src="/images/android_wms_window_add.png" alt="wms_window_add"></p>
<h3 id="窗口检查"><a href="#窗口检查" class="headerlink" title="窗口检查"></a>窗口检查</h3><p>对参数进行进行检查是非常有必要的第一个步骤，大部分函数中都是这样做的，这个很好理解，毕竟如果传入的参数都是错的，后面做过多的内容都是无用功。<br>WMS#addWindow对窗口参数主要做了哪些检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs.type, isRoundedCornerOverlay, attrs.packageName,</span><br><span class="line">          appOp);</span><br></pre></td></tr></table></figure>

<p>mPolicy是窗口管理策略的接口，实现类是PhoneWindowManager。在PhoneWindowManager中对窗口的type合法性做了检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!((type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW)</span><br><span class="line">                || (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW)</span><br><span class="line">                || (type &gt;= FIRST_SYSTEM_WINDOW &amp;&amp; type &lt;= LAST_SYSTEM_WINDOW))) &#123;</span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的话通过DisplayId来获取窗口要添加到哪个DisplayContentshang，如果没有找到DisplayContent， 则返回错误状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> DisplayContent displayContent = getDisplayContentOrCreate(displayId, attrs.token);</span><br></pre></td></tr></table></figure>
<p>如果窗口是子窗口类型，然后是对父窗口的信息做一些检查，如果为空或者父窗口也是子窗口类型则检查不通过，返回错误类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">    			<span class="comment">//通过token获取获取父窗口的信息</span></span><br><span class="line">                parentWindow = windowForClientLocked(<span class="keyword">null</span>, attrs.token, <span class="keyword">false</span>);</span><br><span class="line">    			<span class="comment">//如果父窗口为空输入返回信息</span></span><br><span class="line">                <span class="keyword">if</span> (parentWindow == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ProtoLog.w(WM_ERROR, <span class="string">&quot;Attempted to add window with token that is not a window: &quot;</span></span><br><span class="line">                            + <span class="string">&quot;%s.  Aborting.&quot;</span>, attrs.token);</span><br><span class="line">                    <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">                &#125;</span><br><span class="line">    			<span class="comment">//如果父窗口也是子窗口类型</span></span><br><span class="line">                <span class="keyword">if</span> (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW</span><br><span class="line">                        &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123;</span><br><span class="line">                    ProtoLog.w(WM_ERROR, <span class="string">&quot;Attempted to add window with token that is a sub-window: &quot;</span></span><br><span class="line">                            + <span class="string">&quot;%s.  Aborting.&quot;</span>, attrs.token);</span><br><span class="line">                    <span class="keyword">return</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN;</span><br><span class="line">                &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="WindowToken相关处理"><a href="#WindowToken相关处理" class="headerlink" title="WindowToken相关处理"></a>WindowToken相关处理</h3><p>在WindowToken相关处理这部分内容中，我们先通过DisplayContent尝试获取WindowToken，token为空且有父窗口，则用父窗口的token，token为空没有父窗口自己新建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过DisplayContent获取到WindowToken</span></span><br><span class="line">WindowToken token = displayContent.getWindowToken(</span><br><span class="line">                    hasParent ? parentWindow.mAttrs.token : attrs.token);</span><br><span class="line">            <span class="comment">// If this is a child window, we want to apply the same type checking rules as the</span></span><br><span class="line">            <span class="comment">// parent window type.</span></span><br><span class="line">			..........</span><br><span class="line">            <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">                .........</span><br><span class="line">                <span class="keyword">if</span> (hasParent) &#123;</span><br><span class="line">                    <span class="comment">// Use existing parent window token for child windows.</span></span><br><span class="line">                    <span class="comment">//有父窗口的用父窗口的Token</span></span><br><span class="line">                    token = parentWindow.mToken;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//没有父窗口自己新建一个WindowToken，WindowToken翻译过来是令牌，用于标识一组窗口。</span></span><br><span class="line">                    <span class="keyword">final</span> IBinder binder = attrs.token != <span class="keyword">null</span> ? attrs.token : client.asBinder();</span><br><span class="line">                    token = <span class="keyword">new</span> WindowToken(<span class="keyword">this</span>, binder, type, <span class="keyword">false</span>, displayContent,</span><br><span class="line">                            session.mCanAddInternalSystemWindow, isRoundedCornerOverlay);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="WindowState的创建和处理"><a href="#WindowState的创建和处理" class="headerlink" title="WindowState的创建和处理"></a>WindowState的创建和处理</h3><p>WindowState是WMS端的事实窗口，通过new的方式新建好一个WindowState之后就进行了相关的判断，比如请求添加窗口的客户端是否死亡、窗口的DisplayContent是否失效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">final</span> WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token, parentWindow,</span><br><span class="line">                    appOp[<span class="number">0</span>], seq, attrs, viewVisibility, session.mUid, userId,</span><br><span class="line">                    session.mCanAddInternalSystemWindow);</span><br><span class="line"><span class="comment">//窗口是否死亡</span></span><br><span class="line"><span class="keyword">if</span> (win.mDeathRecipient == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ProtoLog.w(WM_ERROR, <span class="string">&quot;Adding window client %s&quot;</span></span><br><span class="line">                        + <span class="string">&quot; that is dead, aborting.&quot;</span>, client.asBinder());</span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DisplayContent是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (win.getDisplayContent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ProtoLog.w(WM_ERROR, <span class="string">&quot;Adding window to Display that has been removed.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> WindowManagerGlobal.ADD_INVALID_DISPLAY;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.......</span><br><span class="line"><span class="comment">//调用WMP的方法，此方法会根据窗口的Type对LayoutParams的一些成员进行修改</span></span><br><span class="line">displayPolicy.adjustWindowParamsLw(win, win.mAttrs, callingPid, callingUid);</span><br><span class="line">.......</span><br><span class="line"><span class="comment">// 将窗口添加到系统中</span></span><br><span class="line">res = displayPolicy.validateAddingWindowLw(attrs, callingPid, callingUid);</span><br><span class="line">.......</span><br><span class="line"><span class="comment">// windowState保存到Map中</span></span><br><span class="line">mWindowMap.put(client.asBinder(), win);</span><br><span class="line">.......</span><br><span class="line"><span class="comment">// 绑定Token和WindowState关系</span></span><br><span class="line">win.mToken.addWindow(win);</span><br></pre></td></tr></table></figure>

<h3 id="Display的创建和配置"><a href="#Display的创建和配置" class="headerlink" title="Display的创建和配置"></a>Display的创建和配置</h3><p>创建和配置DisplayContent，完成窗口添加到系统前的准备工作。</p>
<h2 id="Window的删除"><a href="#Window的删除" class="headerlink" title="Window的删除"></a>Window的删除</h2><p>Window的删除过程，本文中从WindowManagerImpl开始讲起，主要做了四个事情如图右所示。<br><img src="/images/android_wms_window_remove.png" alt="wms_window_remove"></p>
<h3 id="检查线程的正确性"><a href="#检查线程的正确性" class="headerlink" title="检查线程的正确性"></a>检查线程的正确性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                    <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ViewRootImpl相关数据删除"><a href="#ViewRootImpl相关数据删除" class="headerlink" title="ViewRootImpl相关数据删除"></a>ViewRootImpl相关数据删除</h3><p>在WindowManagerGlobal方法中，会删除相关的一些数据，如ViewRootImpl、LayoutParams、DecorView，并将DecorView加入到死亡列表中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doRemoveView</span><span class="params">(ViewRootImpl root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">//从ViewRootImpl获取到索引值</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = mRoots.indexOf(root);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//删除ViewRootImpl列表中的数据</span></span><br><span class="line">                mRoots.remove(index);</span><br><span class="line">                <span class="comment">//删除LayoutParams列表中的数据</span></span><br><span class="line">                mParams.remove(index);</span><br><span class="line">                <span class="comment">//删除DecorView列表中的数据</span></span><br><span class="line">                <span class="keyword">final</span> View view = mViews.remove(index);</span><br><span class="line">                <span class="comment">//DecorView加入到死亡列表</span></span><br><span class="line">                mDyingViews.remove(view);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断是否立即执行删除"><a href="#判断是否立即执行删除" class="headerlink" title="判断是否立即执行删除"></a>判断是否立即执行删除</h3><p>这ViewRootImpl中die方法中，会先判断是否立即执行删除，如果被判处死刑且立即执行则调用doDie方法，如果不是则通过Handler方法执行死刑的信号，判个缓刑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span></span><br><span class="line">      <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span></span><br><span class="line"><span class="comment">//immediate 是否立即执行 为ture则立即执行</span></span><br><span class="line">      <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">          doDie();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">......</span><br><span class="line">   </span><br><span class="line">    	<span class="comment">//通过Handler发送死亡信息，判处死缓</span></span><br><span class="line">      mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//检查线程</span></span><br><span class="line">        checkThread();</span><br><span class="line">        <span class="keyword">if</span> (LOCAL_LOGV) Log.v(mTag, <span class="string">&quot;DIE in &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; of &quot;</span> + mSurface);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否删除</span></span><br><span class="line">            <span class="keyword">if</span> (mRemoved) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止重复调用</span></span><br><span class="line">            mRemoved = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (mAdded) &#123;</span><br><span class="line">                <span class="comment">//做数据清除 注销操作，调用session的remove方法</span></span><br><span class="line">                dispatchDetachedFromWindow();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123;</span><br><span class="line">                destroyHardwareRenderer();</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> viewVisibility = mView.getVisibility();</span><br><span class="line">                    <span class="keyword">boolean</span> viewVisibilityChanged = mViewVisibility != viewVisibility;</span><br><span class="line">                    <span class="keyword">if</span> (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                        <span class="comment">// If layout params have been changed, first give them</span></span><br><span class="line">                        <span class="comment">// to the window manager to make sure it has the correct</span></span><br><span class="line">                        <span class="comment">// animation info.</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> ((relayoutWindow(mWindowAttributes, viewVisibility, <span class="keyword">false</span>)</span><br><span class="line">                                    &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;</span><br><span class="line">                                mWindowSession.finishDrawing(</span><br><span class="line">                                        mWindow, <span class="keyword">null</span> <span class="comment">/* postDrawTransaction */</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">    				<span class="comment">//销毁画布</span></span><br><span class="line">                    destroySurface();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            mAdded = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用WindowManagerGlobal移除方法</span></span><br><span class="line">        WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在ViewRootImpl的dispatchDetachedFromWindow方法中会调用Session与WMS进行通信，然后执行移除的操作。<br>在WMS的removeWindow函数中，先会通过Session和Client获取到当前窗口在WMS的副本也就是WindowState，如果不为空则执行删除操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeWindow</span><span class="params">(Session session, IWindow client)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mGlobalLock) &#123;</span><br><span class="line">           	<span class="comment">//获取WindowState</span></span><br><span class="line">            WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (win != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//执行删除</span></span><br><span class="line">                win.removeIfPossible();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove embedded window map if the token belongs to an embedded window</span></span><br><span class="line">            mEmbeddedWindowController.remove(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>win.removeIfPossible方法和它的名字一样，并不是直接执行删除操作，而是进行多个条件判断过滤，满足其中一个条件就会return，推迟删除操作。比如V正在运行一个动画，这是就会推迟删除操作知道动画完成。然后调用removeImmediately方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeImmediately</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.removeImmediately();</span><br><span class="line">        <span class="comment">//已经删除</span></span><br><span class="line">        <span class="keyword">if</span> (mRemoved) &#123;</span><br><span class="line">            <span class="comment">// Nothing to do.</span></span><br><span class="line">            ProtoLog.v(WM_DEBUG_ADD_REMOVE,</span><br><span class="line">                    <span class="string">&quot;WS.removeImmediately: %s Already removed...&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除标记</span></span><br><span class="line">        mRemoved = <span class="keyword">true</span>;</span><br><span class="line">        ......</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> DisplayContent dc = getDisplayContent();</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//policy做移除操作</span></span><br><span class="line">        dc.getDisplayPolicy().removeWindowLw(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//关闭输入事件渠道</span></span><br><span class="line">        disposeInputChannel();</span><br><span class="line">        </span><br><span class="line">        mWinAnimator.destroyDeferredSurfaceLocked();</span><br><span class="line">        mWinAnimator.destroySurfaceLocked();</span><br><span class="line">        <span class="comment">//Session集合冲移除WindowState</span></span><br><span class="line">        mSession.windowRemovedLocked();</span><br><span class="line">        .....</span><br><span class="line">      	<span class="comment">//集中处理清除工作</span></span><br><span class="line">        mWmService.postWindowRemoveCleanupLocked(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="输入事件处理"><a href="#输入事件处理" class="headerlink" title="输入事件处理"></a>输入事件处理</h1><h2 id="安卓输入事件整体流程"><a href="#安卓输入事件整体流程" class="headerlink" title="安卓输入事件整体流程"></a>安卓输入事件整体流程</h2><p>Android 系统是由事件驱动的，而 input 是最常见的事件之一，用户的点击、滑动、长按等操作，都属于 input 事件驱动，其中的核心就是 InputReader 和 InputDispatcher。<br>InputReader 和 InputDispatcher 是跑在 SystemServer进程中的两个 native 循环线程，负责读取和分发 Input 事件。整个处理过程大致流程如下：<br><img src="/images/android_wms_input_event01.png" alt="wms_input_event"></p>
<h2 id="InputManagerService"><a href="#InputManagerService" class="headerlink" title="InputManagerService"></a>InputManagerService</h2><p>在SystemServer的startOtherServices函数中，会新建一个InputManagerService对象，然后会作为参数传入到WMS中去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">......</span><br><span class="line">wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">                    <span class="keyword">new</span> PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);</span><br></pre></td></tr></table></figure>

<h2 id="WindowInputEventReceiver输入事件监听"><a href="#WindowInputEventReceiver输入事件监听" class="headerlink" title="WindowInputEventReceiver输入事件监听"></a>WindowInputEventReceiver输入事件监听</h2><p>在ViewRootImpl的setView函数中，会先建立一个InputChannel对象。inputChannel是输入事件的信道，它ViewRootImpl和InputManagerService的沟通桥梁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputChannel inputChannel = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                       &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">     inputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inputChannel会通过mWindowSession.addToDisplayAsUser方法传入到WMS侧，并且与当前新建窗口WindowState建立起关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if  (openInputChannels) &#123;</span><br><span class="line">	//WindowState与InputChannel关联上了</span><br><span class="line">    win.openInputChannel(outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后代码运行到ViewRootImpl侧，这个时候就开始生成监听对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (inputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                        mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                    &#125;</span><br><span class="line">   					<span class="comment">// 输入事件的监听对象</span></span><br><span class="line">                    mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(inputChannel,</span><br><span class="line">                            Looper.myLooper());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EventHub设备事件监听"><a href="#EventHub设备事件监听" class="headerlink" title="EventHub设备事件监听"></a>EventHub设备事件监听</h2><p>它主要是利用Linux的inotify和epoll机制，监听设备事件：包括设备插拔及各种触摸、按钮事件等，可以看做是一个不同设备的集线器，主要面向的是/dev/input目录下的设备节点，比如说/dev/input/event0上的事件就是输入事件：<br><img src="/images/android_wms_input_event_hub.webp" alt="wms_input_event_hub"></p>
<h2 id="InputReader读取事件"><a href="#InputReader读取事件" class="headerlink" title="InputReader读取事件"></a>InputReader读取事件</h2><p>InputReader主要是负责不断的从EventHub读取事件，通知派发给InputDispatcher。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="keyword">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="keyword">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    &#123; </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 读取EventHub中的事件</span></span><br><span class="line">    <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// 通知派发给InputDispatcher</span></span><br><span class="line">   mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="InputDispatcher读取事件"><a href="#InputDispatcher读取事件" class="headerlink" title="InputDispatcher读取事件"></a>InputDispatcher读取事件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 被唤醒 ，处理Input消息</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">       .....</span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    <span class="comment">//睡眠等到事件</span></span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是派发线程的模型，dispatchOnceInnerLocked是具体的派发处理逻辑，这里看其中一个分支，触摸事件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnceInnerLocked</span><span class="params">(<span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        ...</span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::dispatchMotionLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    ...     </span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">bool</span> conflictingPointerActions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">    &lt;!--关键点<span class="number">1</span> 找到目标Window--&gt;</span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;!--关键点<span class="number">2</span>  派发--&gt;</span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，对于触摸事件会首先通过findTouchedWindowTargetsLocked找到目标Window，进而通过dispatchEventLocked将消息发送到目标窗口，下面看一下如何找到目标窗口，以及这个窗口列表是如何维护的。</p>
<h2 id="寻找目标窗口"><a href="#寻找目标窗口" class="headerlink" title="寻找目标窗口"></a>寻找目标窗口</h2><p>Android系统能够同时支持多块屏幕，每块屏幕被抽象成一个DisplayContent对象，内部维护一个WindowList列表对象，用来记录当前屏幕中的所有窗口，包括状态栏、导航栏、应用窗口、子窗口等。对于触摸事件，我们比较关心可见窗口<br>那么，如何找到触摸事件对应的窗口呢，是状态栏、导航栏还是应用窗口呢，这个时候DisplayContent的WindowList就发挥作用了，DisplayContent握着所有窗口的信息，因此，可以<strong>根据触摸事件的位置及窗口的属性来确定将事件发送到哪个窗口</strong>，当然其中的细节比一句话复杂的多，跟窗口的状态、透明、分屏等信息都有关系，下面简单瞅一眼，达到主观理解的流程就可以了，然后会调用到InputDispatcher#findTouchedWindowAtLocked</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历所有窗口 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle : windowHandles) &#123;</span><br><span class="line">        <span class="keyword">const</span> InputWindowInfo* windowInfo = windowHandle-&gt;getInfo();</span><br><span class="line">        <span class="keyword">if</span> (windowInfo-&gt;displayId == displayId) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> flags = windowInfo-&gt;layoutParamsFlags;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (windowInfo-&gt;visible) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(flags &amp; InputWindowInfo::FLAG_NOT_TOUCHABLE)) &#123;</span><br><span class="line">                    <span class="keyword">bool</span> isTouchModal = (flags &amp;</span><br><span class="line">                                         (InputWindowInfo::FLAG_NOT_FOCUSABLE |</span><br><span class="line">                                          InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isTouchModal || windowInfo-&gt;touchableRegionContainsPoint(x, y)) &#123;</span><br><span class="line">                        <span class="keyword">int32_t</span> portalToDisplayId = windowInfo-&gt;portalToDisplayId;</span><br><span class="line">                        ......</span><br><span class="line">                        <span class="comment">// Found window. 找到目标窗口</span></span><br><span class="line">                        <span class="keyword">return</span> windowHandle;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>mWindowHandles代表着所有窗口，找到了目标窗口，同时也将事件封装好了，剩下的就是通知目标窗口，可是有个最明显的问题就是，目前所有的逻辑都是在SystemServer进程，而要通知的窗口位于APP端的用户进程，那么如何通知呢？这里面采用的都是Socket的通信方式。</p>
<h1 id="Surface的创建与操作"><a href="#Surface的创建与操作" class="headerlink" title="Surface的创建与操作"></a>Surface的创建与操作</h1><h2 id="Surface的创建"><a href="#Surface的创建" class="headerlink" title="Surface的创建"></a>Surface的创建</h2><p>在Android系统中每个Activity都有一个独立的画布（在应用侧称为Surface,在SurfaceFlinger侧称为Layer）， 无论这个Activity安排了多么复杂的view结构，它们最终都是被画在了所属Activity的这块画布上。</p>
<h3 id="Surface在应用端的新建"><a href="#Surface在应用端的新建" class="headerlink" title="Surface在应用端的新建"></a>Surface在应用端的新建</h3><p>在 ViewRootImpl 创建时同时会 new 一个 Surface 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure>

<p><img src="/images/android_wms_surfacce_add.png" alt="wms_surfacce_add"><br>Surface其实是广义上的画布，真正意义上的画图是Canvas，也就是在View的onDraw方法里面的Canvas。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Canvas mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ViewRootImpl直接新建的Surface并没有直接大小</p>
<h3 id="SurfaceControl"><a href="#SurfaceControl" class="headerlink" title="SurfaceControl"></a>SurfaceControl</h3><p>SurfaceControl是创建Surface的辅助管理类，它在ViewRootImpl创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SurfaceControl mSurfaceControl = <span class="keyword">new</span> SurfaceControl();</span><br></pre></td></tr></table></figure>

<p>在setView的时候会调用relayoutWindow函数，由mWindowSession将内容传递给WMS端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">          <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(mWindow, mSeq, params,</span><br><span class="line">              (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">              (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>), viewVisibility,</span><br><span class="line">              insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>, frameNumber,</span><br><span class="line">              mTmpFrame, mTmpRect, mTmpRect, mTmpRect, mPendingBackDropFrame,</span><br><span class="line">              mPendingDisplayCutout, mPendingMergedConfiguration, mSurfaceControl, mTempInsets,</span><br><span class="line">              mTempControls, mSurfaceSize, mBlastSurfaceControl);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着代码的执行让我们把视角切换到system_server进程（WMS的relayoutWindow函数）,这里会调用createSurfaceControl去创建一个SurfaceControl：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq, LayoutParams attrs,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">long</span> frameNumber, Rect outFrame, Rect outContentInsets,</span></span></span><br><span class="line"><span class="params"><span class="function">           Rect outVisibleInsets, Rect outStableInsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="params"><span class="function">           DisplayCutout.ParcelableWrapper outCutout, MergedConfiguration mergedConfiguration,</span></span></span><br><span class="line"><span class="params"><span class="function">           SurfaceControl outSurfaceControl, InsetsState outInsetsState,</span></span></span><br><span class="line"><span class="params"><span class="function">           InsetsSourceControl[] outActiveControls, Point outSurfaceSize,</span></span></span><br><span class="line"><span class="params"><span class="function">           SurfaceControl outBLASTSurfaceControl)</span> </span>&#123;</span><br><span class="line">    	......</span><br><span class="line">	result = createSurfaceControl(outSurfaceControl, outBLASTSurfaceControl, result, win, winAnimator);</span><br><span class="line">    	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SurfaceControl的创建过程，注意这里创建工作是调用winAnimator来完成的，注意下面那句surfaceController.getSurfaceControl会把创建出来的SurfaceControl通过形参outSurfaceControl传出去：</p>
<p>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(SurfaceControl outSurfaceControl,</span></span></span><br><span class="line"><span class="params"><span class="function">            SurfaceControl outBLASTSurfaceControl, <span class="keyword">int</span> result,</span></span></span><br><span class="line"><span class="params"><span class="function">            WindowState win, WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    WindowSurfaceController surfaceController;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">&quot;createSurfaceControl&quot;</span>);</span><br><span class="line">        surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurfaceControl(outSurfaceControl);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看下创建过程，创建了一个WindowSurfaceController，进而再创建SurfaceControll:<br>frameworks/base/services/core/java/com/android/server/wm/WindowStateAnimator.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">(<span class="keyword">int</span> windowType, <span class="keyword">int</span> ownerUid)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/*WindowSurfaceController mSurfaceController;*/</span></span><br><span class="line">    mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(attrs.getTitle().toString(), width,</span><br><span class="line">                    height, format, flags, <span class="keyword">this</span>, windowType, ownerUid);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowSurfaceController.java (frameworks\base\services\core\java\com\android\server\wm)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WindowSurfaceController(String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format,</span><br><span class="line">            <span class="keyword">int</span> flags, WindowStateAnimator animator, <span class="keyword">int</span> windowType, <span class="keyword">int</span> ownerUid) &#123;</span><br><span class="line">     ......</span><br><span class="line">     <span class="keyword">final</span> SurfaceControl.Builder b = win.makeSurface()</span><br><span class="line">                .setParent(win.getSurfaceControl())</span><br><span class="line">                .setName(name)</span><br><span class="line">                .setBufferSize(w, h)</span><br><span class="line">                .setFormat(format)</span><br><span class="line">                .setFlags(flags)</span><br><span class="line">                .setMetadata(METADATA_WINDOW_TYPE, windowType)</span><br><span class="line">                .setMetadata(METADATA_OWNER_UID, ownerUid)</span><br><span class="line">                .setCallsite(<span class="string">&quot;WindowSurfaceController&quot;</span>);</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在WMS端SurfaceControl以形参outSurfaceControl传出，然后在ViewRootImpl侧，通过Surface的copyFrom方法，将内容写入到mSurface，此时surface正式新建完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceControl.isValid()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!useBLAST()) &#123;</span><br><span class="line">                    mSurface.copyFrom(mSurfaceControl);</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图层Layer创建"><a href="#图层Layer创建" class="headerlink" title="图层Layer创建"></a>图层Layer创建</h3><p><img src="/images/android_wms_surface_add_layer_create.png" alt="wms_surface_add_layer_create"><br><strong>具体流程如下：</strong><br>在SurfaceControl的构造方法中通过JNI去创建C端对象</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SurfaceControl</span>(<span class="params">SurfaceSession session, String name, <span class="built_in">int</span> w, <span class="built_in">int</span> h, <span class="built_in">int</span> format, <span class="built_in">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">            SurfaceControl parent, SparseIntArray metadata, WeakReference&lt;View&gt; localOwnerView,</span></span></span><br><span class="line"><span class="params"><span class="function">            String callsite</span>)</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags,</span><br><span class="line">                    parent != <span class="literal">null</span> ? parent.mNativeObject : <span class="number">0</span>, metaParcel);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>android_view_SurfaceControl.cpp (frameworks\base\core\jni)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="params"><span class="function">        jstring nameStr, jint w, jint h, jint format, jint flags, jlong parentObject,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject metadataParcel)</span> </span>&#123;</span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;<span class="comment">//Surface名字， 在SurfaceFlinger侧就是Layer的名字</span></span><br><span class="line">    ......</span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; client;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">status_t</span> err = client-&gt;<span class="built_in">createSurfaceChecked</span>(</span><br><span class="line">            <span class="built_in">String8</span>(name.<span class="built_in">c_str</span>()), w, h, format, &amp;surface, flags, parent, std::<span class="built_in">move</span>(metadata));</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C层的Surface在创建时去调用SurfaceComposerClient的createSurface去创建, 这个SurfaceComposerClient可以看作是SurfaceFlinger在Client端的代表</p>
<p>android_view_SurfaceControl.cpp (frameworks\base\core\jni）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceComposerClient::createSurfaceChecked</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     sp&lt;SurfaceControl&gt;* outSurface, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     SurfaceControl* parent, LayerMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="keyword">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      err = mClient-&gt;<span class="built_in">createSurface</span>(name, w, h, format, flags, parentHandle, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                     &amp;handle, &amp;gbp, &amp;transformHint);</span><br><span class="line">      ......</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>SurfaceComposerClient.cpp (frameworks\native\libs\gui)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">sp&lt;SurfaceControl&gt; <span class="title">SurfaceComposerClient::createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        SurfaceControl* parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        LayerMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                        <span class="keyword">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; s;</span><br><span class="line">    <span class="built_in">createSurfaceChecked</span>(name, w, h, format, &amp;s, flags, parent, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                         outTransformHint);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceComposerClient::createSurfaceChecked</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     sp&lt;SurfaceControl&gt;* outSurface, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     SurfaceControl* parent, LayerMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="keyword">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">      .......</span><br><span class="line">      err = mClient-&gt;<span class="built_in">createSurface</span>(name, w, h, format, flags, parentHandle, std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                                     &amp;handle, &amp;gbp, &amp;transformHint);</span><br><span class="line">      .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跨进程呼叫SurfaceFlinger：</p>
<p>ISurfaceComposerClient.cpp (frameworks\native\libs\gui)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width, <span class="keyword">uint32_t</span> height, PixelFormat format,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; parent, LayerMetadata metadata,</span></span></span><br><span class="line"><span class="params"><span class="function">                           sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">uint32_t</span>* outTransformHint)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> callRemote&lt;<span class="keyword">decltype</span>(&amp;ISurfaceComposerClient::createSurface)&gt;(Tag::CREATE_SURFACE,</span><br><span class="line">                               name, width, height,</span><br><span class="line">                               format, flags, parent,</span><br><span class="line">                               std::<span class="built_in">move</span>(metadata),</span><br><span class="line">                               handle, gbp,</span><br><span class="line">                               outTransformHint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后流程就来到了SurfaceFlinger进程，由于SurfaceFlinger支持很多不同类型的Layer, 这里我们只以BufferQueueLayer为例， 当SurfaceFlinger收到这个远程调用后会new 一个BufferQueueLayer出来。</p>
<p>SurfaceFlinger.cpp (frameworks\native\services\surfaceflinger)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">tatus_t</span> <span class="title">SurfaceFlinger::createLayer</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">const</span> sp&lt;Client&gt;&amp; client, <span class="keyword">uint32_t</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; parentHandle, <span class="keyword">const</span> sp&lt;Layer&gt;&amp; parentLayer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">uint32_t</span>* outTransformHint)</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceBufferQueue:</span><br><span class="line">            result = <span class="built_in">createBufferQueueLayer</span>(client, std::<span class="built_in">move</span>(uniqueName), w, h, flags,</span><br><span class="line">                                            std::<span class="built_in">move</span>(metadata), format, handle, gbp, &amp;layer);</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Surface的操作"><a href="#Surface的操作" class="headerlink" title="Surface的操作"></a>Surface的操作</h2><h3 id="Surface操作简介"><a href="#Surface操作简介" class="headerlink" title="Surface操作简介"></a>Surface操作简介</h3><p>Surface对象后怎么就能拿到帧缓冲区的操作接口呢？我们来看Surface的实现：<br>Surface.java (frameworks\base\core\java\android\view)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">nativeLockCanvas</span><span class="params">(<span class="keyword">long</span> nativeObject, Canvas canvas, Rect dirty)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> OutOfResourcesException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(<span class="keyword">long</span> nativeObject, Canvas canvas)</span></span>;</span><br><span class="line">    ......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nativeLockCanvas这个方法对应的是出队dequeueBuffer，从队列中取到Buffer也就是画布；<br>nativeUnlockCanvasAndPost这个方法对应的是入队queueBuffer，将buffer提交到队列中去；</p>
<h3 id="对画布操作"><a href="#对画布操作" class="headerlink" title="对画布操作"></a>对画布操作</h3><p>当我们接收到同步信号的时候会调用ViewRootImpl的performTraversals，最后会调用到drawSoftware，在这个函数中会拿到画布然后分发draw事件，之后的内容就是WMS第一堂课中10.1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">boolean</span> scalingRequired, Rect dirty, Rect surfaceInsets)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//拿到画布</span></span><br><span class="line"> canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//mView是DecorView向下分发事件</span></span><br><span class="line">    mView.draw(canvas);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在View的onDraw方法中，会将界面信息转化为RenderNode，类似于Html的Element。<br>View.java (frameworks\base\core\java\android\view)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">     <span class="keyword">final</span> RecordingCanvas canvas = renderNode.beginRecording(width, height);<span class="comment">//这里开始displaylist的record</span></span><br><span class="line">     ......</span><br><span class="line">     draw(canvas);</span><br><span class="line">     ......</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的RecordingCanvas就是扮演一个绘图指令的记录员角色，它会将这个View通过draw函数绘制的指令以displaylist形式记录下来。<br>在Android的设计里View会对应一个RenderNode, RenderNode里的一个重要数据结构是DisplayList, 每个DisplayList都会包含一系列DisplayListData.  这些DisplayList也会同样以树形结构组织在一起。<br>当UI线程完成它的绘制工作后，它工作的产物是一堆DisplayListData, 我们可以将其理解为是一堆绘图指令的集合，每一个DisplayListData都是在描绘这个View长什么样子，所以一个View树也可能理解为它的样子由对应的DisplayListData构成的树来描述：<br><img src="/images/android_wms_surface_handle.webp" alt="wms_surface_handle"><br>我们再来看下DisplayListData是长什么样子，它定义在下面这个文件中：<br>RecordingCanvas.h (frameworks\base\libs\hwui)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayListData</span> <span class="keyword">final</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawPath</span><span class="params">(<span class="keyword">const</span> SkPath&amp;, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(<span class="keyword">const</span> SkRect&amp;, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawRegion</span><span class="params">(<span class="keyword">const</span> SkRegion&amp;, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawOval</span><span class="params">(<span class="keyword">const</span> SkRect&amp;, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drawArc</span><span class="params">(<span class="keyword">const</span> SkRect&amp;, SkScalar, SkScalar, <span class="keyword">bool</span>, <span class="keyword">const</span> SkPaint&amp;)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">push</span><span class="params">(<span class="keyword">size_t</span>, Args&amp;&amp;...)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    SkAutoTMalloc&lt;<span class="keyword">uint8_t</span>&gt; fBytes;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的组成大体可以看成三个部分，第一部分是一堆以draw打头的函数，它们是最基本的绘图指令，比如画一条线， 画一个矩形，画一段圆弧等等，上面我们摘取了其中几个,后面我们将以drawRect为例来看它是如何工作的； 第二部分是一个push模版函数，后面我们会看到它的作用； 第三个是一块存储区fBytes，它会根据需要放大存储区的大小。<br>通过上面的了解，我们知道了UI线程并没有将应用设计的View转换成像素点数据，而是将每个View的绘图指令存入了内存中，我们通常称这些绘图指令为DisplayList, 下面让我们跳出这些细节，再次回到宏观一些的角度。</p>
<h3 id="提交画布内容"><a href="#提交画布内容" class="headerlink" title="提交画布内容"></a>提交画布内容</h3><p>当所有的View的displaylist建立完成后，代码会来到：<br>RenderProxy.cpp (frameworks\base\libs\hwui\renderthread)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenderProxy::syncAndDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.<span class="built_in">drawFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DrawFrameTask.cpp (frameworks\base\libs\hwui\renderthread)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::postAndWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>().<span class="built_in">post</span>([<span class="keyword">this</span>]() &#123; <span class="built_in">run</span>(); &#125;);<span class="comment">//丢任务到RenderThread线程</span></span><br><span class="line">    mSignal.<span class="built_in">wait</span>(mLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边可以看到UI线程的工作到此结束，它丢了一个叫DrawFrameTask的任务到RenderThread线程中去，之后画面绘制的工作转移到RenderThread中来：<br>DrawFrameTask.cpp (frameworks\base\libs\hwui\renderthread)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    context-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CanvasContext.cpp (frameworks\base\libs\hwui\renderthread)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">void CanvasContext::draw() &#123;</span><br><span class="line">    ......</span><br><span class="line">    Frame frame = mRenderPipeline-&gt;getFrame();<span class="comment">//这句会调用到Surface的dequeueBuffer</span></span><br><span class="line">    ......</span><br><span class="line">     <span class="built_in">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,</span><br><span class="line">                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,</span><br><span class="line">                                      &amp;(profiler()));</span><br><span class="line">    ......</span><br><span class="line">    waitOnFences();</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">bool</span> didSwap =</span><br><span class="line">            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);<span class="comment">//这句会调用到Surface的queueBuffer</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数中完成了三个重要的动作，一个是通过getFrame调到了Surface的dequeueBuffer向SurfaceFlinger申请了画布， 第二是通过mRenderPipeline-&gt;draw将画面画到申请到的画布上， 第三是通过调mRenderPipeline-&gt;swapBuffers把画布提交到SurfaceFlinger去显示。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>WMS</tag>
      </tags>
  </entry>
  <entry>
    <title>NDK开发之CMake</title>
    <url>/2018/11/07/ffmpeg_cmake/</url>
    <content><![CDATA[<p>CMake是一个跨平台的构建工具，可以用简单的语句来描述所有平台的安装(编译过程)。 能够输出各种各样的makefile或者project文件。CMake并不直接构建出最终的软件， 而是产生其他工具的脚本(如makefile)，然后再依据这个工具的构建方式使用。</p>
<span id="more"></span>

<p>CMake是一个比make更高级的编译配置工具，它可以根据不同的平台、不同的编译器， 生成相应的makefile或vcproj项目，从而达到跨平台的目的。</p>
<p>Android Studio利用CMake生成的是ninja。ninja是一个小型的关注速度的构建系统。 我们不需要关心ninja的脚本，知道怎么配置CMake就可以了。</p>
<p>CMake其实是一个跨平台的支持产出各种不同的构建脚本的一个工具。</p>
<p>在Android Studio 2.2及以上，构建原生库的默认工具是CMake. 在项目中会存在一个CMakeLists.txt文件。</p>
<h1 id="配置项释义"><a href="#配置项释义" class="headerlink" title="配置项释义"></a>配置项释义</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最低支持的版本，注意：这里并不能代表最终的版本，最终版本在app.build.gradle中设置的</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3</span>.x.x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前工程名，以前的旧版本，是没有设置的，这个可以设置，也可以不设置</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;ndk_cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量导入 cpp c源文件</span></span><br><span class="line"><span class="comment"># file 可以定义一个变量 SOURCE， GLOB（使用GLOB从源树中收集源文件列表，就可以开心的 *.cpp *.c *.h）</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SOURCE *.cpp *.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个库（动态库SHARED，静态库STATIC）</span></span><br><span class="line"><span class="keyword">add_library</span>(native-lib <span class="comment"># 库的名字 ---&gt; libnative-lib.so</span></span><br><span class="line">             SHARED  <span class="comment"># 动态库</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># cpp的源文件：把cpp源文件编译成 libnative-lib.so 库</span></span><br><span class="line">             <span class="variable">$&#123;SOURCE&#125;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找一个 NDK工具中的 动态库(liblog.so)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径：D:\Android\Sdk\ndk\21.0.6113669\toolchains\llvm\prebuilt\windows-x86_64\sysroot\usr\lib\arm-linux-androideabi\16\liblog.so</span></span><br><span class="line"><span class="comment"># -1(因为local.properties知道了NDK版本，或者是你当前的NDK版本)</span></span><br><span class="line"><span class="comment"># -2(因为我的手机是arm32的 所以 == arm-linux-androideabi 而且还我运行过)</span></span><br><span class="line"><span class="comment"># -3(因为 minSdkVersion 16)</span></span><br><span class="line"><span class="keyword">find_library</span>(log-lib</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"><span class="comment"># native-lib是我们的总库，也就是我们在 apk/lib/libnative-lib.so</span></span><br><span class="line"><span class="comment"># 然后 把log库链接到 总库中去，总库的cpp代码就可以使用 android/log.h的库实现代码了</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(native-lib <span class="comment"># 被链接的总库</span></span><br><span class="line">                       <span class="variable">$&#123;log-lib&#125;</span> <span class="comment"># 链接的具体库</span></span><br><span class="line"></span><br><span class="line">                     <span class="comment"># getndk</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># log 信息输出的查看</span></span><br><span class="line"><span class="comment"># 以前的Cmake版本都是在output.txt, 现在最新版本Cmake在metadata_generation_stderr.txt或cmake_server_log</span></span><br><span class="line"><span class="comment"># 想及时更新你的日志，请安装一次即可 or Linked_C++_Projects</span></span><br><span class="line"><span class="comment"># 在Build也可以查看，注意：是点击Sync Now 才会看到</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># (无) = 重要消息；</span></span><br><span class="line"><span class="comment"># STATUS = 非重要消息；</span></span><br><span class="line"><span class="comment"># WARNING = CMake 警告, 会继续执行；</span></span><br><span class="line"><span class="comment"># AUTHOR_WARNING = CMake 警告 (dev), 会继续执行；</span></span><br><span class="line"><span class="comment"># SEND_ERROR = CMake 错误, 继续执行，但是会跳过生成的步骤；</span></span><br><span class="line"><span class="comment"># FATAL_ERROR = CMake 错误, 终止所有处理过程；</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Message1&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Message2&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Message3&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;10 OldCmakeVersion:output.txt, NewCmakeVersion:cmake_server_log.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO CMake变量</span></span><br><span class="line"><span class="comment"># 声明变量：set(变量名 变量值)</span></span><br><span class="line"><span class="keyword">set</span>(var <span class="number">666</span>)</span><br><span class="line"><span class="comment"># 引用变量：message 命令用来打印</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;var = $&#123;var&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># CMake中所有变量都是string类型。可以使用set()和unset()命令来声明或移除一个变量</span></span><br><span class="line"><span class="comment"># 移除变量</span></span><br><span class="line"><span class="keyword">unset</span>(var)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;my_var = $&#123;var&#125;&quot;</span>) <span class="comment"># 会取不到值，因为被移除了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO CMake列表（lists）</span></span><br><span class="line"><span class="comment"># 声明列表：set(列表名 值1 值2 ... 值N) 或 set(列表名 &quot;值1;值2;...;值N&quot;)</span></span><br><span class="line"><span class="keyword">set</span>(list_var <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>) <span class="comment"># 字符串列表呢？ CMake中所有变量都是string类型</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">set</span>(list_var2 <span class="string">&quot;1;2;3;4;5&quot;</span>) <span class="comment"># 字符串列表呢？  CMake中所有变量都是string类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;list_var = $&#123;list_var&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;list_var2 = $&#123;list_var2&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO CMake流程控制-条件命令</span></span><br><span class="line"><span class="comment"># true(1，ON，YES，TRUE，Y，非0的值)</span></span><br><span class="line"><span class="comment"># false(0，OFF，NO，FALSE，N，IGNORE，NOTFOUND)</span></span><br><span class="line"><span class="keyword">set</span>(if_tap <span class="keyword">OFF</span>) <span class="comment"># 定义一个变量if_tap，值为false</span></span><br><span class="line"><span class="keyword">set</span>(elseif_tap <span class="keyword">ON</span>) <span class="comment"># 定义一个变量elseif_tap，值为ture</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;if_tap&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;if&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$&#123;elseif_tap&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;elseif&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>(<span class="variable">$&#123;if_tap&#125;</span>) <span class="comment"># 可以不加入 $&#123;if_tap&#125;</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;else&quot;</span>)</span><br><span class="line"><span class="comment"># endif($&#123;if_tap&#125;) # 结束if</span></span><br><span class="line"><span class="keyword">endif</span>() <span class="comment"># 结束if 可以不加</span></span><br><span class="line"><span class="comment"># 注意：elseif和else部分是可选的，也可以有多个elseif部分，缩进和空格对语句解析没有影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO CMake流程控制-循环命令</span></span><br><span class="line"><span class="keyword">set</span>(a <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">#  a STREQUAL &quot;xxx&quot;（a等不等xxx，不等于）</span></span><br><span class="line"><span class="comment">#  NOT == !</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">NOT</span> a <span class="keyword">STREQUAL</span> <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(a <span class="string">&quot;$&#123;a&#125;x&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;a = $&#123;a&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br><span class="line"><span class="comment">#[[ 注意：</span></span><br><span class="line"><span class="keyword">break</span>()命令可以跳出整个循环</span><br><span class="line"><span class="keyword">continue</span>()可以继续当前循环</span><br><span class="line">]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;1item = $&#123;item&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>(item) <span class="comment"># 结束for</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">2</span>) <span class="comment"># RANGE 默认从0开始， 所以是：0 1 2</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;2item = $&#123;item&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(item RANGE <span class="number">1</span> <span class="number">6</span> <span class="number">2</span>) <span class="comment">#  1 3 5 每次跳级2</span></span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;3item = $&#123;item&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(list_va3 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="comment"># 列表</span></span><br><span class="line"><span class="comment"># foreach(item IN LISTS $&#123;list_va3&#125;) 没有报错，没有循环</span></span><br><span class="line"><span class="keyword">foreach</span>(item IN LISTS list_va3)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;4item = $&#123;item&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># TODO CMake自定义函数  Shell的函数很类似</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ARGC：表示传入参数的个数</span></span><br><span class="line"><span class="comment"># ARGV0：表示第一个参数，ARGV1、ARGV2以此类推即可</span></span><br><span class="line"><span class="comment"># ARGV：表示所有参数</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">function</span>(num_method n1 n2 n3)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;call num_method method&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;n1 = $&#123;n1&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;n2 = $&#123;n2&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;n3 = $&#123;n3&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;ARGC = $&#123;ARGC&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;arg1 = $&#123;ARGV0&#125; arg2 = $&#123;ARGV1&#125; arg3 = $&#123;ARGV2&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;all args = $&#123;ARGV&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>(num_method)</span><br><span class="line">num_method(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="comment"># 调用num_method函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态库和动态库本质</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>NDK</tag>
        <tag>JNI</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>汽车SOA架构设计浅析</title>
    <url>/2021/07/02/car_soa_introduction/</url>
    <content><![CDATA[<p>SOA（面向服务的架构）可以理解为一种架构设计方法，它是将一个系统所具有的能力抽象成可调用的并具有标准接口的服务，从而可以通过调用服务或者调用多个服务的组合来满足系统的业务需求。</p>
<span id="more"></span>

<p>SOA并不是某一种具体的技术实现，而是一种系统架构的设计思想。SOA的提出是为了解决随着面临的问题越来越复杂，软件系统变得难以维护、难以扩展、容易出错等问题。</p>
<p>SOA也是一种软件架构设计方案，它用以组织和运用分散在系统不同部分的能力(capabilities)。能力与运用能力，概念上有所差别。需求与能力可以独立于 SOA 而存在。</p>
<p>在SOA架构中，服务是更高效地利用现有能力满足需求的一种手段，这也是SOA的意义。</p>
<h1 id="为什么汽车上要应用SOA"><a href="#为什么汽车上要应用SOA" class="headerlink" title="为什么汽车上要应用SOA"></a>为什么汽车上要应用SOA</h1><p>SOA在IT领域已经存在很久，究竟是什么原因促使SOA应用在汽车上呢？</p>
<p>对于任何一个系统来说，外部对系统的“需求”和系统本身具备的“能力”是决定如何设计系统的2个最关键的因素。</p>
<p>能力越强则可以满足更多的需求，但能力越强也意味着需要耗费更多的资源。资源从来都是有限和稀缺的，但需求却不断地增加和快速地变化。有限的资源和能力与无限的需求之间的矛盾是系统设计面临的最大挑战。</p>
<p>对于任何一个盈利性组织来讲，在设计开发汽车电气系统时，如何用相同的能力满足更多的需求，如何用更少的能力满足相同的需求，如何用现有的能力更快速地、更好地满足不断增长的复杂多变的需求，这是促使SOA设计思想和设计方法应用在汽车上的最本质原因。</p>
<h1 id="如何实现SOA"><a href="#如何实现SOA" class="headerlink" title="如何实现SOA"></a>如何实现SOA</h1><h2 id="汽车EEA的发展使SOA具备了初步的应用条件"><a href="#汽车EEA的发展使SOA具备了初步的应用条件" class="headerlink" title="汽车EEA的发展使SOA具备了初步的应用条件"></a>汽车EEA的发展使SOA具备了初步的应用条件</h2><p>汽车EEA从分布式逐步向集中式发展。从整车厂的角度，这种趋势背后的最大驱动力也是为了更好地解决能力与需求的结合和匹配问题。</p>
<p>所谓分布式EEA，可以理解为汽车电气系统的软硬件资源和能力是分散的，分散在不同的供应商手中。ECU的软硬件开发全部由供应商完成，整车厂主要负责提出设计需求和测试验证。</p>
<p>分布式EEA导致的ECU软硬件资源和能力的浪费是显而易见的。不同的供应商负责不同的ECU开发，整车数十个ECU分别负责实现特定的软硬件功能，然后通过硬线信号或者网络信号进行交互，这种信息交互方式也被称为面向信号的通信。</p>
<p>受限于研发周期、项目资源、技术发展（芯片算力、操作系统、软件架构等）、供应商能力以及整车厂能力等众多因素，由分布式EEA走向集中式EEA必然是一个渐进的过程，一般会经历以下几个阶段：</p>
<ul>
<li><p>在局部子系统做一些简单的物理集成。例如，在三电系统，将DCDC和OBC整合为一个ECU，外壳和接插件可以共用（资源的利用率得到提升），但内部还是两个独立的控制器，分别具有各自的PCB和软硬件资源。</p>
</li>
<li><p>在局部子系统做一些功能集成。例如，在车身控制系统，将BCM、PEPS、TPMS实现的功能通过一个ECU来实现。外壳、接插件、PCB可以共用，软硬件资源也可以部分共享，相对于物理集成，功能集成进一步提高了资源的利用率。</p>
</li>
<li><p>将某个功能域的大部分或全部功能通过域控制单元进行集中控制。比较典型的功能域划分方式将整车分为5个域：动力域、底盘域、车身控制域、智能座舱域和智能驾驶域（包括ADAS和AD）。</p>
</li>
<li><p>功能域的进一步融合，整车由几个核心计算单元进行集中控制。例如，特斯拉的整车电气系统主要由autopilot+MCU(智能驾驶+多媒体)、左车身控制和右车身控制三个核心计算单元进行集中控制。华为的智能驾驶、智能座舱和整车控制器三个核心计算单元。</p>
</li>
<li><p>终极EEA形态：整车电气系统由一个中央计算单元进行集中控制。</p>
</li>
</ul>
<p><img src="/images/car_soa_introduction01.png" alt="image"></p>
<p>目前大部分整车厂量产车型的EEA处于第1和第2个阶段，少部分处于第3阶段或第4阶段。前2个阶段从本质上讲还是处于分布式EEA阶段，因为无论是物理集成还是功能集成，都仅仅是在局部功能实现上减少ECU的数量，实现功能所需的软硬件资源还是以ECU为核心进行设计。</p>
<p>从第3阶段开始，EEA才算是进入了集中式控制阶段。分布式与集中式控制的本质区别在于，分布式阶段的整车功能是围绕一个个ECU作为主体进行设计的，而集中式阶段则需要从子系统甚至整车的软硬件资源所具备的不同能力的角度，对功能实现进行分层设计，核心思想是不同的层面具备不同的能力，其主要目的是软硬件资源和能力的解耦。</p>
<p>可以粗略地将整车软硬件资源所具备的能力分为3类：计算能力、通用控制能力和感知执行能力，并将这3种能力分别对应到计算层、通用控制层和感知执行层。</p>
<p>在第3阶段，将某个功能域的计算能力集中到DCU（域控制单元）中，通用控制和感知执行能力由各个功能域中的下层ECU实现。</p>
<p>在第4和第5阶段，将整车的计算能力集中到几个核心计算单元或者唯一的中央计算单元中。通用控制能力则分布在整车不同区域的ZCU（区域控制单元）中，从某个区域的范围看，通用控制能力则集中在特定区域的某个ZCU中。感知执行能力只有特定类型的传感器和执行器才具备，只能分布于整车各个传感器和执行器中。</p>
<p>在SOA架构中，服务是更高效地利用现有能力满足需求的一种手段，而汽车电气系统的所具备的最基础的能力是由所具备的传感器和执行器的类型和数量决定的，也可以理解为由最底层的硬件资源所决定的，因此在汽车上应用SOA的一个重要前提是实现业务需求与硬件资源的解耦。</p>
<p>当EEA发展到第3阶段时，即引入DCU集中控制某个功能域时，汽车上开始具备了实现SOA的条件。</p>
<p>DCU的芯片算力、操作系统以及软件架构可以满足业务需求与硬件资源解耦的需求，即有能力通过一套基础软件框架去实现SOA的设计思想，从而将底层的硬件资源具备的能力抽象为一种服务供外部使用，并能够支持一系列的服务管理功能（服务定位、服务发现，服务调用等）。此外，DCU必须支持基于IP协议的车载以太网通信，因为目前支持SOA的主流中间件，例如，SOME/IP等，都是基于IP协议通信的。</p>
<h2 id="多项关键技术共同促进SOA在汽车上的应用"><a href="#多项关键技术共同促进SOA在汽车上的应用" class="headerlink" title="多项关键技术共同促进SOA在汽车上的应用"></a>多项关键技术共同促进SOA在汽车上的应用</h2><h3 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h3><p>在分布式EEA阶段，各个ECU只连接特定的传感器和执行器，ECU的主要工作是提供I/O资源和网络接口，并进行实时控制。即使ECU需要运行操作系统，一般也是短小精悍的实时操作系统。在这个阶段，ECU并不需要特别强大的算力和巨大的存储空间，使用普通的车规级MCU芯片即可满足需求。</p>
<p>当EEA发展到第3阶段时开始使用DCU对某一个功能域进行集中控制，也是从这个阶段开始，DCU对于芯片算力的需求有了大幅度的提升。</p>
<p>以娱乐功能为例，最早就是简单的收音机或者CD播放器，并且都是实体按键操作。后来用触摸液晶屏进行HMI显示和操作，同时功能不断增加（视频播放、蓝牙音乐及电话、导航、语音控制、倒车影像等），这使得对娱乐主机MCU的数据处理能力和软硬件资源调度能力的要求不断提高，不仅MCU提高到32位，还增加了GPU进行图像处理及运行类似于android这样的非实时性嵌入式操作系统，以便有效分配系统资源，对各种任务调度管理。</p>
<p>等发展到了信息娱乐功能由智能座舱DCU集中控制阶段，除了以上娱乐功能之外，DCU还将组合仪表、HUD、氛围灯控制、DMS（驾驶员监测系统）、行车视频记录等功能进行集中控制。此外，智能网联汽车还需要与外界进行海量的数据交互。</p>
<p>智能座舱DCU要求芯片的数据运算和处理能力进一步提升，并且需要多核异构的系统级芯片SOC来满足不同类型的控制和计算需求。在算力增加的同时，车规级芯片在功耗、安全和成本方面比消费电子要求更高。</p>
<p>综上所述，强大的车规级芯片是实现SOA的底层硬件基础。</p>
<h3 id="操作系统（OS）"><a href="#操作系统（OS）" class="headerlink" title="操作系统（OS）"></a>操作系统（OS）</h3><p>强大的芯片构成了实现SOA的底层硬件基础，但软件技术同样很重要。先从离硬件最近的系统软件-OS开始介绍。</p>
<p>在最初的分布式EEA阶段，很多ECU的功能简单，不需要OS。随着ECU功能的增加以及与外部交互接口越来越复杂，需要OS来协调管理硬件资源及进行任务调度。</p>
<p>汽车不同功能对OS特性的要求也不同。例如，动力域和底盘域功能直接参与车辆的行驶控制，对系统控制的实时性、可靠性和安全性要求非常高，一般使用CP AUTOSAR OS（兼容OSEK OS）。又例如，对于娱乐功能，更注重OS对于应用程序的兼容性和应用生态的丰富性，对于实时性和可靠性要求可适当降低，因此，android这类OS越来越受欢迎。</p>
<p>到了域控制阶段，例如，在智能座舱DCU中，由于娱乐与仪表的功能安全等级不同，需要使用不同安全等级的OS，为此在DCU中引入了虚拟机管理技术(例如，AUTOSAR Hypervisor)。在虚拟机上可以同时运行两个或多个不同的OS，例如，娱乐功能使用Android，仪表功能使用QNX。</p>
<p>感知执行层、通用控制层及计算层，不同层的能力要求不同，采用的OS也不同。一般来讲，感知执行层的ECU和通用控制层的ZCU不需要OS或采用实时性OS，确保对计算层下发的指令进行快速响应，对执行器进行实时控制。计算层的CCU硬件一般采用多核异构系统芯片（SOC），满足复杂的运算和大量的数据处理需求。CCU需要通过虚拟机技术运行多个不同类型的OS，因为不同的业务需求所适用的OS不同。例如，关键安全功能运行CP AUTOSAR OS，娱乐功能运行Linux或Android等。</p>
<h3 id="AUTOSAR"><a href="#AUTOSAR" class="headerlink" title="AUTOSAR"></a>AUTOSAR</h3><p>在介绍了芯片和OS之后，接下来以AUTOSAR为例，介绍SOA的软件架构如何设计。</p>
<p>AUTOSAR的设计理念和思路都着眼于汽车系统的基本软件要求，并努力做到向前和向后的系统兼容性。AUTOSAR将SOA设计融入到了它的方法论中，对最终的软件产品提供了标准化的服务设计和实现方式。当然，SOA的实现方式可以多种多样，AUTOSAR只是其中一种可选的方式，它是否能成为最适合SOA的软件架构还需要时间的检验，但仅从当前来看，AUTOSAR是相对完整并具备可操作性的SOA软件架构解决方案。</p>
<p>AUTOSAR分为Classic AUTOSAR(CP）和Adaptive AUTOSAR(AP)。AP是在CP的基础上发展而来。CP一般应用于对实时性、安全性和可靠性要求高的嵌入式ECU，AP一般应用于需要高算力的多核异构中央计算单元（CCU）。</p>
<p><img src="/images/car_soa_introduction02.png" alt="图1 CP AUTOSAR"></p>
<p><img src="/images/car_soa_introduction03.png" alt="图2 AP AUTOSAR"></p>
<p>CP的通信协议基于在系统运行前的静态预配置的基于信号的规范，而AP基于面向服务的通信，允许动态启动通信。即在CP中，运行时的服务必须在编译时处理确定的，而AP支持运行时服务的动态注册。AP支持的应用程序动态调度策略，它允许在运行时动态部署应用程序。</p>
<p>SOA的软件架构设计离不开服务模型的设计。针对服务组件，SOA定义了服务组件的架构模型SCA（SCA，Service Component Architecture），模型中的主要元素分为“服务接口”和“服务实现”两大类。</p>
<p>表1 AP的SCA模型描述</p>
<p><img src="/images/car_soa_introduction04.png" alt="image"></p>
<p>AP采用经典的代理(Proxy)-框架(Skeleton)模式来完成SCA模型的描述。这种模式将直接交互的客户端(Client)和服务端(Server)分离，由代理负责传递信息来完成服务调用，客户端和服务端不需要处理通信层详细信息。</p>
<p>服务组件由服务单元提供的“业务逻辑”和适配目标系统环境相关的“基础设施逻辑”两部分组成。在开发过程中，这两部分是解耦的，可同时进行的，且软件形态是灵活的。</p>
<p>服务单元的逻辑可以是源码或被封装为SDK形式，且不关心具体的编程语言；基础设施逻辑 (Interface和Message) 则以C++的形态编码，与服务管理中间件一起确保服务的动态响应性和服务自身的可扩展性，其软件形态同样可以是源码或SDK形式提供。</p>
<p>在流程上方法论上，”实现和部署”工作主要分为服务组件接口设计，服务组件集成实现和安装部署3个步骤：</p>
<blockquote>
<p><strong>1、组件接口设计阶段:</strong> 编写arxml完成对服务组件SCA中“基础设施逻辑”的配置开发，并经由AP中间件供应商提供的代码框架和生成器(Generator)，最终得到相关的配置文件(.json)和源代码(.cc/.cpp)；对“服务单元逻辑”，可同步基于建模工具进行开发；</p>
</blockquote>
<blockquote>
<p><strong>2、组件集成实现阶段:</strong> 编写APP框架，完成“服务单元逻辑”与“基础设施逻辑”的软件集成工作；</p>
</blockquote>
<blockquote>
<p><strong>3、组件安装部署阶段:</strong> 编写编译和安装脚本，完成源码的编译链接和可执行文件(App)的安装，同时，对APP安装部署权限和系统环境做适配调整。</p>
</blockquote>
<p>表2 服务组件的设计和部署</p>
<p><img src="/images/car_soa_introduction05.png" alt="image"></p>
<p><strong>SOME/IP:</strong></p>
<p>SOME/IP (Scalable Service-Oriented MiddlewarE Over IP) ，即“运行于IP之上的可伸缩的面向服务的中间件”。“中间件”是一种独立的系统软件或服务程序，SOA软件架构中的“服务”可借助中间件在不同的软件平台或操作系统之间共享资源。</p>
<p>SOME/IP属于应用层协议，它提供面向服务的通讯接口。SOME/IP定义的服务接口包含方法（Methods），事件（Events），字段（Fields）和事件组（Eventgroups），可以支持请求/响应模式的远程服务调用，也可以支持订阅/发布模式的消息通知。</p>
<p><img src="/images/car_soa_introduction06.png" alt="图3 车载以太网协议"></p>
<p>服务是SOME/IP的最核心概念，在一个服务中，定义了服务端（Server）和客户端（Client）两个角色：服务端提供服务，客户端调用服务。对于同一个服务，只能存在一个服务端，但可以同时存在多个客户端调用服务，一个服务由Method/EventField组成。</p>
<p>SOME/IP的访问方式分为事件通知（Notification）、远程过程调用（Remote Procedure Call，RPC）和访问进程数据（Getter、Setter）3种。事件通知与传统CAN通信消息类似，服务端周期性或者事件变化时向客户端发送特定消息。远程过程调用是当客户端有请求的时候，向服务端发送一个请求消息，服务端根据情况返回响应。访问进程数据可以使客户向服务器端写入（Setter）或者读取（Getter）数据。</p>
<p>SOME/IP数据包括2部分，分别是Header和Data。在传输的过程中可以通过TCP和UDP两种通信数据协议进行传输。SOME/IP定义的通信方式主要包括4类：</p>
<ul>
<li><p><strong>1. Method:</strong> 包含了请求后有应答的Method，和请求后没有应答的Method（Fire&amp;Forget）。</p>
</li>
<li><p><strong>2.  Event：</strong>当某种事情发生后，服务端向客户端发送的报文。</p>
</li>
<li><p><strong>3.  Field：</strong>Get/Set/Notifier某种属性或者状态。</p>
</li>
<li><p><strong>4.  EventGroup：</strong>用来进行publish/subscribe处理Eventsand Fields的通信的逻辑组。</p>
</li>
</ul>
<p>SOME/IP定义了其服务发现协议SOME/IP-SD，用于动态发现服务的提供者地址以及检查服务状态是否健康。SOME/IP-SD的报文通过UDP发送，每个设备通过在局域网中周期性地广播一条包含其提供的所有服务的OfferService报文来帮助其他设备完成服务发现（服务IP，端口等信息）。服务调用者也可以通过广播一条FindService消息来主动查询自己需要的服务。</p>
<p>SOME/IP中与数据通信相关的一些术语定义如下：</p>
<ul>
<li><p><strong>1. Request/Response：</strong>客户端向服务端请求特定的报文，然后服务端将相应的数据报文返回给客户端。</p>
</li>
<li><p><strong>2. Fire&amp;Forget：</strong>客户端调用服务端Method的报文，通过请求完成Method远程调用；</p>
</li>
<li><p><strong>3. Notification：</strong>对应Event接口类型，类似CAN报文，在特定的事件触发下，服务端会发给客户端一个notification报文主要包括Cyclic事件、数据Changed等；</p>
</li>
<li><p><strong>4. Publish/Subscribe：</strong>主要用于SOME/IP的SD（服务发现），客户端首先订阅相关的服务，只有订阅成功后，才允许进行Notification通信。</p>
</li>
<li><p><strong>5. Field：</strong>一个可被远程访问的属性。主要包含三种类型的数据通信Getter、Setter和Notifier。其中Getter读取属性值，请求报文的payload为空，响应报文中含有当前属性值；Setter设置属性值，将预设值置于请求报文的payload中，属性的设置结果放于响应报文中，Notifier类似于Event，Notifier在订阅完成后，会立即发送Initial Event，通知当前值。</p>
</li>
</ul>
<p>强大的车规级芯片是实现SOA软件架构的底层硬件基础。</p>
<p>操作系统是离底层硬件最近的系统软件， 它负责为应用软件协调管理硬件资源并进行多任务的切换和调度。</p>
<p>AUTOSAR本质上是一种软件设计的方法论，它为具体如何实现SOA的软件架构提供了标准化的服务设计和实现方式。例如，AUTOSAR定义了为了运行AP的应用程序，操作系统需要具备POSIX标准库接口，操作系统应通过在启动和运行时的动态调度和通信路径的动态配置来支持应用程序的动态行为。</p>
<p>SOME/IP是一种中间层协议，是实现SOA的面向服务通信的一种具体的技术实现方式。AUTOSAR将SOME/IP也融入到了它的方法论中，例如，规定CP只能支持SOME/IP协议，而AP可以运行SOME/IP，也支持HTTP协议，AP后续还会增加其他协议。CP仅支持静态SOME/IP服务交互机制，而AP可以支持静态和动态SOME/IP服务交互机制。SOME/IP在AUTOSAR中的实现主要包括与SD相关的配置和数据通信协议相关模块的配置。</p>
<p>正如SOA的软件架构实现方式不是唯一的（AUTOSAR只是其中一种可选的方式），SOA软件架构下的通信协议也是多元化的，任何基于服务机制的协议均可以认为是SOA通信协议。在汽车上，应用比较广泛的主要是SOME/IP、HTTP、MQTT协议，其中SOME/IP满足车规要求，用于车内节点之间的服务通信，而HTTP和MQTT承接于互联网，多运用于无线网络，以便于车内节点和云端交互，但也可以用于车内有线以太网。</p>
<h1 id="技术是手段，不是目的"><a href="#技术是手段，不是目的" class="headerlink" title="技术是手段，不是目的"></a>技术是手段，不是目的</h1><p>在汽车产业重构期，诸多的新技术不断涌现，整车厂的核心能力到底是什么？</p>
<p>不管是对于企业还是个人，能力和资源都是有限的，必须集中有限的资源做自己应该做的事。</p>
<p>整车厂之所以为整车厂，就是因为它必须对最终生产出来的车辆负责，它必须对客户的用车体验负责。在软件定义汽车的时代，不断提升客户的用车体验也是整车厂的生存之本。</p>
<p>SOA只是诸多应用在汽车上的新技术之一，整车厂的核心能力应该是掌握有效应用这些新技术的集成能力，而有效应用新技术必须以深入理解目标客户的用车需求为前提，其最终的目的就是提升客户的用车体验。</p>
<p>对于SOA在汽车上的应用而言，服务设计才是整车厂的核心能力，因为车辆能够提供服务的好坏决定了用户体验，并且服务设计必须针对目标客户的用车需求来完成。</p>
<p>这篇文章从服务设计的角度介绍SOA。</p>
<p>智能汽车的本质属性并不是功能的多少，因为功能再多也只是一个静态的概念。静态意味着一旦功能设计完成，汽车能够完成的任务是固定的。</p>
<p>一个功能的实现可以分为输入、处理逻辑和输出三个部分。功能设计完成后，它只能根据特定的输入、特定的处理逻辑和特定的输出控制来完成固定的任务，也可以理解为向客户提供特定的用车服务，满足客户的用车需求。</p>
<p>为什么是SOA（面向服务的架构）而不是FOA（面向功能的架构）？服务和功能到底有什么区别和联系？</p>
<p>分析认为，服务和功能这两个概念从完成任务的实现方式（输入、处理逻辑、输出）来讲，并没有本质区别。</p>
<p>之所以使用服务这个概念，相对于传统的功能而言，主要是为了突出智能汽车在完成各种任务时所体现的灵活性、主动性以及预测性，也是就可以根据不同用车场景动态地调整完成任务的方式。</p>
<p>汽车是由各种配置（偏重于硬件）和服务（偏重于软件）组成的。配置的高低决定了车辆的下限，而服务的好坏则决定了车辆的上限。</p>
<p>在特定的时间和空间中，当一个或多个事件发生时，对于车辆而言就形成了我们通常所说的用车场景。</p>
<p>真正意义上的智能汽车是能够更有效地识别用车场景甚至预测用车场景，并且主动通过各种服务来满足客户用车需求的汽车。这里的核心词是“主动”，智能的本质就是具有自主性甚至预测性，并且这种“自主性”和“预测性”的能力也能够在不断的自我进化中得到提升，越来越好地满足用车需求。</p>
<p>基于以上对于智能汽车所提供服务的理解，我们在设计SOA服务时可以将服务分为以下3类：</p>
<h2 id="场景感知类服务"><a href="#场景感知类服务" class="headerlink" title="场景感知类服务"></a>场景感知类服务</h2><p>这类服务主要用于用车场景的感知，即对时间、空间以及发生事件的感知。</p>
<p><strong>时间感知服务：</strong>例如，车辆通过4G网络获取时间信息；</p>
<p><strong>空间感知服务：</strong>例如，车辆通过GPS天线获取位置信息；</p>
<p><strong>事件感知类服务：</strong>例如，车辆上电感知，车辆换挡感知，环境温度感知、驾驶员表情感知、驾驶员视线感知；</p>
<p>场景感知服务主要是基于车辆硬件配置来实现的。</p>
<p>从服务与功能的关系来理解，场景感知类服务属于基础服务，可以等同于传统的感知类功能。</p>
<h2 id="控制决策类服务"><a href="#控制决策类服务" class="headerlink" title="控制决策类服务"></a>控制决策类服务</h2><p>这类服务是造就智能汽车的核心服务。它根据场景感知类服务以及用户操作所提供的各种输入，经过分析和计算，最终决定车辆应该以何种方式满足客户的用车需求。</p>
<p>既然智能汽车的本质属性是具有主动性和预测性，那么对于控制决策类服务而言，能多大程度地减少对于用户操作输入的依赖，能多大程度地充分利用场景感知类服务输入，并将各种输入通过强大的算力进行综合分析计算，完成最终的控制决策过程，这是判断控制决策类服务智能化程度高低的依据。</p>
<p>例如：</p>
<p>氛围灯的颜色可以根据用户心情自主调节。</p>
<p>用户吃饭的餐厅可以根据用户的口味、综合最新的餐厅优惠折扣活动自主推荐。</p>
<p>温度、湿度、空气质量可以根据用户身体状态、当前天气情况自主调节。</p>
<p>控制决策类服务依赖于算法和控制策略，并且这种算法和控制策略自身也可以不断进化，它主要是基于软件来实现。从服务与功能的关系来理解，控制决策类服务属于高级服务，它可以理解为一种具备自主性的高级功能，它可以灵活调用和组合基础服务完成不同的任务，满足不同场景的用车需求。</p>
<h2 id="动作执行类服务"><a href="#动作执行类服务" class="headerlink" title="动作执行类服务"></a>动作执行类服务</h2><p>这类服务主要是用于控制车辆执行各种动作，包括所有用户可以感知到的声音，文字、图像、电机动作等等。</p>
<p>动作执行类服务主要是基于整车硬件配置来实现的。从服务与功能的关系来理解，动作执行类服务也属于基础服务，可以等同于传统的动作执行类功能。</p>
<p>在之前的文章“SOA在汽车上的应用(1)-(3)”中，笔者介绍了SOA是什么，为什么要应用SOA、如何实现SOA以及如何设计SOA服务。</p>
<p>这篇文章继续介绍如何来设计SOA服务。</p>
<p>服务是更高效地利用车辆能力满足需求的一种手段，那么设计服务必然是从车辆所具有能力入手。</p>
<p>车辆电气功能的实现需要输入、处理、输出三个过程，它们对应车辆的三种能力：感知能力（提供信息输入），计算控制能力（对信息进行处理）、执行能力（实现输出的结果）。</p>
<p>笔者曾将车辆的软硬件资源所具备的能力分为3类：计算能力、通用控制能力和感知执行能力，并将这3种能力根据EEA发展的5个阶段，分别对应到计算层、通用控制层和感知执行层。</p>
<p><img src="/images/car_soa_introduction07.png" alt="image"></p>
<p>感知和执行能力取决于车辆具备的传感器和执行器硬件配置，它们是车辆最底层的能力，这些能力可以被抽象为SOA原子服务。</p>
<p>这里的“原子”有2个含义，1个是底层（对应集中式EEA的感知执行层）的意思，可以理解为最基础的服务；1个是不可再分的意思，即原子服务是最小颗粒度的服务，可以通过组合调用1个或多个原子服务形成高层级的（通用控制层和计算层）服务。</p>
<p>既然感知和执行能力是车辆的基础能力，在设计原子服务时，我们可以从传感器和执行器入手，分析所需要的原子服务。</p>
<p>例如，对于车身控制类服务，可以基于不同的执行器（电动车门、电动车窗、电动门锁等）设计原子服务，也可以基于不同的传感器（门状态开关、车窗位置传感器、门锁状态开关）设计原子服务。</p>
<p>这里需要注意，原子服务虽然是最底层和最小颗粒度的服务，但原子服务也是一种服务，设计服务的目的是为了满足实际的需求，而不是机械化地将原子服务等同于车辆最底层的感知和执行能力。</p>
<p>车辆的传感器和执行器数量庞大，且其类型、接口和参数也种类繁多。</p>
<p>例如，对于仅仅一个HVAC电气系统来说，传感器和执行器类型涉及温度传感器、压力传感器、湿度传感器、光线传感器、水泵电机、电动压缩机、PTC加热器、电磁阀、电子膨胀阀、冷却风扇、风门电机、鼓风机等；设备接口涉及数字输入、模拟输入、高端驱动、低端驱动、CAN、LIN等；设备参数涉及电压、电流、压力、温度、位置等；</p>
<p>如果将车辆所有电气系统的所有传感器和执行器抽象为原子服务，不仅使原子服务的数量过于庞大，而且从实际需求的角度也是没有必要的。</p>
<p>对于HVAC电气系统而言，我们需要从实际需求的角度，分析可能需要哪些原子服务。</p>
<p>例如，获取当前车内某个区域的温度值或者设定目标温度值、开启或关闭某个区域的自动温度控制、开启或关闭通风、获取当前风量大小，设置目标风量大小、获取当前吹风模式、设置吹风模式等等；</p>
<p>如果要实现SOA，则需要实现原子服务与车型平台的解耦，从而提升原子服务的复用性。不同车型平台的硬件设备与驱动程序不同，这需要包括操作系统在内的广义平台系统软件来实现软件与硬件设备的解耦，屏蔽硬件设备与驱动的差异，给原子服务提供统一的API。</p>
<p>因此，从软硬件解耦的角度去考虑，车辆所有的硬件设备有必要抽象为标准的接口。另一方面，原子服务可能根据需求进行增加，全面的硬件设备的API接口使原子服务的设计更加灵活。</p>
<p>SOA只是诸多应用在汽车上的新技术之一，整车厂的核心能力应该是掌握有效应用这些新技术的集成能力，而有效应用新技术必须以深入理解目标客户的用车需求为前提，其最终的目的就是提升客户的用车体验。</p>
<p>从这个角度来理解SOA的服务设计，整车厂可以参与原子服务的设计，但这并不是构建整车厂差异化竞争力的关键。</p>
<p>基于原子服务的组合，在不同的用车场景中构建个性化、智能化的应用，提升用车体验，这才是SOA服务设计的最终目的，也是整车厂需要掌握的核心能力。</p>
]]></content>
      <categories>
        <category>Android系统开发</category>
        <category>车联网</category>
      </categories>
      <tags>
        <tag>SOA</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg之音频播放</title>
    <url>/2018/12/18/ffmpeg_audio_play/</url>
    <content><![CDATA[<p>在之前篇中的解封装的最后，把音视频的压缩数据分别放入了视频和音频的队列中，上篇中展示了视频的播放流程，本篇展示音频的播放过程。</p>
<p>音频的播放主要是采用OpenSLES进行的。OpenSL ES 是无授权费、跨平台、针对嵌入式系统精心优化的硬件音频加速API。该库都允许使用C或C ++来实现高性能，低延迟的音频操作。 Android的OpenSL ES库同样位于NDK的platforms文件夹内。</p>
<span id="more"></span>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="CMake中增加的配置"><a href="#CMake中增加的配置" class="headerlink" title="CMake中增加的配置"></a>CMake中增加的配置</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">		native-lib</span><br><span class="line">    ....</span><br><span class="line">    openSLES</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="引入openSLES的头文件"><a href="#引入openSLES的头文件" class="headerlink" title="引入openSLES的头文件"></a>引入openSLES的头文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SLES/OpenSLES.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SLES/OpenSLES_Android.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="相关的结构体"><a href="#相关的结构体" class="headerlink" title="相关的结构体"></a>相关的结构体</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引擎</span></span><br><span class="line">SLObjectItf engineObject = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//引擎接口</span></span><br><span class="line">SLEngineItf engineInterface = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//混音器</span></span><br><span class="line">SLObjectItf outputMixObject = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//播放器</span></span><br><span class="line">SLObjectItf bqPlayerObject = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//播放器接口</span></span><br><span class="line">SLPlayItf bqPlayerPlay = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//播放器队列接口</span></span><br><span class="line">SLAndroidSimpleBufferQueueItf bqPlayerBufferQueue = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="重采样相关的函数"><a href="#重采样相关的函数" class="headerlink" title="重采样相关的函数"></a>重采样相关的函数</h2><p>1&gt; swr_alloc：申请内存</p>
<p>2&gt; swr_alloc_set_opts：设置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param SwrContext *s：音频重采样上下文</span><br><span class="line"></span><br><span class="line">@param int64_t out_ch_layout：输出的声道样式</span><br><span class="line"></span><br><span class="line">@param AVSampleFormat out_sample_fmt：输出的采样格式</span><br><span class="line"></span><br><span class="line">@param int out_sample_rate：输出采样率</span><br><span class="line"></span><br><span class="line">@param int64_t in_ch_layout：输入的声道样式</span><br><span class="line"></span><br><span class="line">@param AVSampleFormat in_sample_fmt：输入的采样格式</span><br><span class="line"></span><br><span class="line">@param int in_sample_rate：输入的采样率</span><br><span class="line"></span><br><span class="line">@param int log_offset, void *log_ctx：日志参数</span><br></pre></td></tr></table></figure>

<p>3&gt; swr_init：初始化</p>
<p>4&gt; swr_convert：转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param SwrContext *s：音频重采样上下文</span><br><span class="line"></span><br><span class="line">@param uint8_t **out, int out_count：输出的数据和单通道数据大小</span><br><span class="line"></span><br><span class="line">@param uint8_t **in, int in_count：输出的数据和单通道数据大小</span><br></pre></td></tr></table></figure>

<p>5&gt; swr_free：释放</p>
<h2 id="音频的解码流程"><a href="#音频的解码流程" class="headerlink" title="音频的解码流程"></a>音频的解码流程</h2><p>跟视频一样，同样是两个队列两个线程</p>
<h3 id="两个队列"><a href="#两个队列" class="headerlink" title="两个队列"></a>两个队列</h3><ol>
<li>存放压缩数据的队列 queue&lt;AVPacket *&gt;</li>
<li>存放解码后原始数据的队列 queue&lt;AVFrame *&gt;</li>
</ol>
<h3 id="两个线程"><a href="#两个线程" class="headerlink" title="两个线程"></a>两个线程</h3><ol>
<li>第一个线程是取出队列的压缩包 进行解码，解码后的原始包 丢到frame对别中去</li>
<li>第二个线程是从frame队列中取出原始包进行播放</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioChannel::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isPlaying = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    packets.<span class="built_in">setWork</span>(<span class="number">1</span>);</span><br><span class="line">    frames.<span class="built_in">setWork</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出packets队列中的压缩包进行解码，解码后的原始包放到frames队列中（音频原始包 PCM）</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid_audio_decode, <span class="literal">nullptr</span>, task_audio_decode, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从frames队列中取出原始包 进行 重采样 播放 使用Open SLES</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid_audio_play, <span class="literal">nullptr</span>, task_audio_play, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>音频：取出队列的压缩包 进行解码 解码后的原始包 再push队列中去 （音频：PCM数据）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AudioChannel::audio_decode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AVPacket *packet = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (isPlaying)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = packets.<span class="built_in">getQueueAndDel</span>(packet);</span><br><span class="line">        <span class="keyword">if</span>(!isPlaying)&#123;</span><br><span class="line">            <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">avcodec_send_packet</span>(codecContext, packet);</span><br><span class="line">        <span class="keyword">if</span>(res)&#123;</span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;audio channel decode AVPacket fail !!!&quot;</span>)</span><br><span class="line">            <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// avcodec_send_packet 出现了错误，结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        AVFrame *frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">        res = <span class="built_in">avcodec_receive_frame</span>(codecContext, frame);</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="built_in">AVERROR</span>(EAGAIN))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;audio channel receive AVFrame fail !!!&quot;</span>)</span><br><span class="line">            <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isPlaying)&#123;</span><br><span class="line">            <span class="comment">// 拿到了 原始包-- PCM数据</span></span><br><span class="line">            frames.<span class="built_in">insert</span>(frame);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">releaseAVFrame</span>(&amp;frame);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重采样播放"><a href="#重采样播放" class="headerlink" title="重采样播放"></a>重采样播放</h2><h3 id="1-创建引擎对象并获取【引擎接口】"><a href="#1-创建引擎对象并获取【引擎接口】" class="headerlink" title="1.创建引擎对象并获取【引擎接口】"></a>1.创建引擎对象并获取【引擎接口】</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.1 创建引擎对象：SLObjectItf engineObject</span></span><br><span class="line">result = <span class="built_in">slCreateEngine</span>(&amp;engineObject, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span>(SL_RESULT_SUCCESS != result)&#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;slCreateEngine error!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.2 初始化引擎</span></span><br><span class="line">(*engineObject)-&gt;<span class="built_in">Realize</span>(engineObject, SL_BOOLEAN_FALSE);<span class="comment">// SL_BOOLEAN_FALSE:延时等待你创建成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.3 获取引擎接口</span></span><br><span class="line">result = (*engineObject)-&gt;<span class="built_in">GetInterface</span>(engineObject, SL_IID_ENGINE, &amp;engineInterface);</span><br><span class="line"><span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;engineObject Realize error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 健壮判断</span></span><br><span class="line"><span class="keyword">if</span> (engineInterface) &#123;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;engineInterface create success&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;engineInterface create error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-设置混音器"><a href="#2-设置混音器" class="headerlink" title="2.设置混音器"></a>2.设置混音器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.1 创建混音器</span></span><br><span class="line">result = (*engineInterface)-&gt;<span class="built_in">CreateOutputMix</span>(engineInterface, &amp;outputMixObject, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>); <span class="comment">// 环境特效，混响特效，.. 都不需要</span></span><br><span class="line"><span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;CreateOutputMix failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 初始化混音器</span></span><br><span class="line">result = (*outputMixObject)-&gt;<span class="built_in">Realize</span>(outputMixObject, SL_BOOLEAN_FALSE); <span class="comment">// SL_BOOLEAN_FALSE:延时等待你创建成功</span></span><br><span class="line"><span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;(*outputMixObject)-&gt;Realize failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不启用混响可以不用获取混音器接口 【声音的效果】</span></span><br><span class="line"><span class="comment">// 获得混音器接口</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB,</span></span><br><span class="line"><span class="comment">                                         &amp;outputMixEnvironmentalReverb);</span></span><br><span class="line"><span class="comment">if (SL_RESULT_SUCCESS == result) &#123;</span></span><br><span class="line"><span class="comment">// 设置混响 ： 默认。</span></span><br><span class="line"><span class="comment">SL_I3DL2_ENVIRONMENT_PRESET_ROOM: 室内</span></span><br><span class="line"><span class="comment">SL_I3DL2_ENVIRONMENT_PRESET_AUDITORIUM : 礼堂 等</span></span><br><span class="line"><span class="comment">const SLEnvironmentalReverbSettings settings = SL_I3DL2_ENVIRONMENT_PRESET_DEFAULT;</span></span><br><span class="line"><span class="comment">(*outputMixEnvironmentalReverb)-&gt;SetEnvironmentalReverbProperties(</span></span><br><span class="line"><span class="comment">       outputMixEnvironmentalReverb, &amp;settings);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">LOGI</span>(<span class="string">&quot;outputMixObject Success&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-创建播放器"><a href="#3-创建播放器" class="headerlink" title="3.创建播放器"></a>3.创建播放器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建buffer缓存类型的队列  2的队列大小</span></span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue loc_bufq = &#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">                                                   <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pcm数据格式 == PCM是不能直接播放，mp3可以直接播放(参数集)，人家不知道PCM的参数</span></span><br><span class="line"><span class="comment">//  SL_DATAFORMAT_PCM：数据格式为pcm格式</span></span><br><span class="line"><span class="comment">//  2：双声道</span></span><br><span class="line"><span class="comment">//  SL_SAMPLINGRATE_44_1：采样率为44100</span></span><br><span class="line"><span class="comment">//  SL_PCMSAMPLEFORMAT_FIXED_16：采样格式为16bit</span></span><br><span class="line"><span class="comment">// SL_PCMSAMPLEFORMAT_FIXED_16：数据大小为16bit</span></span><br><span class="line"><span class="comment">// SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT：左右声道（双声道）</span></span><br><span class="line"><span class="comment">// SL_BYTEORDER_LITTLEENDIAN：小端模式</span></span><br><span class="line">SLDataFormat_PCM format_pcm = &#123;SL_DATAFORMAT_PCM, <span class="comment">// PCM数据格式</span></span><br><span class="line">                               <span class="number">2</span>, <span class="comment">// 声道数</span></span><br><span class="line">                               SL_SAMPLINGRATE_44_1, <span class="comment">// 采样率（每秒44100个点）</span></span><br><span class="line">                               SL_PCMSAMPLEFORMAT_FIXED_16, <span class="comment">// 每秒采样样本 存放大小 16bit</span></span><br><span class="line">                               SL_PCMSAMPLEFORMAT_FIXED_16, <span class="comment">// 每个样本位数 16bit</span></span><br><span class="line">                               SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT, <span class="comment">// 前左声道  前右声道</span></span><br><span class="line">                               SL_BYTEORDER_LITTLEENDIAN&#125;; <span class="comment">// 字节序(小端) 例如：int类型四个字节（到底是 高位在前 还是 低位在前 的排序方式，一般我们都是小端）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据源 将上述配置信息放到这个数据源中</span></span><br><span class="line"><span class="comment">// audioSrc最终配置音频信息的成果，给后面代码使用</span></span><br><span class="line">SLDataSource audioSrc = &#123;&amp;loc_bufq, &amp;format_pcm&#125;;</span><br><span class="line"><span class="comment">// audioSrc 给后面代码用的</span></span><br><span class="line"><span class="comment">// 独立声卡：24bit  集成声卡16bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 配置音轨（输出）</span></span><br><span class="line"><span class="comment">// 设置混音器</span></span><br><span class="line">SLDataLocator_OutputMix loc_outmix = &#123;SL_DATALOCATOR_OUTPUTMIX, outputMixObject&#125;; <span class="comment">// SL_DATALOCATOR_OUTPUTMIX:输出混音器类型</span></span><br><span class="line">SLDataSink audioSnk = &#123;&amp;loc_outmix, <span class="literal">nullptr</span>&#125;; <span class="comment">// outmix最终混音器的成果，给后面代码使用</span></span><br><span class="line"><span class="comment">// 需要的接口 操作队列的接口</span></span><br><span class="line"><span class="keyword">const</span> SLInterfaceID ids[<span class="number">1</span>] = &#123;SL_IID_BUFFERQUEUE&#125;;</span><br><span class="line"><span class="keyword">const</span> SLboolean req[<span class="number">1</span>] = &#123;SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.3 创建播放器 SLObjectItf bqPlayerObject</span></span><br><span class="line">result = (*engineInterface)-&gt;<span class="built_in">CreateAudioPlayer</span>(engineInterface, <span class="comment">// 参数1：引擎接口</span></span><br><span class="line">                                               &amp;bqPlayerObject, <span class="comment">// 参数2：播放器</span></span><br><span class="line">                                               &amp;audioSrc, <span class="comment">// 参数3：音频配置信息</span></span><br><span class="line">                                               &amp;audioSnk, <span class="comment">// 参数4：混音器</span></span><br><span class="line"></span><br><span class="line">                                                <span class="comment">// 下面代码都是 打开队列的工作</span></span><br><span class="line">                                               <span class="number">1</span>, <span class="comment">// 参数5：开放的参数的个数</span></span><br><span class="line">                                               ids,  <span class="comment">// 参数6：代表我们需要 Buff</span></span><br><span class="line">                                               req <span class="comment">// 参数7：代表我们上面的Buff 需要开放出去</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;CreateAudioPlayer failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.4 初始化播放器：SLObjectItf bqPlayerObject</span></span><br><span class="line">result = (*bqPlayerObject)-&gt;<span class="built_in">Realize</span>(bqPlayerObject, SL_BOOLEAN_FALSE);  <span class="comment">// SL_BOOLEAN_FALSE:延时等待你创建成功</span></span><br><span class="line"><span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;init bqPlayerObject Realize failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">LOGI</span>(<span class="string">&quot;bqPlayerObject init success!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.5 获取播放器接口 【以后播放全部使用 播放器接口去干（核心）】</span></span><br><span class="line">result = (*bqPlayerObject)-&gt;<span class="built_in">GetInterface</span>(bqPlayerObject, SL_IID_PLAY, &amp;bqPlayerPlay); <span class="comment">// SL_IID_PLAY:播放接口 == iplayer</span></span><br><span class="line"><span class="keyword">if</span> (SL_RESULT_SUCCESS != result) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;bqPlayerObject GetInterface SL_IID_PLAY failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">LOGI</span>(<span class="string">&quot;bqPlayerObject GetInterface Success&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-设置回调函数"><a href="#4-设置回调函数" class="headerlink" title="4.设置回调函数"></a>4.设置回调函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.1 获取播放器队列接口：SLAndroidSimpleBufferQueueItf bqPlayerBufferQueue  // 播放需要的队列</span></span><br><span class="line">result = (*bqPlayerObject)-&gt;<span class="built_in">GetInterface</span>(bqPlayerObject, SL_IID_BUFFERQUEUE, &amp;bqPlayerBufferQueue);</span><br><span class="line"><span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;bqPlayerBufferQueue GetInterface SL_IID_BUFFERQUEUE failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.2 设置回调 void bqPlayerCallback(SLAndroidSimpleBufferQueueItf bq, void *context)</span></span><br><span class="line">(*bqPlayerBufferQueue)-&gt;<span class="built_in">RegisterCallback</span>(bqPlayerBufferQueue,  <span class="comment">// 传入刚刚设置好的队列</span></span><br><span class="line">                                         bqPlayerCallback,  <span class="comment">// 回调函数</span></span><br><span class="line">                                         <span class="keyword">this</span>); <span class="comment">// 给回调函数的参数</span></span><br><span class="line"><span class="built_in">LOGI</span>(<span class="string">&quot;setting playCallback Success&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-设置播放器状态为播放状态"><a href="#5-设置播放器状态为播放状态" class="headerlink" title="5.设置播放器状态为播放状态"></a>5.设置播放器状态为播放状态</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*bqPlayerPlay)-&gt;<span class="built_in">SetPlayState</span>(bqPlayerPlay, SL_PLAYSTATE_PLAYING);</span><br><span class="line"><span class="built_in">LOGI</span>(<span class="string">&quot;SetPlayState Success&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="6-手动激活回调函数"><a href="#6-手动激活回调函数" class="headerlink" title="6.手动激活回调函数"></a>6.手动激活回调函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bqPlayerCallback</span>(bqPlayerBufferQueue, <span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">LOGI</span>(<span class="string">&quot;active playCallback Success&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7-重采样"><a href="#7-重采样" class="headerlink" title="7.重采样"></a>7.重采样</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.out_buffers给予数据</span></span><br><span class="line"><span class="comment"> * 2.out_buffers给予数据的大小计算工作</span></span><br><span class="line"><span class="comment"> * @return  大小还要计算，因为我们还要做重采样工作，重采样之后，大小不同了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AudioChannel::getPCM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pcm_data_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取PCM数据</span></span><br><span class="line">    <span class="comment">// PCM数据在哪里？答：队列 frames队列中  frame-&gt;data == PCM数据(待 重采样   32bit)</span></span><br><span class="line"></span><br><span class="line">    AVFrame *frame = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (isPlaying) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = frames.<span class="built_in">getQueueAndDel</span>(frame);</span><br><span class="line">        <span class="keyword">if</span> (!isPlaying) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果关闭了播放，跳出循环，releaseAVPacket(&amp;pkt);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ret) &#123; <span class="comment">// ret == 0</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 哪怕是没有成功，也要继续（假设：你生产太慢(原始包加入队列)，我消费就等一下你）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始重采样</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 来源：10个48000   ----&gt;  目标:44100  11个44100</span></span><br><span class="line">        <span class="comment">// 获取单通道的样本数 (计算目标样本数： ？ 10个48000 ---&gt;  48000/44100因为除不尽  11个44100)</span></span><br><span class="line">        <span class="keyword">int</span> dst_nb_samples = <span class="built_in">av_rescale_rnd</span>(<span class="built_in">swr_get_delay</span>(swr_ctx, frame-&gt;sample_rate) + frame-&gt;nb_samples, <span class="comment">// 获取下一个输入样本相对于下一个输出样本将经历的延迟</span></span><br><span class="line">                                            out_sample_rate, <span class="comment">// 输出采样率</span></span><br><span class="line">                                            frame-&gt;sample_rate, <span class="comment">// 输入采样率</span></span><br><span class="line">                                            AV_ROUND_UP); <span class="comment">// 先上取 取去11个才能容纳的上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// pcm的处理逻辑</span></span><br><span class="line">        <span class="comment">// 音频播放器的数据格式是我们自己在下面定义的</span></span><br><span class="line">        <span class="comment">// 而原始数据（待播放的音频pcm数据）</span></span><br><span class="line">        <span class="comment">// 重采样工作</span></span><br><span class="line">        <span class="comment">// 返回的结果：每个通道输出的样本数(注意：是转换后的)    做一个简单的重采样实验(通道基本上都是:1024)</span></span><br><span class="line">        <span class="keyword">int</span> samples_per_channel = <span class="built_in">swr_convert</span>(swr_ctx,</span><br><span class="line">                <span class="comment">// 下面是输出区域</span></span><br><span class="line">                                              &amp;out_buffers,  <span class="comment">// 【成果的buff】  重采样后的</span></span><br><span class="line">                                              dst_nb_samples, <span class="comment">// 【成果的 单通道的样本数 无法与out_buffers对应，所以有下面的pcm_data_size计算】</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面是输入区域</span></span><br><span class="line">                                              (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) frame-&gt;data, <span class="comment">// 队列的AVFrame * 那的  PCM数据 未重采样的</span></span><br><span class="line">                                              frame-&gt;nb_samples); <span class="comment">// 输入的样本数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于out_buffers 和 dst_nb_samples 无法对应，所以需要重新计算</span></span><br><span class="line">        pcm_data_size = samples_per_channel * out_sample_size * out_channels; <span class="comment">// 941通道样本数  *  2样本格式字节数  *  2声道数  =3764</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单通道样本数:1024  * 2声道  * 2(16bit)  =  4,096</span></span><br><span class="line"></span><br><span class="line">        audio_time = frame-&gt;best_effort_timestamp * <span class="built_in">av_q2d</span>(time_base);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 利用while循环 来写我们的逻辑</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// while end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// FFmpeg录制 Mac 麦克风  输出 每一个音频包的size == 4096</span></span><br><span class="line">    <span class="comment">// 4096是单声道的样本数，  44100是每秒钟采样的数</span></span><br><span class="line">    <span class="comment">// 采样率 和 样本数的关系？</span></span><br><span class="line">    <span class="comment">// 答： 单通道样本数:1024  * 2声道  * 2(16bit)  =  4,096 ==  4096是单声道的样本数</span></span><br><span class="line">    <span class="comment">//     采样率 44100是每秒钟采样的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 样本数 = 采样率 * 声道数 * 位声</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双声道的样本数？  答： （采样率 * 声道数 * 位声） * 2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">releaseAVFrame</span>(&amp;frame);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pcm_data_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/jiajunhui/ffmpeg-jjhplayer">https://github.com/jiajunhui/ffmpeg-jjhplayer</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>播放器</tag>
        <tag>NDK</tag>
        <tag>JNI</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>整车CAN网络了解</title>
    <url>/2021/05/21/car_can_introduction/</url>
    <content><![CDATA[<p>CAN是控制器局域网络(Controller Area Network, CAN)的简称。目前普遍运用在汽车网络.</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>先了解一个概念，何为智能硬件, 就是包含智能控制单元的硬件, 比如发动机, 发动机上有一块儿专门负责控制发动机进气量, 喷油量, 排气量的控制单元, 这块单元相当于发动机的大脑. 他具有信号发送, 信号接收, 参数存储等基本功能, 这个控制单元就是ECU.</p>
<p>​     ECU(Electronic ControlUnit）电子控制单元，是汽车专用微机控制器, 一个ECU一般负责1个或多个智能硬件设备.</p>
<p>​     随着汽车的发展, 车上的智能设备越来越多, 也就是说车上的ECU也越来越多, 如何用一个网络把这些智能设备的ECU全部连接起来并整体协调控制?</p>
<p>​    这就是CAN网络。</p>
<h1 id="CAN网络的优势"><a href="#CAN网络的优势" class="headerlink" title="CAN网络的优势"></a>CAN网络的优势</h1><ul>
<li><p>开放的标准</p>
</li>
<li><p>低成本</p>
</li>
<li><p>高速实时传递, 数据传递更安全可靠</p>
</li>
<li><p>适用于各种汽车</p>
</li>
</ul>
<h1 id="CAN网络-早期基本结构图"><a href="#CAN网络-早期基本结构图" class="headerlink" title="CAN网络-早期基本结构图"></a>CAN网络-早期基本结构图</h1><p>早期的整车CAN网络主要是围绕BCM(车身控制器)为控制中心, 早期的汽车, 智能硬件较少, 车身零部件(雨刮/大灯/车窗…)倒是一堆, 所以早期的正常CAN网络把所有其他的ECU全部放在Other ECU里边.</p>
<p><img src="/images/car_can_introduction01.png" alt="image"></p>
<p>随着智能硬件的越来越多, 且考虑到成本与安全, BCM已经不够完成如此庞大的网络管理了, 网关应运而生, 网关管理了5条CAN总线的各类ECU,  并对这5条CAN总线的波特率及信号优先级做了区分. 之前管理一堆车身零部件(雨刮/大灯/车窗…)的BCM也成了BCAN的一个节点!</p>
<h1 id="CAN网络-当今主流结构图"><a href="#CAN网络-当今主流结构图" class="headerlink" title="CAN网络-当今主流结构图"></a>CAN网络-当今主流结构图</h1><p>现如今的燃油车整车CAN网络主要以网关为控制中心, </p>
<p>本篇主要介绍这种类型的CAN网络.</p>
<p><img src="/images/car_can_introduction02.png" alt="image"></p>
<h2 id="CAN网络基本构成单元1-ECU节点"><a href="#CAN网络基本构成单元1-ECU节点" class="headerlink" title="CAN网络基本构成单元1_ECU节点"></a>CAN网络基本构成单元1_ECU节点</h2><p>就是车上的智能硬件设备里ECU控制单元.</p>
<p>比如ABS(防抱死系统)这个ECU是专门用于车辆制动过程中防止车轮被抱死的一套智能设备.</p>
<p>当今汽车越豪华,ECU就越多,智能控制硬件就越多,相对价格就越贵.一般的,一辆车普通的家用  轿车都有25个左右ECU. </p>
<p>如下图, 车上某个智能硬件上的ECU(智能电子控制单元)</p>
<p><img src="/images/car_can_introduction03.png" alt="image"></p>
<p><strong>由于车上ECU太多, 每种ECU作用各不相同, 信号传输速率(波特率)也不一致.</strong></p>
<p><strong>为了更加方便管理这些ECU, 我们把以上各类ECU按其功能/波特率分别布置在5条CAN总线上.</strong> </p>
<h2 id="CAN网络基本构成单元2-CAN总线"><a href="#CAN网络基本构成单元2-CAN总线" class="headerlink" title="CAN网络基本构成单元2_CAN总线"></a>CAN网络基本构成单元2_CAN总线</h2><p>也叫CAN BUS, 为了方便测试人员理解, 可以理解成CAN支线(可理解成一个路由器上的5条分口引出来的分支网线).</p>
<p>一般地, 分成5条CAN总线:</p>
<h3 id="PCAN-PowerTrain-CAN-☞-动力总成CAN总线"><a href="#PCAN-PowerTrain-CAN-☞-动力总成CAN总线" class="headerlink" title="PCAN (PowerTrain CAN ) ☞ 动力总成CAN总线"></a>PCAN (PowerTrain CAN ) ☞ 动力总成CAN总线</h3><blockquote>
<p>这条CAN总线主要负责车辆动力及最高安全级.</p>
<p>这条CAN总线上一般有以下ECU:</p>
<p>ECM ( Engine Control Module ) 发动机控制模块</p>
<p>SRS ( SupplementalRestraintSystem) 电子安全气囊</p>
<p>BMS ( Battery Management System ) 电池管理系统</p>
<p>…….</p>
<p>PCAN上是整车CAN网络信号优先级及信号传输速率最高的一条CAN总线.</p>
</blockquote>
<h3 id="CCAN-Chassis-CAN-☞-底盘控制CAN总线"><a href="#CCAN-Chassis-CAN-☞-底盘控制CAN总线" class="headerlink" title="CCAN (Chassis CAN) ☞ 底盘控制CAN总线"></a>CCAN (Chassis CAN) ☞ 底盘控制CAN总线</h3><blockquote>
<p>这条CAN总线主要负责汽车底盘及4个轮子的制动/稳定/转向</p>
<p>这条CAN总线上一般有以下ECU:</p>
<p>ABS ( Antilock Brake System ) 防抱死制动系统</p>
<p>ESP(Electronic Stability Program)车身电子稳定系统</p>
<p>EPS(Electric Power Steering)电子转向助力</p>
<p>……</p>
<p>CCAN由于涉及整车制动/助力转向等, 所以其网络信号优先级也是较高的. </p>
</blockquote>
<h3 id="BCAN-Body-CAN-☞-车身控制总线"><a href="#BCAN-Body-CAN-☞-车身控制总线" class="headerlink" title="BCAN ( Body CAN )☞ 车身控制总线"></a>BCAN ( Body CAN )☞ 车身控制总线</h3><blockquote>
<p>这条CAN总线主要车身上的一些提高舒适性/安全性的智能硬件的管理与控制</p>
<p>这条CAN总线上一般有以下ECU:</p>
<p>AC ( Air Condition ) 空调</p>
<p>AVM(Around View Monitor) 360环视</p>
<p>BCM(Body Control Module) 天窗, 车窗, 雾灯, 转向灯, 雨刮…</p>
<p>IMMO(Immobilizer) 发动机防盗系统</p>
<p>TPMS(Tire Pressure Monitoring System) 胎压监控系统</p>
<p>……</p>
<p>BCAN其网络信号优先级也是较低, 因为以上设备都是辅助设备.</p>
</blockquote>
<h3 id="ECAN-Entertainment-CAN-☞-娱乐系统总线"><a href="#ECAN-Entertainment-CAN-☞-娱乐系统总线" class="headerlink" title="ECAN ( Entertainment CAN ) ☞ 娱乐系统总线"></a>ECAN ( Entertainment CAN ) ☞ 娱乐系统总线</h3><blockquote>
<p>这条CAN总线主要车身上的一些提高娱乐性的智能硬件的管理与控制</p>
<p>这条CAN总线上一般有以下ECU:</p>
<p>VAES( Video Audio Entertainment System) 车载娱乐系统(中控)</p>
<p>IPK(Instrument Pack) 组合仪表, 当今的数字仪表, 基本有音乐, 地图, 通话等娱乐功能.</p>
<p>……..</p>
<p>ECAN, 也是辅助可选设备, 所以优先级也是较低的.</p>
</blockquote>
<h3 id="DCAN-Diagnose-CAN-☞-诊断控制总线"><a href="#DCAN-Diagnose-CAN-☞-诊断控制总线" class="headerlink" title="DCAN ( Diagnose CAN )☞ 诊断控制总线"></a>DCAN ( Diagnose CAN )☞ 诊断控制总线</h3><blockquote>
<p>这条CAN总线主要提供远程诊断功能</p>
<p>这条CAN总线上只有一个ECU:</p>
<p>Tbox(Telematics BOX) 远程控制模块</p>
<p>…….</p>
</blockquote>
<p>每条CAN总线都是由2根线组成的双绞线构成,</p>
<p>一根can_high, 一根can_low, 分别代表高电平, 低电平.</p>
<p>以下是某条CAN总线的模型图, 一条CAN总线上连着4个ECU控制单元.</p>
<p><img src="/images/car_can_introduction04.png" alt="image"></p>
<h1 id="CAN网关"><a href="#CAN网关" class="headerlink" title="CAN网关"></a>CAN网关</h1><p>网关是整个CAN网络的核心, 控制着整车5条CAN总线的信号转发与处理.</p>
<p>其实准确的说不能叫CAN网关, 应该叫网关或者汽车网关, 因为网关不仅处理CAN网络, 还处理LIN网络.</p>
<h3 id="CAN网关的功能"><a href="#CAN网关的功能" class="headerlink" title="CAN网关的功能"></a>CAN网关的功能</h3><p>CAN网关或叫汽车网关，因为网关不仅处理CAN网络，还处理LIN网络.</p>
<p>实际can网关大概有六七十个接线pin脚，每个接线pin脚都有严格的定义, 要匹配规定好的can总线或者开关设备, 除了刚才涉及的10个can线接线口(5条双绞线)，2个电源线接线口，还应包括定速巡航设备的8个接线口，电源管理方面的3个接线口，钥匙开关(或无钥匙启动系统)的5个接口，脚踏板的3个接线口，5个LIN接线pin脚，档位开关的4个接线pin脚等等。</p>
<p>某些汽车厂商可能有更多新的硬件开关设备，电压电阻开关设备等也都有对应的接线pin脚,<br>且可能预留一些PIN脚以备用.</p>
<p>CAN网关是整个CAN网络的核心, 控制着整车5条CAN总线的各类信号转发与处理，基本功能包括:</p>
<blockquote>
<ol>
<li>连接不同波特率(传输速度)的CAN总线/LIN总线，以实现CAN网络的网关中继功能。</li>
<li>诊断报文/非诊断报文转发。</li>
<li>诊断防火墙管理。</li>
<li>节点在线监控。</li>
<li>巡航控制器开关检测。</li>
<li>脚踏板位置检测。</li>
<li>网关休眠与唤醒管理。</li>
<li>ECU升级/网关升级。</li>
<li>电压管理。</li>
</ol>
</blockquote>
<p>CAN网关可以接收任何CAN总线(还有LIN总线)传来的不同传输速率网络信号，把这些信号按一定的标准处理后，广播到整车网络去，如果有ECU订阅(接收)了这个信号, 则ECU将解析信号并做相应的处理。<br>整车所有ECU基本是以毫秒级或者微妙级的速度在源源不断的发送并接收信号，所以网关需要处理并转发广播的信号是非常多的且必须要很快处理完的。</p>
<h1 id="车机娱乐系统"><a href="#车机娱乐系统" class="headerlink" title="车机娱乐系统"></a>车机娱乐系统</h1><p>基本来说, 当今的智能车机基本有以下几个特点:</p>
<blockquote>
<p>基于智能操作系统：Android，Linux等。<br>基本都是虚拟按键，较少用实体按键。<br>具备外网连接功能，即搭载了Tbox盒子。<br>有配套的车联网App，可以当手机钥匙及远程车控等功能。<br>具备控制：空调，数字液晶仪表，360度环视摄像头，其他车身设备(天窗, 车窗,大灯)的应用程序。</p>
</blockquote>
<p>需要说明的是：</p>
<ul>
<li><p>车机娱乐系统是Info CAN上的一个节点, 节点名称为VAES (Video Audio Entertainment System)</p>
</li>
<li><p>空调是Body CAN上的一个节点, 节点名称AC。</p>
</li>
<li><p>仪表是Info CAN上的节点，节点名称IPK，也叫ICU。</p>
</li>
<li><p>360智能环视摄像头是Body CAN上的节点，节点名称AVM。</p>
</li>
<li><p>其他车身设备(天窗, 车窗, 大灯)等设备是Body CAN上的BCM节点统一管理的。</p>
</li>
</ul>
<p>车机节点是车机上的一块MCU，专门负责车机主机对整车CAN网络的CAN信号转换的，业界一般用IPCL协议进行CAN信号到字符串信号(程序员能识别的信号)的转换，以上字符串信号经过Carservice或App的解析后，转成文字或者图像的界面供用户选择和使用，这样就把原始CAN信号转成用户能够看得懂的文字或图像。<br>因此</p>
<ul>
<li><p>VAES(车机)节点订阅消息(接收): 车机就是一台显示器。</p>
</li>
<li><p>VAES(车机)节点发送消息: 车机就是一台远程控制器。</p>
</li>
</ul>
<h1 id="TBOX"><a href="#TBOX" class="headerlink" title="TBOX"></a>TBOX</h1><p>Tbox是汽车上的一个盒子，其实是一个Android操作系统的带通讯功能的盒子，内含一张SIM卡，一般是中国联通SIM卡，与这个盒子配套硬件还有GPS天线，4G天线等。车机要联网必须有Tbox设备才能实现。</p>
<p><img src="/images/car_can_introduction05.png" alt="image"></p>
<p>TBOX的功能如下：</p>
<ul>
<li><p>Tbox可以给车机提供外网连接功能。<br>如何提供外网, 原理很简单, 可以简单的把它当做是USB上网卡。</p>
</li>
<li><p>Tbox可以提供GPS定位服务。<br>Tbox有GPS天线接入，车机通过USB数据输出接口实时获取GPS定位信息。<br>(Tbox的USB接口，除了提供外网数据, 提供GPS数据外，开发人员还可以通过这个USB线进行Tbox开发及adb debug等。)</p>
</li>
<li><p>Tbox是Diag CAN(诊断CAN)上的一个节点, 该节点可提供本地诊断和远程诊断等功能。</p>
</li>
</ul>
<p>智能车机娱乐系统有配套的车联网手机App，通过App可远程查看车机状态，远程开启座椅加热，远程开启空调，远程获取车机状态信息等。</p>
<p>当然，车联网手机App状态查询/远程控制功能的实现，全部依托Tbox节点，Tbox节点可以接收远程4G信号，之后由Tbox在诊断CAN上发起CAN诊断及控制命令，Tbox还实时获取相关CAN信号并上传云平台，云平台返回数据到车联网手机App。最终达到远程诊断(远程获取车辆状态, 远程读取故障码等…) 和远程控制(控制车上某些智能硬件的作用, 比如空调, 座椅加热等…)。</p>
<p>Tbox上的SIM一般只给车主用户提供网络服务， 虽然这张电话可以打电话, 但是由于车机系统的功能接口限定(软件界面上的功能限定)，限定了其只可以拨打道路救援电话，厂商客服电话，110等紧急电话，不可拨打普通手机号码或电话号码等。</p>
]]></content>
      <categories>
        <category>Android系统开发</category>
        <category>车联网</category>
      </categories>
      <tags>
        <tag>CAN</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg之音画同步与资源释放</title>
    <url>/2018/12/27/ffmpeg_audio_video_sync/</url>
    <content><![CDATA[<p>前面使用FFmpeg完成了视频和音频的播放，但是项目跑起来后发现视频和画面并不一致，也就是说我们从队列中取出数据进行播放时是没有对画面和音频时间进行同步处理的，所以出现了问题。同时播放完成以及错误或者退出时要进行相关的资源释放工作。</p>
<span id="more"></span>

<h2 id="音画同步的处理"><a href="#音画同步的处理" class="headerlink" title="音画同步的处理"></a>音画同步的处理</h2><p>保证画面和音频同步其实很简单，就是尽量保证二者进行输出播放时的时刻尽最大可能进行接近处理。</p>
<p>也就是说也以某个为基准去同步另一个，那么我们应该以哪个为基准呢，一般都是以音频为基准的，因为人对声音的敏感度要大于画面的敏感度。</p>
<p>在视频播放中进行时间的同步处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoChannel::video_play</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AVFrame *frame = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> *dest_data[<span class="number">4</span>];<span class="comment">//RGBA 4字节</span></span><br><span class="line">    <span class="keyword">int</span> dst_lineSize[<span class="number">4</span>];<span class="comment">//RGBA</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_image_alloc</span>(dest_data, dst_lineSize,</span><br><span class="line">                   codecContext-&gt;width, codecContext-&gt;height,</span><br><span class="line">                   AV_PIX_FMT_RGBA, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//YUV -&gt; RGBA</span></span><br><span class="line">    SwsContext *swsContext = <span class="built_in">sws_getContext</span>(</span><br><span class="line">            <span class="comment">//输入</span></span><br><span class="line">            codecContext-&gt;width,</span><br><span class="line">            codecContext-&gt;height,</span><br><span class="line">            codecContext-&gt;pix_fmt,</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            codecContext-&gt;width,</span><br><span class="line">            codecContext-&gt;height,</span><br><span class="line">            AV_PIX_FMT_RGBA,</span><br><span class="line">            SWS_BILINEAR,<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (isPlaying)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = frames.<span class="built_in">getQueueAndDel</span>(frame);</span><br><span class="line">        <span class="keyword">if</span>(!isPlaying)&#123;</span><br><span class="line">            <span class="built_in">releaseAVFrame</span>(&amp;frame);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//如果关闭了播放，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//有可能生产者队列填充数据过慢，需要等一等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sws_scale</span>(swsContext,</span><br><span class="line">                  <span class="comment">//输入</span></span><br><span class="line">                  frame-&gt;data, frame-&gt;linesize,</span><br><span class="line">                  <span class="number">0</span>, codecContext-&gt;height,</span><br><span class="line">                  <span class="comment">//输出</span></span><br><span class="line">                  dest_data, dst_lineSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 音视频同步 3（根据fps来休眠） FPS间隔时间加入（我的视频 默默的播放，不要看起来怪怪的） == 要有延时感觉</span></span><br><span class="line">        <span class="comment">// 0.04是这一帧的真实时间加上延迟时间吧</span></span><br><span class="line">        <span class="comment">// 公式：extra_delay = repeat_pict / (2*fps)</span></span><br><span class="line">        <span class="comment">// 经验值 extra_delay:0.0400000</span></span><br><span class="line">        <span class="keyword">double</span> extra_delay = frame-&gt;repeat_pict / (<span class="number">2</span> * fps); <span class="comment">// 在之前的编码时，加入的额外延时时间取出来（可能获取不到）</span></span><br><span class="line">        <span class="keyword">double</span> fps_delay = <span class="number">1.0</span> / fps; <span class="comment">// 根据fps得到延时时间（fps25 == 每秒25帧，计算每一帧的延时时间，0.040000）</span></span><br><span class="line">        <span class="keyword">double</span> real_delay = fps_delay + extra_delay; <span class="comment">// 当前帧的延时时间  0.040000</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// fps间隔时间后的效果，任何播放器，都会有</span></span><br><span class="line">        <span class="comment">// 为什么不能用：根据是 视频的 fps延时在处理，和音频还没有任何关系</span></span><br><span class="line">        <span class="comment">// av_usleep(real_delay * 1000000);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 下面是音视频同步</span></span><br><span class="line">        <span class="keyword">double</span> video_time = frame-&gt;best_effort_timestamp * <span class="built_in">av_q2d</span>(time_base);</span><br><span class="line">        <span class="keyword">double</span> audio_time = audio_channel-&gt;audio_time;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个时间差值，一个快一个慢（快的等慢的，慢的快点追） == 你追我赶</span></span><br><span class="line">        <span class="keyword">double</span> time_diff = video_time - audio_time;</span><br><span class="line">        <span class="keyword">if</span>(time_diff &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//视频较快</span></span><br><span class="line">            <span class="comment">// 视频时间 &gt; 音频时间： 要等音频，所以控制视频播放慢一点（等音频） 【睡眠】</span></span><br><span class="line">            <span class="keyword">if</span> (time_diff &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;   <span class="comment">// 说明：音频预视频插件很大，TODO 拖动条 特色场景  音频 和 视频 差值很大，我不能睡眠那么久，否则是大Bug</span></span><br><span class="line">                <span class="comment">// av_usleep((real_delay + time_diff) * 1000000);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 音频 和 视频 差值很大，我不会睡很久，我就是稍微睡一下</span></span><br><span class="line">                <span class="built_in">av_usleep</span>((real_delay * <span class="number">2</span>) * <span class="number">1000000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   <span class="comment">// 说明：0~1之间：音频与视频差距不大，所以可以那（当前帧实际延时时间 + 音视频差值）</span></span><br><span class="line">                <span class="built_in">av_usleep</span>((real_delay + time_diff) * <span class="number">1000000</span>); <span class="comment">// 单位是微妙：所以 * 1000000</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(time_diff &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//音频较快</span></span><br><span class="line">            <span class="comment">// 视频时间 &lt; 音频时间： 要追音频，所以控制视频播放快一点（追音频） 【丢包】</span></span><br><span class="line">            <span class="comment">// 丢帧：不能睡意丢，I帧是绝对不能丢</span></span><br><span class="line">            <span class="comment">// 丢包：在frames 和 packets 中的队列</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 经验值 0.05</span></span><br><span class="line">            <span class="comment">// -0.234454   fabs == 0.234454</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(time_diff) &lt;= <span class="number">0.05</span>)&#123;</span><br><span class="line">                <span class="comment">// 多线程（安全 同步丢包）</span></span><br><span class="line">                frames.<span class="built_in">sync</span>();</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 丢完取下一个包</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 百分百同步，这个基本上很难做的</span></span><br><span class="line">            <span class="built_in">LOGI</span>(<span class="string">&quot;百分百同步了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ANativeWindow渲染</span></span><br><span class="line">        <span class="keyword">if</span>(renderCallback &amp;&amp; isPlaying)</span><br><span class="line">            <span class="built_in">renderCallback</span>(dest_data[<span class="number">0</span>], codecContext-&gt;width, codecContext-&gt;height, dst_lineSize[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">releaseAVFrame</span>(&amp;frame);<span class="comment">//释放原始包，因为已经被渲染过了，没用了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">releaseAVFrame</span>(&amp;frame);</span><br><span class="line">    isPlaying = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">av_freep</span>(dest_data[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">sws_freeContext</span>(swsContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样也就尽量保证了画面和视频的同步输出播放。</p>
<h2 id="资源的释放"><a href="#资源的释放" class="headerlink" title="资源的释放"></a>资源的释放</h2><ol>
<li><p>AVFormatContext的释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(formatContext)&#123;</span><br><span class="line">    <span class="built_in">avformat_close_input</span>(&amp;formatContext);</span><br><span class="line">    <span class="built_in">avformat_free_context</span>(formatContext);</span><br><span class="line">    formatContext = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Audio与Video的处理释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoChannel::stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;VideoChannel prepare stop&quot;</span>);</span><br><span class="line">    isPlaying = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">pthread_join</span>(pid_video_decode, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(pid_video_play, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    packets.<span class="built_in">setWork</span>(<span class="number">0</span>);</span><br><span class="line">    frames.<span class="built_in">setWork</span>(<span class="number">0</span>);</span><br><span class="line">    packets.<span class="built_in">clear</span>();</span><br><span class="line">    frames.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;VideoChannel stop&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AVPacket与AVFrame的释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseAVPacket</span><span class="params">(AVPacket ** p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)&#123;</span><br><span class="line">        <span class="built_in">av_packet_unref</span>(*p);</span><br><span class="line">        <span class="built_in">av_packet_free</span>(p);</span><br><span class="line">        *p = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseAVFrame</span><span class="params">(AVFrame ** f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)&#123;</span><br><span class="line">        <span class="built_in">av_frame_unref</span>(*f);</span><br><span class="line">        <span class="built_in">av_frame_free</span>(f);</span><br><span class="line">        *f = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ANativeWindow的释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_jiajunhui_lib_jjhplayer_JJHPlayer_nativeRelease</span><span class="params">(JNIEnv</span></span></span><br><span class="line"><span class="params"><span class="function">* env,</span></span></span><br><span class="line"><span class="params"><span class="function">jobject thiz</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;native-lib prepare release&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先释放之前的显示窗口</span></span><br><span class="line">    <span class="keyword">if</span> (window) &#123;</span><br><span class="line">        <span class="built_in">ANativeWindow_release</span>(window);</span><br><span class="line">        window = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(player)</span><br><span class="line">        player-&gt;<span class="built_in">release</span>();</span><br><span class="line">    <span class="built_in">DELETE</span>(player);</span><br><span class="line">    <span class="built_in">DELETE</span>(vm);</span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;native-lib release&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>源码地址：<a href="https://github.com/jiajunhui/ffmpeg-jjhplayer">https://github.com/jiajunhui/ffmpeg-jjhplayer</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>播放器</tag>
        <tag>NDK</tag>
        <tag>JNI</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL</title>
    <url>/2017/07/09/cpp_stl/</url>
    <content><![CDATA[<p>STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。</p>
<span id="more"></span>

<p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组；</p>
<p>STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效；</p>
<p>从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术；</p>
<p>从实现层次看，整个STL是以一种类型参数化的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性–模板（template）。</p>
<h2 id="STL内容介绍"><a href="#STL内容介绍" class="headerlink" title="STL内容介绍"></a>STL内容介绍</h2><p>STL中六大组件：</p>
<p>容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；<br>迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；<br>算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；<br>仿函数（Functor）<br>适配器（Adaptor）<br>分配器（allocator）</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。<br>（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；<br>       Vector：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；<br>       Deque：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；<br>       List：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；<br>（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap等。<br>       Set/Multiset：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；<br>       Map/Multimap：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；</p>
<p>容器类自动申请和释放内存，无需new和delete操作。</p>
<h3 id="STL迭代器"><a href="#STL迭代器" class="headerlink" title="STL迭代器"></a>STL迭代器</h3><p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator.</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——你可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。<br>STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。<br>算法部分主要由头文件<algorithm>，<numeric>和<functional>组成。<br><algorithm>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<br><numeric>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<br><functional>中则定义了一些模板类，用以声明函数对象。<br>STL中算法大致分为四类：</p>
<p>非可变序列算法：指不直接修改其所操作的容器内容的算法。<br>可变序列算法：指可以修改它们所操作的容器内容的算法。<br>排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。<br>数值算法：对容器内容进行数值计算。<br>以下对所有算法进行细致分类并标明功能：<br>&lt;一&gt;查找算法(13个)：判断容器中是否包含某个值<br>adjacent_find:   在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的                                                 ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。<br>binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。<br>count:                利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。<br>count_if:            利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。<br>equal_range:     功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。<br>find:                   利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的                               一个InputIterator。<br>find_end:          在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一                            个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代                               替等于操作。<br>find_first_of:     在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使                             用了用户自定义操作符。<br>find_if:               使用输入的函数代替等于操作符执行find。<br>lower_bound:   返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函                             数使用自定义比较操作。<br>upper_bound:  返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志                               一个大于value的值。重载函数使用自定义比较操作。<br>search:              给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位                                 置，查找失败指向last1。重载版本使用自定义的比较操作。<br>search_n:          在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。<br>&lt;二&gt;排序和通用算法(14个)：提供元素排序策略<br>inplace_merge:      合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。<br>merge:                    合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。<br>nth_element:          将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重                                    载版本使用自定义的比较操作。<br>partial_sort:            对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。<br>partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。<br>partition:                 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。<br>random_shuffle:    对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。<br>reverse:                  将指定范围内元素重新反序排序。<br>reverse_copy:        与reverse类似，不过将结果写入另一个容器。<br>rotate:                     将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。<br>rotate_copy:           与rotate类似，不过将结果写入另一个容器。<br>sort:                         以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。<br>stable_sort:            与sort类似，不过保留相等元素之间的顺序关系。<br>stable_partition:    与partition类似，不过不保证保留容器中的相对顺序。<br>&lt;三&gt;删除和替换算法(15个)<br>copy:                    复制序列<br>copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。<br>iter_swap:           交换两个ForwardIterator的值。<br>remove:               删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和                               remove_if函数。<br>remove_copy:     将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。<br>remove_if:           删除指定范围内输入操作结果为true的所有元素。<br>remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。<br>replace:               将指定范围内所有等于vold的元素都用vnew代替。<br>replace_copy:     与replace类似，不过将结果写入另一个容器。<br>replace_if:           将指定范围内所有操作结果为true的元素用新值代替。<br>replace_copy_if: 与replace_if，不过将结果写入另一个容器。<br>swap:                   交换存储在两个对象中的值。<br>swap_range:       将指定范围内的元素与另一个序列元素值进行交换。<br>unique:                清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。<br>unique_copy:      与unique类似，不过把结果输出到另一个容器。<br>&lt;四&gt;排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合<br>next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。<br>prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用                                   自定义的比较操作。<br>&lt;五&gt;算术算法(4个)<br>accumulate:               iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的                                      二元操作符被应用到元素上。<br>partial_sum:               创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代                                      替加法。<br>inner_product:           对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义                                        的操作。<br>adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相                                      邻元素的差。<br>&lt;六&gt;生成和异变算法(6个)<br>fill:                 将输入值赋给标志范围内的所有元素。<br>fill_n:            将输入值赋给first到first+n范围内的所有元素。<br>for_each:      用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。<br>generate:      连续调用输入的函数来填充指定的范围。<br>generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。<br>transform:    将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一                        个元素来自输入的另外一个序列。结果输出到指定容器。<br>&lt;七&gt;关系算法(8个)<br>equal:                                  如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操                                               作符。<br>includes:                             判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回                                                true。重载版本使用用户输入的函数。<br>lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。<br>max:                                     返回两个元素中较大一个。重载版本使用自定义比较操作。<br>max_element:                      返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。<br>min:                                      返回两个元素中较小一个。重载版本使用自定义比较操作。<br>min_element:                       返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。<br>mismatch:                            并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。                                                 如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。<br>&lt;八&gt;集合算法(4个)<br>set_union:                            构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。<br>set_intersection:                 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。<br>set_difference:                    构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用                                                  自定义的比较操作。<br>set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。<br>&lt;九&gt;堆算法(4个)<br>make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。<br>pop_heap:   并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的                       back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。<br>push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把                       元素插入容器后。重载版本使用指定的比较操作。<br>sort_heap:  对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。</p>
<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>仿函数(functor)，就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了。<br>　　有些功能的的代码，会在不同的成员函数中用到，想复用这些代码。</p>
<p>   1）公共的函数，可以，这是一个解决方法，不过函数用到的一些变量，就可能成为公共的全局变量，再说为了复用这么一片代码，就要单立出一个函数，也不是很好维护。</p>
<p>   2）仿函数，写一个简单类，除了那些维护一个类的成员函数外，就只是实现一个operator()，在类实例化时，就将要用的，非参数的元素传入类中。</p>
<h4 id="仿函数-functor-在编程语言中的应用"><a href="#仿函数-functor-在编程语言中的应用" class="headerlink" title="仿函数(functor)在编程语言中的应用"></a>仿函数(functor)在编程语言中的应用</h4><p>1）C语言使用<strong>函数指针</strong>和<strong>回调函数</strong>来实现仿函数，例如一个用来排序的函数可以这样使用仿函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//int sort_function( const void *a, const void *b);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sort_function</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="keyword">return</span> *(<span class="keyword">int</span>*)a-*(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> list[<span class="number">5</span>] = &#123; <span class="number">54</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">22</span> &#125;;</span><br><span class="line">   <span class="built_in">qsort</span>((<span class="keyword">void</span> *)list, <span class="number">5</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(list[<span class="number">0</span>]), sort_function);<span class="comment">//起始地址，个数，元素大小，回调函数 </span></span><br><span class="line">   <span class="keyword">int</span>  x;</span><br><span class="line">   <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++)</span><br><span class="line">		  <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, list[x]);</span><br><span class="line">			      </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）在C++里，我们通过在一个类中重载括号运算符的方法使用一个函数对象而不是一个普通函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	for_each(ia, ia + <span class="number">5</span>, display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="仿函数在STL中的定义"><a href="#仿函数在STL中的定义" class="headerlink" title="仿函数在STL中的定义"></a>仿函数在STL中的定义</h4><p>要使用STL内建的仿函数，必须包含<functional>头文件。而头文件中包含的仿函数分类包括</p>
<p>​     1）算术类仿函数</p>
<p>​           加：plus<T></p>
<p>​           减：minus<T></p>
<p>​           乘：multiplies<T></p>
<p>​           除：divides<T></p>
<p>​           模取：modulus<T></p>
<p>​           否定：negate<T></p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="comment">//120</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in">accumulate</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), <span class="number">1</span>, multiplies&lt;<span class="keyword">int</span>&gt;()) &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//15</span></span><br><span class="line">	cout &lt;&lt; multiplies&lt;<span class="keyword">int</span>&gt;()(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	modulus&lt;<span class="keyword">int</span>&gt;  modulusObj;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">modulusObj</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; endl; <span class="comment">// 3 </span></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 2）关系运算类仿函数</p>
<p>​           等于：equal_to<T></p>
<p>​           不等于：not_equal_to<T></p>
<p>​           大于：greater<T></p>
<p>​           大于等于：greater_equal<T></p>
<p>​           小于：less<T></p>
<p>​           小于等于：less_equal<T></p>
<p>​          从大到小排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">display</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T &amp;x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[] = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">iv</span><span class="params">(ia, ia + <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="built_in">sort</span>(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	for_each(iv.<span class="built_in">begin</span>(), iv.<span class="built_in">end</span>(), display&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）逻辑运算仿函数</p>
<p>​             逻辑与：logical_and<T></p>
<p>​             逻辑或：logical_or<T></p>
<p>​             逻辑否：logical_no<T></p>
<p>除了使用STL内建的仿函数，还可使用自定义的仿函数，具体实例见文章3.4.7.2小结</p>
<h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>标准库提供了三种顺序容器适配器：queue(FIFO队列)、priority_queue(优先级队列)、stack(栈)</p>
<p>什么是容器适配器<br>   ”适配器是使一种事物的行为类似于另外一种事物行为的一种机制”，适配器对容器进行包装，使其表现出另外一种行为。例        如，stack&lt;int, vector<int> &gt;实现了栈的功能，但其内部使用顺序容器vector<int>来存储数据。（相当于是vector<int>表现出      了栈的行为）。</p>
<p>容器适配器<br>   要使用适配器，需要加入一下头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span>        <span class="comment">//stack</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span>       <span class="comment">//queue、priority_queue</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>种类</th>
<th>默认顺序容器</th>
<th>可用顺序容器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>stack</td>
<td>deque</td>
<td>vector、list、deque</td>
<td></td>
</tr>
<tr>
<td>queue</td>
<td>deque</td>
<td>list、deque</td>
<td>基础容器必须提供push_front()运算</td>
</tr>
<tr>
<td>priority_queue</td>
<td>vector</td>
<td>vector、deque</td>
<td>基础容器必须提供随机访问功能</td>
</tr>
</tbody></table>
<ul>
<li>定义适配器</li>
</ul>
<p> 1、初始化</p>
<p>​    stack<int> stk(dep);</p>
<p> 2、覆盖默认容器类型</p>
<p>​    stack&lt;int,vector<int> &gt; stk;</p>
<ul>
<li>使用适配器<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">stack&lt; <span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt; &gt; stk;  <span class="comment">//覆盖基础容器类型，使用vector实现stk</span></span><br><span class="line">s.<span class="built_in">empty</span>();  <span class="comment">//判断stack是否为空，为空返回true，否则返回false</span></span><br><span class="line">s.<span class="built_in">size</span>();   <span class="comment">//返回stack中元素的个数</span></span><br><span class="line">s.<span class="built_in">pop</span>();    <span class="comment">//删除栈顶元素，但不返回其值</span></span><br><span class="line">s.<span class="built_in">top</span>();    <span class="comment">//返回栈顶元素的值，但不删除此元素</span></span><br><span class="line">s.<span class="built_in">push</span>(item);   <span class="comment">//在栈顶压入新元素item</span></span><br></pre></td></tr></table></figure>

<p>实例：括号匹配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	stack&lt;<span class="keyword">char</span>&gt; ss;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : s)  <span class="comment">//C++11新标准，即遍历一次字符串s</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ss.<span class="built_in">push</span>(c);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; ss.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ss.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;					</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ss.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ss.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!ss.<span class="built_in">empty</span>() &amp;&amp; c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (ss.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ss.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag)	cout &lt;&lt; <span class="string">&quot;Match!&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;Not Match!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="queue-amp-priority-queue"><a href="#queue-amp-priority-queue" class="headerlink" title="queue &amp; priority_queue"></a>queue &amp; priority_queue</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//priority_queue&lt;int&gt; q;</span></span><br><span class="line">q.<span class="built_in">empty</span>();  <span class="comment">//判断队列是否为空</span></span><br><span class="line">q.<span class="built_in">size</span>();   <span class="comment">//返回队列长度</span></span><br><span class="line">q.<span class="built_in">push</span>(item);   <span class="comment">//对于queue，在队尾压入一个新元素</span></span><br><span class="line">               <span class="comment">//对于priority_queue，在基于优先级的适当位置插入新元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//queue only:</span></span><br><span class="line">q.<span class="built_in">front</span>();  <span class="comment">//返回队首元素的值，但不删除该元素</span></span><br><span class="line">q.<span class="built_in">back</span>();   <span class="comment">//返回队尾元素的值，但不删除该元素</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//priority_queue only:</span></span><br><span class="line">q.<span class="built_in">top</span>();    <span class="comment">//返回具有最高优先级的元素值，但不删除该元素</span></span><br></pre></td></tr></table></figure>

<h2 id="常用容器用法介绍"><a href="#常用容器用法介绍" class="headerlink" title="常用容器用法介绍"></a>常用容器用法介绍</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><h4 id="基本函数实现"><a href="#基本函数实现" class="headerlink" title="基本函数实现"></a>基本函数实现</h4><h5 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h5><p>vector():创建一个空vector<br>vector(int nSize):创建一个vector,元素个数为nSize<br>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t<br>vector(const vector&amp;):复制构造函数<br>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</p>
<h5 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h5><p>void push_back(const T&amp; x):向量尾部增加一个元素X<br>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x<br>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x<br>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</p>
<h5 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h5><p>iterator erase(iterator it):删除向量中迭代器指向元素<br>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素<br>void pop_back():删除向量中最后一个元素<br>void clear():清空向量中所有元素</p>
<h5 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h5><p>reference at(int pos):返回pos位置元素的引用<br>reference front():返回首元素的引用<br>reference back():返回尾元素的引用<br>iterator begin():返回向量头指针，指向第一个元素<br>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置<br>reverse_iterator rbegin():反向迭代器，指向最后一个元素<br>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</p>
<h5 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h5><p>bool empty() const:判断向量是否为空，若为空，则向量中无元素</p>
<h5 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h5><p>int size() const:返回向量中元素的个数<br>int capacity() const:返回当前向量张红所能容纳的最大元素值<br>int max_size() const:返回最大可允许的vector元素数量值</p>
<h5 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h5><p>void swap(vector&amp;):交换两个同类型向量的数据<br>void assign(int n,const T&amp; x):设置向量中第n个元素的值为x<br>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.push_back 在数组的最后添加一个数据</span><br><span class="line"></span><br><span class="line">2.pop_back 去掉数组的最后一个数据</span><br><span class="line"></span><br><span class="line">3.at 得到编号位置的数据</span><br><span class="line"></span><br><span class="line">4.begin 得到数组头的指针</span><br><span class="line"></span><br><span class="line">5.end 得到数组的最后一个单元+1的指针</span><br><span class="line"></span><br><span class="line">6．front 得到数组头的引用</span><br><span class="line"></span><br><span class="line">7.back 得到数组的最后一个单元的引用</span><br><span class="line"></span><br><span class="line">8.max_size 得到vector最大可以是多大</span><br><span class="line"></span><br><span class="line">9.capacity 当前vector分配的大小</span><br><span class="line"></span><br><span class="line">10.size 当前使用数据的大小</span><br><span class="line"></span><br><span class="line">11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</span><br><span class="line"></span><br><span class="line">12.reserve 改变当前vecotr所分配空间的大小</span><br><span class="line"></span><br><span class="line">13.erase 删除指针指向的数据项</span><br><span class="line"></span><br><span class="line">14.clear 清空当前的vector</span><br><span class="line"></span><br><span class="line">15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</span><br><span class="line"></span><br><span class="line">16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</span><br><span class="line"></span><br><span class="line">17.empty 判断vector是否为空</span><br><span class="line"></span><br><span class="line">18.swap 与另一个vector交换数据</span><br></pre></td></tr></table></figure>

<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; vector&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><ol>
<li><p>Vector&lt;类型&gt;标识符</p>
</li>
<li><p>Vector&lt;类型&gt;标识符(最大容量)</p>
</li>
<li><p>Vector&lt;类型&gt;标识符(最大容量,初始所有值)</p>
</li>
<li><p>Int i[5]={1,2,3,4,5} </p>
<p>Vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值</p>
</li>
<li><p>Vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</p>
</li>
</ol>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="pop-back-amp-push-back-elem-实例在容器最后移除和插入数据"><a href="#pop-back-amp-push-back-elem-实例在容器最后移除和插入数据" class="headerlink" title="pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据"></a><strong>pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据</strong></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;<span class="comment">//创建一个向量存储容器 int</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) <span class="comment">// push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)<span class="comment">//去掉数组最后一个数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)<span class="comment">//size()容器中实际数据个数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0,1,2,3,4,5,6,7,8,9,</span><br><span class="line"> </span><br><span class="line">0,1,2,3,4,</span><br></pre></td></tr></table></figure>

<h5 id="clear-清除容器中所有数据"><a href="#clear-清除容器中所有数据" class="headerlink" title="clear()清除容器中所有数据"></a><strong>clear()清除容器中所有数据</strong></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//push_back(elem)在数组最后添加数据 </span></span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    obj.<span class="built_in">clear</span>();<span class="comment">//清除容器中所以数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<p>0,1,2,3,4,5,6,7,8,9,</p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line"></span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    obj.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">sort</span>(obj.<span class="built_in">begin</span>(),obj.<span class="built_in">end</span>());<span class="comment">//从小到大</span></span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;从小到大:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;  </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;从大到小:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">reverse</span>(obj.<span class="built_in">begin</span>(),obj.<span class="built_in">end</span>());<span class="comment">//从大到小 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obj.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从小到大:</span><br><span class="line">0,1,3,</span><br><span class="line"></span><br><span class="line">从大到小:</span><br><span class="line">3,1,0,</span><br></pre></td></tr></table></figure>

<p>1.注意 sort 需要头文件 #include <algorithm></p>
<p>2.如果想 sort 来降序，可重写 sort</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a&lt; b; <span class="comment">//升序排列，如果改为return a&gt;b，则为降序 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">76</span>,<span class="number">0</span>,<span class="number">43</span>,<span class="number">24</span>,<span class="number">65</span>&#125;,i; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) </span><br><span class="line">    cout&lt;&lt; a[i]&lt;&lt; endl; </span><br><span class="line"><span class="built_in">sort</span>(a,a+<span class="number">20</span>,compare);</span><br></pre></td></tr></table></figure>

<h5 id="访问（直接数组访问-amp-迭代器访问）"><a href="#访问（直接数组访问-amp-迭代器访问）" class="headerlink" title="访问（直接数组访问&amp;迭代器访问）"></a>访问（直接数组访问&amp;迭代器访问）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//顺序访问</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;obj;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        obj.<span class="built_in">push_back</span>(i);   </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;直接利用数组：&quot;</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="comment">//方法一 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;obj[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;利用迭代器：&quot;</span> ;</span><br><span class="line">    <span class="comment">//方法二，使用迭代器将容器中数据输出 </span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 </span></span><br><span class="line">    <span class="keyword">for</span>(it=obj.<span class="built_in">begin</span>();it!=obj.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接利用数组：0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">利用迭代器：0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<h5 id="二维数组两种定义方法（结果一样）"><a href="#二维数组两种定义方法（结果一样）" class="headerlink" title="二维数组两种定义方法（结果一样）"></a>二维数组两种定义方法（结果一样）</h5><p>方法一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">obj</span>(N); <span class="comment">//定义二维动态数组大小5行 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//动态二维数组为5行6列，值全为0 </span></span><br><span class="line">    &#123; </span><br><span class="line">        obj[i].<span class="built_in">resize</span>(M); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">5</span>, M=<span class="number">6</span>; </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">obj</span>(N, vector&lt;<span class="keyword">int</span>&gt;(M)); <span class="comment">//定义二维动态数组5行6列 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; obj.<span class="built_in">size</span>(); i++)<span class="comment">//输出二维动态数组 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obj[i].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br><span class="line">0 0 0 0 0 0 </span><br></pre></td></tr></table></figure>

<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>所谓的deque是”double ended queue”的缩写，双端队列不论在尾部或头部插入元素，都十分迅速。而在中间插入元素则会比较费时，因为必须移动中间其他的元素。双端队列是一种随机访问的数据类型，提供了在序列两端快速插入和删除操作的功能，它可以在需要的时候改变自身大小，完成了标准的C++数据结构中队列的所有功能。 </p>
<p>Vector是单向开口的连续线性空间，deque则是一种双向开口的连续线性空间。deque对象在队列的两端放置元素和删除元素是高效的，而向量vector只是在插入序列的末尾时操作才是高效的。deque和vector的最大差异，一在于deque允许于常数时间内对头端进行元素的插入或移除操作，二在于deque没有所谓的capacity观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像vector那样“因旧空间不足而重新配置一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque中是不会发生的。也因此，deque没有必要提供所谓的空间预留（reserved）功能。 </p>
<p>虽然deque也提供Random Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector不可同日而语，这当然涉及到各个运算层面。因此，除非必要，我们应尽可能选择使用vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整复制到一个vector身上，将vector排序后（利用STL的sort算法），再复制回deque。 </p>
<p>deque是一种优化了的对序列两端元素进行添加和删除操作的基本序列容器。通常由一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展。它允许较为快速地随机访问但它不像vector一样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。</p>
<h4 id="声明deque容器"><a href="#声明deque容器" class="headerlink" title="声明deque容器"></a>声明deque容器</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span>  <span class="comment">// 头文件</span></span></span><br><span class="line">deque&lt;type&gt; deq;  <span class="comment">// 声明一个元素类型为type的双端队列que</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(size)</span></span>;  <span class="comment">// 声明一个类型为type、含有size个默认值初始化元素的的双端队列que</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(size, value)</span></span>;  <span class="comment">// 声明一个元素类型为type、含有size个value元素的双端队列que</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(mydeque)</span></span>;  <span class="comment">// deq是mydeque的一个副本</span></span><br><span class="line"><span class="function">deque&lt;type&gt; <span class="title">deq</span><span class="params">(first, last)</span></span>;  <span class="comment">// 使用迭代器first、last范围内的元素初始化deq</span></span><br></pre></td></tr></table></figure>

<h4 id="deque的常用成员函数"><a href="#deque的常用成员函数" class="headerlink" title="deque的常用成员函数"></a>deque的常用成员函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">deq[ ]：用来访问双向队列中单个的元素。</span><br><span class="line">deq.<span class="built_in">front</span>()：返回第一个元素的引用。</span><br><span class="line">deq.<span class="built_in">back</span>()：返回最后一个元素的引用。</span><br><span class="line">deq.<span class="built_in">push_front</span>(x)：把元素x插入到双向队列的头部。</span><br><span class="line">deq.<span class="built_in">pop_front</span>()：弹出双向队列的第一个元素。</span><br><span class="line">deq.<span class="built_in">push_back</span>(x)：把元素x插入到双向队列的尾部。</span><br><span class="line">deq.<span class="built_in">pop_back</span>()：弹出双向队列的最后一个元素。</span><br></pre></td></tr></table></figure>

<h4 id="deque的一些特点"><a href="#deque的一些特点" class="headerlink" title="deque的一些特点"></a>deque的一些特点</h4><p>支持随机访问，即支持[ ]以及at()，但是性能没有vector好。<br>可以在内部进行插入和删除操作，但性能不及list。<br>deque两端都能够快速插入和删除元素，而vector只能在尾端进行。<br>deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。<br>deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。<br>deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。<br>deque不支持对容量和内存分配时机的控制。<br>在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。<br>deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。<br>deque不提供容量操作：capacity()和reverse()，但是vector可以。</p>
<h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">			q.<span class="built_in">push_front</span>(a[i]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	&#125;                                  <span class="comment">/*此时队列里的内容是: &#123;8,6,4,2,0,1,3,5,7,9&#125;*/</span></span><br><span class="line">	q.<span class="built_in">pop_front</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">front</span>());    <span class="comment">/*清除第一个元素后输出第一个(6)*/</span></span><br><span class="line">	q.<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, q.<span class="built_in">back</span>());     <span class="comment">/*清除最后一个元素后输出最后一个(7)*/</span></span><br><span class="line">	deque&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = q.<span class="built_in">begin</span>(); it != q.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/cpp_dequeue_output.png" alt="img"></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><h4 id="list定义"><a href="#list定义" class="headerlink" title="list定义"></a>list定义</h4><p>List是stl实现的双向链表，与向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢。使用时需要添加头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="list定义和初始化"><a href="#list定义和初始化" class="headerlink" title="list定义和初始化"></a>list定义和初始化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> list&lt;int&gt;lst1;          //创建空list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt; lst2(5);       //创建含有5个元素的list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst3(3,2);  //创建含有3个元素的list</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst4(lst2);    //使用lst2初始化lst4</span><br><span class="line"></span><br><span class="line">list&lt;int&gt;lst5(lst2.begin(),lst2.end());  //同lst4</span><br></pre></td></tr></table></figure>

<h4 id="list常用操作函数"><a href="#list常用操作函数" class="headerlink" title="list常用操作函数"></a>list常用操作函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lst1.assign() 给list赋值 </span><br><span class="line">Lst1.back() 返回最后一个元素 </span><br><span class="line">Lst1.begin() 返回指向第一个元素的迭代器 </span><br><span class="line">Lst1.clear() 删除所有元素 </span><br><span class="line">Lst1.empty() 如果list是空的则返回true </span><br><span class="line">Lst1.end() 返回末尾的迭代器 </span><br><span class="line">Lst1.erase() 删除一个元素 </span><br><span class="line">Lst1.front() 返回第一个元素 </span><br><span class="line">Lst1.get_allocator() 返回list的配置器 </span><br><span class="line">Lst1.insert() 插入一个元素到list中 </span><br><span class="line">Lst1.max_size() 返回list能容纳的最大元素数量 </span><br><span class="line">Lst1.merge() 合并两个list </span><br><span class="line">Lst1.pop_back() 删除最后一个元素 </span><br><span class="line">Lst1.pop_front() 删除第一个元素 </span><br><span class="line">Lst1.push_back() 在list的末尾添加一个元素 </span><br><span class="line">Lst1.push_front() 在list的头部添加一个元素 </span><br><span class="line">Lst1.rbegin() 返回指向第一个元素的逆向迭代器 </span><br><span class="line">Lst1.remove() 从list删除元素 </span><br><span class="line">Lst1.remove_if() 按指定条件删除元素 </span><br><span class="line">Lst1.rend() 指向list末尾的逆向迭代器 </span><br><span class="line">Lst1.resize() 改变list的大小 </span><br><span class="line">Lst1.reverse() 把list的元素倒转 </span><br><span class="line">Lst1.size() 返回list中的元素个数 </span><br><span class="line">Lst1.sort() 给list排序 </span><br><span class="line">Lst1.splice() 合并两个list </span><br><span class="line">Lst1.swap() 交换两个list </span><br><span class="line">Lst1.unique() 删除list中相邻重复的元素</span><br></pre></td></tr></table></figure>

<h4 id="List使用实例"><a href="#List使用实例" class="headerlink" title="List使用实例"></a>List使用实例</h4><h5 id="迭代器遍历list"><a href="#迭代器遍历list" class="headerlink" title="迭代器遍历list"></a>迭代器遍历list</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(list&lt;<span class="keyword">int</span>&gt;::const_iteratoriter = lst1.<span class="built_in">begin</span>();iter != lst1.<span class="built_in">end</span>();iter++)</span><br><span class="line">    &#123;</span><br><span class="line">      cout&lt;&lt;*iter;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h5 id="综合实例1"><a href="#综合实例1" class="headerlink" title="综合实例1"></a>综合实例1</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef list&lt;int&gt; LISTINT;</span><br><span class="line">typedef list&lt;int&gt; LISTCHAR;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	//用LISTINT创建一个list对象</span><br><span class="line">	LISTINT listOne;</span><br><span class="line">	//声明i为迭代器</span><br><span class="line">	LISTINT::iterator i;</span><br><span class="line"></span><br><span class="line">    listOne.push_front(3);</span><br><span class="line">    listOne.push_front(2);</span><br><span class="line">    listOne.push_front(1);</span><br><span class="line"></span><br><span class="line">    listOne.push_back(4);</span><br><span class="line">    listOne.push_back(5);</span><br><span class="line">    listOne.push_back(6);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;listOne.begin()--- listOne.end():&quot; &lt;&lt; endl;</span><br><span class="line">    for (i = listOne.begin(); i != listOne.end(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    LISTINT::reverse_iterator ir;</span><br><span class="line">    cout &lt;&lt; &quot;listOne.rbegin()---listOne.rend():&quot; &lt;&lt; endl;</span><br><span class="line">    for (ir = listOne.rbegin(); ir != listOne.rend(); ir++) &#123;</span><br><span class="line">        cout &lt;&lt; *ir &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    int result = accumulate(listOne.begin(), listOne.end(), 0);</span><br><span class="line">    cout &lt;&lt; &quot;Sum=&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    //用LISTCHAR创建一个list对象</span><br><span class="line">    LISTCHAR listTwo;</span><br><span class="line">    //声明i为迭代器</span><br><span class="line">    LISTCHAR::iterator j;</span><br><span class="line"></span><br><span class="line">    listTwo.push_front(&#x27;C&#x27;);</span><br><span class="line">    listTwo.push_front(&#x27;B&#x27;);</span><br><span class="line">    listTwo.push_front(&#x27;A&#x27;);</span><br><span class="line"></span><br><span class="line">    listTwo.push_back(&#x27;D&#x27;);</span><br><span class="line">    listTwo.push_back(&#x27;E&#x27;);</span><br><span class="line">    listTwo.push_back(&#x27;F&#x27;);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;listTwo.begin()---listTwo.end():&quot; &lt;&lt; endl;</span><br><span class="line">    for (j = listTwo.begin(); j != listTwo.end(); ++j)</span><br><span class="line">        cout &lt;&lt; char(*j) &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    j = max_element(listTwo.begin(), listTwo.end());</span><br><span class="line">    cout &lt;&lt; &quot;The maximum element in listTwo is: &quot; &lt;&lt; char(*j) &lt;&lt; endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img src="/images/cpp_list_output1.png" alt="img"></p>
<h5 id="综合实例2"><a href="#综合实例2" class="headerlink" title="综合实例2"></a>综合实例2</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> list&lt;<span class="keyword">int</span>&gt; INTLIST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从前向后显示list队列的全部元素 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_list</span><span class="params">(INTLIST list, <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	INTLIST::iterator plist;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The contents of &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; : &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (plist = list.<span class="built_in">begin</span>(); plist != list.<span class="built_in">end</span>(); plist++)</span><br><span class="line">	cout &lt;&lt; *plist &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试list容器的功能 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//list1对象初始为空 </span></span><br><span class="line">	INTLIST list1;</span><br><span class="line">	<span class="function">INTLIST <span class="title">list2</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">INTLIST <span class="title">list3</span><span class="params">(list2.begin(), --list2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明一个名为i的双向迭代器 </span></span><br><span class="line">    INTLIST::iterator i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">    <span class="built_in">put_list</span>(list2, <span class="string">&quot;list2&quot;</span>);</span><br><span class="line">    <span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list1.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    list1.<span class="built_in">push_back</span>(<span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.push_back(7) and list1.push_back(8):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list1.<span class="built_in">push_front</span>(<span class="number">6</span>);</span><br><span class="line">    list1.<span class="built_in">push_front</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.push_front(6) and list1.push_front(5):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list1.<span class="built_in">insert</span>(++list1.<span class="built_in">begin</span>(), <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.insert(list1.begin()+1,3,9):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试引用类函数 </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.front()=&quot;</span> &lt;&lt; list1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.back()=&quot;</span> &lt;&lt; list1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list1.<span class="built_in">pop_front</span>();</span><br><span class="line">    list1.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.pop_front() and list1.pop_back():&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list1.<span class="built_in">erase</span>(++list1.<span class="built_in">begin</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.erase(++list1.begin()):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list2.<span class="built_in">assign</span>(<span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list2.assign(8,1):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">put_list</span>(list2, <span class="string">&quot;list2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.max_size(): &quot;</span> &lt;&lt; list1.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.size(): &quot;</span> &lt;&lt; list1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1.empty(): &quot;</span> &lt;&lt; list1.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">    <span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1&gt;list3: &quot;</span> &lt;&lt; (list1 &gt; list3) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;list1&lt;list3: &quot;</span> &lt;&lt; (list1 &lt; list3) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    list1.<span class="built_in">sort</span>();</span><br><span class="line">    <span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list1.<span class="built_in">splice</span>(++list1.<span class="built_in">begin</span>(), list3);</span><br><span class="line">    <span class="built_in">put_list</span>(list1, <span class="string">&quot;list1&quot;</span>);</span><br><span class="line">    <span class="built_in">put_list</span>(list3, <span class="string">&quot;list3&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="/images/cpp_list_output2.png" alt="img"></p>
<h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map/multimap"></a>map/multimap</h3><p>map和multimap都需要#include<map>，唯一的不同是，map的键值key不可重复，而multimap可以，也正是由于这种区别，map支持[ ]运算符，multimap不支持[ ]运算符。在用法上没什么区别。</p>
<p>C++中map提供的是一种键值对容器，里面的数据都是成对出现的,如下图：每一对中的第一个值称之为关键字(key)，每个关键字只能在map中出现一次；第二个称之为该关键字的对应值。</p>
<p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。</p>
<h4 id="基本操作函数"><a href="#基本操作函数" class="headerlink" title="基本操作函数"></a>基本操作函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin()         返回指向map头部的迭代器</span><br><span class="line"></span><br><span class="line">clear(）        删除所有元素</span><br><span class="line"></span><br><span class="line">count()         返回指定元素出现的次数</span><br><span class="line"></span><br><span class="line">empty()         如果map为空则返回true</span><br><span class="line"></span><br><span class="line">end()           返回指向map末尾的迭代器</span><br><span class="line"></span><br><span class="line">equal_range()   返回特殊条目的迭代器对</span><br><span class="line"></span><br><span class="line">erase()         删除一个元素</span><br><span class="line"></span><br><span class="line">find()          查找一个元素</span><br><span class="line"></span><br><span class="line">get_allocator() 返回map的配置器</span><br><span class="line"></span><br><span class="line">insert()        插入元素</span><br><span class="line"></span><br><span class="line">key_comp()      返回比较元素key的函数</span><br><span class="line"></span><br><span class="line">lower_bound()   返回键值&gt;=给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">max_size()      返回可以容纳的最大元素个数</span><br><span class="line"></span><br><span class="line">rbegin()        返回一个指向map尾部的逆向迭代器</span><br><span class="line"></span><br><span class="line">rend()          返回一个指向map头部的逆向迭代器</span><br><span class="line"></span><br><span class="line">size()          返回map中元素的个数</span><br><span class="line"></span><br><span class="line">swap()           交换两个map</span><br><span class="line"></span><br><span class="line">upper_bound()    返回键值&gt;给定元素的第一个位置</span><br><span class="line"></span><br><span class="line">value_comp()     返回比较元素value的函数</span><br></pre></td></tr></table></figure>

<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt; ID_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用&#123;&#125;赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012</span></span><br><span class="line">map&lt;<span class="keyword">int</span>, string&gt; ID_Name = &#123;</span><br><span class="line">                &#123; <span class="number">2015</span>, <span class="string">&quot;Jim&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="number">2016</span>, <span class="string">&quot;Tom&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="number">2017</span>, <span class="string">&quot;Bob&quot;</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>共有八个获取迭代器的函数：* begin, end, rbegin,rend* 以及对应的 * cbegin, cend, crbegin,crend*。</p>
<p>二者的区别在于，后者一定返回 const_iterator，而前者则根据map的类型返回iterator 或者 const_iterator。const情况下，不允许对值进行修改。如下面代码所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mmap;</span><br><span class="line"><span class="keyword">const</span> map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; const_mmap;</span><br><span class="line"></span><br><span class="line">it = mmap.<span class="built_in">begin</span>(); <span class="comment">//iterator</span></span><br><span class="line">mmap.<span class="built_in">cbegin</span>(); <span class="comment">//const_iterator</span></span><br><span class="line"></span><br><span class="line">const_mmap.<span class="built_in">begin</span>(); <span class="comment">//const_iterator</span></span><br><span class="line">const_mmap.<span class="built_in">cbegin</span>(); <span class="comment">//const_iterator</span></span><br></pre></td></tr></table></figure>

<p>返回的迭代器可以进行加减操作，此外，如果map为空，则 begin = end。</p>
<p><img src="/images/cpp_iterator_desc.png" alt="12413423523534"></p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><h5 id="用insert插入pair数据"><a href="#用insert插入pair数据" class="headerlink" title="用insert插入pair数据"></a>用insert插入pair数据</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据的插入--第一种：用insert函数插入pair数据  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));  </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;  </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)  </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h5 id="用insert函数插入value-type数据"><a href="#用insert函数插入value-type数据" class="headerlink" title="用insert函数插入value_type数据"></a>用insert函数插入value_type数据</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种：用insert函数插入value_type数据，下面举例说明  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));    </span><br><span class="line">    mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;    </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)  </span><br><span class="line">         cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h5 id="用insert函数进行多个插入"><a href="#用insert函数进行多个插入" class="headerlink" title="用insert函数进行多个插入"></a>用insert函数进行多个插入</h5><p>insert共有4个重载函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 插入单个键值对，并返回插入位置和成功标志，插入位置已经存在值时，插入失败</span><br><span class="line">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class="line"></span><br><span class="line">//在指定位置插入，在不同位置插入效率是不一样的，因为涉及到重排</span><br><span class="line">iterator insert (const_iterator position, const value_type&amp; val);</span><br><span class="line"></span><br><span class="line">// 插入多个</span><br><span class="line">void insert (InputIterator first, InputIterator last);</span><br><span class="line"></span><br><span class="line">//c++11开始支持，使用列表插入多个   </span><br><span class="line">void insert (initializer_list&lt;value_type&gt; il);</span><br></pre></td></tr></table></figure>

<p>下面是具体使用示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入单个值</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;z&#x27;</span>, <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回插入位置以及是否插入成功</span></span><br><span class="line">    std::pair&lt;std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;z&#x27;</span>, <span class="number">500</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret.second == <span class="literal">false</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;element &#x27;z&#x27; already existed&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; with a value of &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定位置插入</span></span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    mymap.<span class="built_in">insert</span>(it, std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;b&#x27;</span>, <span class="number">300</span>));  <span class="comment">//效率更高</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(it, std::pair&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;(<span class="string">&#x27;c&#x27;</span>, <span class="number">400</span>));  <span class="comment">//效率非最高</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//范围多值插入</span></span><br><span class="line">    std::map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; anothermap;</span><br><span class="line">    anothermap.<span class="built_in">insert</span>(mymap.<span class="built_in">begin</span>(), mymap.<span class="built_in">find</span>(<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 列表形式插入</span></span><br><span class="line">    anothermap.<span class="built_in">insert</span>(&#123; &#123; <span class="string">&#x27;d&#x27;</span>, <span class="number">100</span> &#125;, &#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">200</span>&#125; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用数组方式插入数据"><a href="#用数组方式插入数据" class="headerlink" title="用数组方式插入数据"></a>用数组方式插入数据</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三种：用数组方式插入数据，下面举例说明  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>;   </span><br><span class="line">    mapStudent[<span class="number">2</span>] = <span class="string">&quot;student_two&quot;</span>;    </span><br><span class="line">    mapStudent[<span class="number">3</span>] = <span class="string">&quot;student_three&quot;</span>;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;    </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)    </span><br><span class="line">        cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br><span class="line"></span><br><span class="line">mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_two&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>上面这两条语句执行后，map中1这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;map&lt;<span class="keyword">int</span>, string&gt;::iterator, <span class="keyword">bool</span>&gt; Insert_Pair;</span><br><span class="line"></span><br><span class="line">Insert_Pair = mapStudent.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, string&gt;::<span class="built_in">value_type</span> (<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p>
<p>下面给出完成代码，演示插入成功与否问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证插入函数的作用效果  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;  </span><br><span class="line">    pair&lt;map&lt;<span class="keyword">int</span>, string&gt;::iterator, <span class="keyword">bool</span>&gt; Insert_Pair;    </span><br><span class="line">    Insert_Pair = mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));    </span><br><span class="line">    <span class="keyword">if</span>(Insert_Pair.second == <span class="literal">true</span>)  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Successfully&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Failure&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    Insert_Pair = mapStudent.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_two&quot;</span>));    </span><br><span class="line">    <span class="keyword">if</span>(Insert_Pair.second == <span class="literal">true</span>)    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Successfully&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Insert Failure&quot;</span>&lt;&lt;endl;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;   </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)    </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p> 大家可以用如下程序，看下用数组插入在数据覆盖上的效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//验证数组形式插入数据的效果   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>    </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt; mapStudent;    </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_one&quot;</span>;    </span><br><span class="line">    mapStudent[<span class="number">1</span>] = <span class="string">&quot;student_two&quot;</span>;    </span><br><span class="line">    mapStudent[<span class="number">2</span>] = <span class="string">&quot;student_three&quot;</span>;    </span><br><span class="line">    map&lt;<span class="keyword">int</span>, string&gt;::iterator iter;    </span><br><span class="line">    <span class="keyword">for</span>(iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)    </span><br><span class="line">       cout&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;iter-&gt;second&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="查找、删除、交换"><a href="#查找、删除、交换" class="headerlink" title="查找、删除、交换"></a>查找、删除、交换</h4><p>查找</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关键字查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器</span></span><br><span class="line"><span class="comment">// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span> <span class="params">(<span class="keyword">const</span> key_type&amp; k)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>

<p> 删除</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator pos )</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 删除一定范围内的元素，并返回一个指向下一元素的迭代器</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">erase</span><span class="params">( <span class="keyword">const</span> key_type&amp; key )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空map，清空后的size为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>交换 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就是两个map的内容互换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( map&amp; other )</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询map是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询map中键值对的数量</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询map所能包含的最大键值对数量，和系统和应用库有关。</span></span><br><span class="line"><span class="comment">// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">max_size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询关键字为key的元素的个数，在map里结果非0即1</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">count</span><span class="params">( <span class="keyword">const</span> Key&amp; key )</span> <span class="keyword">const</span></span>; <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p>map中的元素是自动按Key升序排序，所以不能对map用sort函数；</p>
<p>这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int 型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体或者自定义类，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过 不去，下面给出两个方法解决这个问题。</p>
<h5 id="小于号-lt-重载"><a href="#小于号-lt-重载" class="headerlink" title="小于号 &lt; 重载"></a>小于号 &lt; 重载</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagStudentinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>      niD;</span><br><span class="line">	string   strName;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (tagStudentinfo <span class="keyword">const</span>&amp; _A) <span class="keyword">const</span></span><br><span class="line">	&#123;     <span class="comment">//这个函数指定排序策略，按niD排序，如果niD相等的话，按strName排序  </span></span><br><span class="line">		<span class="keyword">if</span> (niD &lt; _A.niD) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (niD == _A.niD)</span><br><span class="line">			<span class="keyword">return</span> strName.<span class="built_in">compare</span>(_A.strName) &lt; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Studentinfo, *PStudentinfo; <span class="comment">//学生信息  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nSize;   <span class="comment">//用学生信息映射分数  </span></span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>&gt;mapStudent;</span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">	Studentinfo studentinfo;</span><br><span class="line">	studentinfo.niD = <span class="number">1</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">90</span>));</span><br><span class="line">	studentinfo.niD = <span class="number">2</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">80</span>));</span><br><span class="line">	<span class="keyword">for</span> (iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)</span><br><span class="line">		cout &lt;&lt; iter-&gt;first.niD &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;first.strName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="仿函数的应用，这个时候结构体中没有直接的小于号重载"><a href="#仿函数的应用，这个时候结构体中没有直接的小于号重载" class="headerlink" title="仿函数的应用，这个时候结构体中没有直接的小于号重载"></a>仿函数的应用，这个时候结构体中没有直接的小于号重载</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagStudentinfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span>      niD;</span><br><span class="line">	string   strName;</span><br><span class="line">&#125;Studentinfo, *PStudentinfo; <span class="comment">//学生信息  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Studentinfo <span class="keyword">const</span> &amp;_A, Studentinfo <span class="keyword">const</span> &amp;_B)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (_A.niD &lt; _B.niD)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (_A.niD == _B.niD)</span><br><span class="line">			<span class="keyword">return</span> _A.strName.<span class="built_in">compare</span>(_B.strName) &lt; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	<span class="comment">//用学生信息映射分数  </span></span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>, sort&gt;mapStudent;</span><br><span class="line">	map&lt;Studentinfo, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">	Studentinfo studentinfo;</span><br><span class="line">	studentinfo.niD = <span class="number">1</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_one&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">90</span>));</span><br><span class="line">	studentinfo.niD = <span class="number">2</span>;</span><br><span class="line">	studentinfo.strName = <span class="string">&quot;student_two&quot;</span>;</span><br><span class="line">	mapStudent.<span class="built_in">insert</span>(pair&lt;Studentinfo, <span class="keyword">int</span>&gt;(studentinfo, <span class="number">80</span>));</span><br><span class="line">	<span class="keyword">for</span> (iter = mapStudent.<span class="built_in">begin</span>(); iter != mapStudent.<span class="built_in">end</span>(); iter++)</span><br><span class="line">		cout &lt;&lt; iter-&gt;first.niD &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;first.strName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><p>在c++11标准前，c++标准库中只有一种map，但是它的底层实现并不是适合所有的场景，如果我们需要其他适合的map实现就不得不使用比如boost库等三方的实现，在c++11中加了一种map unordered_map,unordered_set,他们的实现有什么不同呢？</p>
<p>   map底层采用的是红黑树的实现查询的时间复杂度为O(logn),看起来并没有unordered_map快，但是也要看实际的数据量，虽然unordered_map的查询从算法上分析比map快，但是它有一些其它的消耗，比如哈希函数的构造和分析，还有如果出现哈希冲突解决哈希冲突等等都有一定的消耗，因此unordered_map的效率在很大的程度上由它的hash函数算法决定，而红黑树的效率是一个稳定值。</p>
<p>   unordered_map的底层采用哈希表的实现，查询的时间复杂度为是O(1)。所以unordered_map内部就是无序的，数据是按散列函数插入到槽里面去的，数据之间无顺序可言，如果我们不需要内部有序，这种实现是没有问题的。unordered_map属于关联式容器，采用std::pair保存key-value形式的数据。用法与map一致。特别的是，STL中的map因为是有序的二叉树存储，所以对key值需要有大小的判断，当使用内置类型时，无需重载operator &lt; ；但是用用户自定义类型的话，就需要重载operator &lt; 。 unoredered_map全程使用不需要比较元素的key值的大小，但是，对于元素的==要有判断，又因为需要使用hash映射，所以，对于非内部类型，需要程序员为其定义这二者的内容，对于内部类型，就不需要了。unordered库使用“桶”来存储元素，散列值相同的被存储在一个桶里。当散列容器中有大量数据时，同一个桶里的数据也会增多，造成访问冲突，降低性能。为了提高散列容器的性能，unordered库会在插入元素是自动增加桶的数量，不需要用户指定。但是，用户也可以在构造函数或者rehash()函数中，指定最小的桶的数量。</p>
<p>   还有另外一点从占用内存上来说因为unordered_map才用hash结构会有一定的内存损失，它的内存占用回高于map。</p>
<p>   最后就是她们的场景了，首先如果你需要对map中的数据排序，就首选map，他会把你的数据按照key的自然排序排序（由于它的底层实现红黑树机制所以会排序），如果不需要排序，就看你对内存和cpu的选择了，不过一般都会选择unordered_map，它的查找效率会更高。</p>
<p>至于使用方法和函数，两者差不多，由于篇幅限制这里不再赘述，unordered_multimap用法亦可类推。</p>
<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set/multiset"></a>set/multiset</h3><p>std::set 是关联容器，含有 Key 类型对象的已排序集。用比较函数compare进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。</p>
<p>set容器内的元素会被自动排序，set与map不同，set中的元素即是键值又是实值，set不允许两个元素有相同的键值。不能通过set的迭代器去修改set元素，原因是修改元素会破坏set组织。当对容器中的元素进行插入或者删除时，操作之前的所有迭代器在操作之后依然有效。</p>
<p>由于set元素是排好序的，且默认为升序，因此当set集合中的元素为结构体或自定义类时，该结构体或自定义类必须实现运算符‘&lt;’的重载。</p>
<p>　　multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。</p>
<p>　　set和multiset的底层实现是一种高效的平衡二叉树，即红黑树（Red-Black Tree）。</p>
<h4 id="set常用成员函数"><a href="#set常用成员函数" class="headerlink" title="set常用成员函数"></a>set常用成员函数</h4> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. begin()--返回指向第一个元素的迭代器</span><br><span class="line"></span><br><span class="line">2. clear()--清除所有元素</span><br><span class="line"></span><br><span class="line">3. count()--返回某个值元素的个数</span><br><span class="line"></span><br><span class="line">4. empty()--如果集合为空，返回true</span><br><span class="line"></span><br><span class="line">5. end()--返回指向最后一个元素的迭代器</span><br><span class="line"></span><br><span class="line">6. equal_range()--返回集合中与给定值相等的上下限的两个迭代器</span><br><span class="line"></span><br><span class="line">7. erase()--删除集合中的元素</span><br><span class="line"></span><br><span class="line">8. find()--返回一个指向被查找到元素的迭代器</span><br><span class="line"></span><br><span class="line">9. get_allocator()--返回集合的分配器</span><br><span class="line"></span><br><span class="line">10. insert()--在集合中插入元素</span><br><span class="line"></span><br><span class="line">11. lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器</span><br><span class="line"></span><br><span class="line">12. key_comp()--返回一个用于元素间值比较的函数</span><br><span class="line"></span><br><span class="line">13. max_size()--返回集合能容纳的元素的最大限值</span><br><span class="line"></span><br><span class="line">14. rbegin()--返回指向集合中最后一个元素的反向迭代器</span><br><span class="line"></span><br><span class="line">15. rend()--返回指向集合中第一个元素的反向迭代器</span><br><span class="line"></span><br><span class="line">16. size()--集合中元素的数目</span><br><span class="line"></span><br><span class="line">17. swap()--交换两个集合变量</span><br><span class="line"></span><br><span class="line">18. upper_bound()--返回大于某个值元素的迭代器</span><br><span class="line"></span><br><span class="line">19. value_comp()--返回一个用于比较元素间的值的函数</span><br></pre></td></tr></table></figure>

<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p> 以下代码涉及的内容：<br>1、set容器中，元素类型为基本类型，如何让set按照用户意愿来排序？</p>
<p>2、set容器中，如何让元素类型为自定义类型？</p>
<p>3、set容器的insert函数的返回值为什么类型？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仿函数CompareSet，在test02使用 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareSet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    <span class="comment">//bool operator()(int v1, int v2)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    return v1 &lt; v2;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person类，用于test03 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Person &amp;person);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Person &amp;person)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; person.mName &lt;&lt; <span class="string">&quot; age:&quot;</span> &lt;&lt; person.mAge &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仿函数ComparePerson,用于test03 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//名字大的在前面，如果名字相同，年龄大的排前面</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.mName == p2.mName)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> p1.mAge &gt; p2.mAge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.mName &gt; p2.mName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印set类型的函数模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSet</span><span class="params">(T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//set容器默认从小到大排序</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">    <span class="comment">//结果为:10 20 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set的insert函数返回值为一个对组(pair)。</span></span><br><span class="line"><span class="comment">       对组的第一个值first为set类型的迭代器：</span></span><br><span class="line"><span class="comment">       1、若插入成功，迭代器指向该元素。</span></span><br><span class="line"><span class="comment">       2、若插入失败，迭代器指向之前已经存在的元素</span></span><br><span class="line"><span class="comment">       对组的第二个值seconde为bool类型：</span></span><br><span class="line"><span class="comment">       1、若插入成功，bool值为true</span></span><br><span class="line"><span class="comment">       2、若插入失败，bool值为false</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = s.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == ret.second)</span><br><span class="line">        cout &lt;&lt; *ret.first &lt;&lt; <span class="string">&quot; 插入成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; *ret.first &lt;&lt; <span class="string">&quot; 插入失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 如果想让set容器从大到小排序，需要给set容</span></span><br><span class="line"><span class="comment">       器提供一个仿函数,本例的仿函数为CompareSet</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    set&lt;<span class="keyword">int</span>, CompareSet&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line">    <span class="comment">//结果为:30,20,10</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* set元素类型为Person，当set元素类型为自定义类型的时候</span></span><br><span class="line"><span class="comment">       必须给set提供一个仿函数，用于比较自定义类型的大小，</span></span><br><span class="line"><span class="comment">       否则无法通过编译 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    set&lt;Person,ComparePerson&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">25</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Marry&quot;</span>, <span class="number">18</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="string">&quot;Peter&quot;</span>, <span class="number">36</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印set</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="comment">//test02();</span></span><br><span class="line">    <span class="comment">//test03();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>multiset容器的insert函数返回值为什么？ </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印set类型的函数模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSet</span><span class="params">(T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印multiset</span></span><br><span class="line">    <span class="built_in">PrintSet</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* multiset的insert函数返回值为multiset类型的迭代器，</span></span><br><span class="line"><span class="comment">       指向新插入的元素。multiset允许插入相同的值，因此</span></span><br><span class="line"><span class="comment">       插入一定成功，因此不需要返回bool类型。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    multiset&lt;<span class="keyword">int</span>&gt;::iterator iter = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h4><p>C++ 11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)，由于unordered_set和unordered_map内部实现的公共接口大致相同，所以本文以unordered_set为例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_set是基于哈希表，因此要了解unordered_set，就必须了解哈希表的机制。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。比如：现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在[0，200]，所以可以开一个200大小的数组，然后通过哈希函数得到key对应的key-value，这样就能完成统计某个年龄的员工个数。而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如：名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。准确来说，冲突是不可避免的，而解决冲突的方法常见的有：开发地址法、再散列法、链地址法(也称拉链法)。而unordered_set内部解决冲突采用的是----链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。下图展示了链地址法的使用:</span><br></pre></td></tr></table></figure>

<p><img src="/images/cpp_unorder_set_hash.png" alt="img"></p>
<p>使用unordered_set需要包含#include<unordered_set>头文件，同unordered_map类似，用法没有什么太大的区别，参考set/multiset。</p>
<p>除此之外unordered_multiset也是一种可选的容器。</p>
<p>转载：<br>原文链接：<a href="https://blog.csdn.net/u010183728/article/details/81913729">https://blog.csdn.net/u010183728/article/details/81913729</a></p>
<p>reference：</p>
<p><a href="http://www.runoob.com/w3cnote/cpp-vector-container-analysis.html">http://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a></p>
<p><a href="https://blog.csdn.net/tianshuai1111/article/details/7687983">https://blog.csdn.net/tianshuai1111/article/details/7687983</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Touch事件分发机制</title>
    <url>/2017/01/11/android_touch_dispatch/</url>
    <content><![CDATA[<p>Android Touch事件的分发是 Android 工程师必备技能之一。手指触摸屏幕时，即产生了触摸信息。这个触摸信息由屏幕这个硬件产生，被系统底层驱动获取，交给Android的输入系统服务：InputManagerService，也就是IMS</p>
<span id="more"></span>

<p>IMS会对这个触摸信息进行处理，经过WMS找到要分发的window，随后发送给对应的viewRootImpl。因此发送触摸信息的并非WMS，WMS提供的是window的相关信息。</p>
<p>当viewRootImpl接收到触摸信息时，也正是应用程序进程事件分发的开始。</p>
<p><img src="/images/android_touch_dispatch01.png" alt="image"></p>
<h1 id="事件如何到达Activity"><a href="#事件如何到达Activity" class="headerlink" title="事件如何到达Activity"></a>事件如何到达Activity</h1><p>事件分发：<br>DecorView -&gt; Activity -&gt; PhoneWindow -&gt; DecorView<br>当屏幕被触摸input系统事件从Native层分发Framework层的InputEventReceiver.dispachInputEvent()调用了</p>
<ul>
<li><p><strong>ViewRootImpl</strong>.WindowInputEventReceiver.dispachInputEvent()-&gt;</p>
</li>
<li><p><strong>ViewRootImpl</strong>中的<strong>DecorView</strong>.dispatchTouchEvent-&gt;Window.Callback.dispatchTouchEvent(ev) or super.dispatchTouchEvent(ev)</p>
</li>
<li><p><strong>Activity</strong>.dispatchTouchEvent-&gt;getWindow().superDispatchTouchEvent(ev) “<strong>PhoneWindow</strong>”</p>
</li>
<li><p><strong>window</strong>.superDispatchTouchEvent()-&gt;mDecor.superDispatchTouchEvent(event)</p>
</li>
<li><p><strong>DecorView</strong>.superDispatchTouchEvent()-&gt;super.dispatchTouchEvent(event)</p>
</li>
<li><p><strong>ViewGroup</strong>.dispatchTouchEvent()</p>
</li>
</ul>
<p>android的view管理是以window为单位的，每一个window对应一个view树。Window机制不只管理着view的显示，也负责view的事件分发。关于window的本质，能够阅读笔者的另外一篇文章window机制。研究事件分发的来源，须要从window机制入手。布局</p>
<p>因此，首先要了解一个概念：view树，即viewRootImpl。<br>每一棵view树都有一个根，叫作ViewRootImpl ，他负责管理这整一棵view树的绘制、事件分发等。因此能够说，事件分发是从viewRootImpl开始的。</p>
<p>应用界面通常会有多个view树，activity布局就是一个view树、其余应用的悬浮窗也是一个view树、dialog界面也是一个view树、使用windowManager添加的view也是一个view树等等。最简单的view树能够只有一个view。</p>
<p>android中view的绘制和事件分发，都是以view树为单位。每一棵view树，则为一个window 。系统服务WindowManagerService，管理界面的显示就是以window为单位，也能够说是以view树为单位。而view树是由viewRootImpl来负责管理的，因此能够说，wms（WindowManagerService的简写）管理的是viewRootImpl。<br><img src="/images/android_touch_dispatch02.png" alt="image"></p>
<p>对上图作个简单解释。</p>
<p>wms是运行在系统服务进程的，负责管理全部应用的window。应用程序与wms的通讯必须经过Binder进行跨进程通讯。<br>每一个viewRootImpl在wms中都有一个windowState对应，wms能够经过windowState找到对应的viewRootImpl进行管理<br>了解window机制的一个重要缘由是：事件分发并非由Activity驱动的，而是由系统服务驱动viewRootImpl来进行分</p>
<h1 id="ViewRootImpl是如何分发事件的"><a href="#ViewRootImpl是如何分发事件的" class="headerlink" title="ViewRootImpl是如何分发事件的"></a>ViewRootImpl是如何分发事件的</h1><p>1、viewRootImpl会直接调用管理的view的 dispatchTouchEvent 方法，根据具体的view的类型，调用具体的方法。<br>2、view树的根view多是一个view，也多是一个viewGroup，view会直接处理事件，而viewGroup则会进行分发。<br>3、DecorView重写了 dispatchTouchEvent 方法，会先判断是否存在callBack，优先调用callBack的方法，也就是把事件传递给了Activity。<br>4、其余的viewGroup子类会根据自身的逻辑进行事件分发。</p>
<p>所以，触摸事件必定是从Activity开始的吗？不是,Activity只是其中的一种状况，只有Activity本身负责的那一棵view树，才必定会到达activity，而其余的window，则不会通过Activity。触摸事件是从viewRootImpl开始，而不是Activity。</p>
<p>Touch事件分发中只有两个主角:ViewGroup和View。Activity的Touch事件事实上是调用它内部的ViewGroup的Touch事件，可以直接当成ViewGroup处理。</p>
<p>View在ViewGroup内，ViewGroup也可以在其他ViewGroup内，这时候把内部的ViewGroup当成View来分析。</p>
<p>ViewGroup的相关事件有三个：onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent。View的相关事件只有两个：dispatchTouchEvent、onTouchEvent。</p>
<p>先分析ViewGroup的处理流程：首先得有个结构模型概念：ViewGroup和View组成了一棵树形结构，最顶层为Activity的ViewGroup，下面有若干的ViewGroup节点，每个节点之下又有若干的ViewGroup节点或者View节点，依次类推。如图：</p>
<p><img src="/images/android_touch_dispatch03.png" alt="image"></p>
<p>Activity 的dispatchTouchEvent（）事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	 * Called to process touch screen events.  You can override this to</span></span><br><span class="line"><span class="comment">     * intercept all touch screen events before they are dispatched to the</span></span><br><span class="line"><span class="comment">     * window.  Be sure to call this implementation for touch screen events</span></span><br><span class="line"><span class="comment">     * that should be handled normally.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ev The touch screen event.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean Return true if this event was consumed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DecorView会调用super.DispatchTouchEvent方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为DecorView是一个FrameLayout，它最终还是调用了我们熟悉的ViewGroup的dispatchTouchEvent()</p>
<p>所谓的事件分发，本质上就是一个递归函数的调用，这个递归函数就是dispatchTouchEvent，至于onIntercepterTouchEvent，onTouchEvent，OnTouchListener，onClickListener…balabala都是在这个递归函数里面的操作而已，最核心，最骨干的还是dispatchTouchEvent。</p>
<p>当一个Touch事件(触摸事件为例)到达根节点，即Acitivty的ViewGroup时，它会依次下发，下发的过程是调用子View(ViewGroup)的dispatchTouchEvent方法实现的。简单来说，就是ViewGroup遍历它包含着的子View，调用每个View的dispatchTouchEvent方法，而当子View为ViewGroup时，又会通过调用ViwGroup的dispatchTouchEvent方法继续调用其内部的View的dispatchTouchEvent方法。上述例子中的消息下发顺序是这样的：①-②-⑤-⑥-⑦-③-④。dispatchTouchEvent方法只负责事件的分发，它拥有boolean类型的返回值，当返回为true时，顺序下发会中断。在上述例子中如果⑤的dispatchTouchEvent返回结果为true，那么⑥-⑦-③-④将都接收不到本次Touch事件。</p>
<h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//如果事件以无障碍焦点的View为目标，并且此View就是那个无障碍焦点View则开始</span></span><br><span class="line">       <span class="comment">//正常事件分发。</span></span><br><span class="line">       <span class="comment">// If the event targets the accessibility focused view and this is it, start</span></span><br><span class="line">       <span class="comment">// normal event dispatch. Maybe a descendant is what will handle the click.</span></span><br><span class="line">       <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">           ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 第一步:对于ACTION_DOWN进行处理(Handle an initial down)</span></span><br><span class="line"><span class="comment">            * 因为ACTION_DOWN是一系列事件的开端,当是ACTION_DOWN时进行一些初始化操作.</span></span><br><span class="line"><span class="comment">            * 从源码的注释也可以看出来:清除以往的Touch状态(state)开始新的手势(gesture)</span></span><br><span class="line"><span class="comment">            * cancelAndClearTouchTargets(ev)中有一个非常重要的操作:</span></span><br><span class="line"><span class="comment">            * 将mFirstTouchTarget设置为null!!!!</span></span><br><span class="line"><span class="comment">            * 随后在resetTouchState()中重置Touch状态标识</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">           <span class="comment">// Handle an initial down.</span></span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">               <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">               <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">               <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">               cancelAndClearTouchTargets(ev);</span><br><span class="line">               resetTouchState();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 第二步:检查是否要拦截(Check for interception)</span></span><br><span class="line"><span class="comment">		 * 在哪些情况下会调用该代码呢？有如下几种情况</span></span><br><span class="line"><span class="comment">		 * 1 处理ACTION_DOWN事件</span></span><br><span class="line"><span class="comment">		 * 2 当ACTION_DOWN事件被子View消费后处理ACTION_MOVE和ACTION_UP时</span></span><br><span class="line"><span class="comment">		 *  会调用该代码。因为此时mFirstTouchTarget!=null。所以此时ViewGroup</span></span><br><span class="line"><span class="comment">		 *  是有机会拦截ACTION_MOVE和ACTION_UP的,但是我们也可以调用方法:</span></span><br><span class="line"><span class="comment">		 *  requestDisallowInterceptTouchEvent来禁止ViewGroup的事件拦截.</span></span><br><span class="line"><span class="comment">		 *  如果子View没有消费Touch事件,那么那么当后续的ACTION_MOVE和ACTION_UP</span></span><br><span class="line"><span class="comment">		 *  到来时是不会调用到本处代码的.</span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 * 在dispatchTouchEvent(MotionEventev)这一大段代码中</span></span><br><span class="line"><span class="comment">		 * 使用变量intercepted来标记ViewGroup是否拦截Touch事件的传递.</span></span><br><span class="line"><span class="comment">		 * 该变量在后续代码中起着很重要的作用.</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 从此处if(actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)及其内部代码可知:</span></span><br><span class="line"><span class="comment">		 * 当ViewGroup决定拦截事件后,那么后续的点击事件将会默认交给它处理,不再调用</span></span><br><span class="line"><span class="comment">		 * onInterceptTouchEvent()判断是否需要拦截.</span></span><br><span class="line"><span class="comment">		 * 这个是为什么?</span></span><br><span class="line"><span class="comment">		 * 因为在处理ACTION_DOWN时如果Touch事件被子View消费,那么mFirstTouchTarget不为空;</span></span><br><span class="line"><span class="comment">		 * 反之,如果Touch事件没有被子View消费,那么mFirstTouchTarget为空,即此时Touch由当前</span></span><br><span class="line"><span class="comment">		 * 的ViewGroup拦截。此时当ACTION_MOVE和ACTION_UP来到时,不再满足:</span></span><br><span class="line"><span class="comment">		 * if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)</span></span><br><span class="line"><span class="comment">		 * 当然也就无法调用其内部的onInterceptTouchEvent()。</span></span><br><span class="line"><span class="comment">		 * 通俗地说:一旦ViewGroup拦截了ACTION_DOWN事件由自身的onTouchEvent()处理,那么</span></span><br><span class="line"><span class="comment">		 * 对于后续的ACTION_MOVE和ACTION_UP而言ViewGroup不再调用onInterceptTouchEvent()</span></span><br><span class="line"><span class="comment">		 * 判断是否拦截.</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 这里有个东西需要注意:FLAG_DISALLOW_INTERCEPT</span></span><br><span class="line"><span class="comment">		 * 在子View中调用requestDisallowInterceptTouchEvent()后造成disallowIntercept为true</span></span><br><span class="line"><span class="comment">		 * 即禁止拦截.于是不满足if(!disallowIntercept)所以也就调用不到该if内的onInterceptTouchEvent()</span></span><br><span class="line"><span class="comment">		 * 自然就没有办法拦截了.</span></span><br><span class="line"><span class="comment">		 * 但是requestDisallowInterceptTouchEvent()对于ACTION_DOWN是无效的.</span></span><br><span class="line"><span class="comment">		 * 因为对于ACTION_DOWN会调用 cancelAndClearTouchTargets(ev)和resetTouchState();</span></span><br><span class="line"><span class="comment">		 * 对FLAG_DISALLOW_INTERCEPT等状态值复原重置(参考上面的代码)</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 举两种情况说明:</span></span><br><span class="line"><span class="comment">		 * 1 当处理ACTION_DOWN时当然会满足</span></span><br><span class="line"><span class="comment">		 *  if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)</span></span><br><span class="line"><span class="comment">		 *  对于ACTION_DOWN子View有两种处理结果</span></span><br><span class="line"><span class="comment">		 *  1.1 消耗了Touch事件,那么mFirstTouchTarget不为null.</span></span><br><span class="line"><span class="comment">		 *      所以处理后续的ACTION_MOVE和ACTION_UP时依然满足该if判断</span></span><br><span class="line"><span class="comment">		 *  1.2 没有消耗Touch事件.mFirstTouchTarget=null.不满足该if.</span></span><br><span class="line"><span class="comment">		 *      所以后续的ACTION_MOVE和ACTION_UP由ViewGroup处理,此时再讨论什么拦截也就没有意义了.</span></span><br><span class="line"><span class="comment">		 *      同样的道理当子View消费了ACTION_DOWN后当处理ACTION_MOVE的时候ViewGroup拦截了该事件</span></span><br><span class="line"><span class="comment">		 *      那么当ACTION_UP随之到来时由于mFirstTouchTarget=null所以不会再调用该段代码,自然也就</span></span><br><span class="line"><span class="comment">		 *      不会调用onInterceptTouchEvent()判断是否拦截了.这点在上面的注释也有提及</span></span><br><span class="line"><span class="comment">		 * 2 当出现1.1的情况时满足该if判断.</span></span><br><span class="line"><span class="comment">		 *  如果在子View中调用了requestDisallowInterceptTouchEvent()那么就禁止拦截</span></span><br><span class="line"><span class="comment">		 *  即disallowIntercept=true.所以不满足if (!disallowIntercept)当然也就调用不到</span></span><br><span class="line"><span class="comment">		 *  onInterceptTouchEvent(ev)了,而是执行else&#123; intercepted = false;&#125;</span></span><br><span class="line"><span class="comment">		 *  也就是说ViewGroup无法拦截Touch了.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check for interception.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">           <span class="comment">// 事件为ACTION_DOWN或者mFirstTouchTarget不为null(即已经找到能够接收touch事件的目标组件)时if成立</span></span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                   || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   </span><br><span class="line">           	<span class="comment">//判断disallowIntercept(禁止拦截)标志位,可以理解为一个是否允许ViewGroup拦截的开关</span></span><br><span class="line">			<span class="comment">//因为在其他地方可能调用了requestDisallowInterceptTouchEvent()设置mGroupFlags 改变该值.</span></span><br><span class="line">			<span class="comment">//对于此方法的作用其实看requestDisallowInterceptTouchEvent()这个方法名就可明白了</span></span><br><span class="line">               <span class="comment">//disallowIntercept 默认值为FALSE</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">               <span class="comment">//当禁止拦截为false时(即disallowIntercept为false)调用onInterceptTouchEvent(ev)方法</span></span><br><span class="line">               <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">               </span><br><span class="line">               	<span class="comment">//既然disallowIntercept为false那么就调用onInterceptTouchEvent()方法将结果赋值给intercepted</span></span><br><span class="line">               	<span class="comment">//常说事件传递中的流程是:dispatchTouchEvent-&gt;onInterceptTouchEvent-&gt;onTouchEvent</span></span><br><span class="line">               	<span class="comment">//其实在这就是一个体现,在dispatchTouchEvent()中调用了onInterceptTouchEvent()</span></span><br><span class="line">                   intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                   ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               </span><br><span class="line">               	<span class="comment">//禁止拦截的FLAG为ture说明没有必要去执行是否需要拦截了能够顺利通过,所以设置拦截变量为false</span></span><br><span class="line">               	<span class="comment">//即当禁止拦截为true时(即disallowIntercept为true)设置intercepted = false</span></span><br><span class="line">                   <span class="comment">//父view无法拦截事件</span></span><br><span class="line">                   intercepted = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">           	<span class="comment">//当事件不是ACTION_DOWN并且mFirstTouchTarget为null(即没有Touch的目标组件)时</span></span><br><span class="line">           	<span class="comment">//设置 intercepted = true表示ViewGroup执行Touch事件拦截的操作。</span></span><br><span class="line">               <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">               <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">               intercepted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// If intercepted, start normal event dispatch. Also if there is already</span></span><br><span class="line">           <span class="comment">// a view that is handling the gesture, do normal event dispatch.</span></span><br><span class="line">           <span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">               ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 第三步:检查cancel(Check for cancelation)</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="comment">// Check for cancelation.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                   || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> isMouseEvent = ev.getSource() == InputDevice.SOURCE_MOUSE;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 第四步:事件分发(Update list of touch targets for pointer down, if needed)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span></span><br><span class="line">                   &amp;&amp; !isMouseEvent;</span><br><span class="line">           TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">           <span class="comment">//不是ACTION_CANCEL并且ViewGroup的拦截标志位intercepted为false(不拦截)</span></span><br><span class="line">           <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">               <span class="comment">// If the event is targeting accessibility focus we give it to the</span></span><br><span class="line">               <span class="comment">// view that has accessibility focus and if it does not handle it</span></span><br><span class="line">               <span class="comment">// we clear the flag and dispatch the event to all children as usual.</span></span><br><span class="line">               <span class="comment">// We are looking up the accessibility focused host to avoid keeping</span></span><br><span class="line">               <span class="comment">// state since these events are very rare.</span></span><br><span class="line">               View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                       ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">//处理ACTION_DOWN事件.这个环节比较繁琐</span></span><br><span class="line">               <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                       || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                       || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                           : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                   <span class="comment">// have become out of sync.</span></span><br><span class="line">                   removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                   <span class="comment">// 依据Touch坐标寻找子View来接收Touch事件</span></span><br><span class="line">                   <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">float</span> x =</span><br><span class="line">                               isMouseEvent ? ev.getXCursorPosition() : ev.getX(actionIndex);</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">float</span> y =</span><br><span class="line">                               isMouseEvent ? ev.getYCursorPosition() : ev.getY(actionIndex);</span><br><span class="line">                       <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                       <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                       <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                               &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                       <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                        <span class="comment">// 遍历子View判断哪个子View接受Touch事件</span></span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                           <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                                   childrenCount, i, customOrder);</span><br><span class="line">                           <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                                   preorderedList, children, childIndex);</span><br><span class="line">                           <span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">                                   || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                               <span class="keyword">continue</span>;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           newTouchTarget = getTouchTarget(child);</span><br><span class="line">                           <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           </span><br><span class="line">                           	<span class="comment">// 找到接收Touch事件的子View!!!!!!!即为newTouchTarget.</span></span><br><span class="line">                           	<span class="comment">// 既然已经找到了,所以执行break跳出for循环</span></span><br><span class="line">                               <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                               <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                               newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           resetCancelNextUpFlag(child);</span><br><span class="line">                           </span><br><span class="line">                           <span class="comment">/**</span></span><br><span class="line"><span class="comment">                            * 如果上面的if不满足,当然也不会执行break语句.</span></span><br><span class="line"><span class="comment">                            * 于是代码会执行到这里来.</span></span><br><span class="line"><span class="comment">                            * </span></span><br><span class="line"><span class="comment">                            * </span></span><br><span class="line"><span class="comment">                            * 调用方法dispatchTransformedTouchEvent()将Touch事件传递给子View做</span></span><br><span class="line"><span class="comment">                            * 递归处理(也就是遍历该子View的View树)</span></span><br><span class="line"><span class="comment">                            * 该方法很重要,看一下源码中关于该方法的描述:</span></span><br><span class="line"><span class="comment">                            * Transforms a motion event into the coordinate space of a particular child view,</span></span><br><span class="line"><span class="comment">                            * filters out irrelevant pointer ids, and overrides its action if necessary.</span></span><br><span class="line"><span class="comment">                            * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</span></span><br><span class="line"><span class="comment">                            * 将Touch事件传递给特定的子View.</span></span><br><span class="line"><span class="comment">                            * 该方法十分重要!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            * 在该方法中为一个递归调用,会递归调用dispatchTouchEvent()方法!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            * 在dispatchTouchEvent()中:</span></span><br><span class="line"><span class="comment">                            * 如果子View为ViewGroup并且Touch没有被拦截那么递归调用dispatchTouchEvent()</span></span><br><span class="line"><span class="comment">                            * 如果子View为View那么就会调用其onTouchEvent(),这个不再赘述.</span></span><br><span class="line"><span class="comment">                            * </span></span><br><span class="line"><span class="comment">                            * </span></span><br><span class="line"><span class="comment">                            * 该方法返回true则表示子View消费掉该事件,同时进入该if判断.</span></span><br><span class="line"><span class="comment">                            * 满足if语句后重要的操作有:</span></span><br><span class="line"><span class="comment">                            * 1 给newTouchTarget赋值</span></span><br><span class="line"><span class="comment">                            * 2 给alreadyDispatchedToNewTouchTarget赋值为true.</span></span><br><span class="line"><span class="comment">                            *   看这个比较长的英语名字也可知其含义:已经将Touch派发给新的TouchTarget</span></span><br><span class="line"><span class="comment">                            * 3 执行break.</span></span><br><span class="line"><span class="comment">                            *   因为该for循环遍历子View判断哪个子View接受Touch事件,既然已经找到了</span></span><br><span class="line"><span class="comment">                            *   那么就跳出该for循环.</span></span><br><span class="line"><span class="comment">                            * 4 注意:</span></span><br><span class="line"><span class="comment">                            *   如果dispatchTransformedTouchEvent()返回false即子View的onTouchEvent返回false</span></span><br><span class="line"><span class="comment">                            *   (即Touch事件未被消费)那么就不满足该if条件.所以也就无法执行addTouchTarget().</span></span><br><span class="line"><span class="comment">                            *   在此简单说一下addTouchTarget()中涉及到的ViewGroup的一个内部类TouchTarget——它是一个事件链.</span></span><br><span class="line"><span class="comment">                            *   该处的mFirstTouchTarget就是一个TouchTarget.它保存了可以消耗Touch事件的View.</span></span><br><span class="line"><span class="comment">                            *   在该处,如果dispatchTransformedTouchEvent()返回true即子View的onTouchEvent返回true则说明</span></span><br><span class="line"><span class="comment">                            *   该View消耗了Touch事件,那么将该View加入到事件链中!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            *   尤其注意:</span></span><br><span class="line"><span class="comment">                            *   这个操作是在处理ACTION_DOWN的代码块里进行的.即是在:</span></span><br><span class="line"><span class="comment">                            *    if (actionMasked == MotionEvent.ACTION_DOWN|| </span></span><br><span class="line"><span class="comment">                            *    (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || </span></span><br><span class="line"><span class="comment">                            *    actionMasked == MotionEvent.ACTION_HOVER_MOVE)</span></span><br><span class="line"><span class="comment">                            *    这个大的if判断中处理的.</span></span><br><span class="line"><span class="comment">                            *    当处理ACTION_MOVE事件和ACTION_UP事件的时候是不会进入这个if判断的!!!!!</span></span><br><span class="line"><span class="comment">                            *    而是直接从去判断mFirstTouchTarget!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            *    所以如果一个View不处理ACTION_DOWN那么该,那么该View是不会保存在mFirstTouchTarget</span></span><br><span class="line"><span class="comment">                            *    中的,也就无法继续处理ACTION_MOVE事件和ACTION_UP事件!!!!!!!!!!即若该View不消耗</span></span><br><span class="line"><span class="comment">                            *    ACTION_DOWN事件那么系统是不会讲ACTION_MOVE和ACTION_UP事件传给给该View的</span></span><br><span class="line"><span class="comment">                            * 5 注意:</span></span><br><span class="line"><span class="comment">                            *   如果dispatchTransformedTouchEvent()返回true即子View</span></span><br><span class="line"><span class="comment">                            *   的onTouchEvent返回true(即Touch事件被消费)那么就满足该if条件.</span></span><br><span class="line"><span class="comment">                            *   从而mFirstTouchTarget不为null!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="comment">                            * 6 小结:</span></span><br><span class="line"><span class="comment">                            *   对于此处ACTION_DOWN的处理具体体现在dispatchTransformedTouchEvent()</span></span><br><span class="line"><span class="comment">                            *   该方法返回boolean,如下:</span></span><br><span class="line"><span class="comment">                            *   true----&gt;事件被消费-----&gt;mFirstTouchTarget!=null</span></span><br><span class="line"><span class="comment">                            *   false---&gt;事件未被消费---&gt;mFirstTouchTarget==null</span></span><br><span class="line"><span class="comment">                            *   因为在dispatchTransformedTouchEvent()会调用递归调用dispatchTouchEvent()和onTouchEvent()</span></span><br><span class="line"><span class="comment">                            *   所以dispatchTransformedTouchEvent()的返回值实际上是由onTouchEvent()决定的.</span></span><br><span class="line"><span class="comment">                            *   </span></span><br><span class="line"><span class="comment">                            *   简单地说onTouchEvent()是否消费了Touch事件(true or false)的返回值决定了</span></span><br><span class="line"><span class="comment">                            *   dispatchTransformedTouchEvent()的返回值!!!!从而决定了mFirstTouchTarget是否为null!!!!!!</span></span><br><span class="line"><span class="comment">                            *   从而进一步决定了ViewGroup是否处理Touch事件.这一点在下面的代码中很有体现.</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line"></span><br><span class="line">                           <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                               <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                               mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                               <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                       <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                           mLastTouchDownIndex = j;</span><br><span class="line">                                           <span class="keyword">break</span>;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                   mLastTouchDownIndex = childIndex;</span><br><span class="line">                               &#125;</span><br><span class="line">                               mLastTouchDownX = ev.getX();</span><br><span class="line">                               mLastTouchDownY = ev.getY();</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//调用addTouchTarget()将child添加到mFirstTouchTarget链表的表头</span></span><br><span class="line">                               <span class="comment">//注意在addTouchTarget()方法内部会对mFirstTouchTarget操作,使其不为null</span></span><br><span class="line"></span><br><span class="line">                               newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                               alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                               <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           <span class="comment">// The accessibility focus didn&#x27;t handle the event, so clear</span></span><br><span class="line">                           <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                           ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                   &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 该if条件表示:</span></span><br><span class="line"><span class="comment">                    * 经过前面的for循环没有找到子View接收Touch事件并且之前的mFirstTouchTarget不为空</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                       <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                       newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                       </span><br><span class="line">                       <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//newTouchTarget指向了最初的TouchTarget</span></span><br><span class="line">                           newTouchTarget = newTouchTarget.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 经过上面对于ACTION_DOWN的处理后mFirstTouchTarget有两种情况:</span></span><br><span class="line"><span class="comment">            * (当然如果不是ACTION_DOWN就不会经过上面较繁琐的流程而是从此处开始执行,比如ACTION_MOVE和ACTION_UP)</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * 情况1 mFirstTouchTarget为null</span></span><br><span class="line"><span class="comment">            *       即没有找到能够消费touch事件的子组件或者是touch事件被拦截了</span></span><br><span class="line"><span class="comment">            * 情况2 mFirstTouchTarget不为null</span></span><br><span class="line"><span class="comment">            *       即找到了能够消费touch事件的子组件则后续的touch事件都可以传递到子View</span></span><br><span class="line"><span class="comment">            * 这两种情况的详细分析见下.</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * 这两种情况下都会去调用方法:</span></span><br><span class="line"><span class="comment">            * dispatchTransformedTouchEvent(MotionEvent event,boolean cancel,View child,int desiredPointerIdBits)</span></span><br><span class="line"><span class="comment">            * 我们重点关注该方法的第三个参数View child.</span></span><br><span class="line"><span class="comment">            * 详情请参加下面dispatchTransformedTouchEvent()源码分析</span></span><br><span class="line"><span class="comment">            * 在该源码中解释了：</span></span><br><span class="line"><span class="comment">            * 为什么子view对于Touch事件处理返回true那么其上层的ViewGroup就无法处理Touch事件了!!!!!!!!!</span></span><br><span class="line"><span class="comment">            * 为什么子view对于Touch事件处理返回false那么其上层的ViewGroup才可以处理Touch事件!!!!!!!!!!</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">           <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                       TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">           	<span class="comment">/**</span></span><br><span class="line"><span class="comment">           	 * 情况2：mFirstTouchTarget不为null</span></span><br><span class="line"><span class="comment">           	 * 即找到了可以消费Touch事件的子View且后续Touch事件可以传递到该子View</span></span><br><span class="line"><span class="comment">           	 * 在源码中的注释为:</span></span><br><span class="line"><span class="comment">           	 * Dispatch to touch targets, excluding the new touch target if we already dispatched to it.  </span></span><br><span class="line"><span class="comment">           	 * Cancel touch targets if necessary.</span></span><br><span class="line"><span class="comment">           	 */</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">               <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">               TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">               TouchTarget target = mFirstTouchTarget;</span><br><span class="line">               <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                   <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                       </span><br><span class="line">                   	<span class="comment">//如果前面利用ACTION_DOWN事件寻找符合接收条件的子组件的同时消费掉了ACTION_DOWN事件</span></span><br><span class="line">                   	<span class="comment">//那么这里为handled赋值为true</span></span><br><span class="line">                       handled = <span class="keyword">true</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   </span><br><span class="line">                       <span class="comment">//对于非ACTION_DOWN事件继续传递给目标子组件进行处理</span></span><br><span class="line">                       <span class="comment">//依然是递归调用dispatchTransformedTouchEvent()</span></span><br><span class="line">                       <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                               || intercepted;</span><br><span class="line">                       <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                               target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                           handled = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               mFirstTouchTarget = next;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               predecessor.next = next;</span><br><span class="line">                           &#125;</span><br><span class="line">                           target.recycle();</span><br><span class="line">                           target = next;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   predecessor = target;</span><br><span class="line">                   target = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 处理ACTION_UP和ACTION_CANCEL</span></span><br><span class="line"><span class="comment">            * Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line"><span class="comment">            * 在此主要的操作是还原状态</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">           <span class="keyword">if</span> (canceled</span><br><span class="line">                   || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                   || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">               resetTouchState();</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">               removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> handled;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Pass the touch screen motion event down to the target view, or this</span></span><br><span class="line"><span class="comment">  * view if it is the target.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> event The motion event to be dispatched.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> True if the event was handled by the view, false otherwise.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//判断当前事件是否能获得焦点，如果不能获得焦点或者不存在一个View，那我们就直接返回False跳出循环</span></span><br><span class="line">     <span class="comment">// If the event should be handled by accessibility focus first.</span></span><br><span class="line">     <span class="keyword">if</span> (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">         <span class="comment">// We don&#x27;t have focus or no virtual descendant has it, do not handle the event.</span></span><br><span class="line">         <span class="keyword">if</span> (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// We have focus and got the event, then use normal event dispatch.</span></span><br><span class="line">         event.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">     <span class="comment">//这段是系统调试方面，可以直接忽略</span></span><br><span class="line">     <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">         mInputEventConsistencyVerifier.onTouchEvent(event, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">     <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">         <span class="comment">// Defensive cleanup for new gesture</span></span><br><span class="line">         stopNestedScroll();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">             result = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">         ListenerInfo li = mListenerInfo;</span><br><span class="line">         <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                 &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                 &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">             result = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">//由自己内部的onTouchEvent处理。</span></span><br><span class="line">         <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">             result = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!result &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">         mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Clean up after nested scrolls if this is the end of a gesture;</span></span><br><span class="line">     <span class="comment">// also cancel it if we tried an ACTION_DOWN but we didn&#x27;t want the rest</span></span><br><span class="line">     <span class="comment">// of the gesture.</span></span><br><span class="line">     <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">             actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">             (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">         stopNestedScroll();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>负责对事件进行分发的方法主要有三个，分别是：</p>
<p>dispatchTouchEvent(）<br>onTouchEvent（）<br>onInterceptTouchEvent（）</p>
<p><img src="/images/android_touch_dispatch04.png" alt="image"></p>
<p>Down事件的分发决定了那个view要捕获事件，如果捕获了，后续的事件就直接分发给它，也就是说move up等事件的分发交给谁，取决于它们的起始事件Down由谁捕获。</p>
<p>在以上可看出，ViewGroup的dispatchTouchEvent是真正在执行“分发”工作，而View的dispatchTouchEvent方法，并不执行分发工作，或者说它分发的对象就是自己，决定是否把touch事件交给自己处理，而处理的方法，便是onTouchEvent事件，事实上子View的dispatchTouchEvent方法真正执行的代码是自己内部的onTouchEvent方法。</p>
<p>一般情况下，我们不该在普通View内重写dispatchTouchEvent方法，因为它并不执行分发逻辑。当Touch事件到达View时，我们该做的就是是否在onTouchEvent事件中处理它。</p>
<p>那么，ViewGroup的onTouchEvent事件是什么时候处理的呢？当ViewGroup所有的子View都返回false时，onTouchEvent事件便会执行。由于ViewGroup是继承于View的，它其实也是通过调用View的dispatchTouchEvent方法来执行onTouchEvent事件。</p>
<p>在目前的情况看来，似乎只要我们把所有的onTouchEvent都返回false，就能保证所有的子控件都响应本次Touch事件了。但必须要说明的是，这里的Touch事件，只限于Acition_Down事件，即触摸按下事件,而Aciton_UP和Action_MOVE却不会执行。事实上，一次完整的Touch事件，应该是由一个Down、一个Up和若干个Move组成的。Down方式通过dispatchTouchEvent分发，分发的目的是为了找到真正需要处理完整Touch请求的View。当某个View或者ViewGroup的onTouchEvent事件返回true时，便表示它是真正要处理这次请求的View，之后的Aciton_UP和Action_MOVE将由它处理。当所有子View的onTouchEvent都返回false时，这次的Touch请求就由根ViewGroup，即Activity自己处理了。</p>
<p>Down事件的分发决定了那个view要捕获事件，如果捕获了，后续的事件就直接分发给它，也就是说move up等事件的分发交给谁，取决于它们的起始事件Down由谁捕获。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本源码来自 api 28,不同版本略有不同。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步：处理拦截</span></span><br><span class="line">   <span class="keyword">boolean</span> intercepted;  </span><br><span class="line">     <span class="comment">// 注意这个条件，后者代表着有子view消费事件。后面会讲</span></span><br><span class="line">   <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 子view调用了parent.requestDisallowInterceptTouchEvent干预父布局的拦截，不让它爸拦截它</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">             intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">             ev.setAction(action); </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             intercepted = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//既不是DOWN事件，mFirstTouchTarget还是null，这种情况挺常见：如果ViewGroup的所有的子View都不消费				//事件，那么当ACTION_MOVE等非DOWN事件到来时，都被拦截了。</span></span><br><span class="line">         intercepted = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，分发ACTION_DOWN</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>; <span class="comment">//注意这个变量,会用到</span></span><br><span class="line">   <span class="comment">// 不拦截才会分发它，如果拦截了，就不分发ACTION_DOWN了</span></span><br><span class="line">    <span class="keyword">if</span> (!intercepted) &#123;</span><br><span class="line">        <span class="comment">//处理DOWN事件，捕获第一个被触摸的mFirstTouchTarget，mFirstTouchTarget很重要，</span></span><br><span class="line">        保存了消费了ACTION_DOWN事件的子<span class="function">view</span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(ev.getAction == MotionEvent.ACTION_DOWN)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//遍历所有子view(看源码知子View是按照Z轴排好序的)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//子view如果：1.不包含事件坐标 2. 在动画  则跳过</span></span><br><span class="line">                <span class="keyword">if</span> (!isTransformedTouchPointInView() || !canViewReceivePointerEvents()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将事件传递给子view的坐标空间，并且判断该子view是否消费这个触摸事件（分发Down事件）</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent()) &#123;</span><br><span class="line">                    <span class="comment">//将该view加入头节点，并且赋值给mFirstTouchTarget</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步：分发非DOWN事件</span></span><br><span class="line">        <span class="comment">//如果没有子view捕获ACTION_DOWN，则交给本ViewGroup处理这个事件。我们看到，这里并没有判断是否拦截，</span></span><br><span class="line">        <span class="comment">//为什么呢？因为如果拦截的话，上面的代码不会执行，就会导致mFirstTouchTarget== null，于是就走下面第一         				//个条件里的逻辑了</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>.dispatchTouchEvent(ev); <span class="comment">//调用View的dispatchTouchEvent，也就是自己处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历touchTargets链表，依次分发事件</span></span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget) &#123;</span><br><span class="line">                  handled = <span class="keyword">true</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  	<span class="keyword">if</span> (dispatchTransformedTouchEvent()) &#123;</span><br><span class="line">                      handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  target = target.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理ACTION_UP和CANCEL，手指抬起来以后相关变量重置</span></span><br><span class="line">        <span class="keyword">if</span> (ev.getAction == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            reset();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拦截事件"><a href="#拦截事件" class="headerlink" title="拦截事件"></a>拦截事件</h1><p>ViewGroup还有个onInterceptTouchEvent，看名字便知道这是个拦截事件。这个拦截事件需要分两种情况来说明：</p>
<p>1.假如我们在某个ViewGroup的onInterceptTouchEvent中，将Action为Down的Touch事件返回true，那便表示将该ViewGroup的所有下发操作拦截掉，这种情况下，mTarget会一直为null，因为mTarget是在Down事件中赋值的。由于mTarge为null，该ViewGroup的onTouchEvent事件被执行。这种情况下可以把这个ViewGroup直接当成View来对待。</p>
<p>2.假如我们在某个ViewGroup的onInterceptTouchEvent中，将Acion为Down的Touch事件都返回false，其他的都返回True，这种情况下，Down事件能正常分发，若子View都返回false，那mTarget还是为空，无影响。若某个子View返回了true，mTarget被赋值了，在ACTION_MOVE和ACTION_UP分发到该ViewGroup时，便会给mTarget分发一个ACTION_CANCEL的MotionEvent，同时清空mTarget的值，使得接下去的ACTION_MOVE(如果上一个操作不是UP)将由ViewGroup的onTouchEvent处理。</p>
<h1 id="事件分发汇总"><a href="#事件分发汇总" class="headerlink" title="事件分发汇总"></a>事件分发汇总</h1><p>1、IMS从系统底层接收到事件以后，会从WMS中获取window信息，并将事件信息发送给对应的viewRootImpl<br>2、viewRootImpl接收到事件信息，封装成motionEvent对象后，发送给管理的view<br>3、view会根据自身的类型，对事件进行分发仍是本身处理<br>4、顶层viewGroup通常是DecorView，DecorView会根据自身callBack的状况，选择调用callBack或者调用父类ViewGroup的方法<br>5、后面的Touch事件分发中有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。</p>
<p>6、ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。</p>
<p>7、当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。</p>
<p>8、当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。</p>
<p>9、当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。</p>
<p>10、onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。</p>
<p>11、触摸事件由ACTION_DOWN、ACTION_MOVE、ACTION_UP组成，其中一次完整的触摸事件中，DOWN只有一个，MOVE有若干个，可以为0个。UP可以为1个或0个。</p>
<h1 id="滑动冲突处理"><a href="#滑动冲突处理" class="headerlink" title="滑动冲突处理"></a>滑动冲突处理</h1><h2 id="滑动冲突场景"><a href="#滑动冲突场景" class="headerlink" title="滑动冲突场景"></a>滑动冲突场景</h2><p>Android中有许多控件支持用户进行拖拽，滑动等操作，比如SeekBar，ViewPager，ScrollView，RecyclerView等等。随着业务的展现的需求变化，UI越来越复杂，不可避免的就会出现嵌套的多个可滑动View的情况，比如ViewPager中套ViewPager，ScrollView中套ViewPager，ViewPager中套RecyclerView，还有一些开发者自行开发的，可接受滑动手势的控件与标准控件的嵌套。</p>
<p>当ViewTree中从根到某一叶子节点的路径上，存在多个可接受滑动手势的控件时，就有可能发生滑动冲突。</p>
<h2 id="滑动冲突原因"><a href="#滑动冲突原因" class="headerlink" title="滑动冲突原因"></a>滑动冲突原因</h2><p>一般而言，产生滑动冲突的时候，一定有一个可以滑动的父控件作为容器，包裹着一个可以滑动的子控件。</p>
<p>Android的touch事件分发的方向是从父控件到子控件，而事件消费方向则是从子控件到父控件，对于一个可滑动的ViewGroup，假如他有一个子View是一个按钮，那么当用户手触摸该按钮时，该按钮默认会消费掉这一个touch事件序列中的所有的touch事件，直到用户抬手。</p>
<p>理论上父控件没有机会处理滑动事件，因为父控件的onTouchEvent并不会收到touch事件。</p>
<p>此时通常的做法是重写ViewGroup#onInterceptTouchEvent，在其中判断用户的手指在该控件上滑动的距离，如果距离超过一个阈值，则认为用户是在滑动而不是点击，此时ViewGroup#onInterceptTouchEvent返回true，所有事件均直接传给该ViewGroup的onTouchEvent，由拦截事件的控件自身进行处理。</p>
<p>当然重写ViewGroup#dispatchTouchEvent也可以做到，只不过一般不重写它，重写它的要么是经验丰富的人，要么就是略懂的新人。</p>
<p>一般而言，Android官方控件，包括support包中的控件，对滑动冲突都有一定的避免能力，天然就能互相嵌套，且滑动效果符合开发者预期，这是多种手段互相配合的结果。</p>
<h2 id="滑动冲突解决思想"><a href="#滑动冲突解决思想" class="headerlink" title="滑动冲突解决思想"></a>滑动冲突解决思想</h2><p>由于事件一定是通过父控件派发，因此父控件可以监听触摸事件，识别滑动手势，在需要处理滑动时让ViewGroup#onInterceptTouchEvent返回true。但这并不足够，因为父控件并不知道自己内部的子控件到底是什么业务逻辑，可滑动的子控件也不知道自己的父控件到底知不知道什么时候能拦截，什么时候不能拦截，因此父控件提供了ViewGroup#requestDisallowInterceptTouchEvent方法给子控件调用，让子控件能及时通知父控件，什么时候可以拦截，什么时候不能拦截。</p>
<p>一般的，如果有嵌套的可滑动控件，一定是子控件优先滑动，父控件在适当时机拦截事件，自行处理滑动事件。对于父控件如何识别滑动手势，并识别是否可以拦截，也有两种常见的方案。</p>
<p><strong>滑动阈值</strong><br>事件流经父控件时，父控件不对事件做拦截操作，但时刻计算用户的滑动方向和距离，一旦用户的滑动方向与自己可滑动的方向夹角小于一定程度，并且滑动距离超过一个阈值，同时子控件没有禁止父控件拦截的情况下，父控件在ViewGroup#onInterceptTouchEvent中返回true，以拦截事件，之后交由ViewGroup#onTouchEvent处理滑动的具体事务。如果子控件禁止父控件拦截事件，则父控件不拦截事件，也不需要识别滑动手势。</p>
<p>与此同时，如果子控件识别到自己可滑动，将会通过requestDisallowInterceptTouchEvent来禁止父控件对自己可能的拦截行为，并在合适的时机重新允许父控件拦截事件。</p>
<p>从原理上讲，滑动阈值本身并不是为了处理滑动冲突，因为一个正常的可滑动容器，必须要能做到识别滑动手势并拦截，如果不拦截，一旦内部有任何控件吃一切事件，它就滑不动了，不要觉得吃一切事件的控件是极端情况，一个clickable的View，默认就会吃全部事件，也就是说，如果父控件不拦截滑动事件，那么当用户手指落在按钮上开始滑动时，父控件永远收不到事件。</p>
<p>只不过很多人在写一些自定义的可滑动容器时，第一反应就是做阈值判断拦截事件，因此也算时处理滑动冲突的方案。</p>
<p>是不是只要有滑动阈值判断就高枕无忧了呢？</p>
<p>并不是。</p>
<p>一个有滑动阈值的父控件，我们可以说它对子控件自行处理滑动事件是宽容的，而子控件，一般而言没那么宽容，比如SeekBar只要收到DOWN事件，就会请求父控件不拦截事件，相当于当可滑动的子控件完全不给父控件机会拦截自己，当然也就不会有冲突。这种场景下，当用户滑动子控件时，父控件是无论如何不会滑动的。</p>
<p>但假如子控件也是一个有滑动阈值的控件，也就是说两个宽容的控件凑一块了，会怎么样呢？</p>
<p>原生Android事件分发体系里面，涉及到滑动事件的处理，要么是父控件拦截掉事件并处理滑动手势；要么是子控件自行处理滑动，禁止父控件拦截，无论如何，只有一方会处理滑动事件。</p>
<p>而我们知道事件是从父控件派发到子控件的，父控件拦截发生在子控件收到事件之前，假如父控件的阈值是10，子控件的阈值是20，那么一旦达到阈值</p>
<p>最先判断需要处理滑动事件的一定是父控件，因为父控件拦截在前，且阈值小于子控件，子控件根本没机会检测到滑动手势。</p>
<p>有人说将父控件的阈值调整到大于子控件就可以了，这样就能让子控件率先达到阈值，自行处理滑动了。</p>
<p>这种想法还是忽略了一个问题，用户滑动的距离并不是一个从0开始平滑增长的值，而是一系列离散的数，用户的两个touch时间之间的距离，是可能突然变得很大的，比如一上来距离就达到了40，假如父控件的阈值是30，子控件的阈值是10，由于父控件的拦截判断在先，还是父控件先拦截的事件，而不是我们想要的子控件来处理滑动。</p>
<p>所以遇到两个有滑动阈值的控件嵌套，且他们滑动的方向一致时，滑动冲突无法避免。</p>
<p><strong>主动检测</strong><br>既然滑动阈值这种纯靠父子控件自我感觉的方案在某些情况下行不通，那么就需要有主动检测的手段。</p>
<p>即父控件检测到滑动事件后，首先对子控件在该方向和距离上的可滑动性进行检测，如果子控件不可滑动，则事件由父控件拦截；如果子控件可以滑动，则正常放行，由子控件自行处理滑动事件并禁止父控件拦截。恰好有这么两个方法：</p>
<p>View.canScrollHorizontally和View.canScrollVertically。support包中还有兼容版本的实现。</p>
<p>最典型的例子就是ViewPager，我们知道多个ViewPager嵌套是不会有滑动冲突的，并且还能在子ViewPager无法滑动时，改为滑动父ViewPager，它的原理就是使用View.canScrollHorizontally对子控件的可滑动性进行检测。</p>
<p>大部分原生控件都正确实现了这两个方法。</p>
<p><strong>嵌套滑动机制</strong><br>嵌套滑动机制本身是为了解决可滑动父子View的联动问题，正如前面所说，一个滑动事件要么是父控件处理，要么是子控件处理，很难做到子控件处理一部分之后再交给父控件处理，或者父控件处理一部分之后再交给子控件处理。</p>
<p>嵌套滑动机制可以解决可滑动View的联动问题，天然就是解决滑动冲突的方案，只是嵌套滑动机制，对于早期版本的支持有限，我并没有深入了解过，这里就不讨论了。</p>
<h2 id="实践思路"><a href="#实践思路" class="headerlink" title="实践思路"></a>实践思路</h2><p>如果是写可滑动的父控件（即逻辑上的View容器，内部可能嵌套其他可滑动View）</p>
<p>一般使用滑动阈值的方法就可以正确实现，如果想实现实现更精确的控制，可以使用View.canScrollXXX来检测子控件的可滑动性。</p>
<p>如果是写可滑动的子控件（即逻辑上的子控件，内部不再嵌套其他可滑动View），务必不要通过阈值来判断是否需要禁止父控件拦截事件，而是在收到ACTION_DOWN的时候立即请求禁止拦截，在合适的时机再取消禁止。如果能准确知道自己的父控件会使用View.canScrollXXX来检测自己，也可以直接通过正确实现该方法来与父控件配合。</p>
<p>如果在实践中，遇到两个嵌套的可滑动View，均使用了滑动阈值来判断是否处理滑动，且这俩View的源码我们均不能修改，那么可以考虑给子控件设置一个OnTouchListener，遇到ACTION_DOWN直接请求禁止拦截，在合适的时候再取消禁止，虽然体验上会有些奇怪，至少能保证不出很明显的滑动冲突问题。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>系统机制</tag>
        <tag>Touch事件</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会使用Glide吗？——Glide的高级用法</title>
    <url>/2018/06/12/glide_useage/</url>
    <content><![CDATA[<p>今天给大家分享一下Glide的一些使用技巧。Glide应该是Android APP中使用最为广泛的图片加载框架了，如丝般的顺滑滚动以及方便的链式调用为广大开发者所喜爱。但是开发中，我们总能遇上一些不太普遍的需求，比如列表中显示视频缩略图、显示音频的封面图、apk的图标等等，或者更奇葩的需求。这些场景使用框架默认的调用无法满足。</p>
<span id="more"></span>

<p>下面给大家分享一些处理以上需求的方法和技巧。</p>
<p>以下代码中Glide使用的均为4.X版本。尤其是自定义加载部分，4.X版本较之前版本API有些许改动，请注意。</p>
<h1 id="加载视频缩略图"><a href="#加载视频缩略图" class="headerlink" title="加载视频缩略图"></a>加载视频缩略图</h1><p>对于视频缩略图的加载，Glide是自带的，只是很多人并不知道，通过RequestOption可以进行设置加载。如下代码：</p>
<p>配置GlideModule用于生成GlideApp</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaGlideModule</span> <span class="keyword">extends</span> <span class="title">AppGlideModule</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> Glide glide, <span class="meta">@NonNull</span> Registry registry)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用GlideApp加载视频缩略图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GlideApp.with(context)</span><br><span class="line">        .setDefaultRequestOptions(</span><br><span class="line">                <span class="keyword">new</span> RequestOptions()</span><br><span class="line">                        .frame(frameTimeMicros)</span><br><span class="line">                        .centerCrop()</span><br><span class="line">                        .error(defaultHolder)</span><br><span class="line">                        .placeholder(defaultHolder))</span><br><span class="line">                        .load(path)</span><br><span class="line">                        .into(view);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 方法<code>frame(long frameTimeMicros)</code>需要指定你要获取的时间点，传入的参数是微秒，如果要获取2秒处的帧画面即要传入2000000.</p>
<h1 id="Glide的自定义加载"><a href="#Glide的自定义加载" class="headerlink" title="Glide的自定义加载"></a>Glide的自定义加载</h1><p>上面给大家展示了如何使用Glide提供的API加载视频缩略图。但是如果我们想使用Glide去加载更加个性化的数据怎么做呢？比如在一个音乐列表里面要展示所有的音乐封面图，Glide可没提供这种API啊，咋整呢？这就需要用到Glide的自定义加载了。强大的Glide充分考虑到了用户的个性化使用。你可以自定义数据流的获取过程，然后回调给Glide就OK了，其他的什么任务的调度和分发以及缓存依旧是Glide帮你做，这块无需关心。</p>
<p>Glide的自定义加载总结为以下过程：</p>
<ol>
<li><strong>定义一个Model类用于包装需要加载的数据</strong></li>
<li><strong>定义一个Key的实现类，用于实现第一步的Model中的数据的签名用于区分缓存</strong></li>
<li><strong>定义一个DataFetcher的实现类，用于告诉Glide音频封面如何加载，并把加载结果回调出去</strong></li>
<li><strong>定义一个ModelLoader的实现类用于包装DataFetcher</strong></li>
<li><strong>定义一个ModelLoaderFactory的实现类用于生成ModelLoader实例</strong></li>
<li><strong>将自定义加载配置到AppGlideModule中</strong></li>
</ol>
<p>看着好像挺麻烦的，是吧。其实代码没多少，如下：</p>
<ul>
<li>第一步 定义一个包装数据的Model类AudioCover</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioCover</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String path;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioCover</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二部 定义一个Key的实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioCoverSignature</span> <span class="keyword">implements</span> <span class="title">Key</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File file;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder stringBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioCoverSignature</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.file = <span class="keyword">new</span> File(path);</span><br><span class="line">        stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDiskCacheKey</span><span class="params">(MessageDigest messageDigest)</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(file.lastModified()).append(file.getAbsolutePath());</span><br><span class="line">        <span class="keyword">byte</span>[] bs = stringBuilder.toString().getBytes();</span><br><span class="line">        messageDigest.update(bs, <span class="number">0</span>, bs.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三部 定义一个DataFetcher的实现类(关键代码-处理封面的获取并回调给Glide)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioCoverFetcher</span> <span class="keyword">implements</span> <span class="title">DataFetcher</span>&lt;<span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AudioCover model;</span><br><span class="line">    <span class="keyword">private</span> MediaMetadataRetriever mRetriever;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioCoverFetcher</span><span class="params">(AudioCover model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AudioCover <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(<span class="meta">@NonNull</span> Priority priority, <span class="meta">@NonNull</span> DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">        mRetriever = <span class="keyword">new</span> MediaMetadataRetriever();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mRetriever.setDataSource(model.path);</span><br><span class="line">            <span class="keyword">byte</span>[] picture = mRetriever.getEmbeddedPicture();</span><br><span class="line">            <span class="keyword">if</span> (picture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callback.onDataReady(<span class="keyword">new</span> ByteArrayInputStream(picture));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.onLoadFailed(<span class="keyword">new</span> Exception(<span class="string">&quot;load audio cover fail&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mRetriever.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cannot cancel</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;InputStream&gt; <span class="title">getDataClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InputStream.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DataSource.LOCAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 方法<code>loadData()</code>是同步的方法，直接处理获取即可。</p>
<ul>
<li>第四部 定义一个ModelLoader的实现类包装DataFetcher</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioModuleLoader</span> <span class="keyword">implements</span> <span class="title">ModelLoader</span>&lt;<span class="title">AudioCover</span>, <span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadData&lt;InputStream&gt; <span class="title">buildLoadData</span><span class="params">(<span class="meta">@NonNull</span> AudioCover audioCover, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="meta">@NonNull</span> Options options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadData&lt;&gt;(<span class="keyword">new</span> AudioCoverSignature(audioCover.path), <span class="keyword">new</span> AudioCoverFetcher(audioCover));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handles</span><span class="params">(<span class="meta">@NonNull</span> AudioCover audioCover)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第五步 定义一个ModelLoaderFactory的实现类用于生成ModelLoader的实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioCoverLoaderFactory</span> <span class="keyword">implements</span> <span class="title">ModelLoaderFactory</span>&lt;<span class="title">AudioCover</span>,<span class="title">InputStream</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelLoader&lt;AudioCover, InputStream&gt; <span class="title">build</span><span class="params">(<span class="meta">@NonNull</span> MultiModelLoaderFactory multiFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AudioModuleLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teardown</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第六步 将自定义加载配置到GlideModule中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaGlideModule</span> <span class="keyword">extends</span> <span class="title">AppGlideModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> Glide glide, <span class="meta">@NonNull</span> Registry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.registerComponents(context, glide, registry);</span><br><span class="line">        registry.append(</span><br><span class="line">                AudioCover.class,</span><br><span class="line">                InputStream.class,</span><br><span class="line">                <span class="keyword">new</span> AudioCoverLoaderFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以愉快的使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GlideApp.with(context)</span><br><span class="line">        <span class="comment">//使用Model类包装数据即可</span></span><br><span class="line">        .load(<span class="keyword">new</span> AudioCover(path))</span><br><span class="line">        .placeholder(defaultHolder)</span><br><span class="line">        .error(defaultHolder)</span><br><span class="line">        .into(view);</span><br></pre></td></tr></table></figure>

<p>通过Glide的自定义加载可以实现很多Glide之外的数据流加载，加载部分给了充分的自由度，比如你还可以自定义一个用于获取apk图标加载，又或者你可以在加载时请求某些数据接口而实现更为复杂的加载过程等等。</p>
<p>以上就是Glide的自定义加载使用，有需要的可以参考一下。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg之视频播放</title>
    <url>/2018/12/09/ffmpeg_video_play/</url>
    <content><![CDATA[<p>在前一篇中的解封装的最后，把音视频的压缩数据分别放入了视频和音频的队列中，接下来就是在视频播放部分从队列中取出压缩数据进行解码播放。</p>
<span id="more"></span>

<h2 id="主要的结构体和函数释义"><a href="#主要的结构体和函数释义" class="headerlink" title="主要的结构体和函数释义"></a>主要的结构体和函数释义</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>AVCodecContext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相关函数：avcodec_alloc_context3(申请一块AVCodecContext空间)、avcodec_free_context(释放AVCodecContext空间)</span><br></pre></td></tr></table></figure>

<p>AVFrane</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&gt; uint8_t *data[AV_NUM_DATA_POINTERS]：数据内容，视频表示一行数据，音频表示一个通道数据</span><br><span class="line"></span><br><span class="line">2&gt; int line_size[AV_NUM_DATA_POINTERS]：数据大小，视频表示一行数据大小，音频表示一个通道数据大小</span><br><span class="line"></span><br><span class="line">3&gt; int width, int height：视频参数</span><br><span class="line"></span><br><span class="line">4&gt; int nb_samples：音频参数，表示单通道的样本数量，如1024，一个样本2个字节</span><br><span class="line"></span><br><span class="line">5&gt; int64_t pts，int64_t dts：显示时间、解码时间</span><br><span class="line"></span><br><span class="line">6&gt; int sample_rate, uint64_t channel_layout, int channels：音频参数</span><br><span class="line"></span><br><span class="line">7&gt; format：像素格式</span><br><span class="line"></span><br><span class="line">相关函数av_frame_alloc(申请内存)、av_frame_free(释放内存)、av_frame_ref(增加引用计数)、av_frame_clone(拷贝frame)、av_frame_unref(减少引用计数)</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>1&gt; avcodec_register_all：注册所有的解码器</p>
<p>2&gt; avcodec_find_decoder：查找对应的解码器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param enum AVCodecID id：解码器id</span><br><span class="line"></span><br><span class="line">@return AVCodec *：解码器</span><br></pre></td></tr></table></figure>

<p>3&gt; avcodec_find_decoder_by_name：通过名字查找解码器</p>
<p>4&gt; avcodec_open2：打开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param AVCodecContext *avctx：解码上下文</span><br><span class="line"></span><br><span class="line">@param AVCodec *codec：解码器，如果上下文alloc已经指定avcodec可以不传</span><br><span class="line"></span><br><span class="line">@param AVDictionary **options：参数</span><br></pre></td></tr></table></figure>

<p>5&gt; avcodec_parameters_to_context：复制解码参数，主要用于从stream-&gt;codecpar拷贝参数</p>
<p>6&gt; avcode_send_packet：异步解码发送数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param AVCodecContext *avctx：解码上下文</span><br><span class="line"></span><br><span class="line">@param AVPacket *avpkt：packet数据</span><br></pre></td></tr></table></figure>

<p>7&gt; avcodec_receive_frame：异步解码接收数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param AVCodecContext *avctx：解码上下文</span><br><span class="line"></span><br><span class="line">@param AVFrame *frame：解码后的frame</span><br></pre></td></tr></table></figure>

<p>8&gt; avcodec_close：关闭解码器</p>
<blockquote>
<p>sws_getContext：获取上下文</p>
</blockquote>
<blockquote>
<p>sws_getCachedContext：获取上下文，与sws_getContext区别在于内存空间由调用者自己管理</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param SwsContext *context：格式转换上下文</span><br><span class="line"></span><br><span class="line">@param int srcW, int srcH, enum AVPixelFormat srcFormat：输入格式</span><br><span class="line"></span><br><span class="line">@param int dstW, int dstH, enum AVPixelFormat dstFormat：输出格式</span><br><span class="line"></span><br><span class="line">@param  int flags：转换算法，如线性差值算法</span><br><span class="line"></span><br><span class="line">@param  SwsFilter *srcFilter：通常不用</span><br><span class="line"></span><br><span class="line">@param  SwsFilter *dstFilter：通常不用</span><br><span class="line"></span><br><span class="line">@param  const double **param：算法参数，不涉及可不指定</span><br></pre></td></tr></table></figure>

<p>11&gt; sws_scale：转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param SwsContext *context：格式转换上下文</span><br><span class="line"></span><br><span class="line">@param const uint8_t *const srcSlice[]：源数据数组，二维数组数据</span><br><span class="line"></span><br><span class="line">@param const int srcStride[]：一行数据的宽度，linesize</span><br><span class="line"></span><br><span class="line">@param int srcSliceY：用不到</span><br><span class="line"></span><br><span class="line">@param int srcSliceH：图像高度，遍历一行行数据</span><br><span class="line"></span><br><span class="line">@param uint8_t *dst[]：输出数据地址</span><br><span class="line"></span><br><span class="line">@param const int dstStride[]：输出数据长度</span><br><span class="line"></span><br><span class="line">@return：输出的数据高度</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sws_freeContext：释放上下文空间</p>
</blockquote>
<h2 id="解码播放流程"><a href="#解码播放流程" class="headerlink" title="解码播放流程"></a>解码播放流程</h2><h3 id="两个队列"><a href="#两个队列" class="headerlink" title="两个队列"></a>两个队列</h3><ol>
<li>存放压缩数据的队列 queue&lt;AVPacket *&gt;</li>
<li>存放解码后原始数据的队列 queue&lt;AVFrame *&gt;</li>
</ol>
<h3 id="两个线程"><a href="#两个线程" class="headerlink" title="两个线程"></a>两个线程</h3><ol>
<li>第一个线程是取出队列的压缩包 进行解码，解码后的原始包 丢到frame对别中去</li>
<li>第二个线程是从frame队列中取出原始包进行播放</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoChannel::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isPlaying = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    packets.<span class="built_in">setWork</span>(<span class="number">1</span>);</span><br><span class="line">    frames.<span class="built_in">setWork</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出队列的压缩包 解码 解码后的原始包push到frame队列中去</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid_video_decode, <span class="literal">nullptr</span>, task_video_decode, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从frame队列中取出原始包 播放</span></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pid_video_play, <span class="literal">nullptr</span>, task_video_play, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;video channel start&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>解码可以认为是AVPacket 到 AVFrame的过程</p>
<p>把队列里面的压缩包(AVPacket *)取出来，然后解码成（AVFrame * ）原始包 —-&gt; 保存队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoChannel::video_decode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AVPacket *packet = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (isPlaying)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = packets.<span class="built_in">getQueueAndDel</span>(packet);</span><br><span class="line">        <span class="keyword">if</span>(!isPlaying)&#123;</span><br><span class="line">            <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最新的FFmpeg，和旧版本差别很大， 新版本：1.发送pkt（压缩包）给缓冲区，  2.从缓冲区拿出来（原始包）</span></span><br><span class="line">        res = <span class="built_in">avcodec_send_packet</span>(codecContext, packet);</span><br><span class="line">        <span class="keyword">if</span>(res)&#123;</span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;video channel decode AVPacket fail !!!&quot;</span>)</span><br><span class="line">            <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// avcodec_send_packet 出现了错误，结束循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面是从FFmpeg缓冲区获取原始包</span></span><br><span class="line">        AVFrame *frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">        res = <span class="built_in">avcodec_receive_frame</span>(codecContext, frame);</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="built_in">AVERROR</span>(EAGAIN))&#123;</span><br><span class="line">            <span class="comment">// B帧  B帧参考前面成功  B帧参考后面失败   可能是P帧没有出来，再拿一次就行了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">LOGE</span>(<span class="string">&quot;video channel receive AVFrame fail !!!&quot;</span>)</span><br><span class="line">            <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//错误了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isPlaying)&#123;</span><br><span class="line">            <span class="comment">//拿到了原始包</span></span><br><span class="line">            frames.<span class="built_in">insert</span>(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原始包数据进行转换（YUV-gt-RGBA）"><a href="#原始包数据进行转换（YUV-gt-RGBA）" class="headerlink" title="原始包数据进行转换（YUV-&gt;RGBA）"></a>原始包数据进行转换（YUV-&gt;RGBA）</h3><p>把frames队列中的原始包AVFrame *取出来播放原始包YUV数据 使用libswscale 转换为RGBA数据</p>
<p>由于FFmpeg在解码视频时一般情况而言视频数据会被解码为YUV数据，而ANativeWindow并不能直接 显示YUV数 据的图像，所以需要将YUV转换为RGB进行显示。而FFmpeg的swscale模块就提供了颜色空 间转换的功能。 FFmpeg的swscale转换效率可能存在问题，如ijkPlayer中使用的是google的libyuv库进 行的转换。</p>
<p>转换算法<br>SWS_FAST_BILINEAR == 很快 可能会模糊<br>SWS_BILINEAR 适中算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VideoChannel::video_play</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AVFrame *frame = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span> *dest_data[<span class="number">4</span>];<span class="comment">//RGBA 4字节</span></span><br><span class="line">    <span class="keyword">int</span> dst_lineSize[<span class="number">4</span>];<span class="comment">//RGBA</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">av_image_alloc</span>(dest_data, dst_lineSize,</span><br><span class="line">                   codecContext-&gt;width, codecContext-&gt;height,</span><br><span class="line">                   AV_PIX_FMT_RGBA, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//YUV -&gt; RGBA</span></span><br><span class="line">    SwsContext *swsContext = <span class="built_in">sws_getContext</span>(</span><br><span class="line">            <span class="comment">//输入</span></span><br><span class="line">            codecContext-&gt;width,</span><br><span class="line">            codecContext-&gt;height,</span><br><span class="line">            codecContext-&gt;pix_fmt,</span><br><span class="line">            <span class="comment">//输出</span></span><br><span class="line">            codecContext-&gt;width,</span><br><span class="line">            codecContext-&gt;height,</span><br><span class="line">            AV_PIX_FMT_RGBA,</span><br><span class="line">            SWS_BILINEAR,<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">while</span> (isPlaying)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = frames.<span class="built_in">getQueueAndDel</span>(frame);</span><br><span class="line">        <span class="keyword">if</span>(!isPlaying)&#123;</span><br><span class="line">            <span class="built_in">releaseAVFrame</span>(&amp;frame);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//如果关闭了播放，跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//有可能生产者队列填充数据过慢，需要等一等</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sws_scale</span>(swsContext,</span><br><span class="line">                  <span class="comment">//输入</span></span><br><span class="line">                  frame-&gt;data, frame-&gt;linesize,</span><br><span class="line">                  <span class="number">0</span>, codecContext-&gt;height,</span><br><span class="line">                  <span class="comment">//输出</span></span><br><span class="line">                  dest_data, dst_lineSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ANativeWindow渲染</span></span><br><span class="line">        <span class="keyword">if</span>(renderCallback &amp;&amp; isPlaying)</span><br><span class="line">            <span class="built_in">renderCallback</span>(dest_data[<span class="number">0</span>], codecContext-&gt;width, codecContext-&gt;height, dst_lineSize[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">releaseAVFrame</span>(&amp;frame);<span class="comment">//释放原始包，因为已经被渲染过了，没用了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">releaseAVFrame</span>(&amp;frame);</span><br><span class="line">    isPlaying = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">av_freep</span>(dest_data[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">sws_freeContext</span>(swsContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用ANativeWindow进行画面渲染"><a href="#使用ANativeWindow进行画面渲染" class="headerlink" title="使用ANativeWindow进行画面渲染"></a>使用ANativeWindow进行画面渲染</h3><p>实例化ANativeWindow</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_jiajunhui_lib_jjhplayer_JJHPlayer_nativeSetSurface</span><span class="params">(JNIEnv *env, jobject thiz,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                           jobject surface)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先释放之前的显示窗口</span></span><br><span class="line">    <span class="keyword">if</span>(window)&#123;</span><br><span class="line">        <span class="built_in">ANativeWindow_release</span>(window);</span><br><span class="line">        window = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新的窗口用于视频显示</span></span><br><span class="line">    window = <span class="built_in">ANativeWindow_fromSurface</span>(env, surface);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGD</span>(<span class="string">&quot;set surface init window&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向ANativeWindow渲染数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="comment">//实现渲染</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderCallback</span><span class="params">(<span class="keyword">uint8_t</span> *src_data, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> src_lineSize)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">if</span>(!window)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//出现问题后，必须考虑到，释放锁，避免出现死锁问题</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置窗口的大小，各个属性</span></span><br><span class="line">    <span class="built_in">ANativeWindow_setBuffersGeometry</span>(window, width, height, WINDOW_FORMAT_RGBA_8888);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//window的缓冲区buffer</span></span><br><span class="line">    ANativeWindow_Buffer windowBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果我在渲染的时候是被锁住的，那我就无法渲染，我需要释放，防止出现死锁</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ANativeWindow_lock</span>(window, &amp;windowBuffer, <span class="literal">nullptr</span>))&#123;</span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="string">&quot;window is locked!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">ANativeWindow_release</span>(window);</span><br><span class="line">        window = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始真正渲染，window没有被锁住 把RGBA数据  ---&gt; 字节对齐 渲染</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *dst_data = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span> *&gt;(windowBuffer.bits);</span><br><span class="line">    <span class="keyword">int</span> dst_lineSize = windowBuffer.stride * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;windowBuffer.height;i++)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dst_data + i * dst_lineSize, src_data + i * src_lineSize, dst_lineSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据刷新</span></span><br><span class="line">    <span class="comment">//解锁后 并且刷新 window_buffer 的数据显示画面</span></span><br><span class="line">    <span class="built_in">ANativeWindow_unlockAndPost</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="渲染时的字节对齐"><a href="#渲染时的字节对齐" class="headerlink" title="渲染时的字节对齐"></a>渲染时的字节对齐</h3><p>在得到了RGBA格式的时候后就可以向ANativeWindow填充。但是在数据填充时，需要根据 window_buffer.stride 来一行行拷贝，如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> *dst_data = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span> *&gt;(window_buffer.bits);</span><br><span class="line"><span class="comment">//一行需要多少像素 * 4(RGBA)</span></span><br><span class="line"><span class="keyword">int32_t</span> dst_linesize = window_buffer.stride * <span class="number">4</span>; <span class="keyword">uint8_t</span> *src_data = data; <span class="comment">//需要显示的数据</span></span><br><span class="line"><span class="keyword">int32_t</span> src_linesize = linesize; <span class="comment">//数据每行字节数 //一次拷贝一行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; window_buffer.height; ++i) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data + i * dst_linesize, src_data + i * src_linesize,</span><br><span class="line">src_linesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以我们播放的852x480视频为例，在将ANativeWindow的格式设置为同样大小后，得到的 window_buffer.stride为 864，则每行需要864*4 = 3456个字节数据。而将视频解码数据转换为RGBA 之后获得的linesize为3408。window 与图像数据的每行数据数不同，所以需要一行行拷贝。</p>
<p>为什么会出现不同? 无论是window的stride还是ffmpeg的linesize只会出现比widget大的情况，这意味 着不可能出现图像数据缺失的情 况，但是为什么会比widget大呢?这是由于字节对齐不同导致的。在编 译FFmpeg时，会在FFmpeg源码根目录下 生成一个config.h文件，这个文件中根据编译目标平台的特性 定义了一些列的宏，其中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_SIMD_ALIGN_16 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_SIMD_ALIGN_32 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_SIMD_ALIGN_64 0</span></span><br></pre></td></tr></table></figure>

<p>这三个宏表示的就是FFmpeg中数据的以几字节对齐。在目标为android arm架构下，均为0。则 FFmpeg使用8字 节对齐( libavcodec/internal.h )</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_SIMD_ALIGN_64</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> STRIDE_ALIGN 64 <span class="comment">/* AVX-512 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> HAVE_SIMD_ALIGN_32</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> STRIDE_ALIGN 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> HAVE_SIMD_ALIGN_16</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> STRIDE_ALIGN 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> STRIDE_ALIGN 8 <span class="comment">// 注意:会执行此宏，那么就是 8字节对齐 #endif</span></span></span><br></pre></td></tr></table></figure>

<p>那么图像宽为852，即数据为852*4=3408的情况下，3408%8=无余数。则不需要占位字节用于对齐，因此 linesize为<br> 3408。</p>
<p>而ANativeWindow中的stride计算出来结果为3456。这是因为ANativeWindow在此处是以64字节对齐， 若stride<br> 为宽度的852，数据为3408的情况下，3408/16=53.25，此时需要占位字节将其补充为54，则 54*64=3456，所以</p>
<p>stride为3456以便于64字节对齐。</p>
<p>计算机字节对齐的原理:(来自百度百科的解释)， 总结:(字节对齐可以把算法执行效率最佳化)</p>
<p>***各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存 取。<br>比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节 对齐.</p>
<p><em><strong>其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取 效率 上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型(假设为32位系统)如果存放在偶地址 开始 的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次 读出的结果的高低字节进行拼凑才能的到该32bit数据</strong></em></p>
<p>源码地址：<a href="https://github.com/jiajunhui/ffmpeg-jjhplayer">https://github.com/jiajunhui/ffmpeg-jjhplayer</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>播放器</tag>
        <tag>NDK</tag>
        <tag>JNI</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg之Android播放器开发概览</title>
    <url>/2018/11/24/ffmpeg_play_dev/</url>
    <content><![CDATA[<p>FFmpeg的Android播放器开发将会分为一下五个步骤展开：</p>
<span id="more"></span>

<ol>
<li>FFmpeg之音视频解封装</li>
<li>FFmpeg之视频播放</li>
<li>FFmpeg之音频播放</li>
<li>FFmpeg之音画同步与资源释放</li>
</ol>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>开局一张图</p>
<p><img src="/images/ffmpeg_play_dev_introduction.png" alt="视音频播放器流程概况"></p>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>首先新建项目，导入之前编译好的FFmpeg库文件</p>
<p><img src="/images/ffmpeg_play_dev_project.png" alt="image-20210619121301366"></p>
<p>然后进行CMake的配置</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.6</span>.<span class="number">4111459</span>) <span class="keyword">set</span>(FFMPEG <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/ffmpeg) <span class="comment"># ffmpeg的路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(RTMP <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/rtmp) <span class="comment"># rtmp的路径 include_directories($&#123;FFMPEG&#125;/include) # 导入ffmpeg的头文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; - L$&#123;FFMPEG&#125;/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>) <span class="comment"># ffmpeg库指定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; - L$&#123;RTMP&#125;/libs/$&#123;CMAKE_ANDROID_ARCH_ABI&#125;&quot;</span>) <span class="comment"># rtmp库指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量导入 源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB src_files *.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">      native-lib <span class="comment"># 总库libnative-lib.so </span></span><br><span class="line">      SHARED <span class="comment"># 动态库</span></span><br><span class="line">      <span class="variable">$&#123;src_files&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">      native-lib <span class="comment"># 总库libnative-lib.so</span></span><br><span class="line">      <span class="comment"># 忽略顺序的方式，导入</span></span><br><span class="line">      -Wl,--start-group</span><br><span class="line">      avcodec avfilter avformat avutil swresample swscale </span><br><span class="line">      -Wl,--end-group</span><br><span class="line">      log <span class="comment"># 日志库，打印日志用的</span></span><br><span class="line">      z <span class="comment"># libz.so库，是FFmpeg需要用ndk的z库，FFMpeg需要额外支持 libz.so</span></span><br><span class="line">      rtmp <span class="comment"># rtmp 后面会专门介绍</span></span><br><span class="line">      android <span class="comment"># android 后面会专门介绍，目前先要明白的是 ANativeWindow 用来渲染画面的 </span></span><br><span class="line">      OpenSLES <span class="comment"># OpenSLES 后面会专门介绍，目前先要明白的是 OpenSLES 用来播放声音的</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="解码播放整体流程API"><a href="#解码播放整体流程API" class="headerlink" title="解码播放整体流程API"></a>解码播放整体流程API</h2><p><img src="/images/ffmpeg_play_dev_project_api.jpg" alt="ffmpeg解封装解码流程API概况"></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>播放器</tag>
        <tag>NDK</tag>
        <tag>JNI</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>NDK开发之交叉编译FFmpeg</title>
    <url>/2018/11/13/ffmpeg_build/</url>
    <content><![CDATA[<p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL 或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。</p>
<span id="more"></span>

<p>它包含了非常先进的音频/视频编 解码库libavcodec，为了保证高可移植性和编解码质量，libavcodec里很多code都是从头开发的 FFmpeg在Linux平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括Windows、Mac OS X等。这个项目最早由Fabrice Bellard发起，2004年至2015年间由Michael Niedermayer主要负责 维护。许多FFmpeg的开发人员都来自MPlayer项目，而且当前FFmpeg也是放在MPlayer项目组的服务 器上。项目的名称来自MPEG视频编码标准，前面的”FF”代表”Fast Forward”。 多媒体视频处理工具 FFmpeg有非常强大的功能包括视频采集功能、视频格式转换、视频抓图、给视频加水印等</p>
<p>libavformat:用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和 读取音视频帧等功能; libavcodec:用于各种类型声音/图像编解码; libavutil:包含一些公共的工具函 数; libswscale:用于视频场景比例缩放、色彩映射转换; libpostproc:用于后期效果处理; ffmpeg:该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等; ffsever:一个 HTTP 多媒体即时广播串流服务器; ffplay:是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显 示;</p>
<h1 id="FFmpeg源码下载"><a href="#FFmpeg源码下载" class="headerlink" title="FFmpeg源码下载"></a>FFmpeg源码下载</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.ffmpeg.org/releases/ (ffmpeg历史版本下载) </span><br><span class="line"></span><br><span class="line">wget http://www.ffmpeg.org/releases/ffmpeg-4.0.2.tar.bz2 解压</span><br><span class="line"></span><br><span class="line"> tar -xjf ffmpeg-4.0.2.tar.bz2</span><br></pre></td></tr></table></figure>

<h1 id="NDK的下载"><a href="#NDK的下载" class="headerlink" title="NDK的下载"></a>NDK的下载</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.下载:在浏览器，下载中心，复制链接地址: https://dl.google.com/android/repository/android-ndk-r17c-linux-x86_64.zip? hl=zh_cn</span><br><span class="line">2.wget 去下载操作:</span><br><span class="line">wget https://dl.google.com/android/repository/android-ndk-r17c-linux-x86_64.zip? hl=zh_cn</span><br><span class="line">3.修改名称:</span><br><span class="line">mv android-ndk-r17c-linux-x86_64.zip\?hl\=zh_cn android-ndk-r17c-linux- x86_64.zip</span><br><span class="line">4.解压:</span><br><span class="line">unzip android-ndk-r17c-linux-x86_64.zip</span><br></pre></td></tr></table></figure>

<h1 id="FFmpeg的一些配置项"><a href="#FFmpeg的一些配置项" class="headerlink" title="FFmpeg的一些配置项"></a>FFmpeg的一些配置项</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可通过下面命令查看</span><br><span class="line">./configure --help -&gt; ffmpeg_help.txt</span><br><span class="line">sz ffmpeg_help.txt</span><br></pre></td></tr></table></figure>

<h3 id="部分配置项释义"><a href="#部分配置项释义" class="headerlink" title="部分配置项释义"></a>部分配置项释义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Help options:</span><br><span class="line">–help print this message # 帮助选项</span><br><span class="line">–quiet Suppress showing informative output # 信息输出显示</span><br><span class="line">–list-decoders show all available decoders # 可用解码器</span><br><span class="line">–list-encoders show all available encoders # 可用编码器</span><br><span class="line">–list-hwaccels show all available hardware accelerators # 可用硬件编解码器 –list-demuxers show all available demuxers # 可用解复用</span><br><span class="line">–list-muxers show all available muxers # 可用复用器</span><br><span class="line">–list-parsers show all available parsers # 可用解析器</span><br><span class="line">–list-protocols show all available protocols # 可用协议</span><br><span class="line">–list-bsfs show all available bitstream filters # 可用比特流过滤器 –list-indevs show all available input devices # 可用输入设备 –list-outdevs show all available output devices # 可用输出设备 –list-filters show all available filters # 可用过滤器</span><br><span class="line">一般选项</span><br><span class="line">Standard options:</span><br><span class="line">–logfile=FILE log tests and output to FILE [config.log] # 生成指定的log文件 –disable-logging do not log configure debug information # 禁止调试信息 –fatal-warnings fail if any configure warning is generated # 任何警告则失败 –prefix=PREFIX install in PREFIX [$prefix_default] # 安装目录</span><br><span class="line">–bindir=DIR install binaries in DIR [PREFIX/bin] # exe和dll安装目录</span><br><span class="line">–datadir=DIR install data files in DIR [PREFIX/share/ffmpeg] # 数据安装目录 –docdir=DIR install documentation in DIR [PREFIX/share/doc/ffmpeg]# 文档安装目录 –libdir=DIR install libs in DIR [PREFIX/lib] # 静态库安装目录</span><br><span class="line">–shlibdir=DIR install shared libs in DIR [LIBDIR] # 共享库安装目录</span><br><span class="line">–incdir=DIR install includes in DIR [PREFIX/include] # 头文件安装目录</span><br><span class="line">–mandir=DIR install man page in DIR [PREFIX/share/man] # 帮助文档安装目录 –pkgconfigdir=DIR install pkg-config files in DIR [LIBDIR/pkgconfig] # pkg- config安装目录</span><br><span class="line">–enable-rpath use rpath to allow installing libraries in paths # 调用程序所用目录 not part of the dynamic linker search path</span><br><span class="line">use rpath when linking programs (USE WITH CARE)</span><br><span class="line">–install-name-dir=DIR Darwin directory name for installed targets</span><br><span class="line">许可选项</span><br><span class="line">Licensing options:</span><br><span class="line">–enable-gpl allow use of GPL code, the resulting libs # 允许使用GPL</span><br><span class="line">and binaries will be under GPL [no]</span><br><span class="line">–enable-version3 upgrade (L)GPL to version 3 [no] # 更新GPL版本</span><br><span class="line">–enable-nonfree allow use of nonfree code, the resulting libs # 允许使用非免费程序 and binaries will be unredistributable [no]</span><br><span class="line">配置选项</span><br><span class="line">Configuration options:</span><br><span class="line">–disable-static do not build static libraries [no] # 禁止静态库</span><br><span class="line">–enable-shared build shared libraries [no] # 启用共享库</span><br><span class="line">–enable-small optimize for size instead of speed # 启用最小尺寸而非速度</span><br><span class="line">–disable-runtime-cpudetect disable detecting CPU capabilities at runtime (smaller binary) # 禁用实时的CPU效率检测</span><br><span class="line">–enable-gray enable full grayscale support (slower color) # 启用灰度(颜色、空间转换) –disable-swscale-alpha disable alpha channel support in swscale # 禁用swscale中的 透明度</span><br><span class="line">–disable-all disable building components, libraries and programs # 禁用所有，包括组 件、库、程序</span><br><span class="line">–enable-raise-major increase major version numbers in sonames [no] # 提升版本号</span><br><span class="line">项目选项</span><br><span class="line">Program options:</span><br><span class="line">–disable-programs do not build command line programs # 禁止生成所有exe –disable-ffmpeg disable ffmpeg build # 禁止生成ffmpeg.exe –disable-ffplay disable ffplay build # 禁止生成ffplay.exe –disable-ffprobe disable ffprobe build # 禁止生成ffprobe.exe –disable-ffserver disable ffserver build # 禁止生成ffserver.exe</span><br><span class="line">文档选项</span><br><span class="line">Documentation options:</span><br><span class="line">–disable-doc do not build documentation # 禁止生成doc文件</span><br><span class="line">–disable-htmlpages do not build HTML documentation pages # 禁止生成HTML文档页 –disable-manpages do not build man documentation pages # 禁止生成帮助文档页 –disable-podpages do not build POD documentation pages # 禁止生成POD文档页 –disable-txtpages do not build text documentation pages # 禁止生成txt文档页</span><br><span class="line">组件选项</span><br><span class="line">Component options:</span><br><span class="line">–disable-avdevice disable libavdevice build # 禁止libavdevice构造 –disable-avcodec disable libavcodec build # 禁止libavcodec构造 –disable-avformat disable libavformat build # 禁止libavformat构造 –disable-swresample disable libswresample build # 禁止libswresample构造 –disable-swscale disable libswscale build # 禁止libswscale构造 –disable-postproc disable libpostproc build # 禁止libpostproc构造 –disable-avfilter disable libavfilter build # 禁止libavfilter构造 –enable-avresample enable libavresample build [no] # 允许libavresample构造 –disable-pthreads disable pthreads [autodetect] # 禁止pthread构造 –disable-w32threads disable Win32 threads [autodetect] # 禁止使用win32线程 –disable-os2threads disable OS/2 threads [autodetect] # 禁止使用OS/2线程 –disable-network disable network support [no] # 禁止网络支持</span><br><span class="line">–disable-dct disable DCT code # 禁止DCT代码</span><br><span class="line">–disable-dwt disable DWT code # 禁止DWT代码</span><br><span class="line">–disable-error-resilience disable error resilience code # 禁止纠错 –disable-lsp disable LSP code # 禁止行同步脉冲</span><br><span class="line">–disable-lzo disable LZO decoder code # 禁止LZO压缩编码</span><br><span class="line">–disable-mdct disable MDCT code # 禁止修正离散余弦变换</span><br><span class="line">–disable-rdft disable RDFT code # 禁止实数离散傅里叶变换</span><br><span class="line">–disable-fft disable FFT code # 禁止快速傅氏变换算法</span><br><span class="line">–disable-faan disable floating point AAN (I)DCT code</span><br><span class="line">–disable-pixelutils disable pixel utils in libavutil</span><br><span class="line">单个组件选项</span><br><span class="line">Individual component options:</span><br><span class="line">–disable-everything disable all components listed below # 禁用下面已列出的全部组件 –disable-encoder=NAME disable encoder NAME # 禁用指定的编码器 –enable-encoder=NAME enable encoder NAME # 启用指定的编码器</span><br><span class="line">–disable-encoders disable all encoders # 禁用所有的编码器</span><br><span class="line">–disable-decoder=NAME disable decoder NAME # 禁用指定的解码器 –enable-decoder=NAME enable decoder NAME # 启用指定的解码器</span><br><span class="line"># 禁止AAN DCT变换</span><br><span class="line"># 禁用avutil中的像素单元</span><br><span class="line">–disable-decoders disable all decoders # 禁用所有的解码器 –disable-hwaccel=NAME disable hwaccel NAME # 禁用指定的硬件加速 –enable-hwaccel=NAME enable hwaccel NAME # 启用指定的硬件加速 –disable-hwaccels disable all hwaccels # 禁用全部的硬件加速 –disable-muxer=NAME disable muxer NAME # 禁用指定的混合器 –enable-muxer=NAME enable muxer NAME # 启用指定的混合器 –disable-muxers disable all muxers # 禁用所有的混合器 –disable-demuxer=NAME disable demuxer NAME # 禁用指定的解复用器 –enable-demuxer=NAME enable demuxer NAME # 启用指定的解复用器 –disable-demuxers disable all demuxers # 禁用所有的解复用器 –enable-parser=NAME enable parser NAME # 启用指定的分析器 –disable-parser=NAME disable parser NAME # 禁用指定的分析器 –disable-parsers disable all parsers # 禁用所有的分析器 –enable-bsf=NAME enable bitstream filter NAME # 启用指定的流过滤器 –disable-bsf=NAME disable bitstream filter NAME # 禁用指定的流过滤器 –disable-bsfs disable all bitstream filters # 禁用所有的流过滤器 –enable-protocol=NAME enable protocol NAME # 启用指定的协议 –disable-protocol=NAME disable protocol NAME # 禁用指定的协议 –disable-protocols disable all protocols # 禁用所有的协议 –enable-indev=NAME enable input device NAME # 启用指定的输入设备 –disable-indev=NAME disable input device NAME # 禁用指定的输入设备 –disable-indevs disable input devices # 禁用输入设备 –enable-outdev=NAME enable output device NAME # 启用指定的输出设备 –disable-outdev=NAME disable output device NAME# 禁用指定的输出设备 –disable-outdevs disable output devices # 禁用输出设备 –disable-devices disable all devices # 禁用所有设备 –enable-filter=NAME enable filter NAME # 启用指定的过滤器 –disable-filter=NAME disable filter NAME # 禁用指定的过滤器 –disable-filters disable all filters # 禁用所有的过滤器</span><br><span class="line">添加依赖库支持</span><br><span class="line">External library support:</span><br><span class="line"></span><br><span class="line">Using any of the following switches will allow FFmpeg to link to the</span><br><span class="line">corresponding external library. All the components depending on that library</span><br><span class="line">will become enabled, if all their other dependencies are met and they are not</span><br><span class="line">explicitly disabled. E.g. –enable-libwavpack will enable linking to</span><br><span class="line">libwavpack and allow the libwavpack encoder to be built, unless it is</span><br><span class="line">specifically disabled with –disable-encoder=libwavpack.</span><br><span class="line"></span><br><span class="line">Note that only the system libraries are auto-detected. All the other external</span><br><span class="line">libraries must be explicitly enabled.</span><br><span class="line"></span><br><span class="line">Also note that the following help text describes the purpose of the libraries</span><br><span class="line">themselves, not all their features will necessarily be usable by FFmpeg.</span><br><span class="line"></span><br><span class="line">–enable-avisynth enable reading of AviSynth script files [no] # 启用读取AVISynth脚 本文件</span><br><span class="line">–disable-bzlib disable bzlib [autodetect] # 启用bzlib</span><br><span class="line">–enable-chromaprint enable audio fingerprinting with chromaprint [no] # 启用音频指 纹技术</span><br><span class="line">–enable-frei0r enable frei0r video filtering [no] # 启用frei0r视频筛选 –enable-gcrypt enable gcrypt, needed for rtmp(t)e support # 启用加密 if openssl, librtmp or gmp is not used [no]</span><br><span class="line">–enable-gmp enable gmp, needed for rtmp(t)e support # 启用gmp</span><br><span class="line">if openssl or librtmp is not used [no]</span><br><span class="line">–enable-gnutls enable gnutls, needed for https support # 启用gnutls if openssl is not used [no]</span><br><span class="line"></span><br><span class="line">–disable-iconv disable iconv [autodetect] # 禁用iconv</span><br><span class="line">–enable-jni enable JNI support [no] # 启用JNI支持</span><br><span class="line">–enable-ladspa enable LADSPA audio filtering [no] # 启用LADSPA音频过滤 –enable-libass enable libass subtitles rendering, # 启用libass</span><br><span class="line">needed for subtitles and ass filter [no]</span><br><span class="line">–enable-libbluray enable BluRay reading using libbluray [no] # 启用libbluray –enable-libbs2b enable bs2b DSP library [no] # 启用bs2b DSP库</span><br><span class="line">–enable-libcaca enable textual display using libcaca [no] # 启用libcaca用于文本显示 –enable-libcelt enable CELT decoding via libcelt [no] # 启用CEKT解码 –enable-libcdio enable audio CD grabbing with libcdio [no] # 通过libcdio启用音频CD –enable-libdc1394 enable IIDC-1394 grabbing using libdc1394 # 启用libdc1394</span><br><span class="line">and libraw1394 [no]</span><br><span class="line">–enable-libfdk-aac enable AAC de/encoding via libfdk-aac [no] # 启用libfdk-aac解 码/编码</span><br><span class="line">–enable-libflite enable flite (voice synthesis) support via libflite [no] # 启用 libflite</span><br><span class="line">–enable-libfontconfig enable libfontconfig, useful for drawtext filter [no] # 启 用libfontconfig</span><br><span class="line">–enable-libfreetype enable libfreetype, needed for drawtext filter [no]# 启用 libfreetype</span><br><span class="line">–enable-libfribidi enable libfribidi, improves drawtext filter [no] # 启用 libfribidi，改善绘画过滤</span><br><span class="line">–enable-libgme enable Game Music Emu via libgme [no] # 启用libgme</span><br><span class="line">–enable-libgsm enable GSM de/encoding via libgsm [no] # 启用libgsm做GSM编/解码 –enable-libiec61883 enable iec61883 via libiec61883 [no] # 启用libiec61883 –enable-libilbc enable iLBC de/encoding via libilbc [no] # 启用libilbc做iLBC编/解码 –enable-libkvazaar enable HEVC encoding via libkvazaar [no] # 启用libkvazaar做HEVC 编码</span><br><span class="line">–enable-libmodplug enable ModPlug via libmodplug [no] # 启用ModPlug通过libmodplug –enable-libmp3lame enable MP3 encoding via libmp3lame [no] # 启用MP3编码通过 libmp3lame</span><br><span class="line">–enable-libnut enable NUT (de)muxing via libnut, # 启用NUT解复用通过libnut</span><br><span class="line">native (de)muxer exists [no]</span><br><span class="line">–enable-libopencore-amrnb enable AMR-NB de/encoding via libopencore-amrnb [no] # 启用ARN-NB解/编码</span><br><span class="line">–enable-libopencore-amrwb enable AMR-WB decoding via libopencore-amrwb [no] # 启 用ARM-WB解码</span><br><span class="line">–enable-libopencv enable video filtering via libopencv [no] # 启用视频过滤通过 opencv</span><br><span class="line">–enable-libopenh264 enable H.264 encoding via OpenH264 [no] # 启用H.264编码 –enable-libopenjpeg enable JPEG 2000 de/encoding via OpenJPEG [no] # 启用JPEG编解 码</span><br><span class="line">–enable-libopenmpt enable decoding tracked files via libopenmpt [no] # 启用解码文件 通过libopenmpt</span><br><span class="line">–enable-libopus enable Opus de/encoding via libopus [no] # 启用Oplus编解码 –enable-libpulse enable Pulseaudio input via libpulse [no] # 启用Pulse输入 –enable-librubberband enable rubberband needed for rubberband filter [no] # 启用 rubberband</span><br><span class="line">–enable-librtmp enable RTMP[E] support via librtmp [no] # 启用RTMP支持通过librtmp –enable-libschroedinger enable Dirac de/encoding via libschroedinger [no] # 启用 Dirac编解码通过libschroedinger</span><br><span class="line">–enable-libshine enable fixed-point MP3 encoding via libshine [no] # 启用libshine 固定MP3点</span><br><span class="line">–enable-libsmbclient enable Samba protocol via libsmbclient [no] # 启用Samba协议 –enable-libsnappy enable Snappy compression, needed for hap encoding [no] # 启用 Snappy压缩</span><br><span class="line">–enable-libsoxr enable Include libsoxr resampling [no] # 启用libsoxr采样 –enable-libspeex enable Speex de/encoding via libspeex [no] # 启用Speex编解码</span><br><span class="line"></span><br><span class="line">–enable-libssh enable SFTP protocol via libssh [no] # 启用SFTP协议 –enable-libtesseract enable Tesseract, needed for ocr filter [no] # 启用Tesseract –enable-libtheora enable Theora encoding via libtheora [no] # 启用Theora编码 –enable-libtwolame enable MP2 encoding via libtwolame [no] # 启用MP2编码 –enable-libv4l2 enable libv4l2/v4l-utils [no] # 启用libv412</span><br><span class="line">–enable-libvidstab enable video stabilization using vid.stab [no] # 启用 libvidstab</span><br><span class="line">–enable-libvo-amrwbenc enable AMR-WB encoding via libvo-amrwbenc [no] # 启用AMR- WB</span><br><span class="line">–enable-libvorbis enable Vorbis en/decoding via libvorbis, # 启用Vorbis编解码 native implementation exists [no]</span><br><span class="line">–enable-libvpx enable VP8 and VP9 de/encoding via libvpx [no] # 启用VP8/VP9编解码 –enable-libwavpack enable wavpack encoding via libwavpack [no] # 启用wavpack编码 –enable-libwebp enable WebP encoding via libwebp [no] # 启用WbebP编码 –enable-libx264 enable H.264 encoding via x264 [no] # 启用H.264编码 –enable-libx265 enable HEVC encoding via x265 [no] # 启用HEVC编码</span><br><span class="line">–enable-libxavs enable AVS encoding via xavs [no] # 启用AVS编码</span><br><span class="line">–enable-libxcb enable X11 grabbing using XCB [autodetect] # 启用X11 –enable-libxcb-shm enable X11 grabbing shm communication [autodetect] # 启用X11 –enable-libxcb-xfixes enable X11 grabbing mouse rendering [autodetect] # 启用X11 –enable-libxcb-shape enable X11 grabbing shape rendering [autodetect] # 启用X11 –enable-libxvid enable Xvid encoding via xvidcore, # 启用Xvid编码</span><br><span class="line">native MPEG-4/Xvid encoder exists [no]</span><br><span class="line">–enable-libzimg enable z.lib, needed for zscale filter [no] # 启用z.lib –enable-libzmq enable message passing via libzmq [no] # 启用消息传递通过libzmq –enable-libzvbi enable teletext support via libzvbi [no] # 启用文本支持 –disable-lzma disable lzma [autodetect] # 禁用lzma</span><br><span class="line">–enable-decklink enable Blackmagic DeckLink I/O support [no] # 启用阻塞IO支持 –enable-mediacodec enable Android MediaCodec support [no] # 启用安卓MediaCodec支持 –enable-netcdf enable NetCDF, needed for sofalizer filter [no] # 启用NetCDF –enable-openal enable OpenAL 1.1 capture support [no] # 启用OpenAL1.1采集支持 –enable-opencl enable OpenCL code # 启用OpenCL代码</span><br><span class="line">–enable-opengl enable OpenGL rendering [no] # 启用OpenGL</span><br><span class="line">–enable-openssl enable openssl, needed for https support # 启用openssl，需支持https if gnutls is not used [no]</span><br><span class="line">–disable-schannel disable SChannel SSP, needed for TLS support on # 启用SSP Windows if openssl and gnutls are not used [autodetect]</span><br><span class="line">–disable-sdl2 disable sdl2 [autodetect] # 禁用sdl2</span><br><span class="line">–disable-securetransport disable Secure Transport, needed for TLS support # 禁用安 全传输</span><br><span class="line">on OSX if openssl and gnutls are not used [autodetect]</span><br><span class="line">–disable-xlib disable xlib [autodetect] # 禁用xlib</span><br><span class="line">–disable-zlib disable zlib [autodetect] # 禁用zlib</span><br><span class="line">The following libraries provide various hardware acceleration features: –disable-audiotoolbox disable Apple AudioToolbox code [autodetect] # 禁用苹果音频工 具箱</span><br><span class="line">–disable-cuda disable dynamically linked Nvidia CUDA code [autodetect] # 禁用CUDA 编程</span><br><span class="line">–disable-cuvid disable Nvidia CUVID support [autodetect] # 启用Nvidia CUVID –disable-d3d11va disable Microsoft Direct3D 11 video acceleration code [autodetect] # 禁用微软Direct3D 11视频加速</span><br><span class="line">–disable-dxva2 disable Microsoft DirectX 9 video acceleration code [autodetect] # 禁用微软錎irectX视频加速</span><br><span class="line">–enable-libmfx enable Intel MediaSDK (AKA Quick Sync Video) code via libmfx [no] # 启用Intel音频SDk</span><br><span class="line">–enable-libnpp enable Nvidia Performance Primitives-based code [no] # 启用Nvidia性能代码</span><br><span class="line">–enable-mmal enable Broadcom Multi-Media Abstraction Layer (Raspberry Pi) via MMAL [no] # 启用网络多媒体结构层</span><br><span class="line">–disable-nvenc disable Nvidia video encoding code [autodetect] # 禁用Nvidia视频编码 –enable-omx enable OpenMAX IL code [no] # 启用OpenMAX IL代码</span><br><span class="line">–enable-omx-rpi enable OpenMAX IL code for Raspberry Pi [no] # 启用OpenMAX IL代码 –disable-vaapi disable Video Acceleration API (mainly Unix/Intel) code [autodetect] # 禁用视频加速API</span><br><span class="line">–disable-vda disable Apple Video Decode Acceleration code [autodetect] # 禁用苹果 视频解码加速代码</span><br><span class="line">–disable-vdpau disable Nvidia Video Decode and Presentation API for Unix code [autodetect] # 禁用Nvidia视频编码和表达API</span><br><span class="line">–disable-videotoolbox disable VideoToolbox code [autodetect] # 禁用视频工具箱代码</span><br><span class="line">编译工具选项</span><br><span class="line">Toolchain options:</span><br><span class="line">–arch=ARCH select architecture [$arch] # 选择架构</span><br><span class="line">–cpu=CPU select the minimum required CPU (affects instruction selection, may crash on older CPUs) # 选择CPU</span><br><span class="line">–cross-prefix=PREFIX use PREFIX for compilation tools [$cross_prefix] # 交叉编译工 具目录</span><br><span class="line">–progs-suffix=SUFFIX program name suffix [] # 程序后缀名</span><br><span class="line">–enable-cross-compile assume a cross-compiler is used # 启用交叉编译</span><br><span class="line">–sysroot=PATH root of cross-build tree # 交叉编译根目录</span><br><span class="line">–sysinclude=PATH location of cross-build system headers # 交叉编译头文件目录 –target-os=OS compiler targets OS [$target_os] # 交叉编译的目标系统 –target-exec=CMD command to run executables on target # 交叉编译启动程序命令 –target-path=DIR path to view of build directory on target # 交叉编译的安装目录 –target-samples=DIR path to samples directory on target # 交叉编译samples存放目录 –tempprefix=PATH force fixed dir/prefix instead of mktemp for checks # 交叉编译的 temp目录</span><br><span class="line">–toolchain=NAME set tool defaults according to NAME # 编译工具</span><br><span class="line">–nm=NM use nm tool NM [$nm_default]</span><br><span class="line">–ar=AR use archive tool AR [$ar_default]</span><br><span class="line">–as=AS use assembler AS [$as_default]</span><br><span class="line">–ln_s=LN_S use symbolic link tool LN_S [$ln_s_default]</span><br><span class="line">–strip=STRIP use strip tool STRIP [$strip_default]</span><br><span class="line">–windres=WINDRES use windows resource compiler WINDRES [$windre_default] –yasmexe=EXE use yasm-compatible assembler EXE [$yasmexe_default]# 使用yasm编译 –cc=CC use C compiler CC [$cc_default] # 使用gcc编译</span><br><span class="line">–cxx=CXX use C compiler CXX [$cxx_default] # 使用g++编译</span><br><span class="line">–objcc=OCC use ObjC compiler OCC [$cc_default] # 使用object C编译工具occ编译 –dep-cc=DEPCC use dependency generator DEPCC [$cc_default] # 使用依赖生成DEPCC –ld=LD use linker LD [$ld_default] # 使用连接LD</span><br><span class="line">–pkg-config=PKGCONFIG use pkg-config tool PKGCONFIG [$pkg_config_default] # 使用 pkg-config工具</span><br><span class="line">–pkg-config-flags=FLAGS pass additional flags to pkgconf [] # 传递额外标志到pkg- config</span><br><span class="line">–ranlib=RANLIB use ranlib RANLIB [$ranlib_default] # 使用RANLIB</span><br><span class="line">–doxygen=DOXYGEN use DOXYGEN to generate API doc [$doxygen_default] # 生成doxygen 文档</span><br><span class="line">–host-cc=HOSTCC use host C compiler HOSTCC # 使用HOST c编译</span><br><span class="line">–host-cflags=HCFLAGS use HCFLAGS when compiling for host # 使用HCFLAGS –host-cppflags=HCPPFLAGS use HCPPFLAGS when compiling for host # 使用HCPPFLAGSS –host-ld=HOSTLD use host linker HOSTLD # 使用host连接器</span><br><span class="line">–host-ldflags=HLDFLAGS use HLDFLAGS when linking for host # 使用HLDFLAGS –host-libs=HLIBS use libs HLIBS when linking for host # 使用HLIBS</span><br><span class="line">–host-os=OS compiler host OS [$target_os] # 编译主机系统</span><br><span class="line">–extra-cflags=ECFLAGS add ECFLAGS to CFLAGS [$CFLAGS] # 添加ECFLAGS到CFLAGS</span><br><span class="line">–extra-cxxflags=ECFLAGS add ECFLAGS to CXXFLAGS [$CXXFLAGS] # 添加ECFLAGS到 CXXFLAGS</span><br><span class="line">–extra-objcflags=FLAGS add FLAGS to OBJCFLAGS [$CFLAGS] # 添加FLAGS到OBJCFLAGS –extra-ldflags=ELDFLAGS add ELDFLAGS to LDFLAGS [\$LDFLAGS] # 添加ELDFLAGS到 LDFLAGS</span><br><span class="line">–extra-ldexeflags=ELDFLAGS add ELDFLAGS to LDEXEFLAGS [\$LDEXEFLAGS] # 添加 ELDFLAGS到LDEXEFLAGS</span><br><span class="line">–extra-ldlibflags=ELDFLAGS add ELDFLAGS to LDLIBFLAGS [\$LDLIBFLAGS] # 添加 ELDFLAGS到LDLIBFLAGS</span><br><span class="line">–extra-libs=ELIBS add ELIBS [\$ELIBS] # 添加ELIBS</span><br><span class="line">–extra-version=STRING version string suffix [] # 添加版本</span><br><span class="line">–optflags=OPTFLAGS override optimization-related compiler flags # 重写优化编译标志 –build-suffix=SUFFIX library name suffix [] # 添加库名字路径</span><br><span class="line">–enable-pic build position-independent code # 添加位置独立代码</span><br><span class="line">–enable-thumb compile for Thumb instruction set # 编译錞humb指令集</span><br><span class="line">–enable-lto use link-time optimization # 使用连接时优化</span><br><span class="line">–env=”ENV=override” override the environment variables # 重写环境变量</span><br><span class="line">高级选项</span><br><span class="line">Advanced options (experts only):</span><br><span class="line">–malloc-prefix=PREFIX prefix malloc and related names with PREFIX # 申请路径 –custom-allocator=NAME use a supported custom allocator # 申请名字 –disable-symver disable symbol versioning # 禁用symver</span><br><span class="line">–enable-hardcoded-tables use hardcoded tables instead of runtime generation # 启 用硬件编码表</span><br><span class="line">–disable-safe-bitstream-reader # 禁用安全流阅读器</span><br><span class="line">disable buffer boundary checking in bitreaders</span><br><span class="line">(faster, but may crash)</span><br><span class="line">–sws-max-filter-size=N the max filter size swscale uses [$sws_max_filter_size_default] # 最大过滤器大小N</span><br><span class="line">优化选项</span><br><span class="line">Optimization options (experts only):</span><br><span class="line">–disable-asm disable all assembly optimizations # 禁用全部汇编程序优化 –disable-altivec disable AltiVec optimizations # 禁用邋AltiVec优化</span><br><span class="line">–disable-vsx disable VSX optimizations # 急用VSX优化</span><br><span class="line">–disable-power8 disable POWER8 optimizations # 禁用power8优化</span><br><span class="line">–disable-amd3dnow disable 3DNow! optimizations # 禁用3D Now!优化 –disable-amd3dnowext disable 3DNow! extended optimizations # 禁用3D Now!扩展优化 –disable-mmx disable MMX optimizations # 禁用MMX优化</span><br><span class="line">–disable-mmxext disable MMXEXT optimizations # 禁用MMXEXT优化</span><br><span class="line">–disable-sse disable SSE optimizations # 禁用SSE优化</span><br><span class="line">–disable-sse2 disable SSE2 optimizations # 禁用SSE2优化</span><br><span class="line">–disable-sse3 disable SSE3 optimizations # 禁用SSE3优化</span><br><span class="line">–disable-ssse3 disable SSSE3 optimizations # 禁用SSSE3优化</span><br><span class="line">–disable-sse4 disable SSE4 optimizations # 禁用SSE4优化</span><br><span class="line">–disable-sse42 disable SSE4.2 optimizations # 禁用SSE4.2优化</span><br><span class="line">–disable-avx disable AVX optimizations # 禁用AVX优化</span><br><span class="line">–disable-xop disable XOP optimizations # 禁用XOP优化</span><br><span class="line">–disable-fma3 disable FMA3 optimizations # 禁用FMA3优化</span><br><span class="line">–disable-fma4 disable FMA4 optimizations # 禁用FMA4优化</span><br><span class="line">–disable-avx2 disable AVX2 optimizations # 禁用AVX2优化</span><br><span class="line">–disable-aesni disable AESNI optimizations # 禁用AESNI优化</span><br><span class="line">–disable-armv5te disable armv5te optimizations # 禁用armv5te优化</span><br><span class="line">–disable-armv6 disable armv6 optimizations # 禁用armv6优化</span><br><span class="line">–disable-armv6t2 disable armv6t2 optimizations # 禁用armv6t2优化</span><br><span class="line">–disable-vfp disable VFP optimizations # 禁用VFP优化</span><br><span class="line">–disable-neon disable NEON optimizations # 禁用NEON优化</span><br><span class="line">ffmpeg_sh_help.txt 需要关注的选项</span><br><span class="line">–disable-inline-asm disable use of inline assembly # 禁用内部组合优化</span><br><span class="line">–disable-yasm disable use of nasm/yasm assembly # 禁用nasm/yasm组合 –disable-mipsdsp disable MIPS DSP ASE R1 optimizations # 禁用MIPS DSP ASE R1优化 –disable-mipsdspr2 disable MIPS DSP ASE R2 optimizations # 禁用MIPS DSP ASE R2优化 –disable-msa disable MSA optimizations # 禁用MSA优化</span><br><span class="line">–disable-mipsfpu disable floating point MIPS optimizations # 禁用浮点MIPS优化 –disable-mmi disable Loongson SIMD optimizations # 禁用长SIMD优化 –disable-fast-unaligned consider unaligned accesses slow # 禁用快速非对齐，非对齐速度 慢</span><br><span class="line">开发选项</span><br><span class="line">Developer options (useful when working on FFmpeg itself):</span><br><span class="line">–disable-debug disable debugging symbols # 禁用调试符号</span><br><span class="line">–enable-debug=LEVEL set the debug level [$debuglevel] # 禁用调试等级 –disable-optimizations disable compiler optimizations # 禁用编译器优化 –enable-extra-warnings enable more compiler warnings # 启用编译器警告 –disable-stripping disable stripping of executables and shared libraries # 禁用可 执行程序剥脱共享库</span><br><span class="line">–assert-level=level 0(default), 1 or 2, amount of assertion testing, # 启用段保护等 级</span><br><span class="line">2 causes a slowdown at runtime.</span><br><span class="line">–enable-memory-poisoning fill heap uninitialized allocated space with arbitrary data # 启用内存填充，用任意数填充</span><br><span class="line">–valgrind=VALGRIND run “make fate” tests through valgrind to detect memory # 启用 内存检测</span><br><span class="line">leaks and errors, using the specified valgrind binary.</span><br><span class="line">Cannot be combined with –target-exec</span><br><span class="line">–enable-ftrapv Trap arithmetic overflows # 启用算术运算溢出</span><br><span class="line">–samples=PATH location of test samples for FATE, if not set use # 指定测试示例位置 \$FATE_SAMPLES at make invocation time.</span><br><span class="line">–enable-neon-clobber-test check NEON registers for clobbering (should be # 启用 neon clobber测试</span><br><span class="line">used only for debugging purposes)</span><br><span class="line">–enable-xmm-clobber-test check XMM registers for clobbering (Win64-only; # 启用 xmm clobber测试</span><br><span class="line">should be used only for debugging purposes)</span><br><span class="line">–enable-random randomly enable/disable components # 启用组件随机开启或关闭 –disable-random # 禁用组件随机开启或关闭</span><br><span class="line">–enable-random=LIST randomly enable/disable specific components or # 启用随机列表 –disable-random=LIST component groups. LIST is a comma-separated list # 禁用随机列 表</span><br><span class="line">of NAME[:PROB] entries where NAME is a component</span><br><span class="line">(group) and PROB the probability associated with</span><br><span class="line">NAME (default 0.5).</span><br><span class="line">–random-seed=VALUE seed value for –enable/disable-random # 启用随机种子值 –disable-valgrind-backtrace do not print a backtrace under Valgrind</span><br><span class="line">(only applies to –disable-optimizations builds) # 禁用valgrind内存分析追踪</span><br><span class="line">Usage: configure [options]Options: [defaults in brackets after descriptions]</span><br><span class="line"></span><br><span class="line">【这是帮助选项，可以得到我们先查阅的内容，例如:./configure --help】 Help options:</span><br><span class="line">--help</span><br><span class="line">的帮助信息】</span><br><span class="line">--quiet</span><br><span class="line">这个从来没有用过】</span><br><span class="line">  --list-decoders</span><br><span class="line"></span><br><span class="line">常用)</span><br><span class="line">  --list-encoders</span><br><span class="line"></span><br><span class="line">常用)</span><br><span class="line">  --list-hwaccels</span><br><span class="line"></span><br><span class="line">的硬件加速器】</span><br><span class="line">  --list-demuxers</span><br><span class="line">  --list-muxers</span><br><span class="line">  --list-parsers</span><br><span class="line">  --list-protocols</span><br><span class="line">  --list-bsfs</span><br><span class="line"></span><br><span class="line">筛选器】</span><br><span class="line">  --list-indevs</span><br><span class="line"></span><br><span class="line">备】</span><br><span class="line">  --list-outdevs</span><br><span class="line"></span><br><span class="line">备】</span><br><span class="line">  --list-filters</span><br><span class="line"></span><br><span class="line">特效时，就有用】</span><br><span class="line">print this message 【当前所看到的所有内容，就是用--help输出 Suppress showing informative output 【禁止显示信息输出， show all available decoders【显示所有可用的解码器】 (非常 show all available encoders【显示所有可用的编码器】 (非常 show all available hardware accelerators 【显示所有可用</span><br><span class="line">show all available demuxers 【显示所有可用的解复用器】 show all available muxers 【列出所有支持的封装】</span><br><span class="line">show all available parsers 【显示所有可用的解析器】</span><br><span class="line">show all available protocols 【列出支持的通信协议】</span><br><span class="line">show all available bitstream filters 【显示所有可用的位流</span><br><span class="line">show all available input devices 【显示所有可用的输入设 show all available output devices 【显示所有可用的输出设 show all available filters 【显示所有可用过滤器，当要做复杂</span><br><span class="line">【这是标准选项，很多重要信息在这里面，例如:设置编译输出后的路径等】 【disable 关闭】</span><br><span class="line">【enable 开启】</span><br><span class="line">Standard options:</span><br><span class="line">--logfile=FILE log tests and output to FILE [ffbuild/config.log] 【编 译时日志信息输出路径，默认:ffbuild/config.log】</span><br><span class="line">--disable-logging do not log configure debug information 【关闭:不记录配置 调试信息】</span><br><span class="line">--fatal-warnings fail if any configure warning is generated 【如果生成任 何配置警告则失败，注意:不能加，因为编译过程中，警告是会有的】</span><br><span class="line">--prefix=PREFIX (非常常用)</span><br><span class="line">--bindir=DIR 文件】 PREFIX</span><br><span class="line">--datadir=DIR 录中安装数据文件】 PREFIX</span><br><span class="line">install in PREFIX [/usr/local] 【我们最终产出的目录】 install binaries in DIR [PREFIX/bin] 【在目录中安装二进制 install data files in DIR [PREFIX/share/ffmpeg] 【在目</span><br><span class="line">--docdir=DIR</span><br><span class="line">[PREFIX/share/doc/ffmpeg] 【在目录中安装文档】 PREFIX</span><br><span class="line">install documentation in DIR</span><br><span class="line">install libs in DIR [PREFIX/lib] 【在目录中安装libs】 install shared libs in DIR [LIBDIR] 【在目录中安装共享 install includes in DIR [PREFIX/include] 【在目录中安装 install man page in DIR [PREFIX/share/man] 【在目录中安 install pkg-config files in DIR [LIBDIR/pkgconfig]</span><br><span class="line">  --libdir=DIR</span><br><span class="line">PREFIX</span><br><span class="line"></span><br><span class="line">--shlibdir=DIR 库】</span><br><span class="line">--incdir=DIR includes】 PREFIX --mandir=DIR</span><br><span class="line">装手册页】 PREFIX --pkgconfigdir=DIR</span><br><span class="line">【在目录中安装pkg配置文件】 --enable-rpath</span><br><span class="line">use rpath when linking programs (USE WITH CARE) --install-name-dir=DIR Darwin directory name for installed targets 【已安装目标</span><br><span class="line">use rpath to allow installing libraries in paths 【使用 rpath允许在路径中安装库，没有用过】</span><br><span class="line">的目录名】</span><br><span class="line">not part of the dynamic linker search path</span><br><span class="line"></span><br><span class="line">【许可选项:不用关注】</span><br><span class="line">Licensing options:</span><br><span class="line"></span><br><span class="line">  --enable-gpl</span><br><span class="line"></span><br><span class="line">  --enable-version3</span><br><span class="line">  --enable-nonfree</span><br><span class="line"></span><br><span class="line">allow use of GPL code, the resulting libs</span><br><span class="line">and binaries will be under GPL [no]</span><br><span class="line">upgrade (L)GPL to version 3 [no]</span><br><span class="line">allow use of nonfree code, the resulting libs</span><br><span class="line">and binaries will be unredistributable [no]</span><br><span class="line"></span><br><span class="line">【配置选项，至关重要:关系到 编译成动态库 或 静态库】</span><br><span class="line">Configuration options:</span><br><span class="line"></span><br><span class="line">  --disable-static</span><br><span class="line"></span><br><span class="line">常用)</span><br><span class="line">  --enable-shared</span><br><span class="line"></span><br><span class="line">  --enable-small</span><br><span class="line"></span><br><span class="line">以尝试加入进去】 (非常常用)</span><br><span class="line">do not build static libraries [no] 【生成静态库】 (非常 build shared libraries [no] 【不生成动态库】 (非常常用)</span><br><span class="line">optimize for size instead of speed 【可以优化库的大小，可</span><br><span class="line">  --disable-runtime-cpudetect disable detecting CPU capabilities at runtime</span><br><span class="line">(smaller binary)</span><br><span class="line"></span><br><span class="line">  --enable-gray            enable full grayscale support (slower color)</span><br><span class="line">  --disable-swscale-alpha  disable alpha channel support in swscale</span><br><span class="line">  --disable-all            disable building components, libraries and programs</span><br><span class="line">  --disable-autodetect     disable automatically detected external libraries</span><br><span class="line"></span><br><span class="line">[no]</span><br><span class="line">【这个一般是在 Windows/Linux/MacOS 编译出 ffplay,ffmpeg 可执行程序，在Android中用不到】 Program options:</span><br><span class="line">  --disable-programs       do not build command line programs</span><br><span class="line"></span><br><span class="line">--disable-ffmpeg disable ffmpeg build 【ffmpeg:该项目提供的一个工具，可用于 格式转换、解码或电视卡即时编码等;】</span><br><span class="line">--disable-ffplay disable ffplay build 【ffplay:是一个简单的播放器，使用 ffmpeg 库解析和解码，通过SDL显示;】</span><br><span class="line">  --disable-ffprobe</span><br><span class="line"></span><br><span class="line">Documentation options:</span><br><span class="line"></span><br><span class="line">  --disable-doc</span><br><span class="line">  --disable-htmlpages</span><br><span class="line">  --disable-manpages</span><br><span class="line">  --disable-podpages</span><br><span class="line">  --disable-txtpages</span><br><span class="line"></span><br><span class="line">disable ffprobe build 【分析媒体文件信息】</span><br><span class="line">do not build documentation</span><br><span class="line">do not build HTML documentation pages</span><br><span class="line">do not build man documentation pages</span><br><span class="line">do not build POD documentation pages</span><br><span class="line">do not build text documentation pages</span><br><span class="line"></span><br><span class="line">【FFmpeg 是由各个模块所组成的】 FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。它包括了领先的 音/视频编码库libavcodec等。 libavformat:用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取 音视频帧等功能;</span><br><span class="line">libavcodec:用于各种类型声音/图像编解码;</span><br><span class="line">libavutil:包含一些公共的工具函数;</span><br><span class="line">libswscale:用于视频场景比例缩放、色彩映射转换;</span><br><span class="line">libpostproc:用于后期效果处理;</span><br><span class="line">Component options:</span><br><span class="line">--disable-avdevice disable libavdevice build 【可以操作我们的摄像头，视频输出 等等，(但是在Android中是不支持的)】</span><br><span class="line">--disable-avcodec disable libavcodec build 【包含了音视频编解码的东西，默认是 开启的，肯定不能关闭掉】 (非常常用)</span><br><span class="line">--disable-avformat disable libavformat build 【默认开启的，音视频封装格式的生 成与解析】 (非常常用)</span><br><span class="line">--disable-swresample disable libswresample build 【对音频进行重采样的(例如:把 单声道变成双声道，就需要此模块)】 (非常常用)</span><br><span class="line">  --disable-swscale</span><br><span class="line"></span><br><span class="line">此模块】</span><br><span class="line">  --disable-postproc</span><br><span class="line"></span><br><span class="line">掉】 (非常常用)</span><br><span class="line">  --disable-avfilter</span><br><span class="line"></span><br><span class="line">模块】</span><br><span class="line">disable libswscale build 【如果对一个视频 放大 缩小 就需要 disable libpostproc build 【后期处理的，这个模块可以关闭 disable libavfilter build 【给视频加字幕，加水印，就需要此</span><br><span class="line">--disable-everything</span><br><span class="line">--disable-encoder=NAME</span><br><span class="line">--enable-encoder=NAME</span><br><span class="line">--disable-encoders</span><br><span class="line">--disable-decoder=NAME</span><br><span class="line">--enable-decoder=NAME</span><br><span class="line">--disable-decoders</span><br><span class="line">--disable-hwaccel=NAME</span><br><span class="line">--enable-hwaccel=NAME</span><br><span class="line">--disable-hwaccels</span><br><span class="line">--disable-muxer=NAME</span><br><span class="line">--enable-muxer=NAME</span><br><span class="line">--disable-muxers</span><br><span class="line"></span><br><span class="line">disable all components listed below</span><br><span class="line">disable encoder NAME</span><br><span class="line">enable encoder NAME</span><br><span class="line">disable all encoders</span><br><span class="line"></span><br><span class="line">合并在一起 例如.mp4，不想这样就可以关闭)】</span><br><span class="line">--disable-demuxer=NAME</span><br><span class="line">--enable-demuxer=NAME</span><br><span class="line">--disable-demuxers</span><br><span class="line">--enable-parser=NAME</span><br><span class="line">--disable-parser=NAME</span><br><span class="line">--disable-parsers</span><br><span class="line">--enable-bsf=NAME</span><br><span class="line">--disable-bsf=NAME</span><br><span class="line">--disable-bsfs</span><br><span class="line">--enable-protocol=NAME</span><br><span class="line">--disable-protocol=NAME  disable protocol NAME</span><br><span class="line"></span><br><span class="line">--disable-protocols</span><br><span class="line">--enable-indev=NAME</span><br><span class="line">--disable-indev=NAME</span><br><span class="line">--disable-indevs</span><br><span class="line">--enable-outdev=NAME</span><br><span class="line">--disable-outdev=NAME</span><br><span class="line">--disable-outdevs</span><br><span class="line">--disable-devices</span><br><span class="line">--enable-filter=NAME</span><br><span class="line"></span><br><span class="line">disable all protocols</span><br><span class="line">enable input device NAME</span><br><span class="line">disable input device NAME</span><br><span class="line">disable input devices</span><br><span class="line">enable output device NAME</span><br><span class="line">disable output device NAME</span><br><span class="line">disable output devices</span><br><span class="line">disable all devices</span><br><span class="line">enable filter NAME</span><br><span class="line"></span><br><span class="line">enable libavresample build (deprecated) [no]</span><br><span class="line">disable pthreads [autodetect]</span><br><span class="line">disable Win32 threads [autodetect]</span><br><span class="line">disable OS/2 threads [autodetect]</span><br><span class="line"></span><br><span class="line">--enable-avresample</span><br><span class="line">--disable-pthreads</span><br><span class="line">--disable-w32threads</span><br><span class="line">--disable-os2threads</span><br><span class="line">--disable-network</span><br><span class="line">--disable-dct</span><br><span class="line">--disable-dwt</span><br><span class="line">--disable-error-resilience disable error resilience code</span><br><span class="line"></span><br><span class="line">--disable-lsp</span><br><span class="line">--disable-lzo</span><br><span class="line">--disable-mdct</span><br><span class="line">--disable-rdft</span><br><span class="line">--disable-fft</span><br><span class="line">--disable-faan</span><br><span class="line">--disable-pixelutils</span><br><span class="line"></span><br><span class="line">disable LSP code</span><br><span class="line">disable LZO decoder code</span><br><span class="line">disable MDCT code</span><br><span class="line">disable RDFT code</span><br><span class="line">disable FFT code</span><br><span class="line">disable floating point AAN (I)DCT code</span><br><span class="line">disable pixel utils in libavutil</span><br><span class="line"></span><br><span class="line">【单个组件选项，可以查看下，有些选项不使用是可以关闭的】</span><br><span class="line"></span><br><span class="line">Individual component options:</span><br><span class="line"></span><br><span class="line">disable network support [no]</span><br><span class="line">disable DCT code</span><br><span class="line">disable DWT code</span><br><span class="line"></span><br><span class="line">disable decoder NAME</span><br><span class="line">enable decoder NAME</span><br><span class="line">disable all decoders</span><br><span class="line">disable hwaccel NAME</span><br><span class="line">enable hwaccel NAME</span><br><span class="line">disable all hwaccels</span><br><span class="line">disable muxer NAME</span><br><span class="line">enable muxer NAME</span><br><span class="line">disable all muxers 【混合封装(音视频等于 一段音频 一段视频</span><br><span class="line">disable demuxer NAME</span><br><span class="line">enable demuxer NAME</span><br><span class="line">disable all demuxers</span><br><span class="line">enable parser NAME</span><br><span class="line">disable parser NAME</span><br><span class="line">disable all parsers</span><br><span class="line">enable bitstream filter NAME</span><br><span class="line">disable bitstream filter NAME</span><br><span class="line">disable all bitstream filters</span><br><span class="line">enable protocol NAME</span><br><span class="line"></span><br><span class="line">【编码可以去关闭掉】</span><br><span class="line"></span><br><span class="line">  --disable-filter=NAME    disable filter NAME</span><br><span class="line">  --disable-filters        disable all filters</span><br></pre></td></tr></table></figure>

<h1 id="编译FFmpeg"><a href="#编译FFmpeg" class="headerlink" title="编译FFmpeg"></a>编译FFmpeg</h1><h4 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h4><p>放置到FFmpeg主目录下，如test_build.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 首先定义一个NDK目录的变量 NDK_ROOT NDK_ROOT=/root/DerryAll/Tools/android-ndk-r17c</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此变量执行ndk中的交叉编译gcc所在目录 TOOLCHAIN=<span class="variable">$NDK_ROOT</span>/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span></span><br><span class="line"><span class="meta">#</span><span class="bash">从as的 externalNativeBuild/xxx/build.ninja， 反正下面的配置，可以压制警告的意思 FLAGS=<span class="string">&quot;-isystem <span class="variable">$NDK_ROOT</span>/sysroot/usr/include/arm-linux-androideabi - D__ANDROID_API__=21 -g -DANDROID -ffunction-sections -funwind-tables -fstack- protector-strong -no-canonical-prefixes -march=armv7-a -mfloat-abi=softfp - mfpu=vfpv3-d16 -mthumb -Wa,--noexecstack -Wformat -Werror=format-security -O0 - fPIC&quot;</span></span></span><br><span class="line">INCLUDES=&quot; -isystem $NDK_ROOT/sources/android/support/include&quot; # 1.定义编译后，所存放的目录</span><br><span class="line">PREFIX=./android/arm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.--enable-small 优化大小 非常重要，必须优化才行的哦</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.--disable-programs 不编译ffmpeg程序(命令行工具)，我们是需要获取静态、动态库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4.--disable-avdevice 关闭avdevice模块，此模块在android中无用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5.--disable-encoders 关闭所有编码器(播放不需要编码)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 6.--disable-muxers 关闭所有复用器(封装器)，不需要生成mp4这样的文件，所有关闭</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7.--disable-filters 关闭所有滤镜</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 8.--enable-cross-compile 开启交叉编译(ffmpeg是跨平台的，注意:并不是所有库都有这么 happy的选项)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 9.--cross-prefix 看右边的值就知道是干嘛的，gcc的前缀..</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.disable-shared / enable-static 这个不写也可以，默认就是这样的，(代表关闭动态库，开启 静态库)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 11.--sysroot</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 12.--extra-cflags 会传给gcc的参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 13.--arch --target-os</span></span><br><span class="line">./configure \</span><br><span class="line">--prefix=$PREFIX \</span><br><span class="line">--enable-small \</span><br><span class="line">--disable-programs \</span><br><span class="line">--disable-avdevice \</span><br><span class="line">--disable-encoders \</span><br><span class="line">--disable-muxers \</span><br><span class="line">--disable-filters \</span><br><span class="line">--enable-cross-compile \</span><br><span class="line">--cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \</span><br><span class="line">--disable-shared \</span><br><span class="line">--enable-static \</span><br><span class="line">--sysroot=$NDK_ROOT/platforms/android-21/arch-arm \</span><br><span class="line">--extra-cflags=&quot;$FLAGS $INCLUDES&quot; \</span><br><span class="line">--extra-cflags=&quot;-isysroot $NDK_ROOT/sysroot/&quot; \</span><br><span class="line">--arch=arm \</span><br><span class="line">--target-os=android</span><br><span class="line">make clean</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="执行编译"><a href="#执行编译" class="headerlink" title="执行编译"></a>执行编译</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure 【报错，需要关闭 asm 汇编相关】</span><br><span class="line">./configure --disable-x86asm 【生成 Makefile 已经帮你关闭 asm 】</span><br><span class="line">sh test_build.sh</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>播放器</tag>
        <tag>NDK</tag>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg之解封装</title>
    <url>/2018/12/02/ffmpeg_unpacking/</url>
    <content><![CDATA[<p>FFmpeg的解封装大概可分为以下九个步骤：</p>
<span id="more"></span>

<ol>
<li>打开媒体地址（文件路径、视频URL）</li>
<li>查找媒体中的音视频流信息</li>
<li>根据流信息流个数循环查找</li>
<li>获取媒体流</li>
<li>从流获取编解码参数</li>
<li>根据参数获取编解码器</li>
<li>创建编解码器上下文</li>
<li>使用上面的参数初始化编解码器上下文</li>
<li>打开解码器</li>
<li>循环读取压缩数据AVPacket</li>
</ol>
<p>回忆下上篇文章的图</p>
<p><img src="/images/ffmpeg_play_dev_project_api.jpg" alt="ffmpeg解封装解码流程API概况"></p>
<h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><h3 id="Java层代码"><a href="#Java层代码" class="headerlink" title="Java层代码"></a>Java层代码</h3><p>Player的方法设计基本是按照MediaPlayer的API设计的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JJHPlayer</span> <span class="title">implements</span> <span class="title">IJJHPlayer</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.<span class="built_in">loadLibrary</span>(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JJHPlayer</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">nativePrepare</span>(mDataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onNativeCallErrorEvent</span><span class="params">(<span class="keyword">int</span> eventCode, <span class="keyword">int</span> extra, String message)</span></span>&#123;</span><br><span class="line">        mHandler.<span class="built_in">post</span>(<span class="keyword">new</span> <span class="built_in">Runnable</span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span>(mOnErrorEventListener!=null)</span><br><span class="line">                    mOnErrorEventListener.<span class="built_in">onError</span>(eventCode, extra,  message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onNativeCallPrepared</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mHandler.<span class="built_in">post</span>(<span class="keyword">new</span> <span class="built_in">Runnable</span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span>(mOnPrepareListener!=null)</span><br><span class="line">                    mOnPrepareListener.<span class="built_in">onPrepared</span>(JJHPlayer.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">//Native方法函数定义</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> native <span class="keyword">void</span> <span class="title">nativePrepare</span><span class="params">(String dataSource)</span></span>;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JNI部分代码"><a href="#JNI部分代码" class="headerlink" title="JNI部分代码"></a>JNI部分代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_cn_jiajunhui_lib_jjhplayer_JJHPlayer_nativePrepare</span><span class="params">(JNIEnv* env, jobject thiz, jstring data_source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_data_source = env-&gt;<span class="built_in">GetStringUTFChars</span>(data_source, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> *helper = <span class="keyword">new</span> <span class="built_in">JNICallbackHelper</span>(vm, env, thiz);</span><br><span class="line">    player = <span class="keyword">new</span> <span class="built_in">JJHPlayer</span>(_data_source, helper);</span><br><span class="line">    player-&gt;<span class="built_in">setRenderCallback</span>(renderCallback);</span><br><span class="line">    player-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">    env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(data_source, _data_source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要的结构体及函数释义"><a href="#主要的结构体及函数释义" class="headerlink" title="主要的结构体及函数释义"></a>主要的结构体及函数释义</h3><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>AVFormatContext</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&gt; AVIOContext *pb：文件IO的上下文，自定义格式时使用</span><br><span class="line"></span><br><span class="line">2&gt; char filename[1024]：保存打开的文件名，经常用到，例如断开重连</span><br><span class="line"></span><br><span class="line">3&gt; unsigned int nb_streams：流数量</span><br><span class="line"></span><br><span class="line">4&gt; AVStream **streams：具体流内容，通常只有视频、音频，偶尔也会有字幕之类的</span><br><span class="line"></span><br><span class="line">5&gt; int64_t duration：总长度，以AV_TIME_BASE(通常为1000000)为单位，相当于使用微秒(us)为单位，注意这个值不一定能够获取到，如果获取不到可以通过帧数计算</span><br><span class="line"></span><br><span class="line">6&gt; int64_t bit_rate：比特率 1s中有多少bit</span><br></pre></td></tr></table></figure>

<p>AVStream</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&gt; AVCodecContext *codec：解码器，该参数已经过时</span><br><span class="line"></span><br><span class="line">2&gt; AVRational time_base：时间基数，分数，通常分子=&gt;1，分母=&gt;9000</span><br><span class="line"></span><br><span class="line">3&gt; int64_t duration：时长，duration * (time_base.num / time_base.den) 需要考虑除零</span><br><span class="line"></span><br><span class="line">4&gt; AVRational avg_frame_rate：帧率，对于视频来说一帧数据就是一张图片，对于音频来说就是一定量的样本数，具体一帧数据存多少样本数由codecpar-&gt;frame_size决定</span><br><span class="line"></span><br><span class="line">5&gt; AVCodecParameters *codecpar：音视频参数，主要用于替代codec</span><br></pre></td></tr></table></figure>

<p>AVCodecParameters</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&gt; enum AVMediaType codec_type：编码类型，音频/视频</span><br><span class="line"></span><br><span class="line">2&gt; enum AVCodecID codec_id：编码格式，H264格式等</span><br><span class="line"></span><br><span class="line">3&gt; uint32_t codec_tag：用四个字节表示编码器，通常用不到</span><br><span class="line"></span><br><span class="line">4&gt; int format：视频像素格式/音频采样格式</span><br><span class="line"></span><br><span class="line">5&gt; int width, int height：视频宽高，仅视频有；不一定有，如果没有可以使用解码后的frame中的宽高</span><br><span class="line"></span><br><span class="line">6&gt; uint64_t channel_layout，int channels，int sample_rate，int frame_size：声道，如三声道(数值与channels二进制十进制数相同)，声道数，样本率，样本大小(单通道样本数)，仅音频有</span><br></pre></td></tr></table></figure>

<p>AVPacket</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&gt; AVBufferRef *buf：用于存储引用计数的一块空间，packet增加的时候引用计数+1，减少的时候引用计数-1</span><br><span class="line"></span><br><span class="line">2&gt; int64_t pts：显示时间</span><br><span class="line"></span><br><span class="line">3&gt; int64_t dts：解码时间</span><br><span class="line"></span><br><span class="line">4&gt; uint8_t *data, int size：由ffmpeg创建和删除(不同帧数据量不同)，保存帧数据</span><br><span class="line"></span><br><span class="line">注意：在没有B帧的情况下pts = dts</span><br><span class="line"></span><br><span class="line">AVPacket相关函数：av_packet_alloc(创建并初始化一个packet)、av_packet_clone(复制并增加一次引用计数)、av_packet_ref(手动加一次引用)、av_packet_unref(手动减一次引用)、av_packet_free(空间清理)、av_init_packet(为packet设置默认值)、av_packet_from_data(给定数据生成一个packet)、av_copy_packet(废弃的函数，注意不要再使用)</span><br></pre></td></tr></table></figure>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>1&gt; av_register_all：注册所有的解封装和加封装格式，新版本的ffmpeg已经废弃该函数，可以不需要再调用</p>
<p>2&gt; avformat_network_init：支持网络rtsp/rtmp/http数据流</p>
<p>3&gt; avformat_open_input：打开音视频文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param AVFormatContext **ps：需要注意ps不能为空，*ps可以为空，当*ps为空，会在内部创建存储空间，如果不传空可在外部先创建好空间但清理需要在外部处理</span><br><span class="line"></span><br><span class="line">@param const char *url：支持网络rtsp、http、本地路径</span><br><span class="line"></span><br><span class="line">@AVInputFormat *fmt：输入文件的格式，通常不需要指定，不指定的情况下由ffmpeg自己检测输入文件格式</span><br><span class="line"></span><br><span class="line">@AVDictionary **options：输入参数字典，具体有哪些参数可以参考源码ffmpeg-4.3.1\libavcodec\options_table.h里面的定义;可以使用方法av_dict_set设置参数，比如设置rtsp超时时间</span><br><span class="line"></span><br><span class="line">@return：0表示正常，非0返回错误码</span><br></pre></td></tr></table></figure>

<p>4&gt; avformat_find_stream_info：获取流信息</p>
<p>5&gt; av_dump_format：打印流详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param AVFormatContext **ps</span><br><span class="line"></span><br><span class="line">@param int index：用于打印(没啥用)</span><br><span class="line"></span><br><span class="line">@param const char *url：用于打印(没啥用)</span><br><span class="line"></span><br><span class="line">@param int is_output：context是输入(0)或输出(1)</span><br></pre></td></tr></table></figure>
<p>6&gt; av_find_best_stream：获取音视频流信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param AVFormatContext **ps</span><br><span class="line"></span><br><span class="line">@param enum AVMediaType type</span><br><span class="line"></span><br><span class="line">@param  int wanted_stream_nb：通常设为-1，自动选择</span><br><span class="line"></span><br><span class="line">@param  int ratedstream：相关流，通常用不到，设为-1</span><br><span class="line"></span><br><span class="line">@param   AVCodec **decoder_ret：解码时用到，通常也不设置</span><br><span class="line"></span><br><span class="line">@param   int flags：保留字段</span><br></pre></td></tr></table></figure>

<p>7&gt; av_read_frame：读取一帧数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param AVFormatContext **ps</span><br><span class="line"></span><br><span class="line">@param AVPacket *pkt：不能传null，需要预分配空间作为输出参数</span><br></pre></td></tr></table></figure>

<p>8&gt; av_seek_frame：移动到索引的frame</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@param AVFormatContext **ps</span><br><span class="line"></span><br><span class="line">@param stream_index：索引，-1表示default，通常使用视频来做seek，使用音频seek有可能移到视频某个非关键帧的位置</span><br><span class="line"></span><br><span class="line">@int64_t timestamp：移动到位置的时间戳</span><br><span class="line"></span><br><span class="line">@int flags：标志位 AV_SEEKFLAG_BACKWARD[1]：往后找  AV_SEEKFLAG_FRAME[8]：只跳到关键帧</span><br></pre></td></tr></table></figure>

<p>9&gt; avformat_close_input：关闭打开的音视频文件</p>
<p>10&gt; av_strerror：失败时存放错误信息</p>
<h3 id="FFmpeg-API调用部分"><a href="#FFmpeg-API调用部分" class="headerlink" title="FFmpeg API调用部分"></a>FFmpeg API调用部分</h3><p>根据 url ，获取它的信息头，用这些信息来初始化解封装器及输入流。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一步：打开媒体地址</span></span><br><span class="line">formatContext = <span class="built_in">avformat_alloc_context</span>();</span><br><span class="line"></span><br><span class="line">AVDictionary *dictionary = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">av_dict_set</span>(&amp;dictionary, <span class="string">&quot;timeout&quot;</span>, <span class="string">&quot;5000000&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数1，AVFormatContext *</span></span><br><span class="line"><span class="comment"> * 参数2，路径</span></span><br><span class="line"><span class="comment"> * 参数3，AVInputFormat *fmt  Mac、Windows 摄像头、麦克风， 目前安卓用不到</span></span><br><span class="line"><span class="comment"> * 参数4，各种设置：例如：Http 连接超时， 打开rtmp的超时  AVDictionary **options</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="built_in">avformat_open_input</span>(&amp;formatContext, data_source, <span class="literal">nullptr</span>, &amp;dictionary);</span><br><span class="line"></span><br><span class="line"><span class="built_in">av_dict_free</span>(&amp;dictionary);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(res)&#123;</span><br><span class="line">  <span class="built_in">callBackErrorEvent</span>(THREAD_CHILD, FFMPEG_CAN_NOT_OPEN_URL, <span class="number">0</span>, <span class="built_in">av_err2str</span>(res));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">LOGI</span>(<span class="string">&quot;avformat_open_input...&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>读取一些媒体数据，通过读取的这些媒体数据，尝试分析流信息。尤其是对于没有信息头的媒体，例如MPEG等，这步就很重要了，是对第一步的补充。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二步：查找媒体中的音视频流信息</span></span><br><span class="line">res = <span class="built_in">avformat_find_stream_info</span>(formatContext, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(res &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">callBackErrorEvent</span>(THREAD_CHILD, FFMPEG_CAN_NOT_FIND_STREAMS, <span class="number">0</span>, <span class="built_in">av_err2str</span>(res));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换为单位毫秒</span></span><br><span class="line"><span class="keyword">this</span>-&gt;duration = formatContext-&gt;duration / (AV_TIME_BASE/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">LOGI</span>(<span class="string">&quot;avformat_find_stream_info : duration = %d &quot;</span>, duration);</span><br></pre></td></tr></table></figure>

<p>一个媒体文件通常包含视频数据、音频数据、字幕信息等，有的地方将这些不同的数据类别称为轨道，在FFmpeg中称为流stream。根据解封装器中已经获取的流信息，打开合适的解码器。<br>有几个流，就要打开几个解码器。例如：有音频流，要找到对应的音频解码器；有视频流，要找到对应的视频解码器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三步： 根据流信息 流个数 用循环查找</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;formatContext-&gt;nb_streams;i++)&#123;</span><br><span class="line">    <span class="comment">//第四步： 获取媒体流</span></span><br><span class="line">    AVStream *stream = formatContext-&gt;streams[i];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//第五步: 从上面的流中 获取编解码参数 由于 后面的编码器 解码器都需要参数（宽高等等）</span></span><br><span class="line">    AVCodecParameters *parameters = stream-&gt;codecpar;</span><br><span class="line">    <span class="comment">//第六步: 根据上面的参数 获取编解码器</span></span><br><span class="line">    AVCodec *codec = <span class="built_in">avcodec_find_decoder</span>(parameters-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span>(!codec)&#123;</span><br><span class="line">        <span class="built_in">callBackErrorEvent</span>(THREAD_CHILD, FFMPEG_FIND_DECODER_FAIL, <span class="number">0</span>, <span class="string">&quot;can&#x27;t find decoder!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第七步： 编解码器上下文</span></span><br><span class="line">    AVCodecContext *codecContext = <span class="built_in">avcodec_alloc_context3</span>(codec);</span><br><span class="line">    <span class="keyword">if</span>(!codecContext)&#123;</span><br><span class="line">        <span class="built_in">callBackErrorEvent</span>(THREAD_CHILD, FFMPEG_ALLOC_CODEC_CONTEXT_FAIL, <span class="number">0</span>, <span class="string">&quot;init AVCodecContext error!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第八步: 使用上面的参数初始化编解码器上下文</span></span><br><span class="line">    res = <span class="built_in">avcodec_parameters_to_context</span>(codecContext, parameters);</span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">callBackErrorEvent</span>(THREAD_CHILD, FFMPEG_CODEC_CONTEXT_PARAMETERS_FAIL, <span class="number">0</span>, <span class="built_in">av_err2str</span>(res));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第九步: 打开解码器</span></span><br><span class="line">    res = <span class="built_in">avcodec_open2</span>(codecContext, codec, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(res)&#123;</span><br><span class="line">        <span class="built_in">callBackErrorEvent</span>(THREAD_CHILD, FFMPEG_OPEN_DECODER_FAIL, <span class="number">0</span>, <span class="built_in">av_err2str</span>(res));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//Audio部分</span></span><br><span class="line">    <span class="keyword">if</span>(parameters-&gt;codec_type == AVMediaType::AVMEDIA_TYPE_AUDIO)&#123;</span><br><span class="line">        audioChannel = <span class="keyword">new</span> <span class="built_in">AudioChannel</span>(i, codecContext, stream-&gt;time_base, jniCallbackHelper);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//Video部分</span></span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span>(parameters-&gt;codec_type == AVMediaType::AVMEDIA_TYPE_VIDEO)&#123;</span><br><span class="line">        <span class="comment">//虽然是视频类型，但是只是一帧封面</span></span><br><span class="line">        <span class="keyword">if</span>(stream-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)&#123;</span><br><span class="line">          	<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        AVRational fps_rational = stream-&gt;avg_frame_rate;</span><br><span class="line">        <span class="keyword">double</span> fps = <span class="built_in">av_q2d</span>(fps_rational);</span><br><span class="line">        videoChannel = <span class="keyword">new</span> <span class="built_in">VideoChannel</span>(i, codecContext, stream-&gt;time_base, fps, jniCallbackHelper);</span><br><span class="line">      	videoChannel-&gt;<span class="built_in">setRenderCallback</span>(renderCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!audioChannel &amp;&amp; !videoChannel)&#123;</span><br><span class="line">    <span class="built_in">callBackErrorEvent</span>(THREAD_CHILD, FFMPEG_NO_MEDIA, <span class="number">0</span>, <span class="string">&quot;no audio or video!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">LOGI</span>(<span class="string">&quot;prepared finish...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(jniCallbackHelper)&#123;</span><br><span class="line">  	jniCallbackHelper-&gt;<span class="built_in">onPrepared</span>(THREAD_CHILD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 视频 音频 的压缩包(AVPacket *) 循环获取出来 加入到队列里面去</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> JJHPlayer::_start() &#123;</span><br><span class="line">    AVPacket *packet = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (isPlaying)&#123;</span><br><span class="line">        packet = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">av_read_frame</span>(formatContext, packet);</span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            <span class="keyword">if</span>(videoChannel &amp;&amp; videoChannel-&gt;stream_index == packet-&gt;stream_index)&#123;</span><br><span class="line">                videoChannel-&gt;packets.<span class="built_in">insert</span>(packet);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(audioChannel &amp;&amp; audioChannel-&gt;stream_index == packet-&gt;stream_index)&#123;</span><br><span class="line">                audioChannel-&gt;packets.<span class="built_in">insert</span>(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res == AVERROR_EOF)&#123; <span class="comment">//   end of file == 读到文件末尾了 == AVERROR_EOF</span></span><br><span class="line">            <span class="comment">// 表示读完了，要考虑释放播放完成，表示读完了 并不代表播放完毕</span></span><br><span class="line">            <span class="keyword">if</span> (videoChannel-&gt;packets.<span class="built_in">empty</span>() &amp;&amp; audioChannel-&gt;packets.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 队列的数据被音频 视频 全部播放完毕了，我在退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//出现错误，结束当前循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BaseChannel::<span class="built_in">releaseAVPacket</span>(&amp;packet);</span><br><span class="line">    <span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码地址：<a href="https://github.com/jiajunhui/ffmpeg-jjhplayer">https://github.com/jiajunhui/ffmpeg-jjhplayer</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>播放器</tag>
        <tag>NDK</tag>
        <tag>JNI</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-CAS</title>
    <url>/2016/06/24/java_cas/</url>
    <content><![CDATA[<p>在Java并发中，我们最初接触的应该就是<code>synchronized</code>关键字了，但是<code>synchronized</code>属于重量级锁，很多时候会引起性能问题，<code>volatile</code>也是个不错的选择，但是<code>volatile</code>不能保证原子性，只能在某些场合下使用。</p>
<span id="more"></span>

<h2 id="什么是原子操作？如何实现原子操作"><a href="#什么是原子操作？如何实现原子操作" class="headerlink" title="什么是原子操作？如何实现原子操作"></a>什么是原子操作？如何实现原子操作</h2><p>假定有两个操作A和B(A和B可能都很复杂)，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p>
<p>实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁，</p>
<p>这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。</p>
<p>实现原子操作还可以使用当前的处理器基本都支持CAS()的指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p>
<p>CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做cas操作，直到成功为止。</p>
<p><img src="/images/java_cas_flow.png" alt="image-20210626230748795"></p>
<p>像<code>synchronized</code>这种独占锁属于<strong>悲观锁</strong>，它是在假设一定会发生冲突的，那么加锁恰好有用，除此之外，还有<strong>乐观锁</strong>，乐观锁的含义就是假设没有发生冲突，那么我正好可以进行某项操作，如果要是发生冲突呢，那我就重试直到成功，乐观锁最常见的就是<code>CAS</code>。</p>
<p>先看下经典的 i++代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//每个线程让count自增100次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                  	count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      	Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请问cout的输出值是否为200？答案是否定的，因为这个程序是线程不安全的，所以造成的结果count值可能小于200;</p>
<p>那么如何改造成线程安全的呢，其实我们可以使用上<code>Synchronized</code>同步锁,我们只需要在count++的位置添加同步锁，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//每个线程让count自增100次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ThreadCas.class)&#123;</span><br><span class="line">                      	count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      	Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加了同步锁之后，count自增的操作变成了原子性操作，所以最终的输出一定是count=200，代码实现了线程安全。</p>
<p>但是<code>Synchronized</code>虽然确保了线程的安全，但是在性能上却不是最优的，<code>Synchronized</code>关键字会让没有得到锁资源的线程进入<code>BLOCKED</code>状态，而后在争夺到锁资源后恢复为<code>RUNNABLE</code>状态，这个过程中涉及到操作系统用户模式和内核模式的转换，代价比较高。</p>
<p>尽管Java1.6为<code>Synchronized</code>做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。</p>
<p>所谓原子操作类，指的是java.util.concurrent.atomic包下，一系列以Atomic开头的包装类。例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>。它们分别用于<code>Boolean</code>，<code>Integer</code>，<code>Long</code>类型的原子性操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  	Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  	e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//每个线程让count自增100次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                  	count.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      	Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用AtomicInteger之后，最终的输出结果同样可以保证是200。并且在某些情况下，代码的性能会比Synchronized更好。</p>
<h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。</p>
<p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p>
<p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p>
<p>这样说或许有些抽象，我们来看一个例子：</p>
<p>1.在内存地址V当中，存储着值为10的变量。</p>
<p><img src="/images/java_cas_01.jpg" alt="img"></p>
<p>2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p>
<p><img src="/images/java_cas_02.jpg" alt="img"></p>
<p>3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p>
<p><img src="/images/java_cas_03.jpg" alt="img"></p>
<p>4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p>
<p><img src="/images/java_cas_04.jpg" alt="img"></p>
<p>5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</p>
<p><img src="/images/java_cas_05.jpg" alt="img"></p>
<p>6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p>
<p><img src="/images/java_cas_06.jpg" alt="img"></p>
<p>7.线程1进行SWAP，把地址V的值替换为B，也就是12。</p>
<p><img src="/images/java_cas_07.jpg" alt="img"></p>
<p>从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p>
<h2 id="CAS的缺点："><a href="#CAS的缺点：" class="headerlink" title="CAS的缺点："></a>CAS的缺点：</h2><p>1.CPU开销较大</p>
<p>在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p>
<p>2.不能保证代码块的原子性</p>
<p>CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p>
<p>3.ABA问题</p>
<p>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题。 常见的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么<code>A-B-A</code> 就会变成<code>1A-2B-3A</code>。 目前在JDK的atomic包里提供了类<code>AtomicStampedReference</code>和<code>AtomicMarkableReference</code>来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h2 id="JDK中相关原子操作类的使用"><a href="#JDK中相关原子操作类的使用" class="headerlink" title="JDK中相关原子操作类的使用"></a>JDK中相关原子操作类的使用</h2><h3 id="更新基本类型类："><a href="#更新基本类型类：" class="headerlink" title="更新基本类型类："></a>更新基本类型类：</h3><p><strong>AtomicBoolean，AtomicInteger，AtomicLong</strong></p>
<h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>•int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</p>
<p>•boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</p>
<p>•int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</p>
<p>•int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</p>
<h3 id="更新数组类："><a href="#更新数组类：" class="headerlink" title="更新数组类："></a>更新数组类：</h3><p><strong>AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</strong></p>
<h4 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h4><p>主要是提供原子的方式更新数组里的整型，其常用方法如下。</p>
<p>•int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</p>
<p>•boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</p>
<p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h3 id="更新引用类型："><a href="#更新引用类型：" class="headerlink" title="更新引用类型："></a>更新引用类型：</h3><p><strong>AtomicReference，AtomicMarkableReference（带版本戳的原子引用类型，版本戳为</strong>boolean<strong>类型），AtomicStampedReference（带版本戳的原子引用类型，版本戳为</strong>int<strong>类型）</strong></p>
<p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p>
<h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>原子更新引用类型。</p>
<h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><p>利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在ABA问题了。这就是AtomicStampedReference的解决方案。AtomicMarkableReference跟AtomicStampedReference差不多， AtomicStampedReference是使用pair的int stamp作为计数器使用，AtomicMarkableReference的pair使用的是boolean mark。 还是那个水的例子，AtomicStampedReference可能关心的是动过几次，AtomicMarkableReference关心的是有没有被人动过，方法都比较简单。</p>
<h4 id="AtomicMarkableReference："><a href="#AtomicMarkableReference：" class="headerlink" title="AtomicMarkableReference："></a>AtomicMarkableReference：</h4><p>原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，booleaninitialMark）。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-AQS和Lock</title>
    <url>/2016/07/05/java_aqs_lock/</url>
    <content><![CDATA[<p>队列同步器AbstractQueuedSynchronizer（以下简称同步器或AQS），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。并发包的大师（Doug Lea）期望它能够成为实现大部分同步需求的基础。</p>
<span id="more"></span>

<h2 id="AQS使用方式和其中的设计模式"><a href="#AQS使用方式和其中的设计模式" class="headerlink" title="AQS使用方式和其中的设计模式"></a>AQS使用方式和其中的设计模式</h2><p>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int型的state来代表这个状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。</p>
<p><img src="/images/java_aqs_lock01.jpg" alt="img"></p>
<p>在实现上，子类推荐被定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系：</p>
<p>锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；</p>
<p>同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</p>
<p>实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>同步器的设计基于模板方法模式。模板方法模式的意图是，定义一个操作中的算法的骨架，而将一些步骤的实现延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。我们最常见的就是Spring框架里的各种Template。Android中我们封装的BaseActivity也可以看做是一个模板。</p>
<h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><p>我们开了个蛋糕店，蛋糕店不能只卖一种蛋糕呀，于是我们决定先卖奶油蛋糕，芝士蛋糕和慕斯蛋糕。三种蛋糕在制作方式上一样，都包括造型，烘焙和涂抹蛋糕上的东西。所以可以定义一个抽象蛋糕模型</p>
<p><img src="/images/java_aqs_lock02.jpg" alt="img"></p>
<p>然后就可以批量生产三种蛋糕</p>
<p><img src="/images/java_aqs_lock03.jpg" alt="img"></p>
<p><img src="/images/java_aqs_lock04.jpg" alt="img"></p>
<p><img src="/images/java_aqs_lock05.jpg" alt="img"></p>
<p><img src="/images/java_aqs_lock06.jpg" alt="img"></p>
<p>这样一来，不但可以批量生产三种蛋糕，而且如果日后有扩展，只需要继承抽象蛋糕方法就可以了，十分方便，我们天天生意做得越来越赚钱。突然有一天，我们发现市面有一种最简单的小蛋糕销量很好，这种蛋糕就是简单烘烤成型就可以卖，并不需要涂抹什么食材，由于制作简单销售量大，这个品种也很赚钱，于是我们也想要生产这种蛋糕。但是我们发现了一个问题，抽象蛋糕是定义了抽象的涂抹方法的，也就是说扩展的这种蛋糕是必须要实现涂抹方法，这就很鸡儿蛋疼了。怎么办？我们可以将原来的模板修改为带钩子的模板。</p>
<p><img src="/images/java_aqs_lock07.jpg" alt="img"></p>
<p>做小蛋糕的时候通过flag来控制是否涂抹，其余已有的蛋糕制作不需要任何修改可以照常进行。</p>
<p><img src="/images/java_aqs_lock08.jpg" alt="img"></p>
<h2 id="AQS中的方法"><a href="#AQS中的方法" class="headerlink" title="AQS中的方法"></a>AQS中的方法</h2><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>实现自定义同步组件时，将会调用同步器提供的模板方法，</p>
<p><img src="/images/java_aqs_lock09.jpg" alt="img"></p>
<p>这些模板方法同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放、同步状态和查询同步队列中的等待线程情况。</p>
<h3 id="可重写的方法"><a href="#可重写的方法" class="headerlink" title="可重写的方法"></a>可重写的方法</h3><p><img src="/images/java_aqs_lock10.jpg" alt="img"></p>
<p><img src="/images/java_aqs_lock11.jpg" alt="img"></p>
<h3 id="访问或修改同步状态的方法"><a href="#访问或修改同步状态的方法" class="headerlink" title="访问或修改同步状态的方法"></a>访问或修改同步状态的方法</h3><p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。</p>
<p>•getState()：获取当前同步状态。</p>
<p>•setState(int newState)：设置当前同步状态。</p>
<p>•compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。 </p>
<h2 id="CLH队列锁"><a href="#CLH队列锁" class="headerlink" title="CLH队列锁"></a>CLH队列锁</h2><p>CLH队列锁即Craig, Landin, and Hagersten (CLH) locks。</p>
<p>CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</p>
<p>当一个线程需要获取锁时：</p>
<ol>
<li>创建一个的QNode，将其中的locked设置为true表示需要获取锁，myPred表示对其前驱结点的引用</li>
</ol>
<p><img src="/images/java_aqs_lock_clh01.png" alt="image-20210707233648827"></p>
<ol start="2">
<li>线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred</li>
</ol>
<p><img src="/images/java_aqs_lock_clh02.png" alt="image-20210707233734315"></p>
<p>线程B需要获得锁，同样的流程再来一遍</p>
<p><img src="/images/java_aqs_lock_clh03.png" alt="image-20210707233844690"></p>
<p> 3.线程就在前驱结点的locked字段上旋转，直到前驱结点释放锁(前驱节点的锁值 locked == false)</p>
<p> 4.当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点</p>
<p><img src="/images/java_aqs_lock_clh04.png" alt="image-20210707233916664"></p>
<p>如上图所示，前驱结点释放锁，线程A的myPred所指向的前驱结点的locked字段变为false，线程A就可以获取到锁。</p>
<p>CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。</p>
<p>Java中的AQS是CLH队列锁的一种变体实现。</p>
<h2 id="ReentrantLock的实现"><a href="#ReentrantLock的实现" class="headerlink" title="ReentrantLock的实现"></a>ReentrantLock的实现</h2><h3 id="锁的可重入"><a href="#锁的可重入" class="headerlink" title="锁的可重入"></a>锁的可重入</h3><p>重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。</p>
<p>1）线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。</p>
<p>2）锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。</p>
<p>nonfairTryAcquire方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。同步状态表示锁被一个线程重复获取的次数。</p>
<p>如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。</p>
<h3 id="公平和非公平锁"><a href="#公平和非公平锁" class="headerlink" title="公平和非公平锁"></a>公平和非公平锁</h3><p>ReentrantLock的构造函数中，默认的无参构造函数将会把Sync对象创建为NonfairSync对象，这是一个“非公平锁”；而另一个构造函数ReentrantLock(boolean fair)传入参数为true时将会把Sync对象创建为“公平锁”FairSync。</p>
<p>nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。tryAcquire方法，该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类加载-双亲委派机制</title>
    <url>/2016/06/16/java_class_loader_parent_delegate_model/</url>
    <content><![CDATA[<p>双亲委派机制又称为父级委托模型。想要了解它，还需理解[类加载]机制、类加载器、类加载器的层级关系。</p>
<span id="more"></span>

<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><p>编译器把Java源文件编译成.class文件，再由JVM装载.class文件到内存中，JVM装载完成后得到一个Class对象字节码。有了字节码对象，接下来就可以实例化使用了。</p>
<p><img src="/images/java_class_loader_parent_delegate_model01.png" alt="img"></p>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类的加载器主要有启动类加载器、附加类加载器、应用类加载器、用户自定义加载器"><a href="#类的加载器主要有启动类加载器、附加类加载器、应用类加载器、用户自定义加载器" class="headerlink" title="类的加载器主要有启动类加载器、附加类加载器、应用类加载器、用户自定义加载器"></a>类的加载器主要有启动类加载器、附加类加载器、应用类加载器、用户自定义加载器</h2><p><img src="/images/java_class_loader_parent_delegate_model02.png" alt="img"></p>
<p>启动类加载器：是用来加载jdk\jre\lib下的核心类库，比如rt.jar、resources.jar等。<br>扩展类加载器：是用来加载jdk\jre\lib\ext下的扩展类库中的jar包和.class文件。<br>应用类加载器：则用来加载classpath下的jar包和.class文件。还有自定义加载器，也属于应用类加载器。</p>
<p><img src="/images/java_class_loader_parent_delegate_model03.png" alt="img"></p>
<h2 id="双亲委派机制，是按照加载器的层级关系，逐层进行委派"><a href="#双亲委派机制，是按照加载器的层级关系，逐层进行委派" class="headerlink" title="双亲委派机制，是按照加载器的层级关系，逐层进行委派"></a>双亲委派机制，是按照加载器的层级关系，逐层进行委派</h2><p><img src="/images/java_class_loader_parent_delegate_model04.png" alt="img"></p>
<p>要加载一个类MyClass.class，从低层级到高层级一级一级委派，先由应用层加载器委派给扩展类加载器，再由扩展类委派给启动类加载器；启动类加载器载入失败，再由扩展类加载器载入，扩展类加载器载入失败，最后由应用类加载器载入，如果应用类加载器也找不到那就报ClassNotFound异常了。</p>
<h2 id="双亲委派机制的优点"><a href="#双亲委派机制的优点" class="headerlink" title="双亲委派机制的优点"></a>双亲委派机制的优点</h2><ol>
<li>保证安全性，层级关系代表优先级，也就是所有类的加载，优先给启动类加载器，这样就保证了核心类库类。</li>
<li>避免重复，如果父类加载器加载过了，子类加载器就没有必要再去加载了。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类加载与对象实例化</title>
    <url>/2016/06/15/java_class_loader_and_instance/</url>
    <content><![CDATA[<p>类加载过程就是将.class文件转化为Class对象，类实例化的过程，（User user = new User(); 这个过程是对象实例化的过程）;<br>一个.class文件只有一个Class对象（字节码对象），可以有无数个对象（例如：new User();）</p>
<span id="more"></span>

<h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p>我们编写的类（.java文件）会被编译器（如javac编译器）编译成Class文件。Java虚拟机把Class文件加载到内存中的过程就称为类加载过程。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>一个类从被加载到虚拟机内存中，到卸载出内存，共经历七个过程，即这个类的生命周期会经历<strong>加载、验证、准备、解析、初始化、使用、卸载</strong>七个阶段。其中，验证、准备、解析三个阶段又统称为<strong>连接</strong>。</p>
<p><img src="/images/java_class_loader_and_instance01.webp" alt="img"></p>
<ul>
<li><p>类的加载机制:如果没有相应类的class，则加载class到方法区。对应着加载-&gt;验证-&gt;准备-&gt;解析–&gt;初始化阶段</p>
</li>
<li><ul>
<li>加载：载入class对象，不一定是从class文件获取，可以是jar包，或者动态生成的class</li>
<li>验证：校验class字节流是否符合当前jvm规范</li>
<li>准备：为 <strong>类变量</strong> 分配内存并设置变量的初始值( <strong>默认值</strong> )。如果是final修饰的对象则是赋值声明值</li>
<li>解析：将常量池的符号引用替换为直接引用</li>
<li>初始化：执行类构造器<clinit>( <strong>注意不是对象构造器</strong> )，为 <strong>类变量</strong> 赋值，执行静态代码块。jvm会保证子类的<clinit>执行之前，父类的<clinit>先执行完毕</li>
</ul>
</li>
<li><p>其中验证、准备、解析3个部分称为 连接</p>
</li>
<li><p><clinit>方法由 <strong>静态变量赋值代码和静态代码块</strong> 组成；先执行类静态变量显示赋值代码，再到静态代码块代码</p>
</li>
</ul>
<h2 id="触发类加载的条件"><a href="#触发类加载的条件" class="headerlink" title="触发类加载的条件"></a>触发类加载的条件</h2><ul>
<li><p>第一次创建类的新对象时， 会触发类的加载初始化和对象的初始化函数<init>执行，这个是实例初始化，其他6个都是类初始化</p>
</li>
<li><p>JVM启动时会先加载初始化包含main方法的类</p>
</li>
<li><p>调用类的静态方法（如执行invokestatic指令）</p>
</li>
<li><p>对类或接口的静态字段执行读写操作（即执行getstatic、putstatic指令）；不过final修饰的静态字段的除外(已经赋值，String和基本类型，不包含包装类型)，它被初始化为一个编译时常量表达式</p>
</li>
<li><ul>
<li><strong>注意</strong> ：操作静态字段时，只有直接定义这个字段的类才会被初始化；如通过其子类来操作父类中定义的静态字段，只会触发父类<clinit>的初始化而不是子类的初始化</li>
</ul>
</li>
<li><p>调用JavaAPI中的反射方法时(比调用java.lang.Class中的方法(Class.forName)，或者java.lang.reflect包中其他类的方法)</p>
</li>
<li><p>当初始化一个类时，其父类没有初始化，则需先触发父类的初始化(接口例外)</p>
</li>
</ul>
<h1 id="对象的实例化过程"><a href="#对象的实例化过程" class="headerlink" title="对象的实例化过程"></a>对象的实例化过程</h1><ul>
<li><p>对象实例化过程其实就是执行类构造函数 对应在字节码文件中的<init>()方法(称之为实例构造器)；<init>()方法由 <strong>非静态变量、非静态代码块以及对应的构造器组成</strong></p>
</li>
<li><ul>
<li><init>()方法可以重载多个，类有几个构造器就有几个<init>()方法</li>
<li><init>()方法中的代码执行顺序为：父类变量初始化，父类代码块，父类构造器，子类变量初始化，子类代码块，子类构造器。</li>
</ul>
</li>
<li><p>静态变量，静态代码块，普通变量，普通代码块，构造器的执行顺序</p>
</li>
</ul>
<p><img src="/images/java_class_loader_and_instance02.webp" alt="img"></p>
<ul>
<li>具有父类的子类的实例化顺序如下</li>
</ul>
<p><img src="/images/java_class_loader_and_instance03.webp" alt="img"></p>
<h1 id="类加载和双亲委派规则"><a href="#类加载和双亲委派规则" class="headerlink" title="类加载和双亲委派规则"></a>类加载和双亲委派规则</h1><ul>
<li><p>类加载器</p>
</li>
<li><ul>
<li>通过一个类的全限定名来获取 <strong>描述此类的二进制字节流</strong> ，实现这个动作的代码模块称为类加载器</li>
<li>任意一个类都需要其加载器和类本身来确定类在JVM的唯一性；每个类加载器都有自己的类名称空间，同一个类class由不同的加载器加载，则被JVM判断为不同的类</li>
</ul>
</li>
</ul>
<p><img src="/images/java_class_loader_and_instance04.webp" alt="img"></p>
<ul>
<li><p>双亲委派模型</p>
</li>
<li><ul>
<li>启动类加载器有C++代码实现，是虚拟机的一部分。负责加载lib下的类库</li>
<li>其他的类加载器有java语言实现，独立于JVM，并且继承ClassLoader</li>
<li>extention ClassLoader负责加载libext目录下的类库</li>
<li>application ClassLoader 负责加载用户路径下(ClassPath)的代码</li>
<li>不同的类加载器加载同一个class文件会导致出现两个类。而java给出解决方法是下层的加载器加委托上级的加载器去加载类，如果父类无法加载(在自己负责的目录找不到对应的类)，而交还下层类加载器去加载。如下图</li>
</ul>
</li>
</ul>
<p><img src="/images/java_class_loader_and_instance05.webp" alt="img"></p>
<ul>
<li><p>打破双亲委派模型</p>
</li>
<li><ul>
<li>双亲委派模型并不是一个强制的约束模型，而是java设计者推荐给开发者的类加载实现方式</li>
<li>双亲委派模型很好的解决各个类加载基础类的同一问题(越基础的类由越上层的加载器加载)，但是基础类总是作为用户代码调用的API，但是如果它的具体实现是下层的代码，此时基础类需要调用下层的代码，则需要打破双亲委派模型</li>
<li>如JNDI服务，JNDI的代码有启动类去加载(rt.jar)，它需要调用由独立厂商部署在应用程序classpath下的JNDI的SPI(Service Provider Interface)代码。为了解决SPI代码加载问题，java引入了线程上下文类加载器去加载SPI代码。也就是父类加载器请求子类去完成类的加载动作</li>
<li>线程上下文类加载器，线程创建时会从父线程继承，如果全局范围没有设置过，则默认设置为application Class Loader</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-HashMap详解</title>
    <url>/2016/07/02/java_hashmap/</url>
    <content><![CDATA[<p>HashMap是常用的用于存储key-value键值对数据的一个<strong>集合</strong>，底层是基于对<strong>Map</strong>的接口实现。每一个键值对又叫<strong>Entry</strong>，这些<strong>Entry</strong>分散的存储在一个由<strong>数组和链表</strong>组成的集合中。当然在Java8中，Entry变成了<strong>Node</strong>。</p>
<span id="more"></span>

<h1 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h1><h2 id="table数组"><a href="#table数组" class="headerlink" title="table数组"></a>table数组</h2><p>首先我们要知道，我们存在HashMap中的数据最终是存了什么地方，就是如下的结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> HashMap.Node&lt;K, V&gt;[] table;</span><br></pre></td></tr></table></figure>

<p>可能有人看到transient有些陌生，被这个关键字修饰的变量将不会被序列化。简单来说，就是序列化之后这个字段的值就会被干掉，用于一些不需要传递给第三方的字段。<br>例如一个矩形，在本地使用的时候，有长、宽和面积三个属性，但是你要把这个对象给第三方用，但是由于面积可以通过另外两个属性推导出来，这个key就不需要传递给第三方了。这种情况就可以用transient关键字修饰。总的来说就是，被transient修饰的变量将不再参与序列化。</p>
<h2 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h2><p>下面是Node节点的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">   <span class="keyword">final</span> K key;</span><br><span class="line">   V value;</span><br><span class="line">   Node&lt;K,V&gt; next;</span><br><span class="line">   .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码省略了一些<strong>Getter</strong>和<strong>Setter</strong>，结构还是非常清晰和简单。可以看到这个节点存储了下一个节点的对象的引用，形成了一个链表的结构。<br>为什么要用链表？用数组不行吗？刚刚上面提到过，这个集合是由链表和数组组成的。因为再完美的hash算法都有可能产生哈希冲突，所以两个不同key的元素可以被放在同一个地方。<br>而单用数组明显不能满足这个需求，而在数组的槽位上存一个链表就可以解决这个问题。</p>
<h1 id="HashMap的使用"><a href="#HashMap的使用" class="headerlink" title="HashMap的使用"></a>HashMap的使用</h1><h2 id="put存值"><a href="#put存值" class="headerlink" title="put存值"></a>put存值</h2><p>传入了两个参数，Key和Value，函数的定义如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该跟大多数人YY的put方法差不多，put方法再调用了putVal 方法。<br>首先经过了hash之后的key，是一个整型的hashcode，其次是我们传入的key和value。<strong>最后两个布尔值，后面会提到。</strong><br>首先一进入putVal就会声明存放数据的table，如果这个HashMap是首次设置值，就会被初始化一个默认size的table，且所有元素的初始值都是NULL，下面是初始化这块的核心代码，我省略掉了一些无关的变量声明。<br>有趣的是，初始化调用的是resize方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; p;</span><br><span class="line"><span class="keyword">int</span> n, i;</span><br><span class="line"><span class="comment">//如果当前map中无数据，执行resize方法。并且返回n</span></span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">.....</span><br><span class="line">newCap = <span class="number">16</span>;<span class="comment">//默认容量</span></span><br><span class="line">newThr = <span class="number">12</span>;<span class="comment">//默认阈值</span></span><br></pre></td></tr></table></figure>

<p><strong>默认值为啥是16</strong></p>
<p>上面初始化table的默认size给的是16，当然我们也可以自己定义，但是建议是最好是2的幂。有的朋（杠）友（精）就要问了，为什么是16呢？我13，14不他不香吗？我们接下来就要分析为什么不香。<br>当我们放元素进入map的时候，它是如何确定元素在table数组中的位置的呢？我们拿name这个key举例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash = (h = key.hashCode()) ^ h &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">p = tab[i = n - <span class="number">1</span> &amp; hash]</span><br></pre></td></tr></table></figure>

<p>可以看到，是将hash之后key和数组的length-1做与运算得到了一个数组下标。而且，hash值的二进制的位数，大多数情况下都会比table的长度的二进制位数多。换句话说，与运算之后得到的数组下标index完全取决于hash值的后几位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//16 n  	10000;</span></span><br><span class="line"><span class="comment">//15 n-1 	1111;</span></span><br><span class="line"><span class="comment">//14 		1110;</span></span><br><span class="line"><span class="comment">//13 		1101;</span></span><br><span class="line"><span class="comment">//12 		1100;</span></span><br><span class="line"><span class="comment">//11 		1011;</span></span><br><span class="line"><span class="comment">//10 		1010;</span></span><br></pre></td></tr></table></figure>

<p>从13、14的二进制值可以看出来，存在0和1在二进制位数上分布不均匀的情况，这样一来就会造成一个问题，那就是会存在某些<strong>不同的hash值</strong>经过与运算得到的值是<strong>一样的</strong>。这样就会导致hash到的index<strong>不均匀</strong>，换句话说有些index可能永远都不会被hash到，而有些index也被频繁的hash到。<br>本来hash算法是要求计算的结果要均匀分布的，但是上述的结果明显不符合均匀分布的要求。用n-1而不用n也是因为同样的道理。如果这个值是2的幂，那么2的幂的值-1的所有二进制位数都是1，这样有利于hash计算的均匀分布。<br>综上所述，不一定是16，<strong>2的幂</strong>都可以，16只是一个经验值。</p>
<p><em><strong>自动扩容</strong></em></p>
<p>除了size，初始化的时候还会设定一个阈值，值为12，newThr = 12，这里需要提到一个概念<strong>负载因子</strong>，HashMap的实现里默认给的是0.75。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//12/16 = 0.75F</span></span><br><span class="line">    <span class="keyword">this</span>.lodaFactor = <span class="number">0.75F</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>负载因子是用来干嘛的呢？最开始我们提到了，最开始存储的数据结构是数组，这种基础结构是有size设定的。当我们不停的往map里存数据的时候，总会存满，当元素快存满的时候，我们就需要扩大map的容量，来容纳更多的元素，这就需要一个<strong>自动扩容</strong>的机制了。<br>在当数据量大于超过设定的阈值的时候（容量*负载因子），自动对map进行扩容，以存放更多的数据。<br>自动扩容做了什么事情呢？总结来说就是两件事。<br>创建新的数组，大小是原来数组的一倍。将元素rehash到新的数组为什么要<strong>rehash</strong>呢？上面我们提到过了，当元素被放进map时，确认下标的方法是<strong>table的长度-1</strong>和<strong>hash值</strong>做与运算，现在table的长度发生了变化，那么自然而然，元素获取下标的运算结果也就跟之前的不一样了， 所以需要将老的map中的元素再按照新的table长度<strong>rehash</strong>到扩容后的table中。<br>所以在当你对性能有一定要求，且你知道你创建map的时候size的时候，可以指定size，这样一来就不会因为数据量持续的增大而去频繁的自动扩容了</p>
<p><strong>put的过程中到底发生了什么</strong></p>
<p>了解了<strong>底层数据结构</strong>和<strong>自动扩容机制</strong>，接下来我们来看一下put过程中究竟发生了什么。我们上面说过了，会通过<strong>数组的长度-1</strong>和<strong>hash值</strong>与运算得到一个数组下标。</p>
<p>如果该位置没有元素，那么就很简单，直接新建一个节点即可然后放置在数据的具体位置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tab[i] = <span class="keyword">this</span>.newNode(hash, key, value, (HashMap.Node)<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>但是如果该下标已经有元素了，这种情况HashMap是怎么处理的呢？这也要看情况。</p>
<p>如果是跟当前槽位相同的key，就直接覆盖。这就是我们修改某个key的值会发生的情况。那HashMap怎么来判断是不是同一个key呢？就像下面这样。p就是当前槽位上已经有的元素，如果新、老元素的key的<strong>hashCode</strong>和<strong>值</strong>都相同<strong>且key不为空</strong>，那么就能证明这两个key是相同的，那么此时只需要<strong>覆盖</strong>即可。p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))而如果p是TreeNode的实例，那么就代表当前槽位已经是一个<strong>红黑树</strong>了，此时只需要往这个树里putTreeVal即可。至于为什么是红黑树，哪儿来的红黑树，下面马上就要讲到了。最后一种情况就是，既不是已经存在的元素也不是TreeNode的实例，也不是<strong>红黑树</strong>。这种情况下，它就是一个普通的Node。你可以理解为链表，如果hash冲突了，就把这个Node放到该位置的<strong>链表末尾</strong>。Java8之前采用的<strong>头插法</strong>，而Java8换成了<strong>尾插法</strong>，至于为什么要换，后面会讲。当该位置的链表中的元素超过了TREEIFY_THRESHOLD所设置的数量时，就会触发树化，将其转化为<strong>红黑树</strong>。Java8里给的默认值是<strong>8。</strong></p>
<p><strong>为啥要转化成红黑树</strong></p>
<p>首先我们要知道为什么要树化。当大量的数据放入Map中，Hash冲突会越来越多，某些位置就会出现一个很长的链表的情况。这种情况下，查询时间复杂度是O(n) ，删除的时间复杂度也是O(n)，查询、删除的效率会大大降低。而同样的数据情况下，平衡二叉树的时间复杂度都是O(logn)。</p>
<p>有的朋（杠）友（精）看到这个小标题不乐意了，怎么就直接用红黑树了？我用<strong>二叉查找树</strong>它不香吗？</p>
<p>不了解二叉查找树的，我把它的特点列在了下面。</p>
<p>左子树上的所有节点的值都小于根节点的值右子树上的所有节点的值都大于根节点的值再精简一下就是，<strong>左小右大</strong></p>
<p>但是，如果数据大量的趋近于有序，例如所有的节点都比根节点大，那这个时候<strong>二叉查找树</strong>就退化成了<strong>链表</strong>，查询效率就会急剧下降。看到这是不是觉得有点不对，我才从链表树化，你这又给我退化成了链表？</p>
<p>朋友看到这又不乐意了，好好好，就算二叉查找树不行，那AVL树它也不行？用了AVL树就不会出现上面所描述的效率急剧退化的情况了不是吗？</p>
<p>的确是这样，AVL也可以叫<strong>平衡二叉搜索树</strong>。AVL树会在其有退化成链表的趋势的时候（左右子树的高度差超过某个阈值）调整树的结构，也就是通过左旋和右旋来使其左右子树的高度尽量平衡。</p>
<p>那为什么一定要用<strong>红黑树</strong>？</p>
<p>具体的细节也就不在这里赘述，不知不觉已经写了这么多了，直接说结论吧。AVL树的查找速度更快，但是相应的插入和修改的速度较慢。而红黑树则在插入和修改操作较为密集的时候表现更好。</p>
<p>而总结我们日常的HashMap使用，大多数情况下插入和修改应该是比查找更频繁一些的。而在这种情况下，红黑树的综合表现会更好一些。</p>
<p>至于红黑树的相关细节，涉及的东西还是挺多，我之后会单独拿一个篇幅来讲。</p>
<p><strong>为什么要用尾插法</strong></p>
<p>我们目前用的最多的是Java8，在Java8中采用的是<strong>尾插法</strong>，Java8之前采用的是头插法。</p>
<p>那为什么后面又变成了<strong>尾插法</strong>呢？放心，肯定不是设计者闲的蛋疼，没事来改个设计。这样做一定是有一定的道理的。在解释这个问题之前，我们先来看看，如果采取头插法在<strong>多线程</strong>下的情况下会出现什么问题。</p>
<p>我们讲过，假设数组中index=1的位置已经有了元素A，之后又有元素B被分配到了index=1的位置。那么在下标为1的槽位上的链表就变成了B -&gt; A。</p>
<p>此时再分配了一个新元素C，链表又被更新成了C -&gt; B -&gt; A。这也是为什么叫<strong>头插法</strong>，新的元素会被放在链表的头节点，因为当时设计的时候考虑到后被放入map的元素被访问的可能性更大。</p>
<p>上面讲到了在当不停的往map中放置元素后，超过了设定的阈值，就会触发<strong>自动扩容</strong>。此时会触发两个操作，一是创建一个容量为之前两倍的底层数组，并且将老的数组中的元素<strong>rehash</strong>到新的数组中。</p>
<p>而由于数组的长度发生了变化，这就导致了元素的rehash结果跟之前在老数组中的位置不一样。</p>
<p>首先我们来模拟一下rehash的过程，假设新的数组中下标为2的槽位是空的。</p>
<p>首先元素C，被放置在了其他位置。然后元素B，被rehash到了下标为2的槽位， 至此都没有问题。最后元素A，同样被rehash到了下标为2的槽位，此时链表变成了A -&gt; B。到这就有问题了，最开始B的next指向的是A节点。但是rehash之后A的next又指向B，看到这你应该就能明白发生了什么。我看到很多的对JDK1.7版的HashMap在多线程的情况下扩容会出现死锁的解释都只到了环形链表。但是其实就算是环形链表，只要找到了对应的元素，就会直接退出循环的逻辑，也不会造成死循环。</p>
<p>实际情况是，当自动扩容形成了环形链表后，当你去Get了一个在entry链上<strong>不存在的元素时</strong>，就会出现死循环的情况。</p>
<h2 id="get取值"><a href="#get取值" class="headerlink" title="get取值"></a>get取值</h2><p>上面聊了给HashMap赋值的大概过程，接下来聊一下从HashMap获取值会发生什么。get方法的开始，跟put一样很简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，取值的核心操作是getNode来负责完成的。</p>
<p>首先第一件事就是去check的第一个元素是不是当前查找的元素。</p>
<p>如果不是，而且当前槽位已经被树化成了红黑树，就走红黑树的getTreeNode方法。</p>
<p>如果还没有被树化，只是普通的链表，则顺着next一路找下去。</p>
<p>由于get方法逻辑和实现都比较容易理解，就不贴太多源码了。</p>
<h1 id="关于HashMap的问题"><a href="#关于HashMap的问题" class="headerlink" title="关于HashMap的问题"></a>关于HashMap的问题</h1><h2 id="为什么HashMap要树化"><a href="#为什么HashMap要树化" class="headerlink" title="为什么HashMap要树化"></a>为什么HashMap要树化</h2><p>本质上这是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端CPU大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。</p>
<p><u>用哈希碰撞发起拒绝服务攻击(DOS，Denial-Of-Service attack),常见的场景是攻击者可以事先构造大量相同哈希值的数据，然后以JSON数据的形式发送给服务器，服务器端在将其构建成为Java对象过程中，通常以Hashtable或HashMap等形式存储，哈希碰撞将导致哈希表发生严重退化，算法复杂度可能上升一个数据级，进而耗费大量CPU资源。</u></p>
<h2 id="为什么要将链表转红黑树的阈值设置为8"><a href="#为什么要将链表转红黑树的阈值设置为8" class="headerlink" title="为什么要将链表转红黑树的阈值设置为8"></a>为什么要将链表转红黑树的阈值设置为8</h2><p>我们可以这么来看，当链表长度大于或等于阈值（默认为 8）的时候，如果同时还满足容量大于或等于 <em>MIN_TREEIFY_CAPACITY</em>（默认为 64）的要求，就会把链表转换为红黑树。同样，后续如果由于删除或者其他原因调整了大小，当红黑树的节点小于或等于 6 个以后，又会恢复为链表形态。</p>
<p>每次遍历一个链表，平均查找的时间复杂度是 O(n)，n 是链表的长度。红黑树有和链表不一样的查找性能，由于红黑树有自平衡的特点，可以防止不平衡情况的发生，所以可以始终将查找的时间复杂度控制在 O(log(n))。最初链表还不是很长，所以可能 O(n) 和 O(log(n)) 的区别不大，但是如果链表越来越长，那么这种区别便会有所体现。所以为了提升查找性能，需要把链表转化为红黑树的形式。</p>
<p>还要注意很重要的一点，单个 TreeNode 需要占用的空间大约是普通 <em>Node</em> 的两倍，所以只有当包含足够多的 <em>Nodes</em> 时才会转成 <em>TreeNodes</em>，而是否足够多就是由 <em>TREEIFY_THRESHOLD</em> 的值决定的。而当桶中节点数由于移除或者 resize 变少后，又会变回普通的链表的形式，以便节省空间。</p>
<p>默认是链表长度达到 8 就转成红黑树，而当长度降到 6 就转换回去，这体现了时间和空间平衡的思想，最开始使用链表的时候，空间占用是比较少的，而且由于链表短，所以查询时间也没有太大的问题。可是当链表越来越长，需要用红黑树的形式来保证查询的效率。</p>
<p>在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，是最理想的值。</p>
<p>事实上，链表长度超过 8 就转为红黑树的设计，更多的是为了防止用户自己实现了不好的哈希算法时导致链表过长，从而导致查询效率低，而此时转为红黑树更多的是一种保底策略，用来保证极端情况下查询的效率。</p>
<p>通常如果 hash 算法正常的话，那么链表的长度也不会很长，那么红黑树也不会带来明显的查询时间上的优势，反而会增加空间负担。所以通常情况下，并没有必要转为红黑树，所以就选择了概率非常小，小于千万分之一概率，也就是长度为 8 的概率，把长度 8 作为转化的默认阈值。</p>
<p>如果开发中发现 <em>HashMap</em> 内部出现了红黑树的结构，那可能是我们的哈希算法出了问题，所以需要选用合适的hashCode方法，以便减少冲突。 </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Java JVM内存模型</title>
    <url>/2016/06/04/java_jvm/</url>
    <content><![CDATA[<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图所示：</p>
<span id="more"></span>

<p><img src="/images/java_jvm_model.png" alt="java_jvm_model"></p>
<h2 id="运行时数据区讲解"><a href="#运行时数据区讲解" class="headerlink" title="运行时数据区讲解"></a>运行时数据区讲解</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核心处理器来说是一个内核）都会执行一条线程中得指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p><img src="/images/java_jvm_stack_fram.png" alt="image-20210703205220545"></p>
<p>经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分发比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量变部分。</p>
<p>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）对象引用（refrerence类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，本地方法栈保存的是native方法的信息，它们之间的区别不过时虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中 创建栈帧，JVM只是简单地动态链接并直接调用native方法，在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一。与虚拟机一样，本地方法栈区域也会抛出StackOverFlowError和OutOfMemoryError异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆内存上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么绝对了。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”，幸好国内没有翻译成“垃圾堆”，从内存回收的角度来看，由于现在收集器基本都采用分带收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快的分配内存。</p>
<p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p>
<p>对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区成为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有XX:MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如String.intern())会因这个原因导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了，在目前已经发布的JDK1.7的HotSpot中，已经把原本房在永久代的字符串常量池移出。</p>
<p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h2 id="JVM运行过程"><a href="#JVM运行过程" class="headerlink" title="JVM运行过程"></a>JVM运行过程</h2><p><img src="/images/java_jvm_run_step.png" alt="image-20210703204757661"></p>
<h2 id="虚拟机优化技术"><a href="#虚拟机优化技术" class="headerlink" title="虚拟机优化技术"></a>虚拟机优化技术</h2><h3 id="编译优化-方法内联"><a href="#编译优化-方法内联" class="headerlink" title="编译优化-方法内联"></a>编译优化-方法内联</h3><p>方法的内联是为了减少虚拟机栈在执行时的入栈出栈操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">boolean</span> v = method2(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，method2的执行会被优化为下面的样子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">boolean</span> v = <span class="number">1</span> &gt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于是把method2的执行代码给拷贝到method1中执行了，这样就省去了method2执行时在虚拟机栈中的入栈和出栈操作了。</p>
<h3 id="栈的优化技术-栈帧之间数据共享"><a href="#栈的优化技术-栈帧之间数据共享" class="headerlink" title="栈的优化技术-栈帧之间数据共享"></a>栈的优化技术-栈帧之间数据共享</h3><p>在一般的模型中，两个不同的栈帧的内存区域是独立的，但是大部分的JVM在实现中会进行一些优化，使得两个栈帧出现一部分重叠。（主要体现在方法中有参数传递的情况），让下面栈帧的操作数栈和上面栈帧的部分局部变量重叠在一起，这样做不但节约了一部分空间，更加重要的是在进行方法调用时就可以直接公用一部分数据，无需进行额外的参数复制传递了。</p>
<p><img src="/images/java_jvm_stack_frame_share.png" alt="image-20210703213127391"></p>
<p><strong>参考资料：《深入理解Java虚拟机》</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Thread总结</title>
    <url>/2016/06/07/java_thread_base/</url>
    <content><![CDATA[<p>说起线程，就会想到进程。进程是程序运行资源分配的最小单位。进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、 磁盘 IO 等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程 之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次 运行活动,进程是系统进行资源分配和调度的一个独立单位。</p>
<span id="more"></span>

<p>进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一 个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进 程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就 是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。</p>
<p><strong>线程是 CPU 调度的最小单位</strong>,<strong>必须依赖于进程而存在</strong></p>
<p>线程是进程的一个实体,是 CPU 调度和分派的基本单位,它是比进程更小的、 能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中 必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其 他的线程共享进程所拥有的全部资源。</p>
<p><strong>线程无处不在</strong></p>
<p>任何一个程序都必须要创建线程,特别是 Java 不管任何程序都必须启动一个 main 函数的主线程; Java Web 开发里面的定时任务、定时器、JSP 和 Servlet、异 步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都 离不开线程和并发的知识。</p>
<h2 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h2><h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>Java中创建线程有两种方法</p>
<ol>
<li><p>继承Thread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="keyword">super</span>.run();</span><br><span class="line">      	System.out.println(<span class="string">&quot;I am extende Thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;I am implements Runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>线程的调用执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    UseThread useThread = <span class="keyword">new</span> UseThread();</span><br><span class="line">    useThread.start();</span><br><span class="line"></span><br><span class="line">    UseRunnable useRunnable = <span class="keyword">new</span> UseRunnable();</span><br><span class="line">    <span class="keyword">new</span> Thread(useRunnable).start();</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>线程状态流转示意</p>
<p><img src="/images/java_thread_state.png" alt="image-20210620231638101"></p>
<h2 id="如何终止线程？"><a href="#如何终止线程？" class="headerlink" title="如何终止线程？"></a>如何终止线程？</h2><p>查看Thread的API，发现有stop()方法，那stop可以终止线程吗？看注解标记，已经被废弃了。</p>
<p>上代码看看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;running...sleep before&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;running...sleep after&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException exception)&#123;</span><br><span class="line">              	exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    thread1.stop();</span><br><span class="line">    System.out.println(<span class="string">&quot;stop...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">running...sleep before</span><br><span class="line">running...sleep after</span><br><span class="line">running...sleep before</span><br><span class="line">running...sleep after</span><br><span class="line">running...sleep before</span><br><span class="line">running...sleep after</span><br><span class="line">running...sleep before</span><br><span class="line">running...sleep after</span><br><span class="line">running...sleep before</span><br><span class="line">running...sleep after</span><br><span class="line">running...sleep before</span><br><span class="line">running...sleep after</span><br><span class="line">running...sleep before</span><br><span class="line">stop...</span><br></pre></td></tr></table></figure>

<p>根据实测，线程的执行确实被中断了，但是仔细查看输出，发现终止时只执行了 running…sleep before 也就是说sleep后面的代码并未执行，直接被暴力终止了。并未给用户留下收尾处理的机会。这也是为什么在Java的API中被标记废弃的原因，过于暴力的终止可能会造成一些不可预知的错误。</p>
<p><strong>当stop被调用后，可能会发生以下情况：</strong></p>
<ol>
<li>直接停掉run中的执行，包括在catch或finally语句中，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</li>
<li>会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。</li>
</ol>
<p>那么我们改如何优雅的停掉线程执行呢？继续查Thread的API，发现有个interrupt()方法，看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;running...sleep before&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;running...sleep after&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException exception)&#123;</span><br><span class="line">                  	exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;interrupt...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一运行发现，翻车了。。。。怎么停不下来呢？</p>
<p>原因就在于调用interrupt后会抛出InterruptedException，在catch InterruptedException异常时将interrupt标识位重置为false了，所以while一直满足执行。</p>
<p>所以，还需要在catch中增加 interrupt()调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;running...sleep before&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;running...sleep after&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException exception)&#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Thread中的主要方法"><a href="#Thread中的主要方法" class="headerlink" title="Thread中的主要方法"></a>Thread中的主要方法</h2><ol>
<li><p><strong>suspend()和resume()</strong></p>
<p>这两个方法，一个是<strong>挂起</strong>，一个是<strong>恢复</strong>，通常要成对儿出现，不然很容易发生死锁，因为suspend方法并不会释放锁，如果使用suspend的目标线程对一个重要的系统资源持有锁，那么没任何线程可以使用这个资源直到要suspend的目标线程被resumed，如果一个线程在resume目标线程之前尝试持有这个重要的系统资源锁再去resume目标线程，这两条线程就相互死锁了，也就冻结线程。</p>
</li>
<li><p><strong>yield()</strong></p>
<p>yield 即 “谦让”，也是 Thread 类的方法。它让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可能被其他线程获取到。</p>
<p>yield和sleep的不同：</p>
<p>1）yield, sleep 都能暂停当前线程，sleep 可以指定具体休眠的时间，而 yield 则依赖 CPU 的时间片划分。</p>
<p>2）yield, sleep 两个在暂停过程中，如已经持有锁，则都不会释放锁资源。</p>
<p>3）yield 不能被中断，而 sleep 则可以接受中断。</p>
</li>
<li><p><strong>join()</strong></p>
<p><code>join()</code>方法是<code>Thread</code>类中的一个方法，该方法的定义是等待该线程终止。其实就是<code>join()</code>方法将挂起<strong>调用线程</strong>的执行，直到<strong>被调用的对象</strong>完成它的执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;child thread running...num = &quot;</span> + num++);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;child thread finish-----------------------------------------&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException exception)&#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.join();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main running...num = &quot;</span> + num++);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main finish-----------------------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释掉第20行时的输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main running...num = <span class="number">0</span></span><br><span class="line">child thread running...num = <span class="number">0</span></span><br><span class="line">main running...num = <span class="number">1</span></span><br><span class="line">child thread running...num = <span class="number">1</span></span><br><span class="line">main running...num = <span class="number">2</span></span><br><span class="line">child thread running...num = <span class="number">2</span></span><br><span class="line">child thread running...num = <span class="number">3</span></span><br><span class="line">main running...num = <span class="number">3</span></span><br><span class="line">main running...num = <span class="number">4</span></span><br><span class="line">main finish-----------------------------------------</span><br><span class="line">child thread running...num = <span class="number">4</span></span><br><span class="line">child thread running...num = <span class="number">5</span></span><br><span class="line">child thread running...num = <span class="number">6</span></span><br><span class="line">child thread running...num = <span class="number">7</span></span><br><span class="line">child thread running...num = <span class="number">8</span></span><br><span class="line">child thread running...num = <span class="number">9</span></span><br><span class="line">child thread finish-----------------------------------------</span><br></pre></td></tr></table></figure>

<p>放开第20行注释的输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">child thread running...num = <span class="number">0</span></span><br><span class="line">child thread running...num = <span class="number">1</span></span><br><span class="line">child thread running...num = <span class="number">2</span></span><br><span class="line">child thread running...num = <span class="number">3</span></span><br><span class="line">child thread running...num = <span class="number">4</span></span><br><span class="line">child thread running...num = <span class="number">5</span></span><br><span class="line">child thread running...num = <span class="number">6</span></span><br><span class="line">child thread running...num = <span class="number">7</span></span><br><span class="line">child thread running...num = <span class="number">8</span></span><br><span class="line">child thread running...num = <span class="number">9</span></span><br><span class="line">child thread finish-----------------------------------------</span><br><span class="line">main running...num = <span class="number">0</span></span><br><span class="line">main running...num = <span class="number">1</span></span><br><span class="line">main running...num = <span class="number">2</span></span><br><span class="line">main running...num = <span class="number">3</span></span><br><span class="line">main running...num = <span class="number">4</span></span><br><span class="line">main finish-----------------------------------------</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>在Java中有两类线程，分别是User Thread（用户线程）和Daemon Thread（守护线程） 。</p>
<p>用户线程很好理解，我们日常开发中编写的业务逻辑代码，运行起来都是一个个用户线程。而守护线程相对来说则要特别理解一下。</p>
<h3 id="什么是守护线程"><a href="#什么是守护线程" class="headerlink" title="什么是守护线程"></a>什么是守护线程</h3><p>在操作系统里面是没有所谓的守护线程的概念的，只有守护进程一说。但是Java语言机制是构建在JVM的基础之上的，这一机制意味着Java平台是把操作系统的底层给屏蔽了起来，所以它可以在它自己的虚拟的平台里面构造出对自己有利的机制。而Java语言或者说平台的设计者多多少少是收到Unix操作系统思想的影响，而守护线程机制又是对JVM这样的平台凑合，于是守护线程应运而生。</p>
<p>所谓的守护线程，指的是程序运行时在后台提供的一种通用服务的线程。比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。</p>
<p>事实上，User Thread（用户线程）和Daemon Thread（守护线程）从本质上来说并没有什么区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<h3 id="守护线程的使用"><a href="#守护线程的使用" class="headerlink" title="守护线程的使用"></a>守护线程的使用</h3><p>守护线程并非只有虚拟机内部可以提供，用户也可以手动将一个用户线程设定/转换为守护线程。</p>
<p>在Thread类中提供了一个setDaemon(true)方法来将一个普通的线程（用户线程）设置为守护线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在使用的过程中，有几点需要注意：</p>
<p>1.thread.setDaemon(true)必须在thread.start()之前设置，否则会抛出一个IllegalThreadStateException异常。这也就意味着不能把正在运行的常规线程设置为守护线程。 这点与操作系统中的守护进程有着明显的区别，守护进程是创建后，让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别。</p>
<p>2.在Daemon线程中产生的新线程也是Daemon的。关于这一点又是与操作系统中的守护进程有着本质的区别：守护进程fork()出来的子进程不再是守护进程，尽管它把父进程的进程相关信息复制过去了，但是子进程的进程的父进程不是init进程，所谓的守护进程本质上说就是，当父进程挂掉，init就会收养该进程，然后文件0、1和2都是/dev/null，当前目录到/。</p>
<p>3.不是所有的应用都可以分配给Daemon线程来进行服务的，比如读写操作或者计算逻辑。因为这种应用可能在Daemon Thread还没来得及进行操作时，虚拟机已经退出了。这也就意味着，守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</p>
<p>守护线程的示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;child thread running...num = &quot;</span> + num++);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;child thread finish-----------------------------------------&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException exception)&#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread1.setName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    thread1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main running...num = &quot;</span> + num++);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main finish-----------------------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">main running...num = <span class="number">0</span></span><br><span class="line">child thread running...num = <span class="number">0</span></span><br><span class="line">main running...num = <span class="number">1</span></span><br><span class="line">child thread running...num = <span class="number">1</span></span><br><span class="line">main running...num = <span class="number">2</span></span><br><span class="line">child thread running...num = <span class="number">2</span></span><br><span class="line">main running...num = <span class="number">3</span></span><br><span class="line">child thread running...num = <span class="number">3</span></span><br><span class="line">child thread running...num = <span class="number">4</span></span><br><span class="line">main running...num = <span class="number">4</span></span><br><span class="line">main finish-----------------------------------------</span><br></pre></td></tr></table></figure>

<p>守护线程就是用来告诉JVM，我的这个线程是一个低级别的线程，不需要等待它运行完才退出，让JVM喜欢什么时候退出就退出，不用管这个线程。</p>
<p>在日常的业务相关的CRUD开发中，其实并不会关注到守护线程这个概念，也几乎不会用上。</p>
<p>但是如果要往更高的地方走的话，这些深层次的概念还是要了解一下的，比如一些框架的底层实现。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-多线程和线程安全的一些灵魂拷问</title>
    <url>/2016/07/08/java_thread_and_safe_faq/</url>
    <content><![CDATA[<p>各种灵魂发问？？？</p>
<span id="more"></span>

<h3 id="sychronied修饰普通方法和静态方法的区别？什么是可见性"><a href="#sychronied修饰普通方法和静态方法的区别？什么是可见性" class="headerlink" title="sychronied修饰普通方法和静态方法的区别？什么是可见性?"></a>sychronied修饰普通方法和静态方法的区别？什么是可见性?</h3><p>对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。</p>
<p>但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。</p>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>由于线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，那么对于共享变量V，它们首先是在自己的工作内存，之后再同步到主内存。可是并不会及时的刷到主存中，而是会有一定时间差。很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了 。</p>
<p>要解决共享对象可见性这个问题，我们可以使用volatile关键字或者是加锁。</p>
<h3 id="锁分哪几类？"><a href="#锁分哪几类？" class="headerlink" title="锁分哪几类？"></a>锁分哪几类？</h3><p><img src="/images/java_thread_and_safe_faq01.jpg" alt="img"></p>
<h3 id="CAS无锁编程的原理。"><a href="#CAS无锁编程的原理。" class="headerlink" title="CAS无锁编程的原理。"></a>CAS无锁编程的原理。</h3><p>使用当前的处理器基本都支持CAS()的指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p>
<p>CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做cas操作，直到成功为止。</p>
<p>还可以说说CAS的三大问题（见另一篇博客【Java-CAS】）。</p>
<h3 id="ReentrantLock的实现原理。"><a href="#ReentrantLock的实现原理。" class="headerlink" title="ReentrantLock的实现原理。"></a>ReentrantLock的实现原理。</h3><p>线程可以重复进入任何一个它已经拥有的锁所同步着的代码块，synchronized、ReentrantLock都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每 释放一次锁，进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。</p>
<p>底层则是利用了JUC中的AQS来实现的。</p>
<h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p>是用来构建锁或者其他同步组件的基础框架，比如ReentrantLock、ReentrantReadWriteLock和CountDownLatch就是基于AQS实现的。它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。它是CLH队列锁的一种变体实现。它可以实现2种同步方式：独占式，共享式。</p>
<p>AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，同步器的设计基于模板方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可重写的方法，如tryAcquire、tryReleaseShared等等。</p>
<p>这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者与同步组件交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者所需关注的领域。</p>
<p>在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点，构成一个双端双向链表。</p>
<h3 id="Synchronized的原理以及与ReentrantLock的区别。"><a href="#Synchronized的原理以及与ReentrantLock的区别。" class="headerlink" title="Synchronized的原理以及与ReentrantLock的区别。"></a>Synchronized的原理以及与ReentrantLock的区别。</h3><p>synchronized (this)原理：涉及两条指令：monitorenter，monitorexit；再说同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。</p>
<p>JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
<h3 id="Synchronized做了哪些优化"><a href="#Synchronized做了哪些优化" class="headerlink" title="Synchronized做了哪些优化"></a>Synchronized做了哪些优化</h3><p>引入如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁、逃逸分析</p>
<p>等技术来减少锁操作的开销。</p>
<p>逃逸分析</p>
<p>如果证明一个对象不会逃逸方法外或者线程外，则可针对此变量进行优化：</p>
<p>同步消除synchronization Elimination，如果一个对象不会逃逸出线程，则对此变量的同步措施可消除。</p>
<p>锁消除和粗化</p>
<p>锁消除：虚拟机的运行时编译器在运行时如果检测到一些要求同步的代码上不可能发生共享数据竞争，则会去掉这些锁。</p>
<p>锁粗化：将临近的代码块用同一个锁合并起来。</p>
<p>消除无意义的锁获取和释放，可以提高程序运行性能。</p>
<h3 id="Synchronized-static与非static锁的区别和范围"><a href="#Synchronized-static与非static锁的区别和范围" class="headerlink" title="Synchronized static与非static锁的区别和范围"></a>Synchronized static与非static锁的区别和范围</h3><p>对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。</p>
<p>但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。</p>
<h3 id="volatile-能否保证线程安全？在DCL上的作用是什么？"><a href="#volatile-能否保证线程安全？在DCL上的作用是什么？" class="headerlink" title="volatile 能否保证线程安全？在DCL上的作用是什么？"></a>volatile 能否保证线程安全？在DCL上的作用是什么？</h3><p>不能保证，在DCL的作用是：volatile是会保证被修饰的变量的可见性和 有序性，保证了单例模式下，保证在创建对象的时候的执行顺序一定是</p>
<p>1.分配内存空间</p>
<p>2.实例化对象instance</p>
<p>3.把instance引用指向已分配的内存空间,此时instance有了内存地址,不再为null了</p>
<p>的步骤, 从而保证了instance要么为null 要么是已经完全初始化好的对象。</p>
<h3 id="volatile和synchronize有什么区别？"><a href="#volatile和synchronize有什么区别？" class="headerlink" title="volatile和synchronize有什么区别？"></a>volatile和synchronize有什么区别？</h3><p>volatile是最轻量的同步机制。</p>
<p>volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。但是volatile不能保证操作的原子性，因此多线程下的写复合操作会导致线程安全问题。</p>
<p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p>
<h3 id="什么是守护线程？你是如何退出一个线程的？"><a href="#什么是守护线程？你是如何退出一个线程的？" class="headerlink" title="什么是守护线程？你是如何退出一个线程的？"></a>什么是守护线程？你是如何退出一个线程的？</h3><p>Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在<strong>非</strong>Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。</p>
<p>线程的中止：</p>
<p>要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。</p>
<p>暂停、恢复和停止操作对应在线程Thread的API就是**suspend()<strong><strong>、</strong></strong>resume()<strong><strong>和</strong></strong>stop()**。但是这些API是过期的，也就是不建议使用的。因为会导致程序可能工作在不确定状态下。</p>
<p>安全的中止则是其他线程通过调用某个线程A的interrupt()方法对其进行中断操作，被中断的线程则是通过线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。</p>
<h3 id="sleep-、wait、yield-的区别，wait-的线程如何唤醒它？"><a href="#sleep-、wait、yield-的区别，wait-的线程如何唤醒它？" class="headerlink" title="sleep 、wait、yield 的区别，wait 的线程如何唤醒它？"></a>sleep 、wait、yield 的区别，wait 的线程如何唤醒它？</h3><p>yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源。所有执行yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。</p>
<p>yield() 、sleep()被调用后，都不会释放当前线程所持有的锁。</p>
<p>调用wait()方法后，会释放当前线程持有的锁，而且当前被唤醒后，会重新去竞争锁，锁竞争到后才会执行wait方法后面的代码。</p>
<p>Wait通常被用于线程间交互，sleep通常被用于暂停执行，yield()方法使当前线程让出CPU占有权。</p>
<p>wait 的线程使用notify/notifyAll()进行唤醒。</p>
<h3 id="sleep是可中断的么？"><a href="#sleep是可中断的么？" class="headerlink" title="sleep是可中断的么？"></a>sleep是可中断的么？</h3><p>sleep本身就支持中断，如果线程在sleep期间被中断，则会抛出一个中断异常。</p>
<h3 id="线程生命周期。"><a href="#线程生命周期。" class="headerlink" title="线程生命周期。"></a>线程生命周期。</h3><p>Java中线程的状态分为6种：</p>
<ol>
<li><p>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</p>
</li>
<li><p>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。</p>
</li>
</ol>
<p>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</p>
<ol start="3">
<li><p>阻塞(BLOCKED)：表示线程阻塞于锁。</p>
</li>
<li><p>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
</li>
<li><p>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</p>
</li>
<li><p>终止(TERMINATED)：表示该线程已经执行完毕。</p>
</li>
</ol>
<p><img src="/images/java_thread_and_safe_faq02.jpg" alt="img"></p>
<h3 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a>ThreadLocal是什么？</h3><p>ThreadLocal是Java里一种特殊的变量。ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。</p>
<p>在内部实现上，每个线程内部都有一个ThreadLocalMap，用来保存每个线程所拥有的变量副本。</p>
<h3 id="线程池基本原理。"><a href="#线程池基本原理。" class="headerlink" title="线程池基本原理。"></a>线程池基本原理。</h3><p>在开发过程中，合理地使用线程池能够带来3个好处。</p>
<p>第一：降低资源消耗。第二：提高响应速度。第三：提高线程的可管理性。</p>
<p>1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p>
<p>2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p>
<p>3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。</p>
<p>4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<h3 id="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h3><h4 id="使用线程的join方法"><a href="#使用线程的join方法" class="headerlink" title="使用线程的join方法"></a>使用线程的join方法</h4><p> thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
<p>t.join();    //调用join方法，等待线程t执行完毕<br>t.join(1000);  //等待 t 线程，等待时间是1000毫秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line"><span class="comment">// T1、T2、T3三个线程顺序执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(<span class="keyword">null</span>));</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t1));</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t2));</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(Thread beforeThread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beforeThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeThread.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;thread start:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread start:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用CountDownLaunch"><a href="#使用CountDownLaunch" class="headerlink" title="使用CountDownLaunch"></a>使用CountDownLaunch</h4><p>CountDownLatch(闭锁)是一个很有用的工具类，利用它我们可以拦截一个或多个线程使其在某个条件成熟后再执行。它的内部提供了一个计数器，在构造闭锁时必须指定计数器的初始值，且计数器的初始值必须大于0。另外它还提供了一个countDown方法来操作计数器的值，每调用一次countDown方法计数器都会减1，直到计数器的值减为0时就代表条件已成熟，所有因调用await方法而阻塞的线程都会被唤醒。这就是CountDownLatch的内部机制，看起来很简单，无非就是阻塞一部分线程让其在达到某个条件之后再执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// T1、T2、T3三个线程顺序执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CountDownLatch c0 = <span class="keyword">new</span> CountDownLatch(<span class="number">0</span>); <span class="comment">//计数器为0</span></span><br><span class="line">    CountDownLatch c1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>); <span class="comment">//计数器为1</span></span><br><span class="line">    CountDownLatch c2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>); <span class="comment">//计数器为1</span></span><br><span class="line"> </span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(c0, c1));</span><br><span class="line">    <span class="comment">//c0为0，t1可以执行。t1的计数器减1</span></span><br><span class="line"> </span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(c1, c2));</span><br><span class="line">    <span class="comment">//t1的计数器为0时，t2才能执行。t2的计数器c2减1</span></span><br><span class="line"> </span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(c2, c2));</span><br><span class="line">    <span class="comment">//t2的计数器c2为0时，t3才能执行</span></span><br><span class="line"> </span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义Work线程类，需要传入开始和结束的CountDownLatch参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    CountDownLatch c1;</span><br><span class="line">    CountDownLatch c2;</span><br><span class="line"> </span><br><span class="line">    Work(CountDownLatch c1, CountDownLatch c2) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.c1 = c1;</span><br><span class="line">        <span class="keyword">this</span>.c2 = c2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c1.await();<span class="comment">//前一线程为0才可以执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;thread start:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            c2.countDown();<span class="comment">//本线程计数器减少</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用FeatureTask"><a href="#使用FeatureTask" class="headerlink" title="使用FeatureTask"></a>使用FeatureTask</h4><p>FutureTask一个可取消的异步计算，FutureTask 实现了Future的基本方法，提空 start cancel 操作，可以查询计算是否已经完成，并且可以获取计算的结果。结果只可以在计算完成之后获取，get方法会阻塞当计算没有完成的时候，一旦计算已经完成，那么计算就不能再次启动或是取消。</p>
<p>   一个FutureTask 可以用来包装一个 Callable 或是一个runnable对象。因为FurtureTask实现了Runnable方法，所以一个 FutureTask可以提交(submit)给一个Excutor执行(excution). </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// T1、T2、T3三个线程顺序执行</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; future1= <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Work(<span class="keyword">null</span>));</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(future1);</span><br><span class="line"> </span><br><span class="line">    FutureTask&lt;Integer&gt; future2= <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Work(future1));</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(future2);</span><br><span class="line"> </span><br><span class="line">    FutureTask&lt;Integer&gt; future3= <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Work(future2));</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(future3);</span><br><span class="line"> </span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span>  <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FutureTask&lt;Integer&gt; beforeFutureTask;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(FutureTask&lt;Integer&gt; beforeFutureTask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beforeFutureTask = beforeFutureTask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beforeFutureTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Integer result = beforeFutureTask.get();<span class="comment">//阻塞等待</span></span><br><span class="line">            System.out.println(<span class="string">&quot;thread start:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread start:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用BlockingQueue"><a href="#使用BlockingQueue" class="headerlink" title="使用BlockingQueue"></a>使用BlockingQueue</h4><p>阻塞队列 (BlockingQueue)是Java util.concurrent包下重要的数据结构，BlockingQueue提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于BlockingQueue实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest4</span> </span>&#123;</span><br><span class="line"><span class="comment">// T1、T2、T3三个线程顺序执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//blockingQueue保证顺序</span></span><br><span class="line">    BlockingQueue&lt;Thread&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Thread&gt;();</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line"> </span><br><span class="line">    blockingQueue.add(t1);</span><br><span class="line">    blockingQueue.add(t2);</span><br><span class="line">    blockingQueue.add(t3);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">        Thread t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t = blockingQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//检测线程是否还活着</span></span><br><span class="line">        <span class="keyword">while</span> (t.isAlive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread start:&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用单个线程池"><a href="#使用单个线程池" class="headerlink" title="使用单个线程池"></a>使用单个线程池</h4><p>newSingleThreadExecutor返回以个包含单线程的Executor,将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest5</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;T1&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run 2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;T2&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run 3&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;T3&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//使用 单个任务的线程池来实现。保证线程的依次执行</span></span><br><span class="line">    ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">    executor.submit(t1);</span><br><span class="line">    executor.submit(t2);</span><br><span class="line">    executor.submit(t3);</span><br><span class="line">    executor.shutdown();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java JVM相关的灵魂拷问</title>
    <url>/2016/07/17/java_jvm_faq/</url>
    <content><![CDATA[<p>^_^    </p>
<span id="more"></span>

<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p>开放式题目，具体可见前一章节</p>
<p>一般从两个维度出发：线程私有和线程共享。到每一个内存区域的细节点。</p>
<p><img src="/images/java_jvm_faq_jmm_struct.png" alt="img"></p>
<p>Java 虚拟机栈是基于线程的。哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。</p>
<p>栈里的每条数据，就是栈帧。在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了。每个栈帧，都包含四个区域：</p>
<p>局部变量表</p>
<p>操作数栈</p>
<p>动态连接</p>
<p>返回地址</p>
<p>本地方法栈是和虚拟机栈非常相似的一个区域，它服务的对象是 native 方法。</p>
<p>程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。</p>
<p>方法区，这个区域存储的内容，包括：类的信息、常量池、方法数据、方法代码就可以了。</p>
<h2 id="什么情况下栈内存溢出？"><a href="#什么情况下栈内存溢出？" class="headerlink" title="什么情况下栈内存溢出？"></a>什么情况下栈内存溢出？</h2><p>java.lang.StackOverflowError 如果出现了可能会是无限递归。</p>
<p>OutOfMemoryError：不断建立线程，JVM申请栈内存，机器没有足够的内存。</p>
<h2 id="描述new一个对象的流程！"><a href="#描述new一个对象的流程！" class="headerlink" title="描述new一个对象的流程！"></a>描述new一个对象的流程！</h2><p>具体见前一章节</p>
<h2 id="Java对象会不会分配在栈中？"><a href="#Java对象会不会分配在栈中？" class="headerlink" title="Java对象会不会分配在栈中？"></a>Java对象会不会分配在栈中？</h2><p>可以，如果这个对象不满足逃逸分析，那么虚拟机在特定的情况下会走栈上分配。</p>
<h2 id="如果判断一个对象是否被回收，有哪些算法，实际虚拟机使用得最多的是什么？"><a href="#如果判断一个对象是否被回收，有哪些算法，实际虚拟机使用得最多的是什么？" class="headerlink" title="如果判断一个对象是否被回收，有哪些算法，实际虚拟机使用得最多的是什么？"></a>如果判断一个对象是否被回收，有哪些算法，实际虚拟机使用得最多的是什么？</h2><p>引用计数法和根可达性分析两种，用得最多是根可达性分析。</p>
<h2 id="GC收集算法有哪些？他们的特点是什么？"><a href="#GC收集算法有哪些？他们的特点是什么？" class="headerlink" title="GC收集算法有哪些？他们的特点是什么？"></a>GC收集算法有哪些？他们的特点是什么？</h2><p>复制、标记清除、标记整理。复制速度快，但是要浪费空间，不会内存碎片。标记清除空间利用率高，但是有内存碎片。标记整理算法没有内存碎片，但是要移动对象，性能较低。三种算法各有所长，各有所短。</p>
<h2 id="JVM中一次完整的GC流程是怎样的？对象如何晋级到老年代？"><a href="#JVM中一次完整的GC流程是怎样的？对象如何晋级到老年代？" class="headerlink" title="JVM中一次完整的GC流程是怎样的？对象如何晋级到老年代？"></a>JVM中一次完整的GC流程是怎样的？对象如何晋级到老年代？</h2><p>对象优先在新生代区中分配，若没有足够空间，Minor GC；<br> 大对象（需要大量连续内存空间）直接进入老年态；长期存活的对象进入老年态。</p>
<p>如果对象在新生代出生并经过第一次MGC后仍然存活，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。</p>
<h2 id="Java中的几种引用关系，他们的区别是什么？"><a href="#Java中的几种引用关系，他们的区别是什么？" class="headerlink" title="Java中的几种引用关系，他们的区别是什么？"></a>Java中的几种引用关系，他们的区别是什么？</h2><p><strong>强引用</strong></p>
<p>一般的Object obj = new Object() ，就属于强引用。在任何情况下，只有有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。</p>
<p><strong>软引用 SoftReference</strong></p>
<p>一些有用但是并非必需，用软引用关联的对象，系统将要发生内存溢出（OuyOfMemory）之前，这些对象就会被回收（如果这次回收后还是没有足够的空间，才会抛出内存溢出）。</p>
<p><strong>弱引用 WeakReference</strong></p>
<p>一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。</p>
<p><strong>虚引用 PhantomReference</strong></p>
<p>幽灵引用，最弱（随时会被回收掉）</p>
<p>垃圾回收的时候收到一个通知，就是为了监控垃圾回收器是否正常工作。</p>
<h2 id="final、finally、finalize的区别？"><a href="#final、finally、finalize的区别？" class="headerlink" title="final、finally、finalize的区别？"></a>final、finally、finalize的区别？</h2><p>在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）</p>
<p>当用final修饰类的时，表明该类不能被其他类所继承。当我们需要让一个类永远不被继承，此时就可以用final修饰，但要注意：</p>
<p>final类中所有的成员方法都会隐式的定义为final方法。</p>
<p>使用final方法的原因主要有两个：</p>
<p>　　(1) 把方法锁定，以防止继承类对其进行更改。</p>
<p>　　(2) 效率，在早期的java版本中，会将final方法转为内嵌调用。但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。</p>
<p>final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。</p>
<p><strong>finally****作为异常处理的一部分</strong>，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下</p>
<p><strong>Object<strong><strong>中的Finalize</strong></strong>方法</strong></p>
<p>即使通过可达性分析判断不可达的对象，也不是“非死不可”，它还会处于“缓刑”阶段，真正要宣告一个对象死亡，需要经过两次标记过程，一次是没有找到与GCRoots的引用链，它将被第一次标记。随后进行一次筛选（如果对象覆盖了finalize），我们可以在finalize中去拯救。</p>
<p>所以建议大家尽量不要使用finalize，因为这个方法太不可靠。在生产中你很难控制方法的执行或者对象的调用顺序，建议大家忘了finalize方法！因为在finalize方法能做的工作，java中有更好的，比如try-finally或者其他方式可以做得更好</p>
<h2 id="String-s-new-String-“xxx”-创建了几个对象？"><a href="#String-s-new-String-“xxx”-创建了几个对象？" class="headerlink" title="String s = new String(“xxx”);创建了几个对象？"></a>String s = new String(“xxx”);创建了几个对象？</h2><p>2个，</p>
<p>1、 在一开始字符串”xxx”会在加载类时，在常量池中创建一个字符串对象。</p>
<p>调用 new时 会在堆内存中创建一个 String 对象，String 对象中的 char 数组将会引用常量池中字符串。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java虚拟机（JVM）垃圾回收机制</title>
    <url>/2016/07/14/java_gc_garbage/</url>
    <content><![CDATA[<p>垃圾回收机制是由垃圾收集器Garbage Collection GC来实现的，GC是后台的<strong>守护进程。它的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况动态的调整他的优先级。因此，它是在内存中低到一定限度时才会自动运行，从而实现对内存的回收。*<em>这就是垃圾回收的时间不确定的原因。*</em></strong></p>
<span id="more"></span>

<p>为何要这样设计：因为GC也是进程，也要消耗CPU等资源，如果GC执行过于频繁会对java的程序的执行产生较大的影响（java解释器本来就不快），因此JVM的设计者们选着了不定期的gc。</p>
<p>GC有关的是: runtime data area 中的 heap（对象实例会存储在这里） 和 gabage collector方法。<br>程序运行期间，所有对象实例存储在运行时数据区域的heap中，当一个对象不再被引用（使用），它就需要被收回。在GC过程中，这些不再被使用的对象从heap中收回，这样就会有空间被循环利用。<br>GC为内存中不再使用的对象进行回收，GC中调用回收的<code>方法</code>–<code>收集器garbage collector</code>. 由于GC要消耗一些资源和时间，Java 在对对象的生命周期特征（eden or survivor）进行分析之后，采用了<code>分代</code>的方式进行对象的收集，以缩短GC对应用造成的暂停。</p>
<h2 id="虚拟机中的对象"><a href="#虚拟机中的对象" class="headerlink" title="虚拟机中的对象"></a>虚拟机中的对象</h2><p><img src="/images/java_gc_garbage_object_crate.png" alt="image-20210703214455740"></p>
<h3 id="对象的分配"><a href="#对象的分配" class="headerlink" title="对象的分配"></a>对象的分配</h3><p>虚拟机遇到一条new指令时，首先检查是否被类加载器加载，如果没有，那必须先执行相应的类加载过程。</p>
<p>类加载就是把class加载到JVM的运行时数据区的过程</p>
<h4 id="检查加载"><a href="#检查加载" class="headerlink" title="检查加载"></a>检查加载</h4><p>首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（<strong>符号引用</strong> <strong>：</strong>符号引用以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。</p>
<h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p>接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<h5 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h5><p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“<strong>指针碰撞</strong>”。</p>
<p><img src="/images/java_gc_garbage_mem_alloc_pointer.png" alt="image-20210703214939138"></p>
<h5 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h5><p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“<strong>空闲列表</strong>”。</p>
<p><img src="/images/java_gc_garbage_mem_alloc_idle_list.png" alt="image-20210703215121137"></p>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>如果是Serial、ParNew等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效。</p>
<p>如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。</p>
<h5 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h5><p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>
<h6 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h6><p>解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；</p>
<h6 id="分配缓冲"><a href="#分配缓冲" class="headerlink" title="分配缓冲"></a>分配缓冲</h6><p>另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（<strong>Thread Local Allocation Buffer,TLAB</strong>），JVM在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。</p>
<p>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。</p>
<p>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。</p>
<p><strong>参数：</strong></p>
<p>-XX:+UseTLAB</p>
<p>允许在年轻代空间中使用线程本地分配块（TLAB）。默认情况下启用此选项。要禁用TLAB，请指定-XX:-UseTLAB。</p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
<h4 id="内存空间初始化"><a href="#内存空间初始化" class="headerlink" title="内存空间初始化"></a>内存空间初始化</h4><p>（注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes在Java hotspot VM内部表示为类元数据）、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</p>
<h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p><img src="/images/java_gc_garbage_object_mem_struct.png" alt="image-20210703220014236"></p>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p>
<p>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>如果对象是一个java数组，那么在对象头中还有一块用于记录数组长度的数据。</p>
<p>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。</p>
<h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>如果使用直接指针访问， reference中存储的直接就是对象地址。</p>
<p><strong>对比</strong></p>
<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p>
<p>对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。</p>
<h2 id="判断对象的存活"><a href="#判断对象的存活" class="headerlink" title="判断对象的存活"></a>判断对象的存活</h2><p>在堆里面存放着几乎所有的对象实例，垃圾回收器在对对进行回收前，要做的事情就是确定这些对象中哪些还是“存活”着，哪些已经“死去”（死去代表着不可能再被任何途径使用得对象了）</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1，当引用失效时，计数器减1.</p>
<p>Python在用，但主流虚拟机没有使用，因为存在对象相互引用的情况，这个时候需要引入额外的机制来处理，这样做影响效率，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Isalive</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance =<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//占据内存，便于判断分析GC</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Isalive objectA = <span class="keyword">new</span> Isalive();<span class="comment">//objectA 局部变量表 GCRoots</span></span><br><span class="line">        Isalive objectB = <span class="keyword">new</span> Isalive();<span class="comment">//objectB 局部变量表</span></span><br><span class="line">        <span class="comment">//相互引用</span></span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line">        <span class="comment">//切断可达</span></span><br><span class="line">        objectA =<span class="keyword">null</span>;</span><br><span class="line">        objectB =<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//强制垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/java_gc_garbage_ref_count.png" alt="image-20210703221112887"></p>
<p>在代码中看到，只保留相互引用的对象还是被回收掉了，说明JVM中采用的不是引用计数法。</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p>作为GC Roots的对象包括下面几种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 虚拟机栈（栈帧中的本地变量表）中引用的对象。</span><br><span class="line"></span><br><span class="line">* 方法区中类静态属性引用的对象。</span><br><span class="line"></span><br><span class="line">* 方法区中常量引用的对象。</span><br><span class="line"></span><br><span class="line">* 本地方法栈中JNI（即一般说的Native方法）引用的对象。</span><br><span class="line"></span><br><span class="line">* JVM的内部引用（class对象、异常对象NullPointException、OutofMemoryError，系统类加载器）。</span><br><span class="line"></span><br><span class="line">* 所有被同步锁(synchronized关键)持有的对象。</span><br><span class="line"></span><br><span class="line">* JVM内部的JMXBean、JVMTI中注册的回调、本地代码缓存等</span><br><span class="line"></span><br><span class="line">* JVM实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代时） </span><br></pre></td></tr></table></figure>

<p>以上的回收都是对象，类的回收条件：</p>
<p><strong>注意如果Class要被回收</strong>，条件比较苛刻，必须同时满足以下的条件（仅仅是可以，不代表必然，因为还有一些参数可以进行控制）：</p>
<p>1、 **该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</p>
<p>2、 加载该类的ClassLoader已经被回收。</p>
<p>3、 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<p>4、 参数控制：</p>
<p><img src="/images/java_gc_garbage_obj_reachable_analyze.png" alt="img"></p>
<h3 id="Finalize方法"><a href="#Finalize方法" class="headerlink" title="Finalize方法"></a>Finalize方法</h3><p>即使通过可达性分析判断不可达的对象，也不是“非死不可”，它还会处于“缓刑”阶段，真正要宣告一个对象死亡，需要经过两次标记过程，一次是没有找到与GCRoots的引用链，它将被第一次标记。随后进行一次筛选（如果对象覆盖了finalize），我们可以在finalize中去拯救。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeGC instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am still alive!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed&quot;</span>);</span><br><span class="line">        FinalizeGC.instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> FinalizeGC();</span><br><span class="line">        <span class="comment">//对象进行第1次GC</span></span><br><span class="line">        instance =<span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//Finalizer方法优先级很低，需要等待</span></span><br><span class="line">        <span class="keyword">if</span>(instance !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am dead！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对象进行第2次GC</span></span><br><span class="line">        instance =<span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(instance !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am dead！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="/images/java_gc_garbage_finalize01.png" alt="img"></p>
<p>可以看到，对象可以被拯救一次(finalize执行第一次，但是不会执行第二次)</p>
<p>注释掉代码17和26行，再来一次。</p>
<p><strong>运行结果：</strong></p>
<p><img src="/images/java_gc_garbage_finalize02.png" alt="img"></p>
<p>对象没有被拯救，这个就是finalize方法执行缓慢，还没有完成拯救，垃圾回收器就已经回收掉了。</p>
<p>所以建议大家尽量不要使用finalize，因为这个方法太不可靠。在生产中你很难控制方法的执行或者对象的调用顺序，建议大家忘了finalize方法！因为在finalize方法能做的工作，java中有更好的，比如try-finally或者其他方式可以做得更好</p>
<h2 id="各种引用"><a href="#各种引用" class="headerlink" title="各种引用"></a>各种引用</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>一般的Object obj = new Object() ，就属于强引用。在任何情况下，只有有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。</p>
<h3 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h3><p>一些有用但是并非必需，用软引用关联的对象，系统将要发生内存溢出（OuyOfMemory）之前，这些对象就会被回收（如果这次回收后还是没有足够的空间，才会抛出内存溢出）。参见代码：</p>
<p>VM参数 -Xms10m -Xmx10m -XX:+PrintGC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		User u = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;King&quot;</span>); <span class="comment">//new是强引用</span></span><br><span class="line">		SoftReference&lt;User&gt; userSoft = <span class="keyword">new</span> SoftReference&lt;User&gt;(u);<span class="comment">//软引用</span></span><br><span class="line">		u = <span class="keyword">null</span>;<span class="comment">//干掉强引用，确保这个实例只有userSoft的软引用</span></span><br><span class="line">		System.out.println(userSoft.get()); <span class="comment">//看一下这个对象是否还在</span></span><br><span class="line">		System.gc();<span class="comment">//进行一次GC垃圾回收  千万不要写在业务代码中。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;After gc&quot;</span>);</span><br><span class="line">		System.out.println(userSoft.get());</span><br><span class="line">		<span class="comment">//往堆中填充数据，导致OOM</span></span><br><span class="line">		List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) &#123;</span><br><span class="line">				<span class="comment">//System.out.println(&quot;*************&quot;+userSoft.get());</span></span><br><span class="line">				list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1</span>]); <span class="comment">//1M的对象 100m</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">			<span class="comment">//抛出了OOM异常时打印软引用对象</span></span><br><span class="line">			System.out.println(<span class="string">&quot;Exception*************&quot;</span>+userSoft.get());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/images/java_gc_garbage_softreference_output.png" alt="img"></p>
<p>例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。</p>
<h3 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a>弱引用WeakReference</h3><p>一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。</p>
<p>参看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		User u = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;King&quot;</span>);</span><br><span class="line">		WeakReference&lt;User&gt; userWeak = <span class="keyword">new</span> WeakReference&lt;User&gt;(u);</span><br><span class="line">		u = <span class="keyword">null</span>;<span class="comment">//干掉强引用，确保这个实例只有userWeak的弱引用</span></span><br><span class="line">		System.out.println(userWeak.get());</span><br><span class="line">		System.gc();<span class="comment">//进行一次GC垃圾回收,千万不要写在业务代码中。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;After gc&quot;</span>);</span><br><span class="line">		System.out.println(userWeak.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/java_gc_garbage_weakreference_output.png" alt="image-20210703223219530"></p>
<p><strong>注意：</strong>软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。</p>
<p>实际运用（WeakHashMap、ThreadLocal）</p>
<h3 id="虚引用PhantomReference"><a href="#虚引用PhantomReference" class="headerlink" title="虚引用PhantomReference"></a>虚引用PhantomReference</h3><p>幽灵引用，最弱（随时会被回收掉）</p>
<p>垃圾回收的时候收到一个通知，就是为了监控垃圾回收器是否正常工作。</p>
<h2 id="对象的分配策略"><a href="#对象的分配策略" class="headerlink" title="对象的分配策略"></a>对象的分配策略</h2><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>当方法中的对象没有发生逃逸时会使用栈上分配</p>
<p>逃逸分析的原理：分析对象动态作用域，当一个对象在方法中定义后，它可能被外部方法所引用，比如：调用参数传递到其他方法中，这种称之为方法逃逸，甚至还有可能被外部线程访问到，例如：赋值给其他线程中访问的变量，这个称之为线程逃逸。</p>
<p>从不逃逸到方法逃逸到线程逃逸，称之为对象由低到高的不同逃逸程度。</p>
<p>如果确定一个对象不会逃逸出线程之外，那么让对象在栈上分配内存可以提高JVM的效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysisTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000000</span>; i++) &#123;<span class="comment">//5千万的对象，为什么不会垃圾回收</span></span><br><span class="line">            allocate();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println((System.currentTimeMillis() - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">600000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">()</span> </span>&#123;<span class="comment">//满足逃逸分析（不会逃逸出方法）</span></span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject(<span class="number">2020</span>, <span class="number">2020.6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="keyword">double</span> b;</span><br><span class="line"></span><br><span class="line">        MyObject(<span class="keyword">int</span> a, <span class="keyword">double</span> b) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">            <span class="keyword">this</span>.b = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在调用的过程中 myboject这个对象属于全局逃逸，JVM可以做栈上分配</p>
<p>然后通过开启和关闭DoEscapeAnalysis开关观察不同。</p>
<p>开启逃逸分析（JVM默认开启）</p>
<p><img src="/images/java_gc_garbage_open_escape_analyze.png" alt="image-20210703223903951"></p>
<p>输出</p>
<p><img src="/images/java_gc_garbage_open_escape_analyze_output.png" alt="image-20210703224006011"></p>
<p>关闭逃逸分析</p>
<p><img src="/images/java_gc_garbage_close_escape_analyze.png" alt="img"> </p>
<p>查看执行速度</p>
<p><img src="/images/java_gc_garbage_close_escape_analyze_output.png" alt="img"> </p>
<p>测试结果可见，开启逃逸分析对代码的执行性能有很大的影响！</p>
<p>如果是逃逸分析出来的对象可以在栈上分配的话，那么该对象的生命周期就跟随线程了，就不需要垃圾回收，如果是频繁的调用此方法则可以得到很大的性能提高。</p>
<p>采用了逃逸分析后，满足逃逸的对象在栈上分配</p>
<p><img src="/images/java_gc_garbage_open_escape_obj_allco.png" alt="image-20210703224331315"></p>
<p>没有开启逃逸分析，对象都在堆上分配，会频繁触发垃圾回收（垃圾回收会影响系统性能），导致代码运行慢</p>
<p><img src="/images/java_gc_garbage_close_escape_obj_allco.png" alt="image-20210703224428565"></p>
<p>开启GC打印日志</p>
<p>-XX:+PrintGC</p>
<p><strong>开启逃逸分析</strong></p>
<p><img src="/images/java_gc_garbage_open_escape_analyze_output.png" alt="image-20210703224006011"></p>
<p>可以看到没有GC日志</p>
<p>关闭逃逸分析</p>
<p><img src="/images/java_gc_garbage_close_escape_analyze_gc_log_output.png" alt="img"> </p>
<p>可以看到关闭了逃逸分析，JVM在频繁的进行垃圾回收（GC），正是这一块的操作导致性能有较大的差别。</p>
<h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>注意：新生代初始时就有大小</p>
<p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>-XX:+PrintGCDetails</p>
<p>-XX:PretenureSizeThreshold=4m</p>
<p>-XX:+UseSerialGC </p>
<p>PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。</p>
<p>最典型的大对象是那种很长的字符串以及数组。这样做的目的：1.避免大量内存复制,2.避免提前进行垃圾回收，明明内存有空间进行分配。</p>
<h3 id="长期存活的对象进入老年区"><a href="#长期存活的对象进入老年区" class="headerlink" title="长期存活的对象进入老年区"></a>长期存活的对象进入老年区</h3><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(并发的垃圾回收器默认为15),CMS是6时，就会被晋升到老年代中。</p>
<p>-XX:MaxTenuringThreshold调整</p>
<h3 id="对象年龄动态判断"><a href="#对象年龄动态判断" class="headerlink" title="对象年龄动态判断"></a>对象年龄动态判断</h3><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾回收算法的实现设计到大量的程序细节，并且每一个平台的虚拟机操作内存的方式都有不同，所以不需要去了解算法的实现，我们重点讲解分代收集理论和3种算法的思想。</p>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>当前商业虚拟机的垃圾收集器，大多遵循“分代收集”的理论来进行设计，这个理论大体上是这么描述的：</p>
<p>1、 绝大部分的对象都是朝生夕死</p>
<p>2、 熬过多次垃圾回收的对象就越难回收。</p>
<p>根据以上两个理论，朝生夕死的对象放一个区域，难回收的对象放另外一个区域，这个就构成了新生代和老年代。</p>
<h4 id="GC种类"><a href="#GC种类" class="headerlink" title="GC种类"></a>GC种类</h4><p>市面上发生垃圾回收的叫法很多，我大体整理了一下：</p>
<p>1、 新生代回收（Minor GC/Young GC）:指只是进行新生代的回收。</p>
<p>2、 老年代回收（Major GC/Old GC）:指只是进行老年代的回收。目前只有CMS垃圾回收器会有这个单独的收集老年代的行为。（Major GC定义是比较混乱，有说指是老年代，有的说是做整个堆的收集，这个需要你根据别人的场景来定，没有固定的说法）</p>
<p>3、 整堆收集（Full GC）:收集整个Java堆和方法区(注意包含方法区)</p>
<p><img src="/images/java_gc_garbage_gc_01.png" alt="img"></p>
<p><img src="/images/java_gc_garbage_gc_02.png" alt="img"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。</p>
<p>注意：内存移动是必须实打实的移动（复制），不能使用指针玩。</p>
<p>复制回收算法适合于新生代，因为大部分对象朝生夕死，那么复制过去的对象比较少，效率自然就高，另外一半的一次性清理是很快的。</p>
<h3 id="Appel式回收"><a href="#Appel式回收" class="headerlink" title="Appel式回收"></a>Appel式回收</h3><p>一种更加优化的复制回收分代策略：具体做法是分配一块较大的Eden区和两块较小的Survivor空间（你可以叫做From或者To，也可以叫做Survivor1和Survivor2）</p>
<p>专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）</p>
<h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>回收效率不稳定，如果大部分对象是朝生夕死，那么回收效率降低，因为需要大量标记对象和回收对象，对比复制回收效率很低。</p>
<p>它的主要不足，空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<p>回收的时候如果需要回收的对象越多，需要做的标记和清除的工作越多，所以标记清除算法适用于老年代。复制回收算法适用于新生代。</p>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法虽然没有内存碎片，但是效率偏低。</p>
<p>我们看到标记整理与标记清除算法的区别主要在于对象的移动。对象移动不单单会加重系统负担，同时需要全程暂停用户线程才能进行，同时所有引用对象的地方都需要更新。</p>
<p>所以看到，老年代采用的标记整理算法与标记清除算法，各有优点，各有缺点。</p>
<h2 id="JVM中常见的垃圾收集器"><a href="#JVM中常见的垃圾收集器" class="headerlink" title="JVM中常见的垃圾收集器"></a>JVM中常见的垃圾收集器</h2><h3 id="分代收集的思想"><a href="#分代收集的思想" class="headerlink" title="分代收集的思想"></a>分代收集的思想</h3><p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<p><strong>请记住下图的垃圾收集器和之间的连线关系。</strong></p>
<p><strong>具体看官网*JVM参数：</strong><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
<p><img src="/images/java_gc_garbage_gc_machine_display.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>新生代，复制算法</td>
<td>单线程</td>
<td></td>
<td>简单高效；  适合内存不大的情况；</td>
</tr>
<tr>
<td>ParNew</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>ParNew垃圾收集器是Serial收集器的多线程版本</td>
<td>搭配CMS垃圾回收器的首选</td>
</tr>
<tr>
<td>Parallel Scavenge  吞吐量优先收集器</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>类似ParNew，更加关注吞吐量，达到一个可控制的吞吐量；</td>
<td>本身是Server级别多CPU机器上的默认GC方式，主要适合后台运算不需要太多交互的任务；</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Serial Old</td>
<td>老年代，标记整理算法</td>
<td>单线程</td>
<td></td>
<td>Client模式下虚拟机使用</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>老年代，标记整理算法</td>
<td>并行的多线程收集器</td>
<td>Parallel Scavenge收集器的老年代版本，为了配合Parallel  Scavenge的面向吞吐量的特性而开发的对应组合；</td>
<td>在注重吞吐量以及CPU资源敏感的场合采用</td>
</tr>
<tr>
<td>CMS</td>
<td>老年代，标记清除算法</td>
<td>并行与并发收集器</td>
<td>尽可能的缩短垃圾收集时用户线程停止时间；缺点在于：   1.内存碎片   2.需要更多cpu资源   3.浮动垃圾问题，需要更大的堆空间</td>
<td>重视服务的响应速度、系统停顿时间和用户体验的互联网网站或者B/S系统。互联网后端目前cms是主流的垃圾回收器；</td>
</tr>
<tr>
<td>G1</td>
<td>跨新生代和老年代；标记整理 + 化整为零</td>
<td>并行与并发收集器</td>
<td>JDK1.7才正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势；</td>
<td>面向服务端应用的垃圾回收器，目标为取代CMS</td>
</tr>
</tbody></table>
<p>并行：垃圾收集的多线程的同时进行。</p>
<p>并发：垃圾收集的多线程和应用的多线程同时进行。</p>
<p>注：吞吐量=运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)</p>
<p>垃圾收集时间= 垃圾回收频率 * 单次垃圾回收时间</p>
<h3 id="Serial-Serial-Old"><a href="#Serial-Serial-Old" class="headerlink" title="Serial/Serial Old"></a>Serial/Serial Old</h3><p>最古老的，单线程，独占式，成熟，适合单CPU 服务器</p>
<p>-XX:+UseSerialGC 新生代和老年代都用串行收集器</p>
<p>-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old</p>
<p>-XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old</p>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>和Serial基本没区别，唯一的区别：多线程，多CPU的，停顿时间比Serial少</p>
<p>-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old</p>
<h3 id="Parallel-Scavenge（ParallerGC）-Parallel-Old"><a href="#Parallel-Scavenge（ParallerGC）-Parallel-Old" class="headerlink" title="Parallel Scavenge（ParallerGC）/Parallel Old"></a>Parallel Scavenge（ParallerGC）/Parallel Old</h3><p>关注吞吐量的垃圾收集器，高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<h3 id="Concurrent-Mark-Sweep-（CMS）"><a href="#Concurrent-Mark-Sweep-（CMS）" class="headerlink" title="Concurrent Mark Sweep （CMS）"></a>Concurrent Mark Sweep （CMS）</h3><p><img src="/images/java_gc_garbage_gc_cms.png" alt="img"></p>
<p>收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p>
<p>l <strong>初始标记</strong>-短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</p>
<p>l <strong>并发标记</strong>-和用户的应用程序同时进行，进行GC Roots追踪的过程，标记从GCRoots开始关联的所有对象开始遍历整个可达分析路径的对象。这个时间比较长，所以采用并发处理（垃圾回收器线程和用户线程同时工作）</p>
<p>l <strong>重新标记</strong>-短暂，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>l <strong>并发清除</strong></p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>-XX:+UseConcMarkSweepGC ，表示新生代使用ParNew，老年代的用CMS</p>
<p><strong>CPU****敏感：</strong>CMS对处理器资源敏感，毕竟采用了并发的收集、当处理核心数不足4个时，CMS对用户的影响较大。</p>
<p><strong>浮动垃圾：</strong>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<p>由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。</p>
<p>在1.6的版本中老年代空间使用率阈值(92%)</p>
<p>如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</p>
<p><strong>会产生空间碎片：</strong>标记 - 清除算法会导致产生不连续的空间碎片</p>
<p>总体来说，CMS是JVM推出了第一款并发垃圾收集器，所以还是非常有代表性。</p>
<p>但是最大的问题是CMS采用了标记清除算法，所以会有内存碎片，当碎片较多时，给大对象的分配带来很大的麻烦，为了解决这个问题，CMS提供一个参数：-XX:+UseCMSCompactAtFullCollection，一般是开启的，如果分配不了大对象，就进行内存碎片的整理过程。<br>这个地方一般会使用Serial Old ，因为Serial Old是一个单线程，所以如果内存空间很大、且对象较多时,CMS发生这样情况会很卡。</p>
<h3 id="Stop-The-World现象"><a href="#Stop-The-World现象" class="headerlink" title="Stop The World现象"></a>Stop The World现象</h3><p>任何的GC收集器都会进行业务线程的暂停，这个就是STW，Stop The World,所以我们GC调优的目标就是尽可能的减少STW的时间和次数。</p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p><img src="/images/java_gc_garbage_gc_g1.png" alt="img"></p>
<p>-XX:+UseG1GC</p>
<p><strong>内存布局：</strong>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。每一个区域可以通过参数-XX:G1HeapRegionSize=size 来设置。</p>
<p><img src="/images/java_gc_garbage_gc_params_heap_region_size.png" alt="img"></p>
<p>Region中还有一块特殊区域Humongous区域，专门用于存储大对象，一般只要认为一个对象超过了Region容量的一般可认为是大对象，如果对象超级大，那么使用连续的N个Humongous区域来存储。</p>
<p><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p>
<p><strong>分代收集</strong>：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p>
<p><strong>空间整合</strong>：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</p>
<p><strong>追求停顿时间：</strong></p>
<p>-XX:MaxGCPauseMillis 指定目标的最大停顿时间，G1尝试调整新生代和老年代的比例，堆大小，晋升年龄来达到这个目标时间。</p>
<p>-XX:ParallerGCThreads：设置GC的工作线程数量。</p>
<p>一般在G1和CMS中间选择的话平衡点在6~8G，只有内存比较大G1才能发挥优势。</p>
<h2 id="学习垃圾回收的意义"><a href="#学习垃圾回收的意义" class="headerlink" title="学习垃圾回收的意义"></a>学习垃圾回收的意义</h2><p>Java与C++等语言最大的技术区别：自动化的垃圾回收机制（GC）</p>
<p>为什么要了解GC和内存分配策略</p>
<p>1、面试需要</p>
<p>2、GC对应用的性能是有影响的；</p>
<p>3、写代码有好处</p>
<p>栈：栈中的生命周期是跟随线程，所以一般不需要关注</p>
<p>堆：堆中的对象是垃圾回收的重点</p>
<p>方法区/元空间：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin基础</title>
    <url>/2019/07/02/kotlin_base/</url>
    <content><![CDATA[<p>Kotlin（科特林）是一个用于现代多平台应用的静态编程语言，由 JetBrains 开发。<br>Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。除此之外Kotlin还可以编译成二进制代码直接运行在机器上（例如嵌入式设备或 iOS）。<br>Kotlin已正式成为Android官方支持开发语言。</p>
<span id="more"></span>

<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO Var 与 Val</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可变变量定义：var 关键字</span></span><br><span class="line">    <span class="comment">// var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可变变量定义：val 关键字，只能赋值一次的变量(有一点点类似Java中final修饰的变量)</span></span><br><span class="line">    <span class="comment">// val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以修改的</span></span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;Derry&quot;</span></span><br><span class="line">    name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    name = <span class="string">&quot;李四&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> info1 = <span class="string">&quot;AAAA&quot;</span> <span class="comment">// 类型推到</span></span><br><span class="line">    <span class="keyword">var</span> info2 = <span class="string">&#x27;A&#x27;</span> <span class="comment">// 类型推到  Char</span></span><br><span class="line">    <span class="keyword">var</span> info3:<span class="built_in">Int</span> = <span class="number">99</span> <span class="comment">// 类型推到  Int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可以修改的</span></span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">99</span></span><br><span class="line">    <span class="comment">// age = &quot;&quot; 报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态语言 编译期 就决定了 String类型</span></span><br><span class="line">    <span class="keyword">var</span> info4 = <span class="string">&quot;LISI&quot;</span>  <span class="comment">// info4==String类型</span></span><br><span class="line">    <span class="comment">// info4 = 88   // js 动态解释语言</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以改，可以读  get  set</span></span><br><span class="line">    <span class="keyword">var</span> info1 : String = <span class="string">&quot;A&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只能读， 只有 get</span></span><br><span class="line">    <span class="keyword">val</span> info2 : String = <span class="string">&quot;B&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 函数  方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void == :Unit</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line"></span><br><span class="line">    println(add(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    lenMethod(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lambda表达式函数</span></span><br><span class="line">    <span class="keyword">val</span> addMethod : (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123;number1, number2 -&gt; number1 + number2&#125;</span><br><span class="line">    <span class="keyword">val</span> r= addMethod(<span class="number">9</span>, <span class="number">9</span>)</span><br><span class="line">    println(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型Int</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(number1: <span class="type">Int</span>, number2: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number1 + number2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型  == 类型推导 Int</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add2</span><span class="params">(number1: <span class="type">Int</span>, number2: <span class="type">Int</span>)</span></span> = number1 + number2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型  == 类型推导 String</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add3</span><span class="params">(number1: <span class="type">Int</span>, number2: <span class="type">Int</span>)</span></span> = <span class="string">&quot;AAA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数 （可变长 参数函数）</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lenMethod</span><span class="params">(<span class="keyword">vararg</span> value: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> value) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 字符串模板</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $ 表示一个变量名或者变量值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// $varName 表示变量值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;varName.fun()&#125; 表示变量的方法返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;张三&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> age = <span class="number">28</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sex = <span class="string">&#x27;M&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> info = <span class="string">&quot;ABCDEFG&quot;</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;name:<span class="variable">$name</span>,  age:<span class="variable">$age</span>,  sex:<span class="variable">$sex</span>  info:<span class="variable">$info</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 自己不用关系 \n 换行 ，不用自己调整</span></span><br><span class="line">    <span class="keyword">val</span> infoMesage = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        AAAAAAAAAAA</span></span><br><span class="line"><span class="string">        BBBBBBBBBBB</span></span><br><span class="line"><span class="string">        CCCCCCCCCCC</span></span><br><span class="line"><span class="string">        DDDDDDDDDDD</span></span><br><span class="line"><span class="string">        EEEEEEEEEEE</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  <span class="comment">// 前置空格</span></span><br><span class="line">    println(infoMesage)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> infoMesage2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        AAAAAAAAAAA</span></span><br><span class="line"><span class="string">        BBBBBBBBBBB</span></span><br><span class="line"><span class="string">        CCCCCCCCCCC</span></span><br><span class="line"><span class="string">        DDDDDDDDDDD</span></span><br><span class="line"><span class="string">        EEEEEEEEEEE</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()  <span class="comment">// 没空格</span></span><br><span class="line">    println(infoMesage2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> infoMesage3 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        ?AAAAAAAAAAA</span></span><br><span class="line"><span class="string">        ?BBBBBBBBBBB</span></span><br><span class="line"><span class="string">        ?CCCCCCCCCCC</span></span><br><span class="line"><span class="string">        ?DDDDDDDDDDD</span></span><br><span class="line"><span class="string">        ?EEEEEEEEEEE</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimMargin(<span class="string">&quot;?&quot;</span>)  <span class="comment">// 没空格 控制|</span></span><br><span class="line">    println(infoMesage3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求：显示 $99999.99</span></span><br><span class="line">    <span class="keyword">val</span> price = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;<span class="string">&#x27;$&#x27;</span>&#125;</span>99999.99</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>.trimIndent()</span><br><span class="line">    println(price)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NULL检查机制"><a href="#NULL检查机制" class="headerlink" title="NULL检查机制"></a>NULL检查机制</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO NULL检查机制</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，</span></span><br><span class="line">    <span class="comment">// 有两种处理方式，字段后加!!像Java一样抛出空异常，另一种字段后加?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> info: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// println(info?.length)  // 第一种补救：? 如果info是null，就不执行 .length</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// println(info!!.length) // 第2种补救： !! 我自己负责info 不会为null ==  (不管null不null必须执行)  ==  Java</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*if (info != null)           // 第3种补救：  ==  Java</span></span><br><span class="line"><span class="comment">        println(info.length)*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// println(testMethod(&quot;AAAAA&quot;))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刚那个提问的呢?</span></span><br><span class="line">    <span class="comment">// ?:  如果你一定要输出null  就让你  “你很牛逼”</span></span><br><span class="line">    println(info?.length           ?: <span class="string">&quot;你很牛逼&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// : Int? === 允许返回null</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testMethod</span><span class="params">(name: <span class="type">String</span>)</span></span> : <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;zs&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99999</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 区间</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 到 9</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.9</span>) &#123;</span><br><span class="line">        <span class="comment">// println(i)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会输出</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">9.</span><span class="number">.1</span>) &#123;</span><br><span class="line">        <span class="comment">// println(i)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大 到 小</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">9</span> downTo <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// println(i)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用区间做判断</span></span><br><span class="line">    <span class="keyword">val</span> value = <span class="number">88</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">        <span class="comment">// println(&quot;包了 1 到 100&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步长指定</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.20</span> step <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 1 3 5 7 ...</span></span><br><span class="line">        <span class="comment">// println(i)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除 最后元素</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">10</span>) &#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="比较与数组"><a href="#比较与数组" class="headerlink" title="比较与数组"></a>比较与数组</h2><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 比较两个值</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> name1: String = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    <span class="keyword">val</span> name2: String = <span class="string">&quot;张三&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 比较值本身</span></span><br><span class="line">    <span class="comment">// == 等价 Java的equals</span></span><br><span class="line">    println(name1.equals(name2))</span><br><span class="line">    println(name1 == name2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---  比较对象地址</span></span><br><span class="line">    <span class="keyword">val</span> test1:<span class="built_in">Int</span>? =  <span class="number">10000</span></span><br><span class="line">    <span class="keyword">val</span> test2:<span class="built_in">Int</span>? =  <span class="number">10000</span></span><br><span class="line">    println(test1 === test2) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 数组</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 第一种形式</span></span><br><span class="line">    <span class="keyword">val</span> numbers = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="comment">// println(numbers[0])</span></span><br><span class="line">    <span class="comment">// println(numbers[7])</span></span><br><span class="line">    <span class="keyword">for</span> (number <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">        <span class="comment">// println(number)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种形式  value=0</span></span><br><span class="line">    <span class="comment">// 0 + 200 = 200</span></span><br><span class="line">    <span class="comment">// 1 + 200 = 201</span></span><br><span class="line">    <span class="keyword">val</span> numbers2 = Array(<span class="number">10</span>,  &#123;value: <span class="built_in">Int</span> -&gt; (value + <span class="number">200</span>) &#125;)</span><br><span class="line">    <span class="keyword">for</span> (value <span class="keyword">in</span> numbers2) &#123;</span><br><span class="line">        println(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个变量 value Int类型</span></span><br><span class="line">    <span class="comment">// value=0 + 200</span></span><br><span class="line">    <span class="comment">// &#123;value: Int                -&gt;                     (value + 200) &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 条件</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> number1: <span class="built_in">Int</span> = <span class="number">9999999</span></span><br><span class="line">    <span class="keyword">val</span> number2: <span class="built_in">Int</span> = <span class="number">8888888</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表达式 比 大小 最大值</span></span><br><span class="line">    <span class="keyword">val</span> maxValue = <span class="keyword">if</span> (number1 &gt; number2) number1 <span class="keyword">else</span> number2</span><br><span class="line">    <span class="comment">// println(maxValue)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> max: <span class="built_in">Int</span> = <span class="keyword">if</span> (number1 &gt; number2) &#123;</span><br><span class="line">        println(<span class="string">&quot;number1是最大的哦&quot;</span>)</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="comment">// ....... 省略 200行代码</span></span><br><span class="line">        number1</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;number2是最大的哦&quot;</span>)</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="comment">// .......  省略 200行代码</span></span><br><span class="line">        number2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// println(max)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用区间做判断</span></span><br><span class="line">    <span class="keyword">val</span> x = <span class="number">80</span></span><br><span class="line">    <span class="keyword">val</span> y = <span class="number">29</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span> &amp;&amp; y <span class="keyword">in</span> <span class="number">1.</span><span class="number">.50</span>) &#123;</span><br><span class="line">        <span class="comment">// println(&quot;x y 轴 符合&quot;)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// println(&quot;x y 轴 不符合&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* val number = 5</span></span><br><span class="line"><span class="comment">     when(number) &#123;</span></span><br><span class="line"><span class="comment">         1 -&gt; println(&quot;一&quot;)</span></span><br><span class="line"><span class="comment">         2 -&gt; println(&quot;二&quot;)</span></span><br><span class="line"><span class="comment">         3 -&gt; println(&quot;三&quot;)</span></span><br><span class="line"><span class="comment">         4 -&gt; println(&quot;四&quot;)</span></span><br><span class="line"><span class="comment">         5 -&gt; println(&quot;五&quot;)</span></span><br><span class="line"><span class="comment">         else -&gt; println(&quot;其他&quot;)</span></span><br><span class="line"><span class="comment">     &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*val number = 745</span></span><br><span class="line"><span class="comment">    when(number) &#123;</span></span><br><span class="line"><span class="comment">        in 1..100 -&gt; println(&quot;1..100&quot;)</span></span><br><span class="line"><span class="comment">        in 200..500 -&gt; println(&quot;200..500&quot;)</span></span><br><span class="line"><span class="comment">        else -&gt; println(&quot;其他&quot;)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object == Any ?</span></span><br><span class="line">    <span class="comment">// val str : String = &quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> number = <span class="number">3</span></span><br><span class="line">    <span class="keyword">val</span> result = <span class="keyword">when</span> (number) &#123;</span><br><span class="line">        <span class="number">1</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;很开心&quot;</span>)</span><br><span class="line">            <span class="comment">// 很多很多的逻辑..  省略 200行代码</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// TODO ....</span></span><br><span class="line">            <span class="string">&quot;今天是星期一&quot;</span></span><br><span class="line">            <span class="number">99</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">2</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;很开心&quot;</span>)</span><br><span class="line">            <span class="comment">// 很多很多的逻辑..  省略 200行代码</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// TODO ....</span></span><br><span class="line">            <span class="string">&quot;今天是星期二&quot;</span></span><br><span class="line">            <span class="number">88</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">3</span> -&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;很开心&quot;</span>)</span><br><span class="line">            <span class="comment">// 很多很多的逻辑..  省略 200行代码</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// TODO ....</span></span><br><span class="line">            <span class="string">&quot;今天是星期三&quot;</span></span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">            <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="number">99</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// println(result)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span> (<span class="number">8</span>) &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> -&gt; println(<span class="string">&quot;满足&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;不满足&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="循环与标签"><a href="#循环与标签" class="headerlink" title="循环与标签"></a>循环与标签</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 循环 与 标签</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义标签</span></span><br><span class="line">    <span class="symbol">tttt@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.20</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.20</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;i:<span class="variable">$i</span>, j:<span class="variable">$j</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="comment">// break // j循环 给break</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span><span class="symbol">@tttt</span> <span class="comment">// i循环 给break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 循环</span></span><br><span class="line">    <span class="keyword">var</span> items  = listOf&lt;String&gt;(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;王五&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> items) &#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    items.forEach &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> items.indices) &#123;</span><br><span class="line">        println(<span class="string">&quot;下标：<span class="variable">$index</span>,  对应的值：<span class="subst">$&#123;items[index]&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自带的标签</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> I = <span class="string">&quot;AAAA&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(I)</span><br><span class="line">        println(<span class="keyword">this</span>.I)</span><br><span class="line">        println(<span class="keyword">this</span><span class="symbol">@Derry</span>.I)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="构造和继承"><a href="#构造和继承" class="headerlink" title="构造和继承"></a>构造和继承</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public final class Person 默认就是这样的，不能被继承，  可以加open就可以被人家继承了</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(id: <span class="built_in">Int</span>) <span class="comment">// 主构造</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 次构造</span></span><br><span class="line">    <span class="keyword">constructor</span>(id: <span class="built_in">Int</span>, name: String) : <span class="keyword">this</span>(id) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 次构造</span></span><br><span class="line">    <span class="keyword">constructor</span>(id: <span class="built_in">Int</span>, sex: <span class="built_in">Char</span>) : <span class="keyword">this</span>(id) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 次构造</span></span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="number">787</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(id: <span class="built_in">Int</span>) : <span class="comment">// Person() // 次构造</span></span><br><span class="line">                Person(id) <span class="comment">// 主构造了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 再Kotlin 全部都是没有默认值的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再Java 成员有默认值，但是方法内部没有默认值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lateinit 懒加载  没有赋值 就不能使用，否则报错</span></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> name : String</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO 类与对象</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> person = Person() <span class="comment">// 次构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> person2 = Person(<span class="number">6465</span>) <span class="comment">// 主构造</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Person(<span class="number">464</span>, <span class="string">&quot;Derry&quot;</span>) <span class="comment">// 次构造</span></span><br><span class="line">    Person(<span class="number">464</span>, <span class="string">&#x27;M&#x27;</span>) <span class="comment">// 次构造</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口与抽象"><a href="#接口与抽象" class="headerlink" title="接口与抽象"></a>接口与抽象</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口默认都是 open</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callbackMethod</span><span class="params">()</span></span> : <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callback2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">callbackMethod2</span><span class="params">()</span></span> : <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认是 public final class Person 不能被人家继承的      abstract有open的特征 相当于open</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="type">Callback </span>, <span class="type">Callback2 &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLayoutID</span><span class="params">()</span></span> : <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">initView</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getLayoutID</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="number">888</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initView</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">callbackMethod</span><span class="params">()</span></span>: <span class="built_in">Boolean</span>  = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据类和单例"><a href="#数据类和单例" class="headerlink" title="数据类和单例"></a>数据类和单例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据类  == Java实体Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会再修改了，可以是使用val</span></span><br><span class="line"><span class="comment">// 如果有再次修改需求，可以使用var</span></span><br><span class="line"><span class="comment">// get set 构造 equals hashCode toString，  copy</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> id: <span class="built_in">Int</span>, <span class="keyword">val</span> name: String, <span class="keyword">val</span> sex: <span class="built_in">Char</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只实例一次   相当于 单例 饿汉式</span></span><br><span class="line"><span class="keyword">object</span> MyEngine &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">m</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;M run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;我就只有一个实例&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: SingletonDemo? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">                    field = SingletonDemo()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> field</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: SingletonDemo&#123;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重校验锁</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance: SingletonDemo <span class="keyword">by</span> lazy(mode = LazyThreadSafetyMode.SYNCHRONIZED) &#123;</span><br><span class="line">        SingletonDemo() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Lazy是接受一个 lambda 并返回一个 Lazy 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 //get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO  data数据类 ，object单例</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user = User(<span class="number">99</span>, <span class="string">&quot;lisi&quot;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//使用数据类生成的copy函数</span></span><br><span class="line">    <span class="keyword">val</span>(myID, myName, mySex) = user.copy()</span><br><span class="line">    println(<span class="string">&quot;myID:<span class="variable">$myID</span>, myName:<span class="variable">$myName</span>, mySex:<span class="variable">$mySex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _ 代表不接收</span></span><br><span class="line">    <span class="keyword">val</span>(_, myName2, _) = user.copy()</span><br><span class="line">    println(<span class="string">&quot;myName2:<span class="variable">$myName2</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 相当于使用单例，只有一个对象</span></span><br><span class="line">    MyEngine.m()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin手动写单例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO　Kotlin 单例模式1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个实例</span></span><br><span class="line">    <span class="keyword">object</span> Holder &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> instance = NetManager()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看不到 static  可以 派生操作</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全部都是  相当于 Java static</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span> : NetManager = Holder.instance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;show:<span class="variable">$name</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> net  = NetManager.getInstance()</span><br><span class="line">    net.show(<span class="string">&quot;kt Derry1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TODO　kt 单例模式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetManager2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: NetManager2? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值：允许你返回null</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span>: NetManager2? &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = NetManager2()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是null，也返回回去了</span></span><br><span class="line">            <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二种补救： 我来负责 instance 肯定不为null</span></span><br><span class="line">            <span class="comment">// return instance!!</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;show:<span class="variable">$name</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 客户端 来做补救措施</span></span><br><span class="line">    <span class="keyword">val</span> netManager = NetManager2.getInstance()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 netManager == null ，就不执行 .show(&quot;AAA&quot;)</span></span><br><span class="line">    netManager?.show(<span class="string">&quot;AAA&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套类、内部类、嵌套函数"><a href="#嵌套类、内部类、嵌套函数" class="headerlink" title="嵌套类、内部类、嵌套函数"></a>嵌套类、内部类、嵌套函数</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> I = <span class="string">&quot;AAAA&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个不是一个内部类，所有拿不到外部类的成员</span></span><br><span class="line">    <span class="comment">// 嵌套类 = 可以在类的里面再写一个类，但是这个类和外部类 不交换</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个才是内部类</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(I)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">c</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">fun</span> <span class="title">d</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-线程安全与协作</title>
    <url>/2016/06/21/java_thread_safe_cooperation/</url>
    <content><![CDATA[<p>Java的内存模型就决定了其会有线程安全的问题，我们都知道java的内存模型中有主内存和线程的工作内存之分，主内存上存放的是线程共享的变量（实例字段，静态字段和构成数组的元素），线程的工作内存是线程私有的空间，存放的是线程私有的变量（方法参数与局部变量）。</p>
<span id="more"></span>

<p>线程在工作的时候如果要操作主内存上的共享变量，为了获得更好的执行性能并不是直接去修改主内存而是会在线程私有的工作内存中创建一份变量的拷贝（缓存），在工作内存上对变量的拷贝修改之后再把修改的值刷回到主内存的变量中去，JVM提供了8种原子操作来完成这一过程：<code>lock</code>, <code>unlock</code>, <code>read</code>, <code>load</code>, <code>use</code>, <code>assign</code>, <code>store</code>, <code>write</code>。</p>
<p>如果只有一个线程当然不会有什么问题，但是如果有多个线程同时在操作主内存中的变量，因为8种操作的非连续性和线程抢占cpu执行的机制就会带来冲突的问题，也就是多线程的安全问题。线程安全的定义就是：如果线程执行过程中不会产生共享资源的冲突就是线程安全的。</p>
<h2 id="同步锁sychronized"><a href="#同步锁sychronized" class="headerlink" title="同步锁sychronized"></a>同步锁sychronized</h2><p>sychronized是Java中的关键字，是一种同步锁。它修饰的对象有一下几种：</p>
<ol>
<li><p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		sychronized(<span class="keyword">this</span>)&#123;</span><br><span class="line">      	<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	sychronized(obj)&#123;</span><br><span class="line">      	<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个并发线程(thread1和thread2)访问同一个对象中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后才能执行该代码块。thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，下一个线程才能执行并锁定该对象。</p>
<p><strong>注：</strong>如果thread1和thread2一个访问method，另一个访问method2，则不会去争同一把锁，因为两个方法中的同步代码快锁的并不是同一个对象。</p>
</li>
<li><p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> sychronized <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized修饰一个方法很简单，就是在方法的前面加synchronized，synchronized修饰方法和修饰一个代码块类似，只是作用范围不一样，修饰代码块是大括号括起来的范围，而修饰方法范围是整个函数。</p>
<p>虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p>
<p>注：</p>
<p>1）接口定义方法时不能使用sychronized关键字</p>
<p>2）构造方法不能使用synchronized关键字修饰，但是可以使用同步代码块</p>
</li>
<li><p>修饰一个静态的方法，其作用的范围是整个静态方法；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> sychronized <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道静态方法是属于类的而不属于对象的。同样的，synchronized修饰的静态方法锁定的是这个类在JVM中仅有的一份字节码对象。所以静态方法上的synchronized并不会和非静态方法上的synchronized锁互斥。</p>
</li>
<li><p>修饰一个类，其作用的范围是synchronized后面括号括起来的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="keyword">synchronized</span>(Test.class)&#123;</span><br><span class="line">      	<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其和修饰静态方法时类似，锁住的都是.class对象。</p>
</li>
</ol>
<h3 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h3><p>Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。</p>
<p>对同步块，MonitorEnter指令插入在同步代码块的开始位置，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。总的来说，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁：</p>
<p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p>
<p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p>
<p>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</p>
<p>对同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。</p>
<p>JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p>
<p>synchronized使用的锁是存放在Java对象头里面，Java对象的对象头由 mark word 和 klass pointer 两部分组成：</p>
<p>1）mark word存储了同步状态、标识、hashcode、GC状态等等。</p>
<p>2）klass pointer存储对象的类型指针，该指针指向它的类元数据</p>
<p>另外对于数组而言还会有一份记录数组长度的数据。</p>
<p><img src="/images/java_thread_safe_synchronized01.jpg" alt="img"></p>
<p>锁信息则是存在于对象的mark word中，MarkWord里默认数据是存储对象的HashCode等信息，</p>
<p><img src="/images/java_thread_safe_synchronized02.jpg" alt="img"></p>
<p>但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式</p>
<p><img src="/images/java_thread_safe_synchronized03.jpg" alt="img"></p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>先说下数据同步中的两个特性：</p>
<p><strong>可见性：</strong>一个线程对共享变量的修改，更够及时的被其他线程看到</p>
<p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>由于线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，那么对于共享变量V，它们首先是在自己的工作内存，之后再同步到主内存。可是并不会及时的刷到主存中，而是会有一定时间差。很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了 。</p>
<p>要解决共享对象可见性这个问题，我们可以使用volatile关键字或者是加锁。</p>
<p><strong>原子性：</strong>即不可再分了，不能分为多步操作。</p>
<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>我们都知道CPU资源的分配都是以线程为单位的,并且是分时调用,操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。而任务的切换大多数是在时间片段结束以后,</p>
<p>那么线程切换为什么会带来bug呢？因为操作系统做任务切换，可以发生在任何一条CPU 指令执行完！注意，是 CPU 指令，CPU 指令，CPU 指令，而不是高级语言里的一条语句。比如count++，在java里就是一句话，但高级语言里一条语句往往需要多条 CPU 指令完成。其实count++至少包含了三个CPU指令！</p>
<p>比如赋值或者return。比如”a = 1;”和 “return a;”这样的操作都具有原子性。类似”a += b”这样的操作不具有原子性，在某些JVM中”a += b”可能要经过这样三个步骤：<br>①　取出a和b<br>②　计算a+b<br>③　将计算结果写入内存</p>
<p>而volatile就是为了保证可见性而设计的，先来简单了解一下Java内存模型。</p>
<p>（1）Java所有变量都存储在主内存中<br>（2）每个线程都有自己独立的工作内存，里面保存该线程的使用到的变量副本（该副本就是主内存中该变量的一份拷贝）</p>
<p><img src="/images/java_thread_safe_jmm01.png" alt="image-20210626195546859"></p>
<p>（1）线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接在主内存中读写<br>（2）不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p>
<p>线程1对共享变量的修改，要想被线程2及时看到，必须经过如下2个过程：<br>（1）把工作内存1中更新过的共享变量刷新到主内存中<br>（2）将主内存中最新的共享变量的值更新到工作内存2中</p>
<p><img src="/images/java_thread_safe_jmm02.png" alt="image-20210626195755522"></p>
<p><strong>(1)Synchronized：保证可见性和原子性</strong><br>  Synchronized能够实现原子性和可见性；在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。<br><strong>(2)Volatile：保证可见性，但不保证操作的原子性</strong><br>  Volatile实现内存可见性是通过store和load指令完成的；也就是对volatile变量执行写操作时，会在写操作后加入一条store指令，即强迫线程将最新的值刷新到主内存中；而在读操作时，会加入一条load指令，即强迫从主内存中读入变量的值。但volatile不保证volatile变量的原子性。</p>
<p><strong>(3)Synchronized和Volatile的比较</strong><br>  1）Synchronized保证内存可见性和操作的原子性<br>  2）Volatile只能保证内存可见性<br>  3）Volatile不需要加锁，比Synchronized更轻量级，并不会阻塞线程（volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。）<br>  4）volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化（如编译器重排序的优化）.<br>  5）volatile是变量修饰符，仅能用于变量，而synchronized是一个方法或块的修饰符。<br>   volatile本质是在告诉JVM当前变量在寄存器中的值是不确定的，使用前，需要先从主存中读取，因此可以实现可见性。而对n=n+1,n++等操作时，volatile关键字将失效，不能起到像synchronized一样的线程同步（原子性）的效果。</p>
<p>volatile比较适合用在一处写多处读的场景。</p>
<h3 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h3><p>volatile关键字修饰的变量会存在一个“lock:”的前缀。</p>
<p>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。</p>
<p>同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。<code>ThreadLocal</code>是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量这样就不会存在线程不安全问题。</p>
<p>　　<code>ThreadLocal</code>是JDK包提供的，它提供线程本地变量，如果创建一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的一个副本，在实际多线程操作的时候，操作的是自己本地内存中的变量，从而规避了线程安全问题。</p>
<p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p>
<p>• <code>void set(Object value) </code></p>
<p>设置当前线程的线程局部变量的值。</p>
<p>• <code>public Object get() </code></p>
<p>该方法返回当前线程所对应的线程局部变量。</p>
<p>• <code>public void remove() </code></p>
<p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p>
<p>• <code>protected Object initialValue() </code></p>
<p>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p>
<p>public final static ThreadLocal<String> RESOURCE = new ThreadLocal<String>();RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。</p>
<h3 id="实现解析"><a href="#实现解析" class="headerlink" title="实现解析"></a>实现解析</h3><p><img src="/images/java_thread_safe_threadlocal01.png" alt="image-20210626200239926"></p>
<p><img src="/images/java_thread_safe_threadlocal02.png" alt="img02"></p>
<p><img src="/images/java_thread_safe_threadlocal03.png" alt="img03"></p>
<p><img src="/images/java_thread_safe_threadlocal04.png" alt="img04"></p>
<p><img src="/images/java_thread_safe_threadlocal05.png" alt="img05"></p>
<p>上面先取到当前线程，然后调用getMap方法获取对应的ThreadLocalMap，ThreadLocalMap是ThreadLocal的静态内部类，然后Thread类中有一个这样类型成员，所以getMap是直接返回Thread的成员。</p>
<p>看下ThreadLocal的内部类ThreadLocalMap源码：</p>
<p><img src="/images/java_thread_safe_threadlocal06.png" alt="img06"></p>
<p>可以看到有个Entry内部静态类，它继承了WeakReference，总之它记录了两个信息，一个是ThreadLocal&lt;?&gt;类型，一个是Object类型的值。getEntry方法则是获取某个ThreadLocal对应的值，set方法就是更新或赋值相应的ThreadLocal对应的值。</p>
<p><img src="/images/java_thread_safe_threadlocal07.png" alt="img07"></p>
<p><img src="/images/java_thread_safe_threadlocal08.png" alt="img"></p>
<p>回顾我们的get方法，其实就是拿到<strong>每个线程独有的ThreadLocalMap</strong></p>
<p>然后再用ThreadLocal的当前实例，拿到Map中的相应的Entry，然后就可以拿到相应的值返回出去。当然，如果Map为空，还会先进行map的创建，初始化等工作。</p>
<h3 id="引发内存泄露分析"><a href="#引发内存泄露分析" class="headerlink" title="引发内存泄露分析"></a>引发内存泄露分析</h3><p>在前面的介绍中，我们知道ThreadLocal只是一个工具类，它为用户提供get、set、remove接口操作实际存放本地变量的threadLocals（调用线程的成员变量），也知道threadLocals是一个ThreadLocalMap类型的变量，下面我们来看看ThreadLocalMap这个类。在此之前，我们回忆一下Java中的四种引用类型。</p>
<p><strong>①强引用</strong>：Java中默认的引用类型，一个对象如果具有强引用那么只要这种引用还存在就不会被GC。</p>
<p><strong>②软引用</strong>：简言之，如果一个对象具有软引用，在JVM发生OOM之前（即内存充足够使用），是不会GC这个对象的；只有到JVM内存不足的时候才会GC掉这个对象。软引用和一个引用队列联合使用，如果软引用所引用的对象被回收之后，该引用就会加入到与之关联的引用队列中</p>
<p><strong>③弱引用</strong>:（这里讨论ThreadLocalMap中的Entry类的重点）：如果一个对象只具有弱引用，那么这个对象就会被垃圾回收器GC掉(被弱引用所引用的对象只能生存到下一次GC之前，当发生GC时候，无论当前内存是否足够，弱引用所引用的对象都会被回收掉)。弱引用也是和一个引用队列联合使用，如果弱引用的对象被垃圾回收期回收掉，JVM会将这个引用加入到与之关联的引用队列中。弱引用的对象可以通过弱引用的get方法得到，当引用的对象被回收掉之后，再调用get方法就会返回null</p>
<p><strong>④虚引用</strong>:  虚引用是所有引用中最弱的一种引用，其存在就是为了将关联虚引用的对象在被GC掉之后收到一个通知。（不能通过get方法获得其指向的对象）</p>
<p>ThreadLocalMap内部实际上是一个Entry数组，我们先看看Entry的这个内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是继承自WeakReference的一个类，该类中实际存放的key是</span></span><br><span class="line"><span class="comment"> * 指向ThreadLocal的弱引用和与之对应的value值(该value值</span></span><br><span class="line"><span class="comment"> * 就是通过ThreadLocal的set方法传递过来的值)</span></span><br><span class="line"><span class="comment"> * 由于是弱引用，当get方法返回null的时候意味着坑能引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** value就是和ThreadLocal绑定的 */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k：ThreadLocal的引用，被传递给WeakReference的构造方法</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//WeakReference构造方法(public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; )</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(referent); <span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reference构造方法</span></span><br><span class="line">Reference(T referent) &#123;</span><br><span class="line">    <span class="keyword">this</span>(referent, <span class="keyword">null</span>);<span class="comment">//referent：ThreadLocal的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Reference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.referent = referent;</span><br><span class="line">    <span class="keyword">this</span>.queue = (queue == <span class="keyword">null</span>) ? ReferenceQueue.NULL : queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们可以看出，当前ThreadLocal的引用k被传递给WeakReference的构造函数，所以ThreadLocalMap中的key为ThreadLocal的弱引用。当一个线程调用ThreadLocal的set方法设置变量的时候，当前线程的ThreadLocalMap就会存放一个记录，这个记录的key值为ThreadLocal的弱引用，value就是通过set设置的值。如果当前线程一直存在且没有调用该ThreadLocal的remove方法，如果这个时候别的地方还有对ThreadLocal的引用，那么当前线程中的ThreadLocalMap中会存在对ThreadLocal变量的引用和value对象的引用，是不会释放的，就会造成内存泄漏。</p>
<p>　　考虑这个ThreadLocal变量没有其他强依赖，如果当前线程还存在，由于线程的ThreadLocalMap里面的key是弱引用，所以当前线程的ThreadLocalMap里面的ThreadLocal变量的弱引用在gc的时候就被回收，但是对应的value还是存在的这就可能造成内存泄漏(因为这个时候ThreadLocalMap会存在key为null但是value不为null的entry项)。</p>
<p>　　其实ThreadLocal本身不存放任何的数据，而ThreadLocal中的数据实际上是存放在线程实例中，从实际来看是线程内存泄漏，底层来看是Thread对象中的成员变量threadLocals持有大量的K-V结构，并且线程一直处于活跃状态导致变量threadLocals无法释放被回收。threadLocals持有大量的K-V结构这一点的前提是要存在大量的ThreadLocal实例的定义，一般来说，一个应用不可能定义大量的ThreadLocal，所以一般的泄漏源是线程一直处于活跃状态导致变量threadLocals无法释放被回收。但是我们知道，ThreadLocalMap中的Entry结构的Key用到了弱引用(·WeakReference&lt;ThreadLocal&lt;?&gt;&gt;·)，当没有强引用来引用ThreadLocal实例的时候，JVM的GC会回收ThreadLocalMap中的这些Key，此时，ThreadLocalMap中会出现一些Key为null，但是Value不为null的Entry项，这些Entry项如果不主动清理，就会一直驻留在ThreadLocalMap中。也就是为什么ThreadLocal中get()、set()、remove()这些方法中都存在清理ThreadLocalMap实例key为null的代码块。</p>
<p><em>上面是不是你们觉得的缺点？漏~</em></p>
<p>　　ThreadLocal中一个设计亮点是ThreadLocalMap中的Entry结构的Key用到了弱引用。试想如果使用强引用，等于ThreadLocalMap中的所有数据都是与Thread的生命周期绑定，这样很容易出现因为大量线程持续活跃导致的内存泄漏。使用了弱引用的话，JVM触发GC回收弱引用后，ThreadLocal在下一次调用get()、set()、remove()方法就可以删除那些ThreadLocalMap中Key为null的值，起到了惰性删除释放内存的作用。</p>
<p>其次就是在ThreadLocalMap会存在相应的遍历来查看key为null的槽位并且进行删除哦~</p>
<p>综上所述，我并不觉得这是一个缺陷，反而是一个很灵活的点，因为我们可以手动将弱引用变成强引用嘛（static关键字了解一下）</p>
<h3 id="与synchronized比较"><a href="#与synchronized比较" class="headerlink" title="与synchronized比较"></a>与synchronized比较</h3><p><code>ThreadLocal</code>和<code>Synchonized</code>都用于解决多线程并发訪问。可是<code>ThreadLocal</code>与<code>synchronized</code>有本质的差别。<code>synchronized</code>是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程訪问。而<code>ThreadLocal</code>为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。</p>
<h2 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h2><p>在前面我们将了很多关于同步的问题，然而在现实中，需要线程之间的协作。比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。</p>
<h3 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait()/notify()/notifyAll()"></a>wait()/notify()/notifyAll()</h3><p>这三个方法均为Object的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up a single thread that is waiting on this object&#x27;s</span></span><br><span class="line"><span class="comment"> * monitor. If any threads are waiting on this object, one of them</span></span><br><span class="line"><span class="comment"> * is chosen to be awakened. The choice is arbitrary and occurs at</span></span><br><span class="line"><span class="comment"> * the discretion of the implementation. A thread waits on an object&#x27;s</span></span><br><span class="line"><span class="comment"> * monitor by calling one of the wait methods</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wakes up all threads that are waiting on this object&#x27;s monitor. A</span></span><br><span class="line"><span class="comment"> * thread waits on an object&#x27;s monitor by calling one of the</span></span><br><span class="line"><span class="comment"> * wait methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes the current thread to wait until either another thread invokes the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notify()&#125; method or the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> java.lang.Object#notifyAll()&#125; method for this object, or a</span></span><br><span class="line"><span class="comment"> * specified amount of time has elapsed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The current thread must own this object&#x27;s monitor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>



<p>从这三个方法的文字描述可以知道以下几点信息：</p>
<p>　　1）<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>方法是本地方法，并且为final方法，无法被重写。</p>
<p>　　2）调用某个对象的<code>wait()</code>方法能让当前线程阻塞，并且当前线程必须拥有此对象的<code>monitor</code>（即锁）</p>
<p>　　3）调用某个对象的<code>notify()</code>方法能够唤醒一个正在等待这个对象的<code>monitor</code>的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程；</p>
<p>　　4）调用<code>notifyAll()</code>方法能够唤醒所有正在等待这个对象的<code>monitor</code>的线程；</p>
<p>上面已经提到，如果调用某个对象的<code>wait()</code>方法，当前线程必须拥有这个对象的<code>monitor</code>（即锁），因此调用<code>wait()</code>方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mObj)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!mReady)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mObj.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException exception) &#123;</span><br><span class="line">                exception.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>　　调用某个对象的wait()方法，相当于让当前线程交出此对象的monitor（释放了锁），然后进入等待状态，等待后续再次获得此对象的锁（Thread类中的sleep方法使当前线程暂停执行一段时间，从而让其他线程有机会继续执行，但它并不释放对象锁）；</p>
<p>　　notify()方法能够唤醒一个正在等待该对象的monitor的线程，当有多个线程都在等待该对象的monitor的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。</p>
<p>　　同样地，调用某个对象的notify()方法，当前线程也必须拥有这个对象的monitor，因此调用notify()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。</p>
<p>　　nofityAll()方法能够唤醒所有正在等待该对象的monitor的线程，这一点与notify()方法是不同的。</p>
<p>　　这里要注意一点：notify()和notifyAll()方法只是唤醒等待该对象的monitor的线程，并不决定哪个线程能够获取到monitor。</p>
<p>　　上面尤其要注意一点，一个线程被唤醒不代表立即获取了对象的monitor，只有等调用完notify()或者notifyAll()并退出synchronized块，释放对象锁后，其余线程才可获得锁执行。</p>
<h2 id="了解各种锁"><a href="#了解各种锁" class="headerlink" title="了解各种锁"></a>了解各种锁</h2><h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p>一共有四种状态，<strong>无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态</strong>，它会随着竞争情况逐渐升级。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入背景：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。</p>
<p>偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。</p>
<p>偏向锁获取过程：</p>
<p>步骤1、 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</p>
<p>步骤2、 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</p>
<p>步骤3、 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</p>
<p>步骤4、 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</p>
<p>步骤5、 执行同步代码。</p>
<p><img src="/images/java_thread_safe_cooperation_lock01.jpg" alt="img"></p>
<p>偏向锁的释放：</p>
<p>偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p>
<p>偏向锁的适用场景</p>
<p>始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作； </p>
<p>在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。</p>
<p>jvm开启/关闭偏向锁</p>
<p>开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</p>
<p>关闭偏向锁：-XX:-UseBiasedLocking</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； </p>
<p>轻量级锁的加锁过程：</p>
<p>1、在代码进入同步块的时候，如果同步对象锁状态为无锁状态且不允许进行偏向（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</p>
<p>2、拷贝对象头中的Mark Word复制到锁记录中。</p>
<p>3、拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</p>
<p>4、如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态</p>
<p>5、如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，那么它就会自旋等待锁，一定次数后仍未获得锁对象。重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</p>
<p>但是线程自旋是需要消耗CPU的，说白了就是让CPU在做无用功，线程不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。</p>
<p>如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</p>
<h4 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h4><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，占着XX不XX，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。</p>
<h4 id="自旋锁时间阈值"><a href="#自旋锁时间阈值" class="headerlink" title="自旋锁时间阈值"></a>自旋锁时间阈值</h4><p>自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋次数很重要</p>
<p>JVM对于自旋次数的选择，jdk1.5默认为10次，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。</p>
<p>JDK1.6中-XX:+UseSpinning开启自旋锁； JDK1.7后，去掉此参数，由jvm控制；</p>
<p><img src="/images/java_thread_safe_cooperation_lock02.jpg" alt="img"></p>
<h3 id="不同锁的比较"><a href="#不同锁的比较" class="headerlink" title="不同锁的比较"></a>不同锁的比较</h3><p><img src="/images/java_thread_safe_cooperation_lock03.gif" alt="这里写图片描述"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin-巧用内置函数</title>
    <url>/2019/09/07/kotlin_internal_method/</url>
    <content><![CDATA[<p>在<code>Kotlin</code>中，有一些用于扩展 &amp; 方便开发者编码的内置函数，能大大提高开发者的开发效率。</p>
<span id="more"></span>

<p>下面主要讲解的是：</p>
<ul>
<li>let函数</li>
<li>also函数</li>
<li>with函数</li>
<li>run函数</li>
<li>apply函数</li>
</ul>
<h2 id="let函数"><a href="#let函数" class="headerlink" title="let函数"></a>let函数</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/images/kotlin_internal_method_let_introduction.png" alt="image-20210707100630090"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作用1：使用it替代object对象去访问其公有的属性 &amp; 方法</span></span><br><span class="line"><span class="keyword">object</span>.let&#123;</span><br><span class="line">   it.todo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作用2：判断object为null的操作</span></span><br><span class="line"><span class="keyword">object</span>?.let&#123;<span class="comment">//表示object不为null的条件下，才会去执行let函数体</span></span><br><span class="line">   it.todo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：返回值 = 最后一行 / return的表达式</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Java</span></span><br><span class="line"><span class="keyword">if</span>( mVar != <span class="literal">null</span> )&#123;</span><br><span class="line">    mVar.function1();</span><br><span class="line">    mVar.function2();</span><br><span class="line">    mVar.function3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用kotlin（无使用let函数）</span></span><br><span class="line">mVar?.function1()</span><br><span class="line">mVar?.function2()</span><br><span class="line">mVar?.function3()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用kotlin（使用let函数）</span></span><br><span class="line"><span class="comment">// 方便了统一判空的处理 &amp; 确定了mVar变量的作用域</span></span><br><span class="line">mVar?.let &#123;</span><br><span class="line">       it.function1()</span><br><span class="line">       it.function2()</span><br><span class="line">       it.function3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="also函数"><a href="#also函数" class="headerlink" title="also函数"></a>also函数</h2><h3 id="作用-amp-应用场景"><a href="#作用-amp-应用场景" class="headerlink" title="作用 &amp; 应用场景"></a>作用 &amp; 应用场景</h3><p>类似let函数，但区别在于返回值：</p>
<ul>
<li>let函数：返回值 = 最后一行 / return的表达式</li>
<li>also函数：返回值 = 传入的对象的本身</li>
</ul>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let函数</span></span><br><span class="line"><span class="keyword">var</span> result = mVar.let &#123;</span><br><span class="line">               it.function1()</span><br><span class="line">               it.function2()</span><br><span class="line">               it.function3()</span><br><span class="line">               <span class="number">999</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终结果 = 返回999给变量result</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// also函数</span></span><br><span class="line"><span class="keyword">var</span> result = mVar.also &#123;</span><br><span class="line">               it.function1()</span><br><span class="line">               it.function2()</span><br><span class="line">               it.function3()</span><br><span class="line">               <span class="number">999</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终结果 = 返回一个mVar对象给变量result</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="with函数"><a href="#with函数" class="headerlink" title="with函数"></a>with函数</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>调用同一个对象的多个方法 / 属性时，可以省去对象名重复，直接调用方法名 / 属性即可</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>需要调用同一个对象的多个方法 / 属性</p>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> with(<span class="keyword">object</span>)&#123;</span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值 = 函数块的最后一行 / return表达式</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处要调用people的name 和 age属性</span></span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">val</span> people = People(<span class="string">&quot;carson&quot;</span>, <span class="number">25</span>)</span><br><span class="line">with(people) &#123;</span><br><span class="line">println(<span class="string">&quot;my name is <span class="variable">$name</span>, I am <span class="variable">$age</span> years old&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">User peole = new People(<span class="string">&quot;carson&quot;</span>, <span class="number">25</span>);</span><br><span class="line">String var1 = <span class="string">&quot;my name is &quot;</span> + peole.name + <span class="string">&quot;, I am &quot;</span> + peole.age + <span class="string">&quot; years old&quot;</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(var1);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="run函数"><a href="#run函数" class="headerlink" title="run函数"></a>run函数</h2><h3 id="作用-amp-应用场景-1"><a href="#作用-amp-应用场景-1" class="headerlink" title="作用 &amp; 应用场景"></a>作用 &amp; 应用场景</h3><p>结合了let、with两个函数的作用，即：</p>
<ol>
<li>调用同一个对象的多个方法 / 属性时，可以省去对象名重复，直接调用方法名 / 属性即可</li>
<li>定义一个变量在特定作用域内</li>
<li>统一做判空处理</li>
</ol>
<h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span>.run&#123;</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回值 = 函数块的最后一行 / return表达式</span></span><br></pre></td></tr></table></figure>

<h3 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处要调用people的name 和 age属性，且要判空</span></span><br><span class="line"><span class="comment">// kotlin</span></span><br><span class="line"><span class="keyword">val</span> people = People(<span class="string">&quot;carson&quot;</span>, <span class="number">25</span>)</span><br><span class="line">people?.run&#123;</span><br><span class="line">    println(<span class="string">&quot;my name is <span class="variable">$name</span>, I am <span class="variable">$age</span> years old&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line">User peole = new People(<span class="string">&quot;carson&quot;</span>, <span class="number">25</span>);</span><br><span class="line">String var1 = <span class="string">&quot;my name is &quot;</span> + peole.name + <span class="string">&quot;, I am &quot;</span> + peole.age + <span class="string">&quot; years old&quot;</span>;</span><br><span class="line">System.<span class="keyword">out</span>.println(var1);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h2><h3 id="作用-amp-应用场景-2"><a href="#作用-amp-应用场景-2" class="headerlink" title="作用 &amp; 应用场景"></a>作用 &amp; 应用场景</h3><p>与run函数类似，但区别在于返回值：</p>
<ul>
<li>run函数返回最后一行的值 / 表达式</li>
<li>apply函数返回传入的对象的本身</li>
</ul>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>对象实例初始化时需要对对象中的属性进行赋值 &amp; 返回该对象</p>
<h3 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// run函数</span></span><br><span class="line"><span class="keyword">val</span> people = People(<span class="string">&quot;carson&quot;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">val</span> result = people?.run&#123;</span><br><span class="line">    println(<span class="string">&quot;my name is <span class="variable">$name</span>, I am <span class="variable">$age</span> years old&quot;</span>)</span><br><span class="line">    <span class="number">999</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终结果 = 返回999给变量result</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">val</span> people = People(<span class="string">&quot;carson&quot;</span>, <span class="number">25</span>)</span><br><span class="line"><span class="keyword">val</span> result = people?.run&#123;</span><br><span class="line">    println(<span class="string">&quot;my name is <span class="variable">$name</span>, I am <span class="variable">$age</span> years old&quot;</span>)</span><br><span class="line">    <span class="number">999</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终结果 = 返回一个people对象给变量result</span></span><br></pre></td></tr></table></figure>

<p>至此，关于<code>Kotlin</code>里提供用于扩展 &amp; 方便开发者编码的几个有用内置函数讲解完毕。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/kotlin_internal_method_sumarry.png" alt="image-20210707100836222"></p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-线程池和阻塞队列</title>
    <url>/2016/06/08/java_thread_pool/</url>
    <content><![CDATA[<p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
<span id="more"></span>

<p>在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。</p>
<h2 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h2><p><strong>1）支持阻塞的插入方法：</strong>意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
<p><strong>2）支持阻塞的移除方法：</strong>意思是在队列为空时，获取元素的线程会等待队列变为非空。</p>
<p>在并发编程中使用<strong>生产者和消费者模式</strong>能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度。</p>
<p>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。</p>
<p>为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p>
<p><img src="/images/java_threadpool01.png" alt="img01"></p>
<p><strong>抛出异常：</strong>当队列满时，如果再往队列里插入元素，会抛出<code>IllegalStateException</code>（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出<code>NoSuchElementException</code>异常。</p>
<p><strong>返回特殊值：</strong>当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。</p>
<p><strong>一直阻塞：</strong>当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里<code>take</code>元素，队列会阻塞住消费者线程，直到队列不为空。</p>
<p><strong>超时退出：</strong>当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。</p>
<h2 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h2><p><strong>ArrayBlockingQueue：</strong>一个由数组结构组成的有界阻塞队列。</p>
<p><strong>LinkedBlockingQueue：</strong>一个由链表结构组成的有界阻塞队列。</p>
<p><strong>PriorityBlockingQueue：</strong>一个支持优先级排序的无界阻塞队列。</p>
<p><strong>DelayQueue：</strong>一个使用优先级队列实现的无界阻塞队列。</p>
<p><strong>SynchronousQueue：</strong>一个不存储元素的阻塞队列。</p>
<p><strong>LinkedTransferQueue：</strong>一个由链表结构组成的无界阻塞队列。</p>
<p><strong>LinkedBlockingDeque：</strong>一个由链表结构组成的双向阻塞队列。</p>
<p>以上的阻塞队列都实现了<code>BlockingQueue</code>接口，也都是线程安全的。</p>
<h3 id="有界队列和无界队列"><a href="#有界队列和无界队列" class="headerlink" title="有界队列和无界队列"></a>有界队列和无界队列</h3><p>有限队列就是长度有限，满了以后生产者会阻塞，无界队列就是里面能放无数的东西而不会因为队列长度限制被阻塞，当然空间限制来源于系统资源的限制，如果处理不及时，导致队列越来越大越来越大，超出一定的限制致使内存超限，操作系统或者JVM帮你解决烦恼，直接把你 OOM kill 省事了。</p>
<p>无界也会阻塞，为何？因为阻塞不仅仅体现在生产者放入元素时会阻塞，消费者拿取元素时，如果没有元素，同样也会阻塞。</p>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。初始化时有参数可以设置</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为<code>Integer.MAX_VALUE</code>。此队列按照先进先出的原则对元素进行排序。</p>
<p><code>LinkedBlockingDeque</code>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。</p>
<p>多了<code>addFirst</code>、<code>addLast</code>、<code>offerFirst</code>、<code>offerLast</code>、<code>peekFirst</code>和<code>peekLast</code>等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于<code>addLast</code>，移除方法<code>remove</code>等效于<code>removeFirst</code>。但是<code>take</code>方法却等同于<code>takeFirst</code>，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化<code>LinkedBlockingDeque</code>时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。</p>
<h3 id="Array实现和Linked实现区别"><a href="#Array实现和Linked实现区别" class="headerlink" title="Array实现和Linked实现区别"></a>Array实现和Linked实现区别</h3><ol>
<li>队列中锁的实现不同</li>
</ol>
<p><code>ArrayBlockingQueue</code>实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁；</p>
<p><code>LinkedBlockingQueue</code>实现的队列中的锁是分离的，即生产用的是<code>putLock</code>，消费是<code>takeLock</code></p>
<ol start="2">
<li>在生产或消费时操作不同</li>
</ol>
<p><code>ArrayBlockingQueue</code>实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的；</p>
<p><code>LinkedBlockingQueue</code>实现的队列中在生产和消费的时候，需要把枚举对象转换为<code>Node&lt;E&gt;</code>进行插入或移除，会影响性能</p>
<ol start="3">
<li>队列大小初始化方式不同</li>
</ol>
<p><code>ArrayBlockingQueue</code>实现的队列中必须指定队列的大小；</p>
<p><code>LinkedBlockingQueue</code>实现的队列中可以不指定队列的大小，但是默认是<code>Integer.MAX_VALUE</code></p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><code>PriorityBlockingQueue</code>是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现<code>compareTo()</code>方法来指定元素排序规则，或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数<code>Comparator</code>来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>是一个支持延时获取元素的无界阻塞队列。队列使用<code>PriorityQueue</code>来实现。队列中的元素必须实现<code>Delayed</code>接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p>
<p><code>DelayQueue</code>非常有用，可以将<code>DelayQueue</code>运用在以下应用场景。</p>
<p><strong>缓存系统的设计：</strong>可以用<code>DelayQueue</code>保存缓存元素的有效期，使用一个线程循环查询<code>DelayQueue</code>，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。</p>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>多了tryTransfer和transfer方法，</p>
<p>（1）transfer方法</p>
<p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p>
<p>（2）tryTransfer方法</p>
<p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。</p>
<p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p>
<p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。  如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</p>
<p>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p>
<h3 id="ThreadPoolExecutor的类关系"><a href="#ThreadPoolExecutor的类关系" class="headerlink" title="ThreadPoolExecutor的类关系"></a>ThreadPoolExecutor的类关系</h3><p><code>Executor</code>是一个接口，它是<code>Executor</code>框架的基础，它将任务的提交与任务的执行分离开来。</p>
<p><code>ExecutorService</code>接口继承了<code>Executor</code>，在其上做了一些<code>shutdown()</code>、<code>submit()</code>的扩展，可以说是真正的线程池接口；</p>
<p><code>AbstractExecutorService</code>抽象类实现了<code>ExecutorService</code>接口中的大部分方法；</p>
<p><code>ThreadPoolExecutor</code>是线程池的核心实现类，用来执行被提交的任务。</p>
<p><code>ScheduledExecutorService</code>接口继承了<code>ExecutorService</code>接口，提供了带”周期执行”功能<code>ExecutorService</code>；</p>
<p><code>ScheduledThreadPoolExecutor</code>是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。<code>ScheduledThreadPoolExecutor</code>比<code>Timer</code>更灵活，功能更强大。</p>
<h3 id="线程池的创建各个参数含义"><a href="#线程池的创建各个参数含义" class="headerlink" title="线程池的创建各个参数含义"></a>线程池的创建各个参数含义</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；</p>
<p>如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；</p>
<p>如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</p>
<h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize</p>
<h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用</p>
<h4 id="TimeUnit"><a href="#TimeUnit" class="headerlink" title="TimeUnit"></a>TimeUnit</h4><p>keepAliveTime的时间单位</p>
<h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。</p>
<p>一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响。</p>
<p>1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</p>
<p>2）由于1，使用无界队列时maximumPoolSize将是一个无效参数。</p>
<p>3）由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</p>
<p>4）更重要的，使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。</p>
<h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。</p>
<p>Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。</p>
<h4 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h4><p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：</p>
<p>（1）AbortPolicy：直接抛出异常，默认策略；</p>
<p>（2）CallerRunsPolicy：用调用者所在的线程来执行任务；</p>
<p>（3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；</p>
<p>（4）DiscardPolicy：直接丢弃任务；</p>
<p>当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
<h3 id="线程池的工作机制"><a href="#线程池的工作机制" class="headerlink" title="线程池的工作机制"></a>线程池的工作机制</h3><p>1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</p>
<p>2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</p>
<p>3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。</p>
<p>4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</p>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</p>
<p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断<strong>所有没有正在执行任务的线程</strong>。</p>
<p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>
<h3 id="合理的配置线程池"><a href="#合理的配置线程池" class="headerlink" title="合理的配置线程池"></a>合理的配置线程池</h3><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。</p>
<p>•任务的性质：CPU密集型任务、IO密集型任务和混合型任务。</p>
<p>•任务的优先级：高、中和低。</p>
<p>•任务的执行时间：长、中和短。</p>
<p>•任务的依赖性：是否依赖其他系统资源，如数据库连接。</p>
<p>性质不同的任务可以用不同规模的线程池分开处理。</p>
<p>CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。</p>
<p>混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</p>
<p>建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。</p>
<p>如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>NDK开发之Native异常处理</title>
    <url>/2019/01/06/ndk_native_bug/</url>
    <content><![CDATA[<p>在进行NDK相关开发时会经常遇到各种闪退异常，Native层的异常不像Java层的异常一样能直接把详细的堆栈信息输出到logcat，那我们该如何处理Native层异常问题呢？</p>
<span id="more"></span>

<p>Native层的异常排查相对比较麻烦点</p>
<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p>直接点击debug运行，使用LLDB，不要打断点，会自动定位到错误行（Android5.0不行，需要Android6+）</p>
<h2 id="第二种方法（错误日志分析）"><a href="#第二种方法（错误日志分析）" class="headerlink" title="第二种方法（错误日志分析）"></a>第二种方法（错误日志分析）</h2><p>在logcat界面定位到异常输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fatal signal 11 (SIGSEGV), code 1, fault addr 0x0 in tid 20769 (Thread-775)</span><br></pre></td></tr></table></figure>

<p>然后去data/tombstones，目录下找最近报错的日志文件导出（可能需要ROOT权限）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pull /data/tombstones/tombstone_03</span><br><span class="line">/data/tombstones/tombstone_03: 1 file pulled, 0 skipped. 3.5 MB/s (334204 bytes</span><br><span class="line">in 0.092s)</span><br></pre></td></tr></table></figure>

<p>分下日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Build fingerprint: &#x27;Honor/SCL-AL00/hnSCL-Q:5.1.1/HonorSCL-</span><br><span class="line">AL00/C00B261:user/release-keys&#x27;</span><br><span class="line">Revision: &#x27;0&#x27;</span><br><span class="line">ABI: &#x27;arm&#x27;</span><br><span class="line">pid: 20655, tid: 20769, name: Thread-775  &gt;&gt;&gt; com.xxx.player &lt;&lt;&lt;</span><br><span class="line">signal 11 (SIGSEGV), code 0 (SI_USER), fault addr 0x0</span><br><span class="line">【终点是下面的】</span><br><span class="line">backtrace:</span><br><span class="line">    #00 pc 002e0590  /data/app/com.xxx.player-1/lib/arm/libnative-lib.so</span><br><span class="line">(Java_com_xxx_player_XXXPlayer_startNative+43)</span><br><span class="line">    #01 pc 0012e57f  /data/dalvik-cache/arm/data@app@com.xxx.player-</span><br><span class="line">1@base.apk@classes.dex</span><br></pre></td></tr></table></figure>

<p>继续往下分析，具体行 报错的:</p>
<p>需要配置adb和ndk的环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb logcat | ndk-stack -sym 你项目的路径/xxxx/xxx/armeabi-v7a</span><br></pre></td></tr></table></figure>

<p>执行命令后，一直等待，需要运行一次(奔溃一次) 他才能输出结果 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Taurus&gt;adb logcat | ndk-stack -sym</span><br><span class="line">你的项目/app/build/intermediates/cmake/debug/obj/armeabi-v7a</span><br><span class="line">********** Crash dump: **********</span><br><span class="line">Build fingerprint: &#x27;Honor/SCL-AL00/hnSCL-Q:5.1.1/HonorSCL-</span><br><span class="line">AL00/C00B261:user/release-keys&#x27;</span><br><span class="line">#00 0x002e0590 /data/app/com.xxx.player-2/lib/arm/libnative-lib.so</span><br><span class="line">(Java_com_xxx_player_XXXPlayer_startNative+43)</span><br><span class="line"> Java_com_xxx_player_XXXPlayer_startNative</span><br><span class="line"> 你的项目/app/src/main/cpp\native-lib.cpp:111:14</span><br><span class="line">Crash dump is completed</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>JNI</tag>
      </tags>
  </entry>
  <entry>
    <title>YUV与RGB</title>
    <url>/2018/11/17/yuv_rgb/</url>
    <content><![CDATA[<p>对RGB，并不陌生，从初中开始接触的色光的三原色，告诉我们我们可以看到的光可以由这三种颜色按一定的比例去混合得到；后来在HTML以及Android开发中设置元素/控件的颜色时，可以通过一串数字，得到某个特定的颜色。这就是RGB的应用。 </p>
<span id="more"></span>

<p>RGB 模型是目前常用的一种彩色信息表达方式，它使用红、绿、蓝三原色的亮度来定量表示颜色。该模型也称为加色混色模型，是以RGB三色光互相叠加来实现混色的方法，因而适合于显示器等发光体的显示。</p>
<p>RGB 颜色模型可以看做三维直角坐标颜色系统中的一个单位正方体。任何一种颜色在RGB 颜色空间中都可以用三维空间中的一个点来表示。在RGB 颜色空间上，当任何一个基色的亮度值为零时，即在原点处，就显示为黑色。当三种基色都达到最高亮度时，就表现为白色。在连接黑色与白色的对角线上，是亮度等量的三基色混合而成的灰色，该线称为灰色线。</p>
<h2 id="什么是BGR"><a href="#什么是BGR" class="headerlink" title="什么是BGR"></a>什么是BGR</h2><p>与RGB类似，只是存储时B位与R位的位置进行调换。</p>
<h2 id="什么是YCbCr"><a href="#什么是YCbCr" class="headerlink" title="什么是YCbCr"></a>什么是YCbCr</h2><p>Y表示亮度，CbCr表示颜色。怎么表示颜色，可以看下面这幅坐标图： </p>
<p><img src="/images/yuv_rgb_ycbcr1.png" alt="2390759023750273"></p>
<p>Y要如何表示亮度呢，下面是Y在不同的情况下的表现： </p>
<p><img src="/images/yuv_rgb_ycbcr2.png" alt="23907529375923"></p>
<p>因此可以这样理解，同样是使用三个数来表示某个像素点的颜色，但是这三个数的意义变了，与RGB相比。然后接下来是各种yuv的衍生物。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The scope of the terms Y′UV, YUV, YCbCr, YPbPr, etc., is sometimes ambiguous and overlapping. Historically, the terms YUV and Y′UV were used for a specific analog encoding of color information in television systems, while YCbCr was used for digital encoding of color information suited for video and still-image compression and transmission such as MPEG and JPEG. Today, the term YUV is commonly used in the computer industry to describe file-formats that are encoded using YCbCr.</span><br></pre></td></tr></table></figure>

<p>上面的意思是，这些术语有时真的很难区分，因为定义也是模糊不清。不过重要的是最后面那一句话：现在的YUV是通常用于计算机领域用来表示使用YCbCr编码的文件。所以可以粗浅地视YUV为YCbCr。</p>
<p>不过我在Camera预览中的每一帧中，除默认格式NV21外，还发现了其它的格式如YV12。去搜一些关于他们的资料时，发现都是yuv420系列的。具体有什么差异呢？</p>
<p>膜拜一下大佬的博客（稍作编辑与修改）：</p>
<h2 id="YUV分类与意义"><a href="#YUV分类与意义" class="headerlink" title="YUV分类与意义"></a>YUV分类与意义</h2><p>planar和packed<br>对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。<br>对于packed的YUV格式，每个像素点的Y,U,V是连续交*存储的。</p>
<p>YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p>
<p>与我们熟知的RGB类似，YUV也是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像（是不是写错了），只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p>
<p>YUV码流的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0，关于其详细原理，可以通过网上其它文章了解，这里我想强调的是如何根据其采样格式来从码流中还原每个像素点的YUV值，因为只有正确地还原了每个像素点的YUV值，才能通过YUV与RGB的转换公式提取出每个像素点的RGB值，然后显示出来。</p>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><p>用三个图来直观地表示采集的方式吧，以黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量。 </p>
<p><img src="/images/yuv_rgb_store.png" alt="293759835793457"></p>
<p>先记住下面这段话，以后提取每个像素的YUV分量会用到。</p>
<p>YUV 4:4:4采样，每一个Y对应一组UV分量。<br>YUV 4:2:2采样，每两个Y共用一组UV分量。<br>YUV 4:2:0采样，每四个Y共用一组UV分量。</p>
<p>下面我用图的形式给出常见的YUV码流的存储方式，并在存储方式后面附有取样每个像素点的YUV数据的方法，其中，Cb、Cr的含义等同于U、V。</p>
<h3 id="YUVY-格式-（属于YUV422）"><a href="#YUVY-格式-（属于YUV422）" class="headerlink" title="YUVY 格式 （属于YUV422）"></a>YUVY 格式 （属于YUV422）</h3><p><img src="/images/yuv_rgb_storage1.png" alt="239792375934"></p>
<p>YUYV为YUV422采样的存储格式中的一种，相邻的两个Y共用其相邻的两个Cb、Cr，分析，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00，其他的像素点的YUV取值依次类推。</p>
<h3 id="UYVY-格式-（属于YUV422）"><a href="#UYVY-格式-（属于YUV422）" class="headerlink" title="UYVY 格式 （属于YUV422）"></a>UYVY 格式 （属于YUV422）</h3><p><img src="/images/yuv_rgb_storage2.png" alt="23972937547"></p>
<p>UYVY格式也是YUV422采样的存储格式中的一种，只不过与YUYV不同的是UV的排列顺序不一样而已，还原其每个像素点的YUV值的方法与上面一样。</p>
<h3 id="YUV422P（属于YUV422）"><a href="#YUV422P（属于YUV422）" class="headerlink" title="YUV422P（属于YUV422）"></a>YUV422P（属于YUV422）</h3><p><img src="/images/yuv_rgb_storage3.png" alt="239752934573984"></p>
<p>YUV422P也属于YUV422的一种，它是一种Plane模式，即平面模式，并不是将YUV数据交错存储，而是先存放所有的Y分量，然后存储所有的U（Cb）分量，最后存储所有的V（Cr）分量，如上图所示。其每一个像素点的YUV值提取方法也是遵循YUV422格式的最基本提取方法，即两个Y共用一个UV。比如，对于像素点Y’00、Y’01 而言，其Cb、Cr的值均为 Cb00、Cr00。</p>
<h3 id="YV12，YU12格式（属于YUV420）"><a href="#YV12，YU12格式（属于YUV420）" class="headerlink" title="YV12，YU12格式（属于YUV420）"></a>YV12，YU12格式（属于YUV420）</h3><p><img src="/images/yuv_rgb_storage4.png" alt="2037293579"></p>
<p>YU12和YV12属于YUV420格式，也是一种Plane模式，将Y、U、V分量分别打包，依次存储。其每一个像素点的YUV数据提取遵循YUV420格式的提取方式，即4个Y分量共用一组UV。注意，上图中，Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00，其他依次类推。</p>
<h3 id="NV12、NV21（属于YUV420）"><a href="#NV12、NV21（属于YUV420）" class="headerlink" title="NV12、NV21（属于YUV420）"></a>NV12、NV21（属于YUV420）</h3><p><img src="/images/yuv_rgb_storage5.png" alt="239792375934534"></p>
<p>NV12和NV21属于YUV420格式，是一种two-plane模式，即Y和UV分为两个Plane，但是UV（CbCr）为交错存储，而不是分为三个plane。其提取方式与上一种类似，即Y’00、Y’01、Y’10、Y’11共用Cr00、Cb00</p>
<h2 id="YUV文件大小计算"><a href="#YUV文件大小计算" class="headerlink" title="YUV文件大小计算"></a>YUV文件大小计算</h2><p>以720×488大小图象YUV420 planar为例，其存储格式是： 共大小为(720×480×3&gt;&gt;1)字节，</p>
<p>分为三个部分:Y,U和V</p>
<p>Y分量： (720×480)个字节<br>U(Cb)分量：(720×480&gt;&gt;2)个字节<br>V(Cr)分量：(720×480&gt;&gt;2)个字节</p>
<p>三个部分内部均是行优先存储，三个部分之间是Y,U,V 顺序存储。<br>即<br>0－－720×480字节是Y分量值，<br>720×480－－720×480×5/4字节是U分量<br>720×480×5/4 －－720×480×3/2字节是V分量。</p>
<h3 id="4-：2：-2-和4：2：0-转换"><a href="#4-：2：-2-和4：2：0-转换" class="headerlink" title="4 ：2： 2 和4：2：0 转换"></a>4 ：2： 2 和4：2：0 转换</h3><p>最简单的方式：</p>
<p>YUV4:2:2 —&gt; YUV4:2:0 Y不变，将U和V信号值在行(垂直方向)在进行一次隔行抽样。 YUV4:2:0 —&gt; YUV4:2:2 Y不变，将U和V信号值的每一行分别拷贝一份形成连续两行数据。</p>
<p>在YUV420中，一个像素点对应一个Y，一个4X4的小方块对应一个U和V。对于所有YUV420图像，它们的Y值排列是完全相同的，因为只有Y的图像就是灰度图像。YUV420sp与YUV420p的数据格式它们的UV排列在原理上是完全不同的。420p它是先把U存放完后，再存放V，也就是说UV它们是连续的。而420sp它是UV、UV这样交替存放的。(见下图) 有了上面的理论，我就可以准确的计算出一个YUV420在内存中存放的大小。 width * hight =Y（总和） U = Y / 4 V = Y / 4。所以YUV420 数据在内存中的长度是 width * hight * 3 / 2，</p>
<p>假设一个分辨率为8X4的YUV图像，它们的格式如下图： </p>
<p><img src="/images/yuv_rgb_switch1.png" alt="19379237592834"></p>
<p>YUV420p数据格式如下图 </p>
<p><img src="/images/yuv_rgb_switch2.png" alt="2397239573488"></p>
<h3 id="旋转90度的算法"><a href="#旋转90度的算法" class="headerlink" title="旋转90度的算法:"></a>旋转90度的算法:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotateYUV240SP</span><span class="params">(<span class="keyword">byte</span>[] src,<span class="keyword">byte</span>[] des,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> wh = width * height;</span><br><span class="line">    <span class="comment">//旋转Y</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;height;j++) &#123;</span><br><span class="line">            des[k] = src[width*j + i];   </span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width;i+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;height/<span class="number">2</span>;j++) &#123; </span><br><span class="line">            des[k] = src[wh+ width*j + i]; </span><br><span class="line">            des[k+<span class="number">1</span>]=src[wh + width*j + i+<span class="number">1</span>];</span><br><span class="line">            k+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="YV12和I420的区别"><a href="#YV12和I420的区别" class="headerlink" title="YV12和I420的区别"></a>YV12和I420的区别</h2><p>一般来说，直接采集到的视频数据是RGB24的格式，RGB24一帧的大小size＝width×heigth×3 Bit，RGB32的size＝width×heigth×4，如果是I420（即YUV标准格式4：2：0）的数据量是 size＝width×heigth×1.5 Bit。 在采集到RGB24数据后，需要对这个格式的数据进行第一次压缩。即将图像的颜色空间由RGB2YUV。因为，X264在进行编码的时候需要标准的YUV（4：2：0）。但是这里需要注意的是，虽然YV12也是（4：2：0），但是YV12和I420的却是不同的，在存储空间上面有些区别。如下： YV12 ： 亮度（行×列） ＋ U（行×列/4) + V（行×列/4）</p>
<p>I420 ： 亮度（行×列） ＋ V（行×列/4) + U（行×列/4）</p>
<p>可以看出，YV12和I420基本上是一样的，就是UV的顺序不同。</p>
<p>继续我们的话题，经过第一次数据压缩后RGB24－&gt;YUV（I420）。这样，数据量将减少一半，为什么呢？呵呵，这个就太基础了，我就不多写了。同样，如果是RGB24－&gt;YUV（YV12），也是减少一半。但是，虽然都是一半，如果是YV12的话效果就有很大损失。然后，经过X264编码后，数据量将大大减少。将编码后的数据打包，通过RTP实时传送。到达目的地后，将数据取出，进行解码。完成解码后，数据仍然是YUV格式的，所以，还需要一次转换，这样windows的驱动才可以处理，就是YUV2RGB24。</p>
<h2 id="YUV420P和-YUV420SP的区别"><a href="#YUV420P和-YUV420SP的区别" class="headerlink" title="YUV420P和 YUV420SP的区别"></a>YUV420P和 YUV420SP的区别</h2><p>YUV420P，Y，U，V三个分量都是平面格式，分为I420和YV12。I420格式和YV12格式的不同处在U平面和V平面的位置不同。在I420格式中，U平面紧跟在Y平面之后，然后才是V平面（即：YUV）；但YV12则是相反（即：YVU）。<br>YUV420SP, Y分量平面格式，UV打包格式, 即NV12。 NV12与NV21类似，U 和 V 交错排列,不同在于UV顺序。</p>
<p><strong>I420: YYYYYYYY UU VV =&gt;YUV420P</strong><br><strong>YV12: YYYYYYYY VV UU =&gt;YUV420P</strong><br><strong>NV12: YYYYYYYY UVUV =&gt;YUV420SP</strong><br><strong>NV21: YYYYYYYY VUVU =&gt;YUV420SP</strong></p>
<p><strong>Y′UV420p (and Y′V12 or YV12) to RGB888 conversion</strong><br>Y′UV420p is a planar format, meaning that the Y′, U, and V values are grouped together instead of interspersed. The reason for this is that by grouping the U and V values together, the image becomes much more compressible. When given an array of an image in the Y′UV420p format, all the Y′ values come first, followed by all the U values, followed finally by all the V values.</p>
<p>The Y′V12 format is essentially the same as Y′UV420p, but it has the U and V data switched: the Y′ values are followed by the V values, with the U values last. As long as care is taken to extract U and V values from the proper locations, both Y′UV420p and Y′V12 can be processed using the same algorithm.</p>
<p>As with most Y′UV formats, there are as many Y′ values as there are pixels. Where X equals the height multiplied by the width, the first X indices in the array are Y′ values that correspond to each individual pixel. However, there are only one fourth as many U and V values. The U and V values correspond to each 2 by 2 block of the image, meaning each U and V entry applies to four pixels. After the Y′ values, the next X/4 indices are the U values for each 2 by 2 block, and the next X/4 indices after that are the V values that also apply to each 2 by 2 block.</p>
<p>Translating Y′UV420p to RGB is a more involved process compared to the previous formats. Lookup of the Y′, U and V values can be done using the following method:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">size.total = size.width * size.height;</span><br><span class="line">y = yuv[position.y * size.width + position.x];</span><br><span class="line">u = yuv[(position.y / <span class="number">2</span>) * (size.width / <span class="number">2</span>) + (position.x / <span class="number">2</span>) + size.total];</span><br><span class="line">v = yuv[(position.y / <span class="number">2</span>) * (size.width / <span class="number">2</span>) + (position.x / <span class="number">2</span>) + size.total + (size.total / <span class="number">4</span>)];</span><br><span class="line">rgb = Y′UV420toRGB888(y, u, v);</span><br></pre></td></tr></table></figure>

<p><img src="/images/yuv_rgb_switch3.png" alt="2395293845384"></p>
<p>As shown in the above image, the Y′, U and V components in Y′UV420 are encoded separately in sequential blocks. A Y′ value is stored for every pixel, followed by a U value for each 2×2 square block of pixels, and finally a V value for each 2×2 block. Corresponding Y′, U and V values are shown using the same color in the diagram above. Read line-by-line as a byte stream from a device, the Y′ block would be found at position 0, the U block at position x×y (6×4 = 24 in this example) and the V block at position x×y + (x×y)/4 (here, 6×4 + (6×4)/4 = 30).</p>
<p><strong>Y′UV420sp (NV21) to RGB conversion (Android)</strong><br>This format (NV21) is the standard picture format on Android camera preview. YUV 4:2:0 planar image, with 8 bit Y samples, followed by interleaved V/U plane with 8bit 2x2 subsampled chroma samples.<br>C++ code used on Android to convert pixels of YUVImage:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">YUVImage::yuv2rgb</span><span class="params">(<span class="keyword">uint8_t</span> yValue, <span class="keyword">uint8_t</span> uValue, <span class="keyword">uint8_t</span> vValue,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">uint8_t</span> *r, <span class="keyword">uint8_t</span> *g, <span class="keyword">uint8_t</span> *b)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rTmp = yValue + (<span class="number">1.370705</span> * (vValue<span class="number">-128</span>));</span><br><span class="line">    <span class="keyword">int</span> gTmp = yValue - (<span class="number">0.698001</span> * (vValue<span class="number">-128</span>)) - (<span class="number">0.337633</span> * (uValue<span class="number">-128</span>));</span><br><span class="line">    <span class="keyword">int</span> bTmp = yValue + (<span class="number">1.732446</span> * (uValue<span class="number">-128</span>));</span><br><span class="line">    *r = <span class="built_in">clamp</span>(rTmp, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    *g = <span class="built_in">clamp</span>(gTmp, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    *b = <span class="built_in">clamp</span>(bTmp, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="YUV与RGB优缺点"><a href="#YUV与RGB优缺点" class="headerlink" title="YUV与RGB优缺点"></a>YUV与RGB优缺点</h2><p>1，YUV中的Y指的是亮度信息。也就是说，只靠Y数据，可以完美实现黑白图像。</p>
<p>早期技术不发达的时候，照片打印和电视播放都只能实现黑白的灰度显示，所以Y数据就成了标准。之后才有了彩色打印和彩色电视，为了兼容之前的黑白数据，厂商发明了UV数据。YUV一起就可以实现彩色，单独使用Y可以实现黑白，这样一套数据格式就同时兼容了黑白设备和彩色设备。</p>
<p>2，人眼对亮点信息更敏感。也就是说，可以压缩UV数据，而人眼难以发现。</p>
<p>所以压缩算法的第一步，往往先把RGB数据转换成YUV数据。对Y少压缩一点，对UV多压缩一点，以平衡图像效果和压缩率。</p>
<p>3，既然YUV更有优势，为什么还要保留RGB呢？</p>
<p>因为目前人类发明的所有彩色的输入输出设备，本质上都只支持RGB数据。哪怕设备允许YUV的输入输出，那也是经过内部的数据转换而间接支持。</p>
<p>参考：<br><a href="http://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html">http://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html</a><br><a href="https://www.jianshu.com/p/a91502c00fb0">https://www.jianshu.com/p/a91502c00fb0</a><br><a href="https://en.wikipedia.org/wiki/YUV">https://en.wikipedia.org/wiki/YUV</a></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>播放器</tag>
      </tags>
  </entry>
  <entry>
    <title>Android播放器基础封装库PlayerBase</title>
    <url>/2018/06/04/playerbase/</url>
    <content><![CDATA[<p>视频播放是我们开发中比较常见的场景。这两年关于视频方面的热度不断提升，可以说前两年是直播年，今年是小视频年，各种短视频应用铺天盖地。对于视频的业务场景也越来越丰富，功能也越来越多。对于我们开发来说播放相关组件的代码变得也越来越复杂，管理维护成本也越来越高，面对不断迭代的业务，我们需要一种有效的方案来应对这种频繁的业务变化。</p>
<span id="more"></span>

<p>这几年一直在做视频相关的业务，手机端和TV端均做过适配开发。<strong>MediaPlayer</strong>、<strong>exoplayer</strong>、<strong>ijkplayer</strong>、<strong>VLC</strong>、<strong>FFmpeg</strong>等都摸索使用过。这一路遇到很多问题……说多了都是泪，为了适应多变的产品需求，中间重构了N多个版本。最终<strong>PlayerBase</strong>也就诞生了。<strong>PlayerBase3</strong> 版本进行了完整重构设计，目前大致框架基本已稳定下来。对于大部分应用视频播放组件场景都能轻松处理。</p>
<p><strong>^_^ star传送门</strong>—&gt;<strong>项目地址</strong>：<a href="https://github.com/jiajunhui/PlayerBase">https://github.com/jiajunhui/PlayerBase</a></p>
<p>QQ交流群：<strong>600201778</strong>    ，有问题群里直接提出，看到后会一一解答。</p>
<p>P图技术有限，文中图片就凑合着看吧！</p>
<h1 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h1><p><strong>请注意！</strong> <strong>请注意！</strong> <strong>请注意！</strong> <strong>PlayerBase</strong>区别于大部分播放器封装库。</p>
<p><strong>PlayerBase</strong>是一种将解码器和播放视图组件化处理的解决方案框架。您需要什么解码器实现框架定义的抽象引入即可，对于视图，无论是播放器内的控制视图还是业务视图，均可以做到组件化处理。将播放器的开发变得清晰简单，更利于产品的迭代。</p>
<p><strong>PlayerBase</strong>不会为您做任何多余的功能业务组件，有别于大部分播放器封装库的通过配置或者继承然后重写然后定制你需要的功能组件和屏蔽你不需要的功能组件（这种之前我也经历过，上层可能需要经常改动，感觉很low!!!）。正确的方向应该是需要什么组件就拓展添加什么组件，不需要时移除即可，而不是已经提供了该组件去选择用不用。</p>
<h1 id="功能特色"><a href="#功能特色" class="headerlink" title="功能特色"></a>功能特色</h1><ul>
<li><strong>视图的组件化处理</strong><br></li>
<li><strong>视图组件的高复用、低耦合</strong><br></li>
<li><strong>解码方案的组件化、配置化管理</strong><br></li>
<li><strong>视图组件的完全定制</strong><br></li>
<li><strong>视图组件的热插拔，用时添加不用时移除</strong><br></li>
<li><strong>自定义接入各种解码方案</strong><br></li>
<li><strong>解码方案的切换</strong><br></li>
<li><strong>支持倍速播放</strong><br></li>
<li><strong>支持Window模式播放</strong><br></li>
<li><strong>支持Window模式的无缝续播</strong><br></li>
<li><strong>支持列表模式的无缝续播</strong><br></li>
<li><strong>支持跨页面无缝续播</strong><br></li>
<li><strong>支持调整画面显示比例</strong><br></li>
<li><strong>支持动态调整渲染视图类型</strong><br></li>
<li><strong>支持VideoView切角处理，边缘阴影效果</strong><br></li>
<li><strong>提供自定义数据提供者</strong><br></li>
<li><strong>统一的事件下发机制</strong><br></li>
<li><strong>扩展事件的添加</strong><br></li>
<li><strong>等功能……</strong><br></li>
</ul>
<h1 id="部分使用示例"><a href="#部分使用示例" class="headerlink" title="部分使用示例"></a>部分使用示例</h1><ol>
<li><strong>解码配置和框架初始化</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//如果您想使用默认的网络状态事件生产者，请添加此行配置。</span></span><br><span class="line">        <span class="comment">//并需要添加权限 android.permission.ACCESS_NETWORK_STATE</span></span><br><span class="line">        PlayerConfig.setUseDefaultNetworkEventProducer(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//设置默认解码器</span></span><br><span class="line">        <span class="keyword">int</span> defaultPlanId = <span class="number">1</span>;</span><br><span class="line">        PlayerConfig.addDecoderPlan(<span class="keyword">new</span> DecoderPlan(defaultPlanId, IjkPlayer.class.getName(), <span class="string">&quot;IjkPlayer&quot;</span>));</span><br><span class="line">PlayerConfig.setDefaultPlanId(defaultPlanId);</span><br><span class="line">        <span class="comment">//初始化库</span></span><br><span class="line">        PlayerLibrary.init(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>组装组件</strong>（添加您需要的组件【组件来自用户自定义，框架不提供任何视图组件】）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReceiverGroup receiverGroup = <span class="keyword">new</span> ReceiverGroup();</span><br><span class="line"><span class="comment">//Loading组件</span></span><br><span class="line">receiverGroup.addReceiver(KEY_LOADING_COVER, <span class="keyword">new</span> LoadingCover(context));</span><br><span class="line"><span class="comment">//Controller组件</span></span><br><span class="line">receiverGroup.addReceiver(KEY_CONTROLLER_COVER, <span class="keyword">new</span> ControllerCover(context));</span><br><span class="line"><span class="comment">//CompleteCover组件</span></span><br><span class="line">receiverGroup.addReceiver(KEY_COMPLETE_COVER, <span class="keyword">new</span> CompleteCover(context));</span><br><span class="line"><span class="comment">//Error组件</span></span><br><span class="line">receiverGroup.addReceiver(KEY_ERROR_COVER, <span class="keyword">new</span> ErrorCover(context));</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>设置组件启动播放</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BaseVideoView videoView = findViewById(R.id.videoView);</span><br><span class="line">videoView.setReceiverGroup(receiverGroup);</span><br><span class="line">DataSource data = <span class="keyword">new</span> DataSource(<span class="string">&quot;http://url...&quot;</span>);</span><br><span class="line">videoView.setDataSource(data);</span><br><span class="line">videoView.start();</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>事件的监听</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//player event</span></span><br><span class="line">videoView.setOnPlayerEventListener(<span class="keyword">new</span> OnPlayerEventListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPlayerEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//receiver event</span></span><br><span class="line">videoView.setOnReceiverEventListener(<span class="keyword">new</span> OnReceiverEventListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiverEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>详细使用示例请参阅github项目主页及wiki介绍</strong></p>
<h1 id="框架的设计"><a href="#框架的设计" class="headerlink" title="框架的设计"></a>框架的设计</h1><h2 id="视图的处理"><a href="#视图的处理" class="headerlink" title="视图的处理"></a>视图的处理</h2><p>别小看一个小小的播放器，里面真的是别有洞天。有时视图组件复杂到你怀疑人生。</p>
<p>我们先看下播放器开发时常见的一些视图场景：</p>
<div align="center">
<img src="/images/playerbase_cover_eg01.png" width="640" height="360">
<img src="/images/playerbase_cover_eg02.png" width="640" height="360">
</div>

<div align="center">
<img src="/images/playerbase_cover_eg03.png" width="640" height="360">
<img src="/images/playerbase_cover_eg04.png" width="640" height="360">
</div>

<div align="center">
<img src="/images/playerbase_cover_eg05.png" width="640" height="360">
<img src="/images/playerbase_cover_eg06.png" width="640" height="360">
</div>

<p>以上是我们最常见到的一些视图（其实还有很多，比如清晰度切换、视频列表、播放完成提示页等等），这些视图如果没有一个行之有效的方案来进行管理，将逐渐会乱到失控。</p>
<p>上面只是列出了控制器视图、加载视图、手势视图、错误视图、弹幕视图和广告视图，这一股脑的视图都是和播放紧密相连的，完全由播放状态驱动，视图之间可能共存、可能制约。</p>
<p>那么这些视图如何进行统一的管理呢？光布局文件就够喝一壶了吧，即便用include来管理依然摆脱不了显示层级的管理问题。要是一股脑全写到一个<strong>xml</strong>中，想想都可怕……，<br>改进型的一般都是把每个组件封装成View了，然后再分别写到布局中，显然比前一种要轻松一些。但是，但是播放器和组件间的通信、组件与组件间的通信是个问题。依然有问题存在：</p>
<ol>
<li><em><strong>组件布局的层级完全由布局文件决定了，想调整只能去修改布局文件。并不友好。</strong></em></li>
<li><em><strong>组件和播放器完全捆绑了，耦合度相当高，播放器和组件，组件和组件间的通信完全直接使用引用去操作，如果产品说某个组件要去掉或者大改，你就哭吧，改不好手一哆嗦就有可能带来一堆bug。组件耦合度高，并不支持插拔。这是最大阻碍。</strong></em></li>
<li><em><strong>组件的复用困难。</strong></em></li>
</ol>
<p>接下来，且看PlayerBase如何做。</p>
<h2 id="接收者Receiver与覆盖层Cover的概念"><a href="#接收者Receiver与覆盖层Cover的概念" class="headerlink" title="接收者Receiver与覆盖层Cover的概念"></a>接收者Receiver与覆盖层Cover的概念</h2><p>做过播放器开发的应该都很清楚一点，所有视图的工作都是由状态事件来驱动的，这是一条主线。有可能是来自播放器的事件（比如解码器出错了），也有可能是来自某个视图的事件（比如手势调节播放进度），还有可能是外部事件（比如网络状态变化）。</p>
<p>这些信息我们可以归结为</p>
<ul>
<li>视图是事件接收者，也是事件的生产者</li>
<li>解码器是事件生产者</li>
<li>可能有外来的事件生产者</li>
</ul>
<p>也就是说我们把视图当做事件接收者，同时视图具备发送事件的能力。</p>
<p>解码器不断发出自己工作状态的事件要传递给视图。</p>
<p>外部的某些事件也需要传递给视图</p>
<p><img src="/images/playerbase_receiver_event.png"></p>
<p>至此，框架内部定义了事件接收者的概念，接收者作为事件消费者的同时也能生产事件，而覆盖层继承自接收者引入了视图View。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseReceiver</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">notifyReceiverEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span></span>&#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * all player event dispatch by this method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onPlayerEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * error event.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onErrorEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * receivers event.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onReceiverEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * you can call this method dispatch private event for a receiver.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Bundle Return value after the receiver&#x27;s response, nullable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Bundle <span class="title">onPrivateEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseCover</span> <span class="keyword">extends</span> <span class="title">BaseReceiver</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> View <span class="title">onCreateCoverView</span><span class="params">(Context context)</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>且看代码，有播放器的事件、有错误事件、有组件（Receiver）间的事件。这众多事件如何下发呢，如果有N多个接收者呢，如何破？</p>
<h2 id="接收者组管理（ReceiverGroup）"><a href="#接收者组管理（ReceiverGroup）" class="headerlink" title="接收者组管理（ReceiverGroup）"></a>接收者组管理（ReceiverGroup）</h2><p>ReceiverGroup的出现目的就是对众多接收者进行统一的管理，统一的事件下发，当然还有下面的数据共享问题。来张图：</p>
<p><img src="/images/playerbase_receivergroup.png"></p>
<p>在ReceiverGroup中包含Cover（其实也是Receiver）和Receiver，提供了Receiver的添加、移除、遍历、销毁等操作。当有事件需要下发时，便可通过ReceiverGroup进行统一的遍历下发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IReceiverGroup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOnReceiverGroupChangeListener</span><span class="params">(OnReceiverGroupChangeListener onReceiverGroupChangeListener)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add a receiver, you need put a unique key for this receiver.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receiver</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReceiver</span><span class="params">(String key, IReceiver receiver)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * remove a receiver by key.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReceiver</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * loop all receivers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onLoopListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(OnLoopListener onLoopListener)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * loop all receivers by a receiver filter.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onLoopListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(OnReceiverFilter filter, OnLoopListener onLoopListener)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get receiver by key.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T extends IReceiver&gt; <span class="function">T <span class="title">getReceiver</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get the ReceiverGroup group value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">GroupValue <span class="title">getGroupValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * clean receivers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearReceivers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件间数据共享（GroupValue）"><a href="#组件间数据共享（GroupValue）" class="headerlink" title="组件间数据共享（GroupValue）"></a>组件间数据共享（GroupValue）</h2><p>播放器开发中很多时候我们需要依据某个视图的状态来限制另外视图的功能或状态，比如当处于加载中时禁止拖动进度条或者播放出错显示error后禁止其他视图操作等等。这些都属于状态上的相互制约。</p>
<p>GroupValue就相当于提供了一个共享的数据池，当某个数据被刷新时，监听该数据的回调接口能及时收到通知，当然也可以直接去主动获取数据状态。你可以指定你要监听那些数据的更新事件，如果您注册了您要监听的数据的key值，其对应的value被更新时，您就会收到回调。然后您可以在回调中进行UI视图的控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCover</span> <span class="keyword">extends</span> <span class="title">BaseCover</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiverBind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onReceiverBind();</span><br><span class="line">        getGroupValue().registerOnGroupValueUpdateListener(mOnGroupValueUpdateListener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> IReceiverGroup.OnGroupValueUpdateListener mOnGroupValueUpdateListener =</span><br><span class="line">            <span class="keyword">new</span> IReceiverGroup.OnGroupValueUpdateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String[] filterKeys() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123; DataInter.Key.KEY_COMPLETE_SHOW &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onValueUpdate</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiverUnBind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onReceiverUnBind();</span><br><span class="line">        getGroupValue().unregisterOnGroupValueUpdateListener(mOnGroupValueUpdateListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="视图的布局管理（分级填充）"><a href="#视图的布局管理（分级填充）" class="headerlink" title="视图的布局管理（分级填充）"></a>视图的布局管理（分级填充）</h2><p>上文中常见的视图组件，我们在使用中肯定会遇到覆盖优先级的问题。举个栗子，比如Error视图出现后其他的视图一概不可见，也就是说Error视图的优先级是最高的，谁都不能挡着它，我们创建了一个个的<strong>Cover</strong>视图，对于视图的放置就需要一个视图的优先级标量（<strong>CoverLevel</strong>）来进行控制，不同的<strong>Level</strong>的<strong>Cover</strong>视图会被放置于不同级别的容器内。</p>
<p>总结为以下：</p>
<ul>
<li>指定<strong>Cover</strong>的优先级<strong>CoverLevel</strong></li>
<li><strong>Cover</strong>组件被添加时自动根据<strong>Level</strong>值进行分别放置</li>
</ul>
<p>示意图<br><img src="/images/playerbase_view_struct.png"><br>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCover</span> <span class="keyword">extends</span> <span class="title">BaseCover</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCoverLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ICover.COVER_LEVEL_LOW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的视图容器管理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultLevelCoverContainer</span> <span class="keyword">extends</span> <span class="title">BaseLevelCoverContainer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAvailableCoverAdd</span><span class="params">(BaseCover cover)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onAvailableCoverAdd(cover);</span><br><span class="line">        <span class="keyword">switch</span> (cover.getCoverLevel())&#123;</span><br><span class="line">            <span class="keyword">case</span> ICover.COVER_LEVEL_LOW:</span><br><span class="line">                mLevelLowCoverContainer.addView(cover.getView(),getNewMatchLayoutParams());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ICover.COVER_LEVEL_MEDIUM:</span><br><span class="line">                mLevelMediumCoverContainer.addView(cover.getView(),getNewMatchLayoutParams());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ICover.COVER_LEVEL_HIGH:</span><br><span class="line">                mLevelHighCoverContainer.addView(cover.getView(),getNewMatchLayoutParams());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件的层级关系"><a href="#组件的层级关系" class="headerlink" title="组件的层级关系"></a>组件的层级关系</h2><p>如图：</p>
<p><img src="/images/playerbase_widget_struct.png"></p>
<h2 id="事件生产者（EventProducer）"><a href="#事件生产者（EventProducer）" class="headerlink" title="事件生产者（EventProducer）"></a>事件生产者（EventProducer）</h2><p>顾名思义，就是它是产生事件的源。比如系统网络状态发生了变化，发出了通知，然后各个应用根据自己的情况来调整显示或设置等。又或者电池电量的变化和低电量预警通知事件等。</p>
<p>再比如，我们上文中的弹幕视图中需要显示弹幕数据，弹幕数据来自服务器，我们需要源源不断的从服务器上取数据，然后显示在弹幕视图。取回数据传给视图的这个过程我们可以将其看作是一个事件生产者在不断生产弹幕数据更新事件，弹幕数据更新时不断将事件发送给弹幕视图来刷新显示。</p>
<p>框架内自带了一个网络变化事件生产者的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkEventProducer</span> <span class="keyword">extends</span> <span class="title">BaseEventProducer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper())&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="keyword">switch</span> (msg.what)&#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_CODE_NETWORK_CHANGE:</span><br><span class="line">                    <span class="keyword">int</span> state = (<span class="keyword">int</span>) msg.obj;</span><br><span class="line">                    <span class="comment">//...将网络状态发送出去</span></span><br><span class="line">                    getSender().sendInt(InterKey.KEY_NETWORK_STATE, state);</span><br><span class="line">                    PLog.d(TAG,<span class="string">&quot;onNetworkChange : &quot;</span> + state);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NetworkEventProducer</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NetChangeBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//post state message</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于事件生产者所发出的事件是针对Receiver的，所以会被回调到onReceiverEvent()中，如果发送的是key-value的数据，会被放置于GroupValue中。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCover</span> <span class="keyword">extends</span> <span class="title">BaseCover</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceiverEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据提供者（DataProvider）"><a href="#数据提供者（DataProvider）" class="headerlink" title="数据提供者（DataProvider）"></a>数据提供者（DataProvider）</h2><p><strong>DataProvider</strong>是为了播控的统一以及使用上的优雅而设计的。</p>
<p>在开发中，我们可能会遇到如下场景：你拿到的数据源可能只是个id之类的标识，并不是能直接播放的uri或者url，需要你再用这个id去请求一个接口才能拿到播放的源地址。通常我们都是先去请求接口，然后在成功回调中用拿到的源数据再设置给播放器去播放。</p>
<p><img src="/images/playerbase_dataprovider.png"><br><strong>DataProvider</strong>的设计就是为了将此过程独立出来包装为一个数据提供者（其实也可以叫数据生产者），拿到数据后发送出去即可。而您只需要把那个id标识给<strong>DataProvider</strong>即可，接下来的过程就由<strong>DataProvider</strong>来完成了。<strong>DataProvider</strong>的具体实现需要由用户完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorDataProvider</span> <span class="keyword">extends</span> <span class="title">BaseDataProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonitorDataProvider</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleSourceData</span><span class="params">(DataSource sourceData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDataSource = sourceData;</span><br><span class="line">        <span class="comment">//...provider start</span></span><br><span class="line">        onProviderDataStart();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//...将数据回调出去</span></span><br><span class="line">        onProviderMediaDataSuccess(bundle);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//...异常时</span></span><br><span class="line">        onProviderError(-<span class="number">1</span>, <span class="keyword">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...cancel something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...destroy something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 数据提供者必须要设置在启动播放前。</p>
<h1 id="功能使用"><a href="#功能使用" class="headerlink" title="功能使用"></a>功能使用</h1><h2 id="VideoView的使用"><a href="#VideoView的使用" class="headerlink" title="VideoView的使用"></a>VideoView的使用</h2><p>大致归结为以下步骤：</p>
<ol>
<li>初始化<strong>VideoView</strong>，并设置相应的监听事件或者数据提供者等</li>
<li>使用<strong>ReceiverGroup</strong>组装需要的组件Cover和Receiver</li>
<li>把组件设置给<strong>VideoView</strong></li>
<li>设置数据启动播放</li>
<li>暂停恢复播放等操作</li>
<li>销毁播放器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoViewActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">OnPlayerEventListener</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    BaseVideoView mVideoView;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle saveInstance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(saveInstance);</span><br><span class="line">        mVideoView = findViewById(R.id.videoView);</span><br><span class="line">        mVideoView.setOnPlayerEventListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//设置数据提供者 MonitorDataProvider</span></span><br><span class="line">        MonitorDataProvider dataProvider = <span class="keyword">new</span> MonitorDataProvider();</span><br><span class="line">        mVideoView.setDataProvider(dataProvider);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        ReceiverGroup receiverGroup = <span class="keyword">new</span> ReceiverGroup();</span><br><span class="line">        <span class="comment">//Loading组件</span></span><br><span class="line">        receiverGroup.addReceiver(KEY_LOADING_COVER, <span class="keyword">new</span> LoadingCover(context));</span><br><span class="line">        <span class="comment">//Controller组件</span></span><br><span class="line">        receiverGroup.addReceiver(KEY_CONTROLLER_COVER, <span class="keyword">new</span> ControllerCover(context));</span><br><span class="line">        <span class="comment">//CompleteCover组件</span></span><br><span class="line">        receiverGroup.addReceiver(KEY_COMPLETE_COVER, <span class="keyword">new</span> CompleteCover(context));</span><br><span class="line">        <span class="comment">//Error组件</span></span><br><span class="line">        receiverGroup.addReceiver(KEY_ERROR_COVER, <span class="keyword">new</span> ErrorCover(context));</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        DataSource data = <span class="keyword">new</span> DataSource(<span class="string">&quot;monitor_id&quot;</span>);</span><br><span class="line">        videoView.setDataSource(data);</span><br><span class="line">        videoView.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPlayerEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (eventCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> OnPlayerEventListener.PLAYER_EVENT_ON_VIDEO_RENDER_START:</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OnPlayerEventListener.PLAYER_EVENT_ON_PLAY_COMPLETE:</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        mVideoView.pause();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        mVideoView.onResume();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mVideoView.stopPlayback();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AVPlayer的使用"><a href="#AVPlayer的使用" class="headerlink" title="AVPlayer的使用"></a>AVPlayer的使用</h2><p>如果您想直接使用<strong>AVPlayer</strong>自己进行处理播放，那么大致步骤如下：</p>
<ol>
<li>初始化一个<strong>AVPlayer</strong>对象。</li>
<li>初始化一个<strong>SuperContainer</strong>对象，将<strong>ReceiverGroup</strong>设置到<strong>SuperContainer</strong>中。</li>
<li>使用<strong>SuperContainer</strong>设置一个渲染视图<strong>Render</strong>，然后自己处理RenderCallBack并关联解码器。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SuperContainer mSuperContainer = <span class="keyword">new</span> SuperContainer(context);</span><br><span class="line">ReceiverGroup receiverGroup = <span class="keyword">new</span> ReceiverGroup();</span><br><span class="line"><span class="comment">//...add some covers</span></span><br><span class="line">receiverGroup.addReceiver(KEY_LOADING_COVER, <span class="keyword">new</span> LoadingCover(context));</span><br><span class="line">mSuperContainer.setReceiverGroup(receiverGroup);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">final</span> RenderTextureView render = <span class="keyword">new</span> RenderTextureView(mAppContext);</span><br><span class="line">render.setTakeOverSurfaceTexture(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">mPlayer.setOnPlayerEventListener(<span class="keyword">new</span> OnPlayerEventListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPlayerEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...此处需要根据事件自行实现一些特定的设置</span></span><br><span class="line">        <span class="comment">//...比如视频的尺寸需要传递Render刷新测量或者视频的角度等等</span></span><br><span class="line">        <span class="comment">//将事件分发给子视图</span></span><br><span class="line">        mSuperContainer.dispatchPlayEvent(eventCode, bundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mPlayer.setOnErrorEventListener(<span class="keyword">new</span> OnErrorEventListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorEvent</span><span class="params">(<span class="keyword">int</span> eventCode, Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将事件分发给子视图</span></span><br><span class="line">        mSuperContainer.dispatchErrorEvent(eventCode, bundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">render.setRenderCallback(<span class="keyword">new</span> IRender.IRenderCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(IRender.IRenderHolder renderHolder, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        mRenderHolder = renderHolder;</span><br><span class="line">        bindRenderHolder(mRenderHolder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(IRender.IRenderHolder renderHolder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceDestroy</span><span class="params">(IRender.IRenderHolder renderHolder)</span> </span>&#123;</span><br><span class="line">        mRenderHolder = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mSuperContainer.setRenderView(render.getRenderView());</span><br><span class="line">mPlayer.setDataSource(dataSource);</span><br><span class="line">mPlayer.start();</span><br></pre></td></tr></table></figure>
<p>如果非必须，请尽量使用框架封装好的<strong>BaseVideoView</strong>进行播放，框架相对来说处理的比较完善且提供了丰富的回调和定制性。</p>
<h2 id="关联助手的使用（RelationAssist）"><a href="#关联助手的使用（RelationAssist）" class="headerlink" title="关联助手的使用（RelationAssist）"></a>关联助手的使用（RelationAssist）</h2><p>现在的短视频应用都有这样的场景：</p>
<ul>
<li><strong>列表中播放</strong></li>
<li><strong>列表跳详情自然过渡无停顿播放</strong></li>
</ul>
<p>对于第一条在列表中播放，理论上<strong>VideoView</strong>就能完成，但是<strong>VideoView</strong>用在列表中量级较重，不太适合。需要一个轻量化处理的方案。</p>
<p>而对于第二条，<strong>VideoView</strong>就不行了，<strong>VideoView</strong>是对解码器进行了包装，当跳到下一个页面时，是一个新的页面自然有新的视图，无法使用前一个页面的播放器实例去渲染当前页面播放。</p>
<p>其实对于这种无缝的续播，原理很简单。就是不同的渲染视图使用同一个解码实例即可。可以简单比作一个<strong>MediaPlayer</strong>去不断设置不同的<strong>surface</strong>呈现播放。如果自己处理这个过程的话想对比较繁琐，你需要处理Render的回调并关联给解码器，还需要自己处理Render的测量以及显示比例、角度等等问题。</p>
<p><strong>RelationAssist</strong> 就是为了简化这个过程而设计的。在不同的页面或视图切换播放时，您只需要提供并传入对应位置的视图容器（<strong>ViewGroup</strong>类型）即可。内部复杂的设置项和关联由<strong>RelationAssist</strong>完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppcompatActivity</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    RelationAssist mAssist;</span><br><span class="line">    ViewGroup view2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle saveInstance)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">super</span>.onCreate(saveInstance);</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">    	mAssist = <span class="keyword">new</span> RelationAssist(<span class="keyword">this</span>);</span><br><span class="line">    	mAssist.setEventAssistHandler(eventHandler);</span><br><span class="line">    	mReceiverGroup = ReceiverGroupManager.get().getLiteReceiverGroup(<span class="keyword">this</span>);</span><br><span class="line">    	mAssist.setReceiverGroup(mReceiverGroup);</span><br><span class="line">    	DataSource dataSource = <span class="keyword">new</span> DataSource();</span><br><span class="line">    	dataSource.setData(<span class="string">&quot;http://...&quot;</span>);</span><br><span class="line">    	dataSource.setTitle(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    	mAssist.setDataSource(dataSource);</span><br><span class="line">    	mAssist.attachContainer(mVideoContainer);</span><br><span class="line">    	mAssist.play();</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">    	switchPlay(view2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">switchPlay</span><span class="params">(ViewGroup container)</span></span>&#123;</span><br><span class="line">    	 mAssist.attachContainer(container);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您想跨页面进行关联，只需要自己将<strong>RelationAssist</strong>包装为一个单例即可。此处不做代码展示，详细代码可参见github项目demo代码。</p>
<h2 id="事件助手处理器（EventAssistHandler）"><a href="#事件助手处理器（EventAssistHandler）" class="headerlink" title="事件助手处理器（EventAssistHandler）"></a>事件助手处理器（EventAssistHandler）</h2><p>视图中的一些基本操作，比如暂停播放、重播、重试、恢复播放等等，这些事件最终都要传递给解码器进行相关操作。可能还有用户自定义的事件比如播放下一个或上一个等。</p>
<p>对于基本的操作事件（暂停、恢复、重播等），框架内部可自动完成，而用户自定的事件需要让用户自行处理。框架内部<strong>BaseVideoView</strong>和<strong>RelationAssist</strong>均做了<strong>EventAssistHandler</strong>的对接，使用时需要传入一个可用的事件处理器对象，可根据不同的事件参数进行相应处理。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mVideoView.setOnVideoViewEventHandler(<span class="keyword">new</span> OnVideoViewEventHandler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAssistHandle</span><span class="params">(BaseVideoView assist, <span class="keyword">int</span> eventCode, Bundle bundle)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//基本的事件处理已在父类super中完成，如果需要重写，重写相应方法即可。</span></span><br><span class="line">            <span class="keyword">super</span>.onAssistHandle(assist, eventCode, bundle);</span><br><span class="line">            <span class="keyword">switch</span> (eventCode)&#123;</span><br><span class="line">                <span class="keyword">case</span> DataInter.Event.EVENT_CODE_REQUEST_NEXT:</span><br><span class="line">                    <span class="comment">//...播放下一个</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Window模式播放"><a href="#Window模式播放" class="headerlink" title="Window模式播放"></a>Window模式播放</h2><p>我们有时可能为了不打断用户的浏览需要小窗播放。框架特意设计了window播放的使用。框架提供了两种window相关的组件。</p>
<ul>
<li><strong>WindowVideoView</strong></li>
<li><strong>FloatWindow</strong></li>
</ul>
<p><strong>WindowVideoView</strong>使用上几乎和VideoView是一样的，只不过<strong>WindowVideoView</strong>是以window的形式呈现的。window默认是可以拖动的，如果您不需要，可以禁止，window的每个设置项都有默认值，window的设置示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FloatWindowParams windowParams = <span class="keyword">new</span> FloatWindowParams();</span><br><span class="line">windowParams.setWindowType(WindowManager.LayoutParams.TYPE_TOAST)</span><br><span class="line">            .setFormat(PixelFormat.RGBA_8888)</span><br><span class="line">            .setFlag(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)</span><br><span class="line">            .setDefaultAnimation(<span class="keyword">true</span>)</span><br><span class="line">            .setX(<span class="number">100</span>)</span><br><span class="line">            .setY(<span class="number">100</span>)</span><br><span class="line">            .setWidth(width)</span><br><span class="line">            .setHeight(height)</span><br><span class="line">            .setGravity(Gravity.TOP | Gravity.LEFT));</span><br><span class="line">mWindowVideoView = <span class="keyword">new</span> WindowVideoView(<span class="keyword">this</span>,windowParams);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>而<strong>FloatWindow</strong>只是一个悬浮窗View，您可以传入您要显示的布局View。可以用于窗口切换播放时的无缝续播。此处不做代码示例展示。</p>
<h2 id="一些样式设置（StyleSetter）"><a href="#一些样式设置（StyleSetter）" class="headerlink" title="一些样式设置（StyleSetter）"></a>一些样式设置（StyleSetter）</h2><p>样式的设置是针对 <strong>VideoView</strong>、<strong>WindowVideoView</strong> 和 <strong>FloatWindow</strong> 的。当然框架提供的<strong>StyleSetter</strong>您也可以用于别处。提供了如下的样式设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStyleSetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置圆角</span></span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRoundRectShape</span><span class="params">(<span class="keyword">float</span> radius)</span></span>;</span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRoundRectShape</span><span class="params">(Rect rect, <span class="keyword">float</span> radius)</span></span>;</span><br><span class="line">    <span class="comment">//设置为圆形</span></span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOvalRectShape</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setOvalRectShape</span><span class="params">(Rect rect)</span></span>;</span><br><span class="line">    <span class="comment">//清除样式设置</span></span><br><span class="line">    <span class="meta">@TargetApi(Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearShapeStyle</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//设置阴影</span></span><br><span class="line">    <span class="comment">//注意阴影的设置要求对应的View对象必须要有背景色（不能是TRANSPARENT）</span></span><br><span class="line">    <span class="comment">//如果您没设置，框架内部会自定设置为黑色</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setElevationShadow</span><span class="params">(<span class="keyword">float</span> elevation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setElevationShadow</span><span class="params">(<span class="keyword">int</span> backgroundColor, <span class="keyword">float</span> elevation)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解码器的接入"><a href="#解码器的接入" class="headerlink" title="解码器的接入"></a>解码器的接入</h2><p>框架自带了系统的MediaPlayer的解码实现，项目demo中示例接入了ijkplayer和exoplayer，如果您想接入其他的解码器，请参见示例代码，以下为简单示例，更详细的请参见项目源码。</p>
<p><strong>接入步骤</strong></p>
<ol>
<li>继承自BaseInternalPlayer</li>
<li>实现定义的抽象方法</li>
<li>配置引入您的解码器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXPlayer</span> <span class="keyword">extends</span> <span class="title">BaseInternalPlayer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XXXPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//implements some abstract methods.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过配置设置使用该解码器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> planId = <span class="number">2</span>;</span><br><span class="line">PlayerConfig.addDecoderPlan(<span class="keyword">new</span> DecoderPlan(planId, XXXPlayer.class.getName(), <span class="string">&quot;XXXPlayer&quot;</span>));</span><br><span class="line">PlayerConfig.setDefaultPlanId(planId);</span><br></pre></td></tr></table></figure>

<p>以上对于<strong>PlayerBase</strong>的讲解基本完成。码字好累！！！</p>
<p>主要的模块差不多就这么多了，更详细的可参见项目源码。</p>
<p>如有问题联系：<a href="mailto:junhui_jia@163.com">junhui_jia@163.com</a></p>
<p>QQ交流群：<strong>600201778</strong></p>
<p><strong>最后再附上项目地址</strong>：<a href="https://github.com/jiajunhui/PlayerBase">PlayerBase</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>播放器</tag>
      </tags>
  </entry>
</search>
